var documenterSearchIndex = {"docs":
[{"location":"code_of_conduct/","page":"Code of conduct","title":"Code of conduct","text":"EditURL = \"https://github.com/trixi-framework/P4est.jl/blob/main/CODE_OF_CONDUCT.md\"","category":"page"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of conduct","title":"Code of conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Joshua Lampert, Michael Schlottke-Lakemper, Hendrik Ranocha, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/trixi-framework/P4est.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2020-present The P4est.jl Authors (see Authors)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/trixi-framework/P4est.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"P4est.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as merge requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"P4est.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Installation instructions and first usage examples are shown on the main page. This page collects some additional examples and translation guidelines from the C library p4est to its Julia wrapper P4est.jl.","category":"page"},{"location":"introduction/#High-level-overview-of-the-setup","page":"Introduction","title":"High-level overview of the setup","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The Julia bindings of p4est are generated using Clang.jl. This process is described in the dev folder of P4est.jl. Since all MPI datatypes are mapped to types from MPI.jl, the generated bindings are agnostic of the local MPI installation. Hence, there should be no need to generate new bindings as a user. If there are problems, please let us know, e.g., by creating on issue on GitHub. New bindings only need to be generated for a new version of p4est that comes with a different API. We will probably provide some new bindings when we learn about this.","category":"page"},{"location":"introduction/#translation_guidelines","page":"Introduction","title":"Translation guidelines","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Many functions of p4est work with pointers, e.g.,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"int p4est_connectivity_is_valid (p4est_connectivity_t * connectivity);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"or return pointers to newly created structs, e.g.,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p4est_connectivity_t *p4est_connectivity_new_periodic (void);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"P4est.jl wraps these C functions accordingly and works with pointers. For a convenient alternative to using raw pointers directly, see the next section on PointerWrappers. We also follow the naming scheme of p4est. For example, we use connectivity::Ptr{p4est_connectivity}. However, it is sometimes useful/required to also load the wrappers of the C structs from their pointers. In this case, we use the naming convention to append _obj, e.g., connectivity_obj = unsafe_load(connectivity). A full example is given here:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using P4est, MPI; MPI.Init()\nconnectivity = p4est_connectivity_new_periodic()\n@doc(p4est_connectivity)\nconnectivity_obj = unsafe_load(connectivity)\nconnectivity_obj.num_vertices\nconnectivity_obj.num_trees\nconnectivity_obj.num_corners\np4est_connectivity_destroy(connectivity)","category":"page"},{"location":"introduction/#pointer_wrappers","page":"Introduction","title":"PointerWrappers","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As we have seen in the previous section on translation guidelines, many functions provided by p4est return pointers to structs, which requires one to unsafe_load the pointer in order to access the underlying data. P4est.jl offers a convenient alternative to directly using unsafe_load by providing the PointerWrapper data type. If you, e.g., have a pointer to a p4est_connectivity (i.e., an object of type Ptr{p4est_connectivity}) called connectivity, you can use connectivity_pw = PointerWrapper(connectivity) to obtain a wrapped version of the pointer, where the underlying data can be accessed simply by connectivity_pw.num_trees[] without the need to call unsafe_load manually. This works even for nested structures, e.g, where the named field of a struct is a pointer to a struct. A full example on how to use the PointerWrapper is given here (note the nested access at p4est_pw.connectivity.num_trees[] compared to unsafe_load(unsafe_load(p4est).connectivity).num_trees without a PointerWrapper):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using P4est, MPI; MPI.Init()\nconnectivity = p4est_connectivity_new_periodic()\nconnectivity_pw = PointerWrapper(connectivity)\nconnectivity_pw.num_trees[]\np4est = p4est_new_ext(MPI.COMM_WORLD, connectivity, 0, 0, true, 0, C_NULL, C_NULL)\np4est_pw = PointerWrapper(p4est)\np4est_pw.connectivity.num_trees[]\np4est_destroy(p4est)\np4est_connectivity_destroy(connectivity)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"You may also use the PointerWrapper to set variables in structs.  Here we set the user data pointer in the p4est_t struct to point to some data:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using P4est, MPI; MPI.Init()\nconnectivity = p4est_connectivity_new_periodic()\np4est = p4est_new_ext(MPI.COMM_WORLD, connectivity, 0, 0, true, 0, C_NULL, C_NULL)\np4est_pw = PointerWrapper(p4est)\ndata = Ref((rand(4), rand(5)))\nGC.@preserve data begin\n    p4est_pw.user_pointer = pointer_from_objref(data)\n\n    # Call p4est function with callback that uses p4est_pw.user_pointer here.\n    # You may retrieve the data `Ref` in the callback with\n    # data = unsafe_pointer_to_objref(pointer(p4est_pw.user_pointer))\nend\np4est_destroy(p4est)\np4est_connectivity_destroy(connectivity)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In addition, you can use a PointerWrapper as an array if the underlying datastructure is an array, i.e. you can access the i-th element of the underlying array by pw[i] for a PointerWrapper pw. See the following code for a full example:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using P4est, MPI; MPI.Init()\nconnectivity = p4est_connectivity_new_periodic()\np4est = p4est_new_ext(MPI.COMM_WORLD, connectivity, 0, 0, true, 0, C_NULL, C_NULL)\np4est_pw = PointerWrapper(p4est)\np4est_pw.global_first_quadrant[2]\np4est_destroy(p4est)\np4est_connectivity_destroy(connectivity)","category":"page"},{"location":"introduction/#Note-on-MPI-datatypes","page":"Introduction","title":"Note on MPI datatypes","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MPI types used by p4est are mapped to the types provided by MPI.jl.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p4est P4est.jl\nsc_MPI_Comm MPI.MPI_Comm\nMPI_Datatype MPI.MPI_Datatype\nMPI_File MPI.MPI_File","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In particular, it is currently not possible to use p4est without MPI support.","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"EditURL = \"https://github.com/trixi-framework/P4est.jl/blob/main/AUTHORS.md\"","category":"page"},{"location":"authors/#authors_separate_page","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The development of P4est.jl is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about P4est.jl. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The P4est.jl Authors\" as mentioned in the License file.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Michael Schlottke-Lakemper\nHendrik Ranocha\nJoshua Lampert","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to P4est.jl and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Alexander Astanin\nLars Christmann\nJoshua Lampert\nHendrik Ranocha\nMichael Schlottke-Lakemper\nLucas C Wilcox","category":"page"},{"location":"reference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"CurrentModule = P4est","category":"page"},{"location":"reference/#Higher-level-API-provided-by-P4est.jl","page":"API reference","title":"Higher-level API provided by P4est.jl","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Modules = [P4est]","category":"page"},{"location":"reference/#P4est.init-Tuple{Any, Any}","page":"API reference","title":"P4est.init","text":"P4est.init(log_handler, log_threshold)\n\nCalls p4est_init if it has not already been called, otherwise do nothing. Thus, P4est.init can safely be called multiple times.\n\nTo use the default log handler and suppress most output created by default by p4est, call this function as\n\nP4est.init(C_NULL, SC_LP_ERROR)\n\nbefore calling other functions from p4est.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.package_id-Tuple{}","page":"API reference","title":"P4est.package_id","text":"P4est.package_id()\n\nReturns the value of the global variable p4est_package_id which can be used to check whether p4est has been initialized.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.path_p4est_library-Tuple{}","page":"API reference","title":"P4est.path_p4est_library","text":"P4est.path_p4est_library()\n\nReturn the path of the p4est library that is used, when a system-provided library is configured via the preferences. Otherwise P4est_jll is returned, which means that the default p4est version from P4est_jll.jl is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.path_sc_library-Tuple{}","page":"API reference","title":"P4est.path_sc_library","text":"P4est.path_sc_library()\n\nReturn the path of the sc library that is used, when a system-provided library is configured via the preferences. Otherwise P4est_jll is returned, which means that the default sc version from P4est_jll.jl is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.preferences_set_correctly-Tuple{}","page":"API reference","title":"P4est.preferences_set_correctly","text":"P4est.preferences_set_correctly()\n\nReturns false if a system-provided MPI installation is set via the MPIPreferences, but not a system-provided p4est installation. In this case, P4est.jl is not usable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.set_library_p4est!","page":"API reference","title":"P4est.set_library_p4est!","text":"P4est.set_library_p4est!(path; force = true)\n\nSet the path to a system-provided p4est installation. Restart the Julia session after executing this function so that the changes take effect. Calling this function is necessary when you want to use a system-provided p4est installation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.set_library_sc!","page":"API reference","title":"P4est.set_library_sc!","text":"P4est.set_library_sc!(path; force = true)\n\nSet the path to a system-provided sc installation. Restart the Julia session after executing this function so that the changes take effect. Calling this function is necessary, when you want to use a system-provided p4est installation on Windows or when you want to use another sc installation than the one that libp4est.so already links to.\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.uses_mpi-Tuple{}","page":"API reference","title":"P4est.uses_mpi","text":"P4est.uses_mpi()\n\nIs intended to return trueif thep4estlibrary was compiled with MPI enabled. Since P4est.jl currently only supportsp4estwith MPI enabled, this may always returntrue`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.version-Tuple{}","page":"API reference","title":"P4est.version","text":"P4est.version()\n\nReturns the version of the underlying p4est library (not of P4est.jl).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PointerWrapper-provided-by-P4est.jl","page":"API reference","title":"PointerWrapper provided by P4est.jl","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Everything documented here is also exported from P4est.jl and available when using P4est.","category":"page"},{"location":"reference/","page":"API reference","title":"API reference","text":"Modules = [P4est.PointerWrappers]\nPrivate = false","category":"page"},{"location":"reference/#P4est.PointerWrappers.PointerWrapper","page":"API reference","title":"P4est.PointerWrappers.PointerWrapper","text":"PointerWrapper(p::Ptr)\n\nWrap the pointer p to conveniently access the data of the underlying struct. Fields of the struct (or the struct itself) can be dereferenced for reading/writing using []. As opposed to using unsafe_load/unsafe_store on the struct directly, the [] operator only accesses the memory for the requested field, thereby avoiding to having to load/store the entire struct when accessing only a single field. This can be helpful especially when accessing data in nested structures.\n\nExample\n\njulia> using P4est, MPI\n\njulia> MPI.Init()\nMPI.ThreadLevel(2)\n\njulia> connectivity = p4est_connectivity_new_brick(2, 2, 0, 0)\nPtr{p4est_connectivity} @0x000060000378b010\n\njulia> p4est = p4est_new_ext(MPI.COMM_WORLD, connectivity, 0, 0, true, 0, C_NULL, C_NULL)\nInto p4est_new with min quadrants 0 level 0 uniform 1\nNew p4est with 4 trees on 1 processors\nInitial level 0 potential global quadrants 4 per tree 1\nDone p4est_new with 4 total quadrants\nPtr{P4est.LibP4est.p4est} @0x0000600002b9d7b0\n\njulia> p4est_pw = PointerWrapper(p4est)\nPointerWrapper{P4est.LibP4est.p4est}(Ptr{P4est.LibP4est.p4est} @0x0000600002b9d7b0)\n\njulia> p4est_pw.connectivity.num_trees[]\n4\n\n\n\n\n\n","category":"type"},{"location":"reference/#Wrapper-of-the-C-API-of-[p4est](https://github.com/cburstedde/p4est)","page":"API reference","title":"Wrapper of the C API of p4est","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Everything documented here is also exported from P4est.jl and available when using P4est.","category":"page"},{"location":"reference/","page":"API reference","title":"API reference","text":"Modules = [P4est.LibP4est]\nPrivate = false","category":"page"},{"location":"reference/#P4est.LibP4est.p4est_coarsen_t","page":"API reference","title":"P4est.LibP4est.p4est_coarsen_t","text":"Callback function prototype to decide for coarsening.\n\nParameters\n\np4est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\nquadrants:[in] Pointers to 4 siblings in Morton ordering.\n\nReturns\n\nnonzero if the quadrants shall be replaced with their parent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_comm_tag","page":"API reference","title":"P4est.LibP4est.p4est_comm_tag","text":"p4est_comm_tag\n\nTags for MPI messages\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_comm_tag_t","page":"API reference","title":"P4est.LibP4est.p4est_comm_tag_t","text":"Tags for MPI messages\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connect_type_t","page":"API reference","title":"P4est.LibP4est.p4est_connect_type_t","text":"p4est_connect_type_t\n\nCharacterize a type of adjacency.\n\nSeveral functions involve relationships between neighboring trees and/or quadrants, and their behavior depends on how one defines adjacency: 1) entities are adjacent if they share a face, or 2) entities are adjacent if they share a face or corner. p4est_connect_type_t is used to choose the desired behavior. This enum must fit into an int8_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connectivity","page":"API reference","title":"P4est.LibP4est.p4est_connectivity","text":"p4est_connectivity\n\nThis structure holds the 2D inter-tree connectivity information. Identification of arbitrary faces and corners is possible.\n\nThe arrays tree_to_* are stored in z ordering. For corners the order wrt. yx is 00 01 10 11. For faces the order is -x +x -y +y. They are allocated [0][0]..[0][3]..[num_trees-1][0]..[num_trees-1][3].\n\nThe values for tree_to_face are 0..7 where ttf % 4 gives the face number and ttf / 4 the face orientation code. The orientation is 0 for edges that are aligned in z-order, and 1 for edges that are running opposite in z-order.\n\nIt is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].\n\nThe corners are only stored when they connect trees. In this case tree_to_corner indexes into ctt_offset. Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.\n\nThe arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].\n\nThe *_to_attr arrays may have arbitrary contents defined by the user.\n\nField Note\nnum_vertices the number of vertices that define the embedding of the forest (not the topology)\nnum_trees the number of trees\nnum_corners the number of corners that help define topology\nvertices an array of size (3 * num_vertices)\ntree_to_vertex embed each tree into  c++ R^3  for e.g. visualization (see p4est_vtk.h)\ntree_attr_bytes bytes per tree in tree_to_attr\ntree_to_attr not touched by p4est\ntree_to_tree (4 * num_trees) neighbors across faces\ntree_to_face (4 * num_trees) face to face+orientation (see description)\ntree_to_corner (4 * num_trees) or NULL (see description)\nctt_offset corner to offset in cornertotree and cornertocorner\ncorner_to_tree list of trees that meet at a corner\ncorner_to_corner list of tree-corners that meet at a corner\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_encode_t","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_encode_t","text":"p4est_connectivity_encode_t\n\nTypedef for serialization method.\n\nEnumerator Note\nP4EST_CONN_ENCODE_LAST Invalid entry to close the list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_t","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_t","text":"This structure holds the 2D inter-tree connectivity information. Identification of arbitrary faces and corners is possible.\n\nThe arrays tree_to_* are stored in z ordering. For corners the order wrt. yx is 00 01 10 11. For faces the order is -x +x -y +y. They are allocated [0][0]..[0][3]..[num_trees-1][0]..[num_trees-1][3].\n\nThe values for tree_to_face are 0..7 where ttf % 4 gives the face number and ttf / 4 the face orientation code. The orientation is 0 for edges that are aligned in z-order, and 1 for edges that are running opposite in z-order.\n\nIt is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].\n\nThe corners are only stored when they connect trees. In this case tree_to_corner indexes into ctt_offset. Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.\n\nThe arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].\n\nThe *_to_attr arrays may have arbitrary contents defined by the user.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange","text":"p4est_ghost_exchange\n\nTransient storage for asynchronous ghost exchange.\n\nField Note\nis_custom False for p4est_ghost_exchange_data\nis_levels Are we restricted to levels or not\nminlevel Meaningful with is_levels\nmaxlevel \n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_t","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_t","text":"Transient storage for asynchronous ghost exchange.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_ghost_t","page":"API reference","title":"P4est.LibP4est.p4est_ghost_t","text":"p4est_ghost_t\n\nquadrants that neighbor the local domain\n\nField Note\nbtype which neighbors are in the ghost layer\nghosts array of p4est_quadrant_t type\ntree_offsets num_trees + 1 ghost indices\nproc_offsets mpisize + 1 ghost indices\nmirrors array of p4est_quadrant_t type\nmirror_tree_offsets num_trees + 1 mirror indices\nmirror_proc_mirrors indices into mirrors grouped by outside processor rank and ascending within each rank\nmirror_proc_offsets mpisize + 1 indices into  mirror_proc_mirrors\nmirror_proc_fronts like mirror_proc_mirrors, but limited to the outermost octants. This is NULL until p4est_ghost_expand is called\nmirror_proc_front_offsets NULL until p4est_ghost_expand is called\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_gloidx_t","page":"API reference","title":"P4est.LibP4est.p4est_gloidx_t","text":"Typedef for globally unique indexing of quadrants.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_init_t","page":"API reference","title":"P4est.LibP4est.p4est_init_t","text":"Callback function prototype to initialize the quadrant's user data.\n\nParameters\n\np4est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\nquadrant:[in,out] the quadrant to be initialized: if data_size > 0, the data to be initialized is at quadrant->p.userdata; otherwise, the non-pointer user data (such as quadrant->p.userint) can be initialized\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_inspect","page":"API reference","title":"P4est.LibP4est.p4est_inspect","text":"p4est_inspect\n\nData pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p4est main structure.\n\nThe balance_ranges and balance_notify* times are collected whenever an inspect structure is present in p4est.\n\nField Note\nuse_balance_ranges Use sc_ranges to determine the asymmetric communication pattern. If usebalanceranges is false (the default), sc_notify is used.\nuse_balance_ranges_notify If true, call both sc_ranges and sc_notify and verify consistency. Which is actually used is still determined by usebalanceranges.\nuse_balance_verify Verify sc_ranges and/or sc_notify as applicable.\nbalance_max_ranges If positive and smaller than p4est_num ranges, overrides it\nbalance_ranges time spent in sc_ranges\nbalance_notify time spent in sc_notify\nbalance_notify_allgather time spent in sc_notify_allgather\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_inspect_t","page":"API reference","title":"P4est.LibP4est.p4est_inspect_t","text":"Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p4est main structure. Declared in p4est_extended.h. Used to profile important algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_info","page":"API reference","title":"P4est.LibP4est.p4est_iter_corner_info","text":"p4est_iter_corner_info\n\nThe information that is available to the user-defined p4est_iter_corner_t callback.\n\nIf tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P4EST_CONNECT_FACE/CORNER depending on the location of the corner relative to the tree.\n\nField Note\ntree_boundary boolean: interior face (0), tree boundary face (true)\nsides array of type p4est_iter_corner_side_t type\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_info_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_corner_info_t","text":"The information that is available to the user-defined p4est_iter_corner_t callback.\n\nIf tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P4EST_CONNECT_FACE/CORNER depending on the location of the corner relative to the tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_side","page":"API reference","title":"P4est.LibP4est.p4est_iter_corner_side","text":"p4est_iter_corner_side\n\nInformation about one side of a corner in the forest. If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nthe faces field provides some additional information about the local topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that there is a common face between these two sides of the corner.\n\nField Note\ntreeid the tree that contains quad\ncorner which of the quadrant's corners touches this corner\nis_ghost boolean: local (0) or ghost (1)\nquadid the index in the tree or ghost array\nfaces internal work data\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_side_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_corner_side_t","text":"Information about one side of a corner in the forest. If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nthe faces field provides some additional information about the local topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that there is a common face between these two sides of the corner.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_corner_t","text":"The prototype for a function that p4est_iterate will execute wherever quadrants meet at a conformal corner\n\ni.e. the callback will not execute on a hanging corner.\n\nnote: Note\nthe forest does not need to be corner balanced for p4est_iterate() to correctly execute a callback function at corners, only face balanced (see p4est_balance()).\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p4est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_info","page":"API reference","title":"P4est.LibP4est.p4est_iter_face_info","text":"p4est_iter_face_info\n\nThe information that is available to the user-defined p4est_iter_face_t callback.\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity. If the face is on the outside boundary of the forest, then there is only one side. If tree_boundary is false, the face is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P4EST_CONNECT_FACE.\n\nField Note\norientation the orientation of the sides to each other, as in the definition of p4est_connectivity_t\ntree_boundary boolean: interior face (0), tree boundary face (true)\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_info_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_face_info_t","text":"The information that is available to the user-defined p4est_iter_face_t callback.\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity. If the face is on the outside boundary of the forest, then there is only one side. If tree_boundary is false, the face is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P4EST_CONNECT_FACE.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_side","page":"API reference","title":"P4est.LibP4est.p4est_iter_face_side","text":"p4est_iter_face_side\n\nInformation about one side of a face in the forest.\n\nIf a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nField Note\ntreeid the tree on this side\nface which quadrant side the face touches\nis_hanging boolean: one full quad (0) or two smaller quads (1)\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_side_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_face_side_t","text":"Information about one side of a face in the forest.\n\nIf a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_face_t","text":"The prototype for a function that p4est_iterate will execute wherever two quadrants share a face: the face can be a 2:1 hanging face, it does not have to be conformal.\n\nnote: Note\nthe forest must be face balanced for p4est_iterate() to execute a callback function on faces (see p4est_balance()).\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p4est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_volume_info","page":"API reference","title":"P4est.LibP4est.p4est_iter_volume_info","text":"p4est_iter_volume_info\n\nThe information that is available to the user-defined p4est_iter_volume_t callback function.\n\ntreeid gives the index in p4est->trees of the tree to which quad belongs. quadid gives the index of quad within tree's quadrants array.\n\nField Note\nquad the quadrant of the callback\nquadid id in quad's tree array (see p4est_tree_t)\ntreeid the tree containing quad\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_volume_info_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_volume_info_t","text":"The information that is available to the user-defined p4est_iter_volume_t callback function.\n\ntreeid gives the index in p4est->trees of the tree to which quad belongs. quadid gives the index of quad within tree's quadrants array.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_volume_t","page":"API reference","title":"P4est.LibP4est.p4est_iter_volume_t","text":"The prototype for a function that p4est_iterate will execute at every quadrant local to the current process.\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p4est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lid_t","page":"API reference","title":"P4est.LibP4est.p4est_lid_t","text":"A datatype to handle the linear id in 2D.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_buffer","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_buffer","text":"p4est_lnodes_buffer\n\np4est_lnodes_buffer_t handles the communication of data associated with nodes.\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data. It should not be altered between a shared__begin and a shared__end call.\n\nrecv_buffers is an array of arrays that is used in lnodes_share_all_. *recv_buffers[j] corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->sharednodes. At the completion of lnodes\\share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_buffer_t","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_buffer_t","text":"p4est_lnodes_buffer_t handles the communication of data associated with nodes.\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data. It should not be altered between a shared__begin and a shared__end call.\n\nrecv_buffers is an array of arrays that is used in lnodes_share_all_. *recv_buffers[j] corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->sharednodes. At the completion of lnodes\\share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_rank","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_rank","text":"p4est_lnodes_rank\n\nThe structure stored in the sharers array.\n\nshared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes. The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p4est_lnodes_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_rank_t","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_rank_t","text":"The structure stored in the sharers array.\n\nshared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes. The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p4est_lnodes_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_t","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_t","text":"Store a parallel numbering of Lobatto points of a given degree > 0.\n\nEach element has degree+1 nodes per face and vnodes = (degree+1)^2 nodes per volume. num_local_elements is the number of local quadrants in the p4est. element_nodes is of dimension vnodes * num_local_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); so for degree == 2, this is the layout of nodes:\n\nf_3 c_2 c_3 6–-7–-8 | | f_0 3 4 5 f_1 | | 0–-1–-2 c_0 c_1 f_2\n\nelement_nodes indexes into the set of local nodes, layed out as follows: local nodes = [<––-owned_count––->|<––-nonlocal_nodes––->] = [<––––––––num_local_nodes––––––––->] nonlocal_nodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.\n\nWhether nodes are hanging or not is decided based on the element faces. This information is encoded in face_code with one int8_t per element. If no faces are hanging, the value is zero, otherwise the face_code is interpreted by p4est_lnodes_decode.\n\nIndependent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree touching the node.\n\nWhat is meant by touching? A quadrant is said to touch all faces/corners that are incident on it, and by extension all nodes that are contained in those faces/corners.\n\nX +–––––-+ o | | o | | +––-+ o | p | | q | o | | | | o | | +––-+ O +–––––-+\n\nIn this example degree = 6. There are 5 nodes that live on the face between q and p, and one at each corner of that face. The face is incident on q, so q owns the nodes on the face (provided q is from a lower tree or has a lower index than p). The lower corner is incident on q, so q owns it as well. The upper corner is not incident on q, so q cannot own it.\n\nglobal_owned_count contains the number of independent nodes owned by each process.\n\nThe sharers array contains items of type p4est_lnodes_rank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.\n\ndegree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces and corners) rather than the C^0 Lobatto nodes:\n\nif degree == -1, then one node is assigned per face, and no nodes are assigned per volume or per corner: this numbering can be used for low-order Raviart-Thomas elements. In this case, vnodes == 4, and the nodes are listed in face-order:\n\nf_3 c_2 c_3 +–-3–-+ | | f_0 0 1 f_1 | | +–-2–-+ c_0 c_1 f_2\n\nif degree == -2, then one node is assigned per face and per corner and no nodes are assigned per volume. In this case, vnodes == 8, and the nodes are listed in face-order, followed by corner-order:\n\nf_3 c_2 c_3 6–-3–-7 | | f_0 0 1 f_1 | | 4–-2–-5 c_0 c_1 f_2\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_locidx_t","page":"API reference","title":"P4est.LibP4est.p4est_locidx_t","text":"Typedef for processor-local indexing of quadrants and nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_t","page":"API reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_t","text":"p4est_mesh_face_neighbor_t\n\nThis structure can be used as the status of a face neighbor iterator. It always contains the face and subface of the neighbor to be processed.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_mesh_t","page":"API reference","title":"P4est.LibP4est.p4est_mesh_t","text":"p4est_mesh_t\n\nThis structure contains complete mesh information on a 2:1 balanced forest. It stores the locally relevant neighborhood, that is, all locally owned quadrants and one layer of adjacent ghost quadrants and their owners.\n\nFor each local quadrant, its tree number is stored in quad_to_tree. The quad_to_tree array is NULL by default and can be enabled using p4estmeshnewext. For each ghost quadrant, its owner rank is stored in ghost\\to_proc. For each level, an array of local quadrant numbers is stored in quad_level. The quad_level array is NULL by default and can be enabled using p4estmeshnew_ext.\n\nThe quad_to_quad list stores one value for each local quadrant's face. This value is in 0..local_num_quadrants-1 for local quadrants, or in local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.\n\nThe quad_to_face list has equally many entries that are either: 1. A value of v = 0..7 indicates one same-size neighbor. This value is decoded as v = r * 4 + nf, where nf = 0..3 is the neighbor's connecting face number and r = 0..1 is the relative orientation of the neighbor's face; see p4est_connectivity.h. 2. A value of v = 8..23 indicates a double-size neighbor. This value is decoded as v = 8 + h * 8 + r * 4 + nf, where r and nf are as above and h = 0..1 is the number of the subface. h designates the subface of the large neighbor that the quadrant touches (this is the same as the large neighbor's face corner). 3. A value of v = -8..-1 indicates two half-size neighbors. In this case the corresponding quad_to_quad index points into the quad_to_half array that stores two quadrant numbers per index, and the orientation of the smaller faces follows from 8 + v. The entries of quad_to_half encode between local and ghost quadrant in the same way as the quad_to_quad values described above. The small neighbors in quad_to_half are stored in the sequence of the face corners of this, i.e., the large quadrant.\n\nA quadrant on the boundary of the forest sees itself and its face number.\n\nThe quad_to_corner list stores corner neighbors that are not face neighbors. On the inside of a tree, there is precisely one such neighbor per corner. In this case, its index is encoded as described above for quad_to_quad. The neighbor's matching corner number is always diagonally opposite, that is, corner number ^ 3.\n\nOn the inside of an inter-tree face, we have precisely one corner neighbor. If a corner is an inter-tree corner, then the number of corner neighbors may be any non-negative number. In both cases, the quad_to_corner value is in local_num_quadrants + local_num_ghosts + [0 .. local_num_corners - 1]. After subtracting the number of local and ghost quadrants, it indexes into corner_offset, which encodes a group of corner neighbors. Each group contains the quadrant numbers encoded as usual for quad_to_quad in corner_quad, and the corner number from the neighbor as corner_corner.\n\nCorners with no diagonal neighbor at all are assigned the value -3. This only happens on the domain boundary, which is necessarily a tree boundary. Corner-neighbors for hanging nodes are assigned the value -1.\n\nTODO: In case of an inter-tree corner neighbor relation in a brick-like situation (exactly one neighbor, diagonally opposite corner number), use the same encoding as for corners within a tree.\n\nField Note\nquad_to_tree tree index for each local quad. Is NULL by default, but may be enabled by p4estmeshnew_ext.\nghost_to_proc processor for each ghost quad\nquad_to_quad one index for each of the 4 faces\nquad_to_face encodes orientation/2:1 status\nquad_to_half stores half-size neighbors\nquad_level Stores lists of per-level quads. The array has entries indexed by 0..P4EST_QMAXLEVEL inclusive that are arrays of local quadrant ids. Is NULL by default, but may be enabled by p4estmeshnew_ext.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_qcoord_t","page":"API reference","title":"P4est.LibP4est.p4est_qcoord_t","text":"Typedef for quadrant coordinates.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_quadrant","page":"API reference","title":"P4est.LibP4est.p4est_quadrant","text":"p4est_quadrant\n\nThe 2D quadrant datatype\n\nField Note\nx coordinates\ny \nlevel level of refinement\npad8 padding\npad16 \np a union of additional data attached to a quadrant\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_t","page":"API reference","title":"P4est.LibP4est.p4est_quadrant_t","text":"The 2D quadrant datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_refine_t","page":"API reference","title":"P4est.LibP4est.p4est_refine_t","text":"Callback function prototype to decide for refinement.\n\nParameters\n\np4est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\nquadrant:[in] the quadrant that may be refined\n\nReturns\n\nnonzero if the quadrant shall be refined.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_replace_t","page":"API reference","title":"P4est.LibP4est.p4est_replace_t","text":"Callback function prototype to replace one set of quadrants with another.\n\nThis is used by extended routines when the quadrants of an existing, valid p4est are changed. The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.\n\nIf the mesh is being refined, num_outgoing will be 1 and num_incoming will be 4, and vice versa if the mesh is being coarsened.\n\nParameters\n\nnum_outgoing:[in] The number of outgoing quadrants.\noutgoing:[in] The outgoing quadrants: after the callback, the user_data, if p4est->data_size is nonzero, will be destroyed.\nnum_incoming:[in] The number of incoming quadrants.\nincoming:[in,out] The incoming quadrants: prior to the callback, the user_data, if p4est->datasize is nonzero, is allocated, and the [`p4estinit_t`](@ref) callback, if it has been provided, will be called.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_search_all_t","page":"API reference","title":"P4est.LibP4est.p4est_search_all_t","text":"Callback function for the top-down search through the whole forest.\n\nParameters\n\np4est:[in] The forest to search. We recurse through the trees one after another.\nwhich_tree:[in] The current tree number.\nquadrant:[in] The current quadrant in the recursion. This quadrant is either a non-leaf tree branch or a leaf. If the quadrant is contained in the local partition, we know which, otherwise we don't. Let us first consider the situation when quadrant is local, which is indicated by both pfirst and plast being equal to p4est->mpirank. Then the parameter local_num is negative for non-leaves and the number of the quadrant as a leaf in local storage otherwise. Only if the quadrant is a local leaf, it points to the actual local storage and can be used to access user data etc., and the recursion terminates. The other possibility is that pfirst < plast, in which case we proceed with the recursion, or both are equal to the same remote rank, in which case the recursion terminates. Either way, the quadrant is not from local forest storage.\npfirst:[in] The lowest processor that owns part of quadrant. Guaranteed to be non-empty.\nplast:[in] The highest processor that owns part of quadrant. Guaranteed to be non-empty.\nlocal_num:[in] If quadrant is a local leaf, this number is the index of the leaf in local quadrant storage. Else, this is a negative value.\npoint:[in,out] User-defined representation of a point. This parameter distinguishes two uses of the callback. For each quadrant, the callback is first called with a NULL point, and if this callback returns true, once for each point tracked in this branch. The return value for a point determines whether it shall be tracked further down the branch or not, and has no effect on a local leaf. The call with a NULL point is intended to prepare quadrant-related search meta data that is common to all points, and/or to efficiently terminate the recursion for all points in the branch in one call.\n\nReturns\n\nIf false, the recursion at quadrant terminates. If true, it continues if pfirst < plast or if they are both equal to p4est->mpirank and the recursion has not reached a leaf yet.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_search_local_t","page":"API reference","title":"P4est.LibP4est.p4est_search_local_t","text":"Callback function to query the match of a \"point\" with a quadrant.\n\nThis function can be called in two roles: Per-quadrant, in which case the parameter point is NULL, or per-point, possibly many times per quadrant.\n\nParameters\n\np4est:[in] The forest to be queried.\nwhich_tree:[in] The tree id under consideration.\nquadrant:[in] The quadrant under consideration. This quadrant may be coarser than the quadrants that are contained in the forest (an ancestor), in which case it is a temporary variable and not part of the forest storage. Otherwise, it is a leaf and points directly into the forest storage.\nlocal_num:[in] If the quadrant is not a leaf, this is < 0. Otherwise it is the (non-negative) index of the quadrant relative to the processor-local storage.\npoint:[in] Representation of a \"point\"; user-defined. If point is NULL, the callback may be used to prepare quadrant-related search meta data.\n\nReturns\n\nIf point is NULL, true if the search confined to quadrant should be executed, false to skip it. Else, true if point may be contained in the quadrant and false otherwise; the return value has no effect on a leaf.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_search_partition_t","page":"API reference","title":"P4est.LibP4est.p4est_search_partition_t","text":"Callback function for the partition recursion.\n\nParameters\n\np4est:[in] The forest to traverse. Its local quadrants are never accessed.\nwhich_tree:[in] The tree number under consideration.\nquadrant:[in] This quadrant is not from local forest storage, and its user data is undefined. It represents the branch of the forest in the top-down recursion.\npfirst:[in] The lowest processor that owns part of quadrant. Guaranteed to be non-empty.\nplast:[in] The highest processor that owns part of quadrant. Guaranteed to be non-empty. If this is equal to pfirst, then the recursion will stop for quadrant's branch after this function returns.\npoint:[in,out] Pointer to a user-defined point object. If called per-quadrant, this is NULL.\n\nReturns\n\nIf false, the recursion at quadrant is terminated. If true, it continues if pfirst < plast.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_search_query_t","page":"API reference","title":"P4est.LibP4est.p4est_search_query_t","text":"This typedef is provided for backwards compatibility.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_t","page":"API reference","title":"P4est.LibP4est.p4est_t","text":"The p4est forest datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_topidx_t","page":"API reference","title":"P4est.LibP4est.p4est_topidx_t","text":"Typedef for counting topological entities (trees, tree vertices).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_tree","page":"API reference","title":"P4est.LibP4est.p4est_tree","text":"p4est_tree\n\nThe p4est tree datatype\n\nField Note\nquadrants locally stored quadrants\nfirst_desc first local descendant\nlast_desc last local descendant\nquadrants_offset cumulative sum over earlier trees on this processor (locals only)\nmaxlevel highest local quadrant level\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_tree_t","page":"API reference","title":"P4est.LibP4est.p4est_tree_t","text":"The p4est tree datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_weight_t","page":"API reference","title":"P4est.LibP4est.p4est_weight_t","text":"Callback function prototype to calculate weights for partitioning.\n\nnote: Note\nGlobal sum of weights must fit into a 64bit integer.\n\nParameters\n\np4est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\n\nReturns\n\na 32bit integer >= 0 as the quadrant weight.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_column_t","page":"API reference","title":"P4est.LibP4est.p6est_coarsen_column_t","text":"Callback function prototype to decide for horizontal coarsening.\n\nParameters\n\ncolumns:[in] Pointers to 4 sibling columns.\n\nReturns\n\nnonzero if the columns shall be replaced with their parent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_layer_t","page":"API reference","title":"P4est.LibP4est.p6est_coarsen_layer_t","text":"Callback function prototype to decide for vertical coarsening.\n\nParameters\n\nlayers:[in] Pointers to 2 vertical sibling layers.\n\nReturns\n\nnonzero if the layers shall be replaced with their parent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_connectivity","page":"API reference","title":"P4est.LibP4est.p6est_connectivity","text":"p6est_connectivity\n\nThis structure holds the 2D+1D inter-tree connectivity information. It is essentially a wrapper of the 2D p4est_connecitivity_t datatype, with some additional information about how the third dimension is embedded.\n\nField Note\nconn4 the 2D connecitvity; owned; vertices interpreted as the vertices of the bottom of the sheet\ntop_vertices if NULL, uniform vertical profile, otherwise the vertices of the top of the sheet: should be the same size as conn4->treetovertex; owned.\nheight if top_vertices == NULL, this gives the offset from the bottom of the sheet to the top\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_connectivity_t","page":"API reference","title":"P4est.LibP4est.p6est_connectivity_t","text":"This structure holds the 2D+1D inter-tree connectivity information. It is essentially a wrapper of the 2D p4est_connecitivity_t datatype, with some additional information about how the third dimension is embedded.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_init_t","page":"API reference","title":"P4est.LibP4est.p6est_init_t","text":"Callback function prototype to initialize the layers's user data.\n\nParameters\n\np6est:[in] the forest\nwhich_tree:[in] the tree in the forest\ncolumn:[in] the column in the tree in the forest\nlayer:[in] the layer in the column in the tree in the forest, whose user_data is to be initialized\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_refine_column_t","page":"API reference","title":"P4est.LibP4est.p6est_refine_column_t","text":"Callback function prototype to decide whether to horizontally refine a column, i.e., horizontally refine all of the layers in the column.\n\nReturns\n\nnonzero if the layer shall be refined.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_refine_layer_t","page":"API reference","title":"P4est.LibP4est.p6est_refine_layer_t","text":"Callback function prototype to decide whether to vertically refine a layer.\n\nReturns\n\nnonzero if the layer shall be refined.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_replace_t","page":"API reference","title":"P4est.LibP4est.p6est_replace_t","text":"Callback function prototype to transfer information from outgoing layers to incoming layers.\n\nThis is used by extended routines when the layers of an existing, valid p6est are changed. The callback allows the user to make changes to newly initialized layers before the layers that they replace are destroyed.\n\nParameters\n\nnum_outcolumns:[in] The number of columns that contain the outgoing layers: will be either 1 or 4.\nnum_outlayers:[in] The number of outgoing layers: will be either 1 (a single layer is being refined), 2 (two layers are being vertically coarsened), or 4 (four layers are being horizontally coarsened).\noutcolumns:[in] The columns of the outgoing layers\noutlayers:[in] The outgoing layers: after the callback, the user_data, if p6est->data_size is nonzero, will be destroyed.\nnum_incolumns:[in] The number of columns that contain the outgoing layers: will be either 1 or 4.\nnum_inlayers:[in] The number of incoming layers: will be either 1 (coarsening), 2 (vertical refinement), or 4 (horizontal refinement)\nincolumns:[in] The columns of the incoming layers\ninlayers:[in,out] The incoming layers: prior to the callback, the user_data, if p6est->datasize is nonzero, is allocated, and the [`p6estinit_t`](@ref) callback, if it has been provided, will be called.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_t","page":"API reference","title":"P4est.LibP4est.p6est_t","text":"The p6est forest datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_weight_t","page":"API reference","title":"P4est.LibP4est.p6est_weight_t","text":"Callback function prototype to calculate weights for partitioning.\n\nnote: Note\nGlobal sum of weights must fit into a 64bit integer.\n\nReturns\n\na 32bit integer >= 0 as the quadrant weight.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_coarsen_t","page":"API reference","title":"P4est.LibP4est.p8est_coarsen_t","text":"Callback function prototype to decide for coarsening.\n\nParameters\n\np8est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\nquadrants:[in] Pointers to 8 siblings in Morton ordering.\n\nReturns\n\nnonzero if the quadrants shall be replaced with their parent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connect_type_t","page":"API reference","title":"P4est.LibP4est.p8est_connect_type_t","text":"p8est_connect_type_t\n\nCharacterize a type of adjacency.\n\nSeveral functions involve relationships between neighboring trees and/or quadrants, and their behavior depends on how one defines adjacency: 1) entities are adjacent if they share a face, or 2) entities are adjacent if they share a face or corner, or 3) entities are adjacent if they share a face, corner or edge. p8est_connect_type_t is used to choose the desired behavior. This enum must fit into an int8_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connectivity","page":"API reference","title":"P4est.LibP4est.p8est_connectivity","text":"p8est_connectivity\n\nThis structure holds the 3D inter-tree connectivity information. Identification of arbitrary faces, edges and corners is possible.\n\nThe arrays tree_to_* are stored in z ordering. For corners the order wrt. zyx is 000 001 010 011 100 101 110 111. For faces the order is -x +x -y +y -z +z. They are allocated [0][0]..[0][N-1]..[num_trees-1][0]..[num_trees-1][N-1]. where N is 6 for tree and face, 8 for corner, 12 for edge.\n\nThe values for tree_to_face are in 0..23 where ttf % 6 gives the face number and ttf / 6 the face orientation code. The orientation is determined as follows. Let my_face and other_face be the two face numbers of the connecting trees in 0..5. Then the first face corner of the lower of my_face and other_face connects to a face corner numbered 0..3 in the higher of my_face and other_face. The face orientation is defined as this number. If my_face == other_face, treating either of both faces as the lower one leads to the same result.\n\nIt is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].\n\nThe edges are only stored when they connect trees. In this case tree_to_edge indexes into ett_offset. Otherwise the tree_to_edge entry must be -1 and this edge is ignored. If num_edges == 0, tree_to_edge and edge_to_* arrays are set to NULL.\n\nThe arrays edge_to_* store a variable number of entries per edge. For edge e these are at position [ett_offset[e]]..[ett_offset[e+1]-1]. Their number for edge e is ett_offset[e+1] - ett_offset[e]. The entries encode all trees adjacent to edge e. The size of the edge_to_* arrays is num_ett = ett_offset[num_edges]. The edge_to_edge array holds values in 0..23, where the lower 12 indicate one edge orientation and the higher 12 the opposite edge orientation.\n\nThe corners are only stored when they connect trees. In this case tree_to_corner indexes into ctt_offset. Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.\n\nThe arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].\n\nThe *_to_attr arrays may have arbitrary contents defined by the user.\n\nField Note\nnum_vertices the number of vertices that define the embedding of the forest (not the topology)\nnum_trees the number of trees\nnum_edges the number of edges that help define the topology\nnum_corners the number of corners that help define the topology\nvertices an array of size (3 * num_vertices)\ntree_to_vertex embed each tree into  c++ R^3  for e.g. visualization (see p8est_vtk.h)\ntree_attr_bytes bytes per tree in tree_to_attr\ntree_to_attr not touched by p4est\ntree_to_tree (6 * num_trees) neighbors across faces\ntree_to_face (6 * num_trees) face to face+orientation (see description)\ntree_to_edge (12 * num_trees) or NULL (see description)\nett_offset edge to offset in edgetotree and edgetoedge\nedge_to_tree list of trees that meet at an edge\nedge_to_edge list of tree-edges+orientations that meet at an edge (see description)\ntree_to_corner (8 * num_trees) or NULL (see description)\nctt_offset corner to offset in cornertotree and cornertocorner\ncorner_to_tree list of trees that meet at a corner\ncorner_to_corner list of tree-corners that meet at a corner\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_encode_t","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_encode_t","text":"p8est_connectivity_encode_t\n\nTypedef for serialization method.\n\nEnumerator Note\nP8EST_CONN_ENCODE_LAST Invalid entry to close the list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_t","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_t","text":"This structure holds the 3D inter-tree connectivity information. Identification of arbitrary faces, edges and corners is possible.\n\nThe arrays tree_to_* are stored in z ordering. For corners the order wrt. zyx is 000 001 010 011 100 101 110 111. For faces the order is -x +x -y +y -z +z. They are allocated [0][0]..[0][N-1]..[num_trees-1][0]..[num_trees-1][N-1]. where N is 6 for tree and face, 8 for corner, 12 for edge.\n\nThe values for tree_to_face are in 0..23 where ttf % 6 gives the face number and ttf / 6 the face orientation code. The orientation is determined as follows. Let my_face and other_face be the two face numbers of the connecting trees in 0..5. Then the first face corner of the lower of my_face and other_face connects to a face corner numbered 0..3 in the higher of my_face and other_face. The face orientation is defined as this number. If my_face == other_face, treating either of both faces as the lower one leads to the same result.\n\nIt is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].\n\nThe edges are only stored when they connect trees. In this case tree_to_edge indexes into ett_offset. Otherwise the tree_to_edge entry must be -1 and this edge is ignored. If num_edges == 0, tree_to_edge and edge_to_* arrays are set to NULL.\n\nThe arrays edge_to_* store a variable number of entries per edge. For edge e these are at position [ett_offset[e]]..[ett_offset[e+1]-1]. Their number for edge e is ett_offset[e+1] - ett_offset[e]. The entries encode all trees adjacent to edge e. The size of the edge_to_* arrays is num_ett = ett_offset[num_edges]. The edge_to_edge array holds values in 0..23, where the lower 12 indicate one edge orientation and the higher 12 the opposite edge orientation.\n\nThe corners are only stored when they connect trees. In this case tree_to_corner indexes into ctt_offset. Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.\n\nThe arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].\n\nThe *_to_attr arrays may have arbitrary contents defined by the user.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange","text":"p8est_ghost_exchange\n\nTransient storage for asynchronous ghost exchange.\n\nField Note\nis_custom False for p8est_ghost_exchange_data\nis_levels Are we restricted to levels or not\nminlevel Meaningful with is_levels\nmaxlevel \n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_t","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_t","text":"Transient storage for asynchronous ghost exchange.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_ghost_t","page":"API reference","title":"P4est.LibP4est.p8est_ghost_t","text":"p8est_ghost_t\n\nquadrants that neighbor the local domain\n\nField Note\nbtype which neighbors are in the ghost layer\nghosts array of p8est_quadrant_t type\ntree_offsets num_trees + 1 ghost indices\nproc_offsets mpisize + 1 ghost indices\nmirrors array of p8est_quadrant_t type\nmirror_tree_offsets num_trees + 1 mirror indices\nmirror_proc_mirrors indices into mirrors grouped by outside processor rank and ascending within each rank\nmirror_proc_offsets mpisize + 1 indices into  mirror_proc_mirrors\nmirror_proc_fronts like mirror_proc_mirrors, but limited to the outermost octants. This is NULL until p8est_ghost_expand is called\nmirror_proc_front_offsets NULL until p8est_ghost_expand is called\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_init_t","page":"API reference","title":"P4est.LibP4est.p8est_init_t","text":"Callback function prototype to initialize the quadrant's user data.\n\nParameters\n\np8est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\nquadrant:[in,out] the quadrant to be initialized: if data_size > 0, the data to be initialized is at quadrant->p.userdata; otherwise, the non-pointer user data (such as quadrant->p.userint) can be initialized\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_inspect","page":"API reference","title":"P4est.LibP4est.p8est_inspect","text":"p8est_inspect\n\nField Note\nuse_balance_ranges Use sc_ranges to determine the asymmetric communication pattern. If usebalanceranges is false (the default), sc_notify is used.\nuse_balance_ranges_notify If true, call both sc_ranges and sc_notify and verify consistency. Which is actually used is still determined by usebalanceranges.\nuse_balance_verify Verify sc_ranges and/or sc_notify as applicable.\nbalance_max_ranges If positive and smaller than p8est_num ranges, overrides it\nbalance_ranges time spent in sc_ranges\nbalance_notify time spent in sc_notify\nbalance_notify_allgather time spent in sc_notify_allgather\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_inspect_t","page":"API reference","title":"P4est.LibP4est.p8est_inspect_t","text":"Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p8est main structure. Declared in p8est_extended.h. Used to profile important algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_info","page":"API reference","title":"P4est.LibP4est.p8est_iter_corner_info","text":"p8est_iter_corner_info\n\nThe information that is availalbe to the user-defined p8est_iter_corner_t callback.\n\nIf tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE/CORNER depending on the location of the corner relative to the tree.\n\nField Note\ntree_boundary boolean: interior face (0), tree boundary face (true)\nsides array of p8est_iter_corner_side_t type\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_info_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_corner_info_t","text":"The information that is availalbe to the user-defined p8est_iter_corner_t callback.\n\nIf tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE/CORNER depending on the location of the corner relative to the tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_side","page":"API reference","title":"P4est.LibP4est.p8est_iter_corner_side","text":"p8est_iter_corner_side\n\nField Note\ntreeid the tree that contains quad\ncorner which of the quadrant's corners touches this corner\nis_ghost boolean: local (0) or ghost (1)\nquadid the index in the tree or ghost array\nfaces internal work data\nedges \n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_corner_t","text":"The prototype for a function that p8est_iterate will execute wherever the corner is a corner for all quadrants that touch it\n\ni.e. the callback will not execute on a corner that sits on a hanging face or edge.\n\nnote: Note\nthe forest does not need to be corner balanced for p8est_iterate() to execute a callback function at corners, only face and edge balanced.\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p8est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_info","page":"API reference","title":"P4est.LibP4est.p8est_iter_edge_info","text":"p8est_iter_edge_info\n\nThe information about all sides of an edge in the forest. If tree_boundary is false, the edge is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the edge. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE depending on the location of the edge relative to the tree.\n\nField Note\ntree_boundary boolean: interior face (0), tree boundary face (true)\nsides array of p8est_iter_edge_side_t type\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_info_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_edge_info_t","text":"The information about all sides of an edge in the forest. If tree_boundary is false, the edge is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the edge. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE depending on the location of the edge relative to the tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_side","page":"API reference","title":"P4est.LibP4est.p8est_iter_edge_side","text":"p8est_iter_edge_side\n\nField Note\ntreeid the tree on this side\nedge which quadrant side the edge touches\norientation the orientation of each quadrant relative to this edge, as in the definition of p8est_connectivity_t\nis_hanging boolean: one full quad (0) or two smaller quads (1)\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_edge_t","text":"The prototype for a function that p8est_iterate will execute wherever the edge is an edge of all quadrants that touch it i.e. the callback will not execute on an edge the sits on a hanging face.\n\nnote: Note\nthe forest must be edge balanced for p8est_iterate() to execute a callback function on edges.\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p8est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_info","page":"API reference","title":"P4est.LibP4est.p8est_iter_face_info","text":"p8est_iter_face_info\n\nThe information that is available to the user-defined p8est_iter_face_t callback.\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity. If the face is on the outside of the forest, then there is only one side. If tree_boundary is false, the face is on the interior of a tree. When tree_boundary false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P8EST_CONNECT_FACE.\n\nField Note\norientation the orientation of the sides to each other, as in the definition of p8est_connectivity_t\ntree_boundary boolean: interior face (0), tree boundary face (true)\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_info_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_face_info_t","text":"The information that is available to the user-defined p8est_iter_face_t callback.\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity. If the face is on the outside of the forest, then there is only one side. If tree_boundary is false, the face is on the interior of a tree. When tree_boundary false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P8EST_CONNECT_FACE.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_side","page":"API reference","title":"P4est.LibP4est.p8est_iter_face_side","text":"p8est_iter_face_side\n\nInformation about one side of a face in the forest. If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nField Note\ntreeid the tree on this side\nface which quadrant side the face touches\nis_hanging boolean: one full quad (0) or four smaller quads (1)\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_side_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_face_side_t","text":"Information about one side of a face in the forest. If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_face_t","text":"The prototype for a function that p8est_iterate() will execute wherever two quadrants share a face: the face can be a 2:1 hanging face, it does not have to be conformal.\n\nnote: Note\nthe forest must be face balanced for p8est_iterate() to execute a callback function on faces (see p8est_balance()).\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p8est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_volume_info","page":"API reference","title":"P4est.LibP4est.p8est_iter_volume_info","text":"p8est_iter_volume_info\n\nThe information that is available to the user-defined p8est_iter_volume_t callback function.\n\ntreeid gives the index in p4est->trees of the tree to which quad belongs. quadid gives the index of quad within tree's quadrants array.\n\nField Note\nquad the quadrant of the callback\nquadid id in quad's tree array (see p8est_tree_t)\ntreeid the tree containing quad\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_volume_info_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_volume_info_t","text":"The information that is available to the user-defined p8est_iter_volume_t callback function.\n\ntreeid gives the index in p4est->trees of the tree to which quad belongs. quadid gives the index of quad within tree's quadrants array.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_volume_t","page":"API reference","title":"P4est.LibP4est.p8est_iter_volume_t","text":"The prototype for a function that p8est_iterate() will execute at every quadrant local to the current process.\n\nParameters\n\ninfo:[in] information about a quadrant provided to the user\nuser_data:[in,out] the user context passed to p8est_iterate()\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lid_t","page":"API reference","title":"P4est.LibP4est.p8est_lid_t","text":"A datatype to handle the linear id in 3D. We use the implementation of unsigned 128 bit integer in libsc, i.e., a struct with the members high_bits and low_bits (both uint64_t).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_buffer","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_buffer","text":"p8est_lnodes_buffer\n\np8est_lnodes_buffer_t handles the communication of data associated with nodes.\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data. It should not be altered between a shared__begin and a shared__end call.\n\nrecv_buffers is an array of arrays that is used in lnodes_share_all_. *recv_buffers[j] corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->sharednodes. At the completion of lnodes\\share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_buffer_t","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_buffer_t","text":"p8est_lnodes_buffer_t handles the communication of data associated with nodes.\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data. It should not be altered between a shared__begin and a shared__end call.\n\nrecv_buffers is an array of arrays that is used in lnodes_share_all_. *recv_buffers[j] corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->sharednodes. At the completion of lnodes\\share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_rank","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_rank","text":"p8est_lnodes_rank\n\nThe structure stored in the sharers array.\n\nshared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes. The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p8est_lnodes_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_rank_t","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_rank_t","text":"The structure stored in the sharers array.\n\nshared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes. The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p8est_lnodes_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_t","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_t","text":"Store a parallel numbering of Lobatto points of a given degree > 0.\n\nEach element has degree+1 nodes per edge and vnodes = (degree+1)^3 nodes per volume. element_nodes is of dimension vnodes * num_local_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); element_nodes indexes into the set of local nodes, layed out as follows: local nodes = [<––-owned_count––->|<––-nonlocal_nodes––->] = [<––––––––num_local_nodes––––––––->] nonlocal_nodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.\n\nWhether nodes are hanging or not is decided based on the element faces and edges. This information is encoded in face_code with one int16_t per element. If no faces or edges are hanging, the value is zero, otherwise the face_code is interpreted by p8est_lnodes_decode.\n\nIndependent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree touching the node.\n\nWhat is meant by touching? A quadrant is said to touch all faces/edges/corners that are incident on it, and by extension all nodes that are contained in those faces/edges/corners.\n\nX +–––––-+ x |\\ \\ x | \\ \\ . x | \\ \\ x X | +–––––-+ +––-+ . . | | | |\\ \\ X o + | | | +––-+ o . \\ | p | + | q | o \\ | | \\| | o \\| | +––-+ O +–––––-+\n\nIn this example degree = 3. There are 4 nodes that live on the face between q and p, two on each edge and one at each corner of that face. The face is incident on q, so q owns the nodes marked '.' on the face (provided q is from a lower tree or has a lower index than p). The bottom and front edges are incident on q, so q owns its nodes marked 'o' as well. The front lower corner is incident on q, so q owns its node 'O' as well. The other edges and corners are not incident on q, so q cannot own their nodes, marked 'x' and 'X'.\n\nglobal_owned_count contains the number of independent nodes owned by each process.\n\nThe sharers array contains items of type p8est_lnodes_rank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.\n\ndegree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces, edge and corners) rather than the C^0 Lobatto nodes:\n\nif degree == -1, then one node is assigned per face, and no nodes are assigned per volume, per edge, or per corner: this numbering can be used for low-order Raviart-Thomas elements. In this case, vnodes == 6, and the nodes are listed in face-order.\n\nif degree == -2, then one node is assigned per face and per edge and no nodes are assigned per volume or per corner. In this case, vnodes == 18, and the nodes are listed in face-order, followed by edge-order.\n\nif degree == -3, then one node is assigned per face, per edge and per corner and no nodes are assigned per volume. In this case, vnodes == 26, and the nodes are listed in face-order, followed by edge-order, followed by corner-order.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_t","page":"API reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_t","text":"p8est_mesh_face_neighbor_t\n\nThis structure can be used as the status of a face neighbor iterator. It always contains the face and subface of the neighbor to be processed.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_mesh_t","page":"API reference","title":"P4est.LibP4est.p8est_mesh_t","text":"p8est_mesh_t\n\nThis structure contains complete mesh information on a 2:1 balanced forest. It stores the locally relevant neighborhood, that is, all locally owned quadrants and one layer of adjacent ghost quadrants and their owners.\n\nFor each local quadrant, its tree number is stored in quad_to_tree. The quad_to_tree array is NULL by default and can be enabled using p8estmeshnewext. For each ghost quadrant, its owner rank is stored in ghost\\to_proc. For each level, an array of local quadrant numbers is stored in quad_level. The quad_level array is NULL by default and can be enabled using p8estmeshnew_ext.\n\nThe quad_to_quad list stores one value for each local quadrant's face. This value is in 0..local_num_quadrants-1 for local quadrants, or in local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.\n\nThe quad_to_face list has equally many entries that are either: 1. A value of v = 0..23 indicates one same-size neighbor. This value is decoded as v = r * 6 + nf, where nf = 0..5 is the neighbor's connecting face number and r = 0..3 is the relative orientation of the neighbor's face; see p8est_connectivity.h. 2. A value of v = 24..119 indicates a double-size neighbor. This value is decoded as v = 24 + h * 24 + r * 6 + nf, where r and nf are as above and h = 0..3 is the number of the subface. h designates the subface of the large neighbor that the quadrant touches (this is the same as the large neighbor's face corner). 3. A value of v = -24..-1 indicates four half-size neighbors. In this case the corresponding quad_to_quad index points into the quad_to_half array that stores four quadrant numbers per index, and the orientation of the smaller faces follows from 24 + v. The entries of quad_to_half encode between local and ghost quadrant in the same way as the quad_to_quad values described above. The small neighbors in quad_to_half are stored in the sequence of the face corners of this, i.e., the large quadrant.\n\nA quadrant on the boundary of the forest sees itself and its face number.\n\nThe quad_to_edge list stores edge neighbors that are not face neighbors. On the inside of a tree, there are one or two of those depending on size. Between trees, there can be any number of same- or different-sized neighbors. For same-tree same-size neighbors, we record their number in quad_to_edge by the same convention as described for quad_to_quad above. In this case, the neighbor's matching edge number is always diagonally opposite, that is, edge number ^ 3.\n\nFor half- and double-size and all inter-tree edge neighbors, the quad_to_edge value is in local_num_quadrants + local_num_ghosts + [0 .. local_num_edges - 1]. After subtracting the number of local and ghost quadrants, it indexes into edge_offset, which encodes a group of edge neighbors. Each member of a group may be one same/double-size quadrant or two half-size quadrants; this is determined by the value of the edge_edge field as follows. 1. A value of e = 0..23 indicates one same-size neighbor. This value is encoded as e = r * 12 + ne, where ne = 0..11 is the neighbor's connecting edge number and r = 0..1 indicates an edge flip. 2. A value of e = 24..71 indicates a double-size neighbor. This value is decoded as e = 24 + h * 24 + r * 12 + ne, where r and ne are as above and h = 0..1 is the number of the subedge. h designates the subedge of the large neighbor that the quadrant touches (this is the same as the large neighbor's edge corner). 3. A value of e = -24..-1 indicates two half-size neighbors. They are represented by two consecutive entries of the edge_quad and edge_edge arrays with identical values for edge_edge. The orientation of the smaller edges follows from 24 + e. The small neighbors in edge_quad are stored in the sequence of the edge corners of this, i.e., the large quadrant.\n\nEdges with no diagonal neighbor at all are assigned the value -3. This only happens on the domain boundary, which is necessarily a tree boundary. Edge neighbors for face-hanging nodes are assigned the value -1.\n\nThe quad_to_corner list stores corner neighbors that are not face or edge neighbors. On the inside of a tree, there is precisely one such neighbor per corner. In this case, its index is encoded as described above for quad_to_quad. The neighbor's matching corner number is always diagonally opposite, that is, corner number ^ 7.\n\nOn the inside of an inter-tree face, we have precisely one corner neighbor. If a corner is across an inter-tree edge or corner, then the number of corner neighbors may be any non-negative number. In all three cases, the quad_to_corner value is in local_num_quadrants + local_num_ghosts + [0 .. local_num_corners - 1]. After subtracting the number of local and ghost quadrants, it indexes into corner_offset, which encodes a group of corner neighbors. Each group contains the quadrant numbers encoded as usual for quad_to_quad in corner_quad, and the corner number from the neighbor as corner_corner.\n\nCorners with no diagonal neighbor at all are assigned the value -3. This only happens on the domain boundary, which is necessarily a tree boundary. Corner-neighbors for face- and edge-hanging nodes are assigned the value -1.\n\nTODO: In case of an inter-tree neighbor relation in a brick-like situation (one same-size neighbor, diagonally opposite edge/corner), use the same encoding as for edges/corners within a tree.\n\nField Note\nquad_to_tree tree index for each local quad. Is NULL by default, but may be enabled by p8estmeshnew_ext.\nghost_to_proc processor for each ghost quad\nquad_to_quad one index for each of the 6 faces\nquad_to_face encodes orientation/2:1 status\nquad_to_half stores half-size neighbors\nquad_level Stores lists of per-level quads. The array has entries indexed by 0..P4EST_QMAXLEVEL inclusive that are arrays of local quadrant ids. Is NULL by default, but may be enabled by p8estmeshnew_ext.\nlocal_num_edges unsame-size and tree-boundary edges\nquad_to_edge 12 indices for each local quad\nedge_offset local_num_edges + 1 entries\nedge_quad edge_offset indexes into this\nedge_edge and this one too (type int8_t)\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_quadrant","page":"API reference","title":"P4est.LibP4est.p8est_quadrant","text":"p8est_quadrant\n\nThe 3D quadrant (i.e., octant) datatype\n\nField Note\nx coordinates\ny \nz \nlevel level of refinement\npad8 padding\npad16 \np a union of additional data attached to a quadrant\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_t","page":"API reference","title":"P4est.LibP4est.p8est_quadrant_t","text":"The 3D quadrant (i.e., octant) datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_refine_t","page":"API reference","title":"P4est.LibP4est.p8est_refine_t","text":"Callback function prototype to decide for refinement.\n\nParameters\n\np8est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\nquadrant:[in] the quadrant that may be refined\n\nReturns\n\nnonzero if the quadrant shall be refined.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_replace_t","page":"API reference","title":"P4est.LibP4est.p8est_replace_t","text":"Callback function prototype to replace one set of quadrants with another.\n\nThis is used by extended routines when the quadrants of an existing, valid p8est are changed. The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.\n\nIf the mesh is being refined, num_outgoing will be 1 and num_incoming will be 8, and vice versa if the mesh is being coarsened.\n\nParameters\n\nnum_outgoing:[in] The number of outgoing quadrants.\noutgoing:[in] The outgoing quadrants: after the callback, the user_data, if p8est->data_size is nonzero, will be destroyed.\nnum_incoming:[in] The number of incoming quadrants.\nincoming:[in,out] The incoming quadrants: prior to the callback, the user_data, if p8est->datasize is nonzero, is allocated, and the [`p8estinit_t`](@ref) callback, if it has been provided, will be called.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_search_all_t","page":"API reference","title":"P4est.LibP4est.p8est_search_all_t","text":"Callback function for the top-down search through the whole forest.\n\nParameters\n\np4est:[in] The forest to search. We recurse through the trees one after another.\nwhich_tree:[in] The current tree number.\nquadrant:[in] The current quadrant in the recursion. This quadrant is either a non-leaf tree branch or a leaf. If the quadrant is contained in the local partition, we know which, otherwise we don't. Let us first consider the situation when quadrant is local, which is indicated by both pfirst and plast being equal to p4est->mpirank. Then the parameter local_num is negative for non-leaves and the number of the quadrant as a leaf in local storage otherwise. Only if the quadrant is a local leaf, it points to the actual local storage and can be used to access user data etc., and the recursion terminates. The other possibility is that pfirst < plast, in which case we proceed with the recursion, or both are equal to the same remote rank, in which case the recursion terminates. Either way, the quadrant is not from local forest storage.\npfirst:[in] The lowest processor that owns part of quadrant. Guaranteed to be non-empty.\nplast:[in] The highest processor that owns part of quadrant. Guaranteed to be non-empty.\nlocal_num:[in] If quadrant is a local leaf, this number is the index of the leaf in local quadrant storage. Else, this is a negative value.\npoint:[in,out] User-defined representation of a point. This parameter distinguishes two uses of the callback. For each quadrant, the callback is first called with a NULL point, and if this callback returns true, once for each point tracked in this branch. The return value for a point determines whether it shall be tracked further down the branch or not, and has no effect on a local leaf. The call with a NULL point is intended to prepare quadrant-related search meta data that is common to all points, and/or to efficiently terminate the recursion for all points in the branch in one call.\n\nReturns\n\nIf false, the recursion at quadrant terminates. If true, it continues if pfirst < plast or if they are both equal to p4est->mpirank and the recursion has not reached a leaf yet.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_search_local_t","page":"API reference","title":"P4est.LibP4est.p8est_search_local_t","text":"Callback function to query the match of a \"point\" with a quadrant.\n\nThis function can be called in two roles: Per-quadrant, in which case the parameter point is NULL, or per-point, possibly many times per quadrant.\n\nParameters\n\np4est:[in] The forest to be queried.\nwhich_tree:[in] The tree id under consideration.\nquadrant:[in] The quadrant under consideration. This quadrant may be coarser than the quadrants that are contained in the forest (an ancestor), in which case it is a temporary variable and not part of the forest storage. Otherwise, it is a leaf and points directly into the forest storage.\nlocal_num:[in] If the quadrant is not a leaf, this is < 0. Otherwise it is the (non-negative) index of the quadrant relative to the processor-local storage.\npoint:[in] Representation of a \"point\"; user-defined. If point is NULL, the callback may be used to prepare quadrant-related search meta data.\n\nReturns\n\nIf point is NULL, true if the search confined to quadrant should be executed, false to skip it. Else, true if point may be contained in the quadrant and false otherwise; the return value has no effect on a leaf.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_search_partition_t","page":"API reference","title":"P4est.LibP4est.p8est_search_partition_t","text":"Callback function for the partition recursion.\n\nParameters\n\np4est:[in] The forest to traverse. Its local quadrants are never accessed.\nwhich_tree:[in] The tree number under consideration.\nquadrant:[in] This quadrant is not from local forest storage, and its user data is undefined. It represents the branch of the forest in the top-down recursion.\npfirst:[in] The lowest processor that owns part of quadrant. Guaranteed to be non-empty.\nplast:[in] The highest processor that owns part of quadrant. Guaranteed to be non-empty. If this is equal to pfirst, then the recursion will stop for quadrant's branch after this function returns.\npoint:[in,out] Pointer to a user-defined point object. If called per-quadrant, this is NULL.\n\nReturns\n\nIf false, the recursion at quadrant is terminated. If true, it continues if pfirst < plast.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_search_query_t","page":"API reference","title":"P4est.LibP4est.p8est_search_query_t","text":"This typedef is provided for backwards compatibility.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_t","page":"API reference","title":"P4est.LibP4est.p8est_t","text":"The p8est forest datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_tree","page":"API reference","title":"P4est.LibP4est.p8est_tree","text":"p8est_tree\n\nThe p8est tree datatype\n\nField Note\nquadrants locally stored quadrants\nfirst_desc first local descendant\nlast_desc last local descendant\nquadrants_offset cumulative sum over earlier trees on this processor (locals only)\nmaxlevel highest local quadrant level\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_tree_t","page":"API reference","title":"P4est.LibP4est.p8est_tree_t","text":"The p8est tree datatype\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_weight_t","page":"API reference","title":"P4est.LibP4est.p8est_weight_t","text":"Callback function prototype to calculate weights for partitioning.\n\nnote: Note\nGlobal sum of weights must fit into a 64bit integer.\n\nParameters\n\np8est:[in] the forest\nwhich_tree:[in] the tree containing quadrant\n\nReturns\n\na 32bit integer >= 0 as the quadrant weight.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_array","page":"API reference","title":"P4est.LibP4est.sc_array","text":"sc_array\n\nThe sc_array object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index. Their address may change. The number of elements (== elem_count) of the array can be changed by  scarrayresize and scarrayrewind. Elements can be sorted with scarraysort. If the array is sorted, it can be searched with scarraybsearch. A priority queue is implemented with pqueue_add and pqueue_pop (untested).\n\nField Note\nelem_size size of a single element\nelem_count number of valid elements\nbyte_alloc number of allocated bytes or -(number of viewed bytes + 1) if this is a view: the \"+ 1\" distinguishes an array of size 0 from a view of size 0\narray linear array to store elements\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_array_t","page":"API reference","title":"P4est.LibP4est.sc_array_t","text":"The sc_array object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index. Their address may change. The number of elements (== elem_count) of the array can be changed by  scarrayresize and scarrayrewind. Elements can be sorted with scarraysort. If the array is sorted, it can be searched with scarraybsearch. A priority queue is implemented with pqueue_add and pqueue_pop (untested).\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_array_type_t","page":"API reference","title":"P4est.LibP4est.sc_array_type_t","text":"Function to determine the enumerable type of an object in an array.\n\nParameters\n\narray:[in] Array containing the object.\nindex:[in] The location of the object.\ndata:[in] Arbitrary user data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_equal_function_t","page":"API reference","title":"P4est.LibP4est.sc_equal_function_t","text":"Function to check equality of two objects.\n\nParameters\n\nu:[in] Arbitrary user data.\n\nReturns\n\nReturns false if *v1 is unequal *v2 and true otherwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash","page":"API reference","title":"P4est.LibP4est.sc_hash","text":"sc_hash\n\nThe sc_hash implements a hash table. It uses an array which has linked lists as elements.\n\nField Note\nelem_count total number of objects contained\nslots the slot count is slots->elem_count\nuser_data user data passed to hash function\nallocator must allocate sc_link_t\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_array","page":"API reference","title":"P4est.LibP4est.sc_hash_array","text":"sc_hash_array\n\nThe sc_hash_array implements an array backed up by a hash table. This enables O(1) access for array elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_array_t","page":"API reference","title":"P4est.LibP4est.sc_hash_array_t","text":"The sc_hash_array implements an array backed up by a hash table. This enables O(1) access for array elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_foreach_t","page":"API reference","title":"P4est.LibP4est.sc_hash_foreach_t","text":"Function to call on every data item of a hash table.\n\nParameters\n\nv:[in] The address of the pointer to the current object.\nu:[in] Arbitrary user data.\n\nReturns\n\nReturn true if the traversal should continue, false to stop.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_function_t","page":"API reference","title":"P4est.LibP4est.sc_hash_function_t","text":"Function to compute a hash value of an object.\n\nParameters\n\nv:[in] The object to hash.\nu:[in] Arbitrary user data.\n\nReturns\n\nReturns an unsigned integer.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_t","page":"API reference","title":"P4est.LibP4est.sc_hash_t","text":"The sc_hash implements a hash table. It uses an array which has linked lists as elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_encode_t","page":"API reference","title":"P4est.LibP4est.sc_io_encode_t","text":"sc_io_encode_t\n\nEnumerator Note\nSC_IO_ENCODE_LAST Invalid entry to close list\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_error_t","page":"API reference","title":"P4est.LibP4est.sc_io_error_t","text":"sc_io_error_t\n\nError values for io.\n\nEnumerator Note\nSC_IO_ERROR_NONE The value of zero means no error.\nSC_IO_ERROR_FATAL The io object is now disfunctional.\nSC_IO_ERROR_AGAIN Another io operation may resolve it. The function just returned was a noop.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_mode_t","page":"API reference","title":"P4est.LibP4est.sc_io_mode_t","text":"sc_io_mode_t\n\nEnumerator Note\nSC_IO_MODE_WRITE Semantics as \"w\" in fopen.\nSC_IO_MODE_APPEND Semantics as \"a\" in fopen.\nSC_IO_MODE_LAST Invalid entry to close list\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_sink","page":"API reference","title":"P4est.LibP4est.sc_io_sink","text":"sc_io_sink\n\nField Note\nbuffer_bytes distinguish from array elems\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_source","page":"API reference","title":"P4est.LibP4est.sc_io_source","text":"sc_io_source\n\nField Note\nbuffer_bytes distinguish from array elems\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_type_t","page":"API reference","title":"P4est.LibP4est.sc_io_type_t","text":"sc_io_type_t\n\nEnumerator Note\nSC_IO_TYPE_LAST Invalid entry to close list\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_link","page":"API reference","title":"P4est.LibP4est.sc_link","text":"sc_link\n\nThe sc_link structure is one link of a linked list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_link_t","page":"API reference","title":"P4est.LibP4est.sc_link_t","text":"The sc_link structure is one link of a linked list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_list","page":"API reference","title":"P4est.LibP4est.sc_list","text":"sc_list\n\nThe sc_list object provides a linked list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_list_t","page":"API reference","title":"P4est.LibP4est.sc_list_t","text":"The sc_list object provides a linked list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mempool","page":"API reference","title":"P4est.LibP4est.sc_mempool","text":"sc_mempool\n\nThe sc_mempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool) and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.\n\nField Note\nelem_size size of a single element\nelem_count number of valid elements\nzero_and_persist Boolean; is set in constructor.\nmstamp fixed-size chunk allocator\nfreed buffers the freed elements\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mempool_t","page":"API reference","title":"P4est.LibP4est.sc_mempool_t","text":"The sc_mempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool) and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mstamp","page":"API reference","title":"P4est.LibP4est.sc_mstamp","text":"sc_mstamp\n\nA data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See scmempoolt for that purpose.\n\nField Note\nelem_size Input parameter: size per item\nper_stamp Number of items per stamp\nstamp_size Bytes allocated in a stamp\ncur_snext Next number within a stamp\ncurrent Memory of current stamp\nremember Collects all stamps\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mstamp_t","page":"API reference","title":"P4est.LibP4est.sc_mstamp_t","text":"A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See scmempoolt for that purpose.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_recycle_array","page":"API reference","title":"P4est.LibP4est.sc_recycle_array","text":"sc_recycle_array\n\nThe sc_recycle_array object provides an array of slots that can be reused.\n\nIt keeps a list of free slots in the array which will be used for insertion while available. Otherwise, the array is grown.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_t","page":"API reference","title":"P4est.LibP4est.sc_recycle_array_t","text":"The sc_recycle_array object provides an array of slots that can be reused.\n\nIt keeps a list of free slots in the array which will be used for insertion while available. Otherwise, the array is grown.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_uint128","page":"API reference","title":"P4est.LibP4est.sc_uint128","text":"sc_uint128\n\nAn unsigned 128 bit integer represented as two uint64_t.\n\nField Note\nhigh_bits The more significant 64 bits.\nlow_bits The less significant 64 bits.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_uint128_t","page":"API reference","title":"P4est.LibP4est.sc_uint128_t","text":"An unsigned 128 bit integer represented as two uint64_t.\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_balance-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_balance","text":"p4est_balance(p4est_, btype, init_fn)\n\n2:1 balance the size differences of neighboring elements in a forest.\n\nParameters\n\np4est:[in,out] The p4est to be worked on.\nbtype:[in] Balance type (face or corner/full). Corner balance is almost never required when discretizing a PDE; just causes smoother mesh grading.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p4est_balance (p4est_t * p4est, p4est_connect_type_t btype, p4est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_balance_ext-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_balance_ext","text":"p4est_balance_ext(p4est_, btype, init_fn, replace_fn)\n\n2:1 balance the size differences of neighboring elements in a forest.\n\nParameters\n\np4est:[in,out] The p4est to be worked on.\nbtype:[in] Balance type (face or corner/full). Corner balance is almost never required when discretizing a PDE; just causes smoother mesh grading.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p4est_balance_ext (p4est_t * p4est, p4est_connect_type_t btype, p4est_init_t init_fn, p4est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_balance_subtree_ext-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_balance_subtree_ext","text":"p4est_balance_subtree_ext(p4est_, btype, which_tree, init_fn, replace_fn)\n\nPrototype\n\nvoid p4est_balance_subtree_ext (p4est_t * p4est, p4est_connect_type_t btype, p4est_topidx_t which_tree, p4est_init_t init_fn, p4est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_checksum-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_checksum","text":"p4est_checksum(p4est_)\n\nCompute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize.\n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nPrototype\n\nunsigned p4est_checksum (p4est_t * p4est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_checksum_partition-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_checksum_partition","text":"p4est_checksum_partition(p4est_)\n\nCompute a partition-dependent checksum for a forest.\n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nPrototype\n\nunsigned p4est_checksum_partition (p4est_t * p4est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_coarsen-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_coarsen","text":"p4est_coarsen(p4est_, coarsen_recursive, coarsen_fn, init_fn)\n\nCoarsen a forest.\n\nParameters\n\np4est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncoarsen_fn:[in] Callback function that returns true if a family of quadrants shall be coarsened\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p4est_coarsen (p4est_t * p4est, int coarsen_recursive, p4est_coarsen_t coarsen_fn, p4est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_coarsen_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_coarsen_ext","text":"p4est_coarsen_ext(p4est_, coarsen_recursive, callback_orphans, coarsen_fn, init_fn, replace_fn)\n\nCoarsen a forest.\n\nParameters\n\np4est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncallback_orphans:[in] Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family. With coarsen_recursive false and callback_orphans true, it is guaranteed that every quadrant is passed exactly once into the coarsen_fn callback.\ncoarsen_fn:[in] Callback function that returns true if a family of quadrants shall be coarsened.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p4est_coarsen_ext (p4est_t * p4est, int coarsen_recursive, int callback_orphans, p4est_coarsen_t coarsen_fn, p4est_init_t init_fn, p4est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connect_type_int-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connect_type_int","text":"p4est_connect_type_int(btype)\n\nConvert the p4est_connect_type_t into a number.\n\nParameters\n\nbtype:[in] The balance type to convert.\n\nReturns\n\nReturns 1 or 2.\n\nPrototype\n\nint p4est_connect_type_int (p4est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connect_type_string-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connect_type_string","text":"p4est_connect_type_string(btype)\n\nConvert the p4est_connect_type_t into a const string.\n\nParameters\n\nbtype:[in] The balance type to convert.\n\nReturns\n\nReturns a pointer to a constant string.\n\nPrototype\n\nconst char *p4est_connect_type_string (p4est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_bcast-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_bcast","text":"p4est_connectivity_bcast(conn_in, root, comm)\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_bcast (p4est_connectivity_t * conn_in, int root, sc_MPI_Comm comm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_complete-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_complete","text":"p4est_connectivity_complete(conn)\n\nInternally connect a connectivity based on tree_to_vertex information. Periodicity that is not inherent in the list of vertices will be lost.\n\nParameters\n\nconn:[in,out] The connectivity needs to have proper vertices and tree_to_vertex fields. The tree_to_tree and tree_to_face fields must be allocated and satisfy p4est_connectivity_is_valid (conn) but will be overwritten. The corner fields will be freed and allocated anew.\n\nPrototype\n\nvoid p4est_connectivity_complete (p4est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_deflate-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_deflate","text":"p4est_connectivity_deflate(conn, code)\n\nAllocate memory and store the connectivity information there.\n\nParameters\n\nconn:[in] The connectivity structure to be exported to memory.\ncode:[in] Encoding and compression method for serialization.\n\nReturns\n\nNewly created array that contains the information.\n\nPrototype\n\nsc_array_t *p4est_connectivity_deflate (p4est_connectivity_t * conn, p4est_connectivity_encode_t code);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_destroy","text":"p4est_connectivity_destroy(connectivity)\n\nDestroy a connectivity structure. Also destroy all attributes.\n\nPrototype\n\nvoid p4est_connectivity_destroy (p4est_connectivity_t * connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_face_neighbor_corner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_face_neighbor_corner","text":"p4est_connectivity_face_neighbor_corner(c, f, nf, o)\n\nTransform a corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately.\n\n.\n\nParameters\n\nc:[in] A corner number in 0..3.\nf:[in] A face number that touches the corner c.\nnf:[in] A neighbor face that is on the other side of .\no:[in] The orientation between tree boundary faces f and\n\nReturns\n\nThe number of the corner seen from the neighbor tree.\n\nPrototype\n\nint p4est_connectivity_face_neighbor_corner (int c, int f, int nf, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_face_neighbor_face_corner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_face_neighbor_face_corner","text":"p4est_connectivity_face_neighbor_face_corner(fc, f, nf, o)\n\nTransform a face corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately.\n\n.\n\nParameters\n\nfc:[in] A face corner number in 0..1.\nf:[in] A face that the face corner number fc is relative to.\nnf:[in] A neighbor face that is on the other side of .\no:[in] The orientation between tree boundary faces f and\n\nReturns\n\nThe face corner number relative to the neighbor's face.\n\nPrototype\n\nint p4est_connectivity_face_neighbor_face_corner (int fc, int f, int nf, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_inflate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_inflate","text":"p4est_connectivity_inflate(buffer)\n\nCreate new connectivity from a memory buffer.\n\nParameters\n\nbuffer:[in] The connectivity is created from this memory buffer.\n\nReturns\n\nThe newly created connectivity, or NULL on error.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_inflate (sc_array_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_is_equal-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_is_equal","text":"p4est_connectivity_is_equal(conn1, conn2)\n\nCheck two connectivity structures for equality.\n\nReturns\n\nReturns true if structures are equal, false otherwise.\n\nPrototype\n\nint p4est_connectivity_is_equal (p4est_connectivity_t * conn1, p4est_connectivity_t * conn2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_is_equivalent-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_is_equivalent","text":"p4est_connectivity_is_equivalent(conn1, conn2)\n\np4est_connectivity_is_equivalent This function compares two connectivities for equivalence: it returns true if they are the same connectivity, or if they have the same topology. The definition of topological sameness is strict: there is no attempt made to determine whether permutation and/or rotation of the trees makes the connectivities equivalent.\n\nParameters\n\nconn1:[in] a valid connectivity\nconn2:[out] a valid connectivity\n\nPrototype\n\nint p4est_connectivity_is_equivalent (p4est_connectivity_t * conn1, p4est_connectivity_t * conn2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_is_valid-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_is_valid","text":"p4est_connectivity_is_valid(connectivity)\n\nExamine a connectivity structure.\n\nReturns\n\nReturns true if structure is valid, false otherwise.\n\nPrototype\n\nint p4est_connectivity_is_valid (p4est_connectivity_t * connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_join_faces-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_join_faces","text":"p4est_connectivity_join_faces(conn, tree_left, tree_right, face_left, face_right, orientation)\n\np4est_connectivity_join_faces This function takes an existing valid connectivity conn and modifies it by joining two tree faces that are currently boundary faces.\n\nParameters\n\nconn:[in,out] connectivity that will be altered.\ntree_left:[in] tree that will be on the left side of the joined faces.\ntree_right:[in] tree that will be on the right side of the joined faces.\nface_left:[in] face of tree_left that will be joined.\nface_right:[in] face of tree_right that will be joined.\norientation:[in] the orientation of face_left and face_right once joined (see the description of p4est_connectivity_t to understand orientation).\n\nPrototype\n\nvoid p4est_connectivity_join_faces (p4est_connectivity_t * conn, p4est_topidx_t tree_left, p4est_topidx_t tree_right, int face_left, int face_right, int orientation);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_load-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_load","text":"p4est_connectivity_load(filename, bytes)\n\nLoad a connectivity structure from disk.\n\nParameters\n\nfilename:[in] Name of the file to read.\nbytes:[in,out] Size in bytes of connectivity on disk or NULL.\n\nReturns\n\nReturns valid connectivity, or NULL on file error.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_load (const char *filename, size_t *bytes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_memory_used","text":"p4est_connectivity_memory_used(conn)\n\nCalculate memory usage of a connectivity structure.\n\nParameters\n\nconn:[in] Connectivity structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p4est_connectivity_memory_used (p4est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new","text":"p4est_connectivity_new(num_vertices, num_trees, num_corners, num_ctt)\n\nAllocate a connectivity structure. The attribute fields are initialized to NULL.\n\nParameters\n\nnum_vertices:[in] Number of total vertices (i.e. geometric points).\nnum_trees:[in] Number of trees in the forest.\nnum_corners:[in] Number of tree-connecting corners.\nnum_ctt:[in] Number of total trees in corner_to_tree array.\n\nReturns\n\nA connectivity structure with allocated arrays.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new (p4est_topidx_t num_vertices, p4est_topidx_t num_trees, p4est_topidx_t num_corners, p4est_topidx_t num_ctt);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_brick-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_brick","text":"p4est_connectivity_new_brick(mi, ni, periodic_a, periodic_b)\n\nA rectangular m by n array of trees with configurable periodicity. The brick is periodic in x and y if periodic_a and periodic_b are true, respectively.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_brick (int mi, int ni, int periodic_a, int periodic_b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_byname-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_byname","text":"p4est_connectivity_new_byname(name)\n\nCreate connectivity structure from predefined catalogue.\n\nParameters\n\nname:[in] Invokes connectivity_new_* function. brick23 brick (2, 3, 0, 0) corner corner cubed cubed disk disk moebius moebius periodic periodic pillow pillow rotwrap rotwrap star star unit unitsquare\n\nReturns\n\nAn initialized connectivity if name is defined, NULL else.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_byname (const char *name);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_copy-NTuple{11, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_copy","text":"p4est_connectivity_new_copy(num_vertices, num_trees, num_corners, vertices, ttv, ttt, ttf, ttc, coff, ctt, ctc)\n\nAllocate a connectivity structure and populate from constants. The attribute fields are initialized to NULL.\n\nParameters\n\nnum_vertices:[in] Number of total vertices (i.e. geometric points).\nnum_trees:[in] Number of trees in the forest.\nnum_corners:[in] Number of tree-connecting corners.\ncoff:[in] Corner-to-tree offsets (num_corners + 1 values). This must always be non-NULL; in trivial cases it is just a pointer to a p4est_topix value of 0.\n\nReturns\n\nThe connectivity is checked for validity.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_copy (p4est_topidx_t num_vertices, p4est_topidx_t num_trees, p4est_topidx_t num_corners, const double *vertices, const p4est_topidx_t * ttv, const p4est_topidx_t * ttt, const int8_t * ttf, const p4est_topidx_t * ttc, const p4est_topidx_t * coff, const p4est_topidx_t * ctt, const int8_t * ctc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_corner-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_corner","text":"p4est_connectivity_new_corner()\n\nCreate a connectivity structure for a three-tree mesh around a corner.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_corner (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_cubed-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_cubed","text":"p4est_connectivity_new_cubed()\n\nCreate a connectivity structure for the six sides of a unit cube. The ordering of the trees is as follows: 0 1 2 3 <– 3: axis-aligned top side 4 5. This choice has been made for maximum symmetry (see tree_to_* in .c file).\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_cubed (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_disk-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_disk","text":"p4est_connectivity_new_disk(periodic_a, periodic_b)\n\nCreate a connectivity structure for a five-tree flat spherical disk. This disk can just as well be used as a square to test non-Cartesian maps. Without any mapping this connectivity covers the square [-3, 3]**2.\n\nnote: Note\nThe API of this function has changed to accept two arguments. You can query the #define P4EST_CONN_DISK_PERIODIC to check whether the new version with the argument is in effect.\n\nThe ordering of the trees is as follows: 4 1 2 3 0.\n\nThe outside x faces may be identified topologically. The outside y faces may be identified topologically. Both identifications may be specified simultaneously. The general shape and periodicity are the same as those obtained with p4estconnectivitynewbrick (1, 1, periodic\\a, periodic_b).\n\nWhen setting periodic_a and periodic_b to false, the result is the same as that of p4estconnectivitynewdisknonperiodic.\n\nParameters\n\nperiodic_a:[in] Bool to make disk periodic in x direction.\nperiodic_b:[in] Bool to make disk periodic in y direction.\n\nReturns\n\nInitialized and usable connectivity.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_disk (int periodic_a, int periodic_b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_disk2d-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_disk2d","text":"p4est_connectivity_new_disk2d()\n\nCreate a connectivity structure that maps a 2d disk.\n\nThis is a 5 trees connectivity meant to be used together with p4estgeometrynew_disk2d to map the disk.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_disk2d (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_disk_nonperiodic-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_disk_nonperiodic","text":"p4est_connectivity_new_disk_nonperiodic()\n\nCreate a connectivity structure for a five-tree flat spherical disk. This disk can just as well be used as a square to test non-Cartesian maps. Without any mapping this connectivity covers the square [-3, 3]**2.\n\nReturns\n\nInitialized and usable connectivity.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_disk_nonperiodic (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_icosahedron-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_icosahedron","text":"p4est_connectivity_new_icosahedron()\n\nCreate a connectivity for mapping the sphere using an icosahedron.\n\nThe regular icosadron is a polyhedron with 20 faces, each of which is an equilateral triangle. To build the p4est connectivity, we group faces 2 by 2 to from 10 quadrangles, and thus 10 trees.\n\nThis connectivity is meant to be used together with p4estgeometrynew_icosahedron to map the sphere.\n\nThe flat connectivity looks like that: Vextex numbering:\n\nA00 A01 A02 A03 A04 / \\ / \\ / \\ / \\ / \\ A05–-A06–-A07–-A08–-A09–-A10 \\ / \\ / \\ / \\ / \\ / \\ A11–-A12–-A13–-A14–-A15–-A16 \\ / \\ / \\ / \\ / \\ / A17 A18 A19 A20 A21\n\nOrigin in A05.\n\nTree numbering:\n\n0 2 4 6 8 1 3 5 7 9\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_icosahedron ();\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_moebius-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_moebius","text":"p4est_connectivity_new_moebius()\n\nCreate a connectivity structure for a five-tree moebius band.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_moebius (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_periodic-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_periodic","text":"p4est_connectivity_new_periodic()\n\nCreate a connectivity structure for an all-periodic unit square.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_periodic (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_pillow-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_pillow","text":"p4est_connectivity_new_pillow()\n\nCreate a connectivity structure for two trees on top of each other.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_pillow (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_rotwrap-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_rotwrap","text":"p4est_connectivity_new_rotwrap()\n\nCreate a connectivity structure for a periodic unit square. The left and right faces are identified, and bottom and top opposite.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_rotwrap (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_shell2d-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_shell2d","text":"p4est_connectivity_new_shell2d()\n\nCreate a connectivity structure that builds a 2d spherical shell. p8estconnectivitynew_shell\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_shell2d (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_star-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_star","text":"p4est_connectivity_new_star()\n\nCreate a connectivity structure for a six-tree star.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_star (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_twotrees-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_twotrees","text":"p4est_connectivity_new_twotrees(l_face, r_face, orientation)\n\nCreate a connectivity structure for two trees being rotated w.r.t. each other in a user-defined way\n\nParameters\n\nl_face:[in] index of left face\nr_face:[in] index of right face\norientation:[in] orientation of trees w.r.t. each other\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_twotrees (int l_face, int r_face, int orientation);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_unitsquare-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_new_unitsquare","text":"p4est_connectivity_new_unitsquare()\n\nCreate a connectivity structure for the unit square.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_new_unitsquare (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_permute-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_permute","text":"p4est_connectivity_permute(conn, perm, is_current_to_new)\n\np4est_connectivity_permute Given a permutation perm of the trees in a connectivity conn, permute the trees of conn in place and update conn to match.\n\nParameters\n\nconn:[in,out] The connectivity whose trees are permuted.\nperm:[in] A permutation array, whose elements are size_t's.\nis_current_to_new:[in] if true, the jth entry of perm is the new index for the entry whose current index is j, otherwise the jth entry of perm is the current index of the tree whose index will be j after the permutation.\n\nPrototype\n\nvoid p4est_connectivity_permute (p4est_connectivity_t * conn, sc_array_t * perm, int is_current_to_new);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_read_inp-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_read_inp","text":"p4est_connectivity_read_inp(filename)\n\nCreate a p4est connectivity from an ABAQUS input file.\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below. The *Node section gives the vertex number and x, y, and z components for each vertex. The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4 3 +–––––––––-+ | | | | | | | | | | | | +–––––––––-+ 1 2\n\nand in 3D they are given as:\n\n8 7 +––––––––––-+ |\\ |\\ | \\ | \\ | \\ | \\ | \\ | \\ | 5+––––––––––-+6 | | | | +––|––––––––+ | 4\\ | 3 \\ | \\ | \\ | \\ | \\ | \\| \\| +––––––––––-+ 1 2\n\n *Heading\n  box.inp\n *Node\n 1,  -5, -5, 0\n 2,   5, -5, 0\n 3,   5,  5, 0\n 4,  -5,  5, 0\n 5,   0, -5, 0\n 6,   5,  0, 0\n 7,   0,  5, 0\n 8,  -5,  0, 0\n 9,   1, -1, 0\n 10,  0,  0, 0\n 11, -2,  1, 0\n *Element, type=CPS4, ELSET=Surface1\n 1,  1, 10, 11, 8\n 2,  3, 10, 9,  6\n 3,  9, 10, 1,  5\n 4,  7,  4, 8, 11\n 5, 11, 10, 3,  7\n 6,  2,  6, 9,  5\n\nThis function reads a mesh from filename and returns an associated p4est connectivity.\n\nParameters\n\nfilename:[in] file to read the connectivity from\n\nReturns\n\nan allocated connectivity associated with the mesh in filename or NULL if an error occurred.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_read_inp (const char *filename);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_read_inp_stream-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_read_inp_stream","text":"p4est_connectivity_read_inp_stream(stream, num_vertices, num_trees, vertices, tree_to_vertex)\n\nRead an ABAQUS input file from a file stream.\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below. The *Node section gives the vertex number and x, y, and z components for each vertex. The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4 3 +–––––––––-+ | | | | | | | | | | | | +–––––––––-+ 1 2\n\nand in 3D they are given as:\n\n8 7 +––––––––––-+ |\\ |\\ | \\ | \\ | \\ | \\ | \\ | \\ | 5+––––––––––-+6 | | | | +––|––––––––+ | 4\\ | 3 \\ | \\ | \\ | \\ | \\ | \\| \\| +––––––––––-+ 1 2\n\n *Heading\n  box.inp\n *Node\n 1,  -5, -5, 0\n 2,   5, -5, 0\n 3,   5,  5, 0\n 4,  -5,  5, 0\n 5,   0, -5, 0\n 6,   5,  0, 0\n 7,   0,  5, 0\n 8,  -5,  0, 0\n 9,   1, -1, 0\n 10,  0,  0, 0\n 11, -2,  1, 0\n *Element, type=CPS4, ELSET=Surface1\n 1,  1, 10, 11, 8\n 2,  3, 10, 9,  6\n 3,  9, 10, 1,  5\n 4,  7,  4, 8, 11\n 5, 11, 10, 3,  7\n 6,  2,  6, 9,  5\n\nThis code can be called two ways. The first, when vertex==NULL and tree_to_vertex==NULL, is used to count the number of trees and vertices in the connectivity to be generated by the .inp mesh in the stream. The second, when vertices!=NULL and tree_to_vertex!=NULL, fill vertices and tree_to_vertex. In this case num_vertices and num_trees need to be set to the maximum number of entries allocated in vertices and tree_to_vertex.\n\nParameters\n\nstream:[in,out] file stream to read the connectivity from\nnum_vertices:[in,out] the number of vertices in the connectivity\nnum_trees:[in,out] the number of trees in the connectivity\nvertices:[out] the list of vertices of the connectivity\ntree_to_vertex:[out] the tree_to_vertex map of the connectivity\n\nReturns\n\n0 if successful and nonzero if not\n\nPrototype\n\nint p4est_connectivity_read_inp_stream (FILE * stream, p4est_topidx_t * num_vertices, p4est_topidx_t * num_trees, double *vertices, p4est_topidx_t * tree_to_vertex);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_reduce-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_reduce","text":"p4est_connectivity_reduce(conn)\n\nRemoves corner information of a connectivity such that enough information is left to run p4est_connectivity_complete successfully. The reduced connectivity still passes p4est_connectivity_is_valid.\n\nParameters\n\nconn:[in,out] The connectivity to be reduced.\n\nPrototype\n\nvoid p4est_connectivity_reduce (p4est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_refine-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_refine","text":"p4est_connectivity_refine(conn, num_per_edge)\n\nUniformly refine a connectivity. This is useful if you would like to uniformly refine by something other than a power of 2.\n\nParameters\n\nconn:[in] A valid connectivity\nnum_per_edge:[in] The number of new trees in each direction. Must use no more than P4ESTOLDQMAXLEVEL bits.\n\nReturns\n\na refined connectivity.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_refine (p4est_connectivity_t * conn, int num_per_edge);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_save-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_save","text":"p4est_connectivity_save(filename, connectivity)\n\nSave a connectivity structure to disk.\n\nParameters\n\nfilename:[in] Name of the file to write.\nconnectivity:[in] Valid connectivity structure.\n\nReturns\n\nReturns 0 on success, nonzero on file error.\n\nPrototype\n\nint p4est_connectivity_save (const char *filename, p4est_connectivity_t * connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_set_attr-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_set_attr","text":"p4est_connectivity_set_attr(conn, bytes_per_tree)\n\nAllocate or free the attribute fields in a connectivity.\n\nParameters\n\nconn:[in,out] The conn->*_to_attr fields must either be NULL or previously be allocated by this function.\nbytes_per_tree:[in] If 0, tree_to_attr is freed (being NULL is ok). If positive, requested space is allocated.\n\nPrototype\n\nvoid p4est_connectivity_set_attr (p4est_connectivity_t * conn, size_t bytes_per_tree);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_sink-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_sink","text":"p4est_connectivity_sink(conn, sink)\n\nWrite connectivity to a sink object.\n\nParameters\n\nconn:[in] The connectivity to be written.\nsink:[in,out] The connectivity is written into this sink.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint p4est_connectivity_sink (p4est_connectivity_t * conn, sc_io_sink_t * sink);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_source-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_connectivity_source","text":"p4est_connectivity_source(source)\n\nRead connectivity from a source object.\n\nParameters\n\nsource:[in,out] The connectivity is read from this source.\n\nReturns\n\nThe newly created connectivity, or NULL on error.\n\nPrototype\n\np4est_connectivity_t *p4est_connectivity_source (sc_io_source_t * source);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_copy","text":"p4est_copy(input, copy_data)\n\nMake a deep copy of a p4est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:[in] If true, data are copied. If false, data_size is set to 0.\n\nReturns\n\nReturns a valid p4est that does not depend on the input, except for borrowing the same connectivity. Its revision counter is 0.\n\nPrototype\n\np4est_t *p4est_copy (p4est_t * input, int copy_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_copy_ext-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_copy_ext","text":"p4est_copy_ext(input, copy_data, duplicate_mpicomm)\n\nMake a deep copy of a p4est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:[in] If true, data are copied. If false, data_size is set to 0.\nduplicate_mpicomm:[in] If true, MPI communicator is copied.\n\nReturns\n\nReturns a valid p4est that does not depend on the input, except for borrowing the same connectivity. Its revision counter is 0.\n\nPrototype\n\np4est_t *p4est_copy_ext (p4est_t * input, int copy_data, int duplicate_mpicomm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_destroy","text":"p4est_destroy(p4est_)\n\nDestroy a p4est.\n\nnote: Note\nThe connectivity structure is not destroyed with the p4est.\n\nPrototype\n\nvoid p4est_destroy (p4est_t * p4est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_expand_face_transform-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_expand_face_transform","text":"p4est_expand_face_transform(iface, nface, ftransform)\n\nFill an array with the axis combination of a face neighbor transform.\n\nParameters\n\niface:[in] The number of the originating face.\nnface:[in] Encoded as nface = r * 4 + nf, where nf = 0..3 is the neigbbor's connecting face number and r = 0..1 is the relative orientation to the neighbor's face. This encoding matches p4est_connectivity_t.\nftransform:[out] This array holds 9 integers. [0,2] The coordinate axis sequence of the origin face, the first referring to the tangential and the second to the normal. A permutation of (0, 1). [3,5] The coordinate axis sequence of the target face. [6,8] Edge reversal flag for tangential axis (boolean); face code in [0, 3] for the normal coordinate q: 0: q' = -q 1: q' = q + 1 2: q' = q - 1 3: q' = 2 - q [1,4,7] 0 (unused for compatibility with 3D).\n\nPrototype\n\nvoid p4est_expand_face_transform (int iface, int nface, int ftransform[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_face_quadrant_exists-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p4est_face_quadrant_exists","text":"p4est_face_quadrant_exists(p4est_, ghost, treeid, q, face, hang, owner_rank)\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nFor quadrants across tree boundaries it checks if the quadrant exists across any face, but not across corners.\n\nParameters\n\np4est:[in] The forest in which to search for q.\nghost:[in] The ghost layer in which to search for q.\ntreeid:[in] The tree to which q belongs.\nq:[in] The quadrant that is being searched for.\nface:[in,out] On input, face id across which q was created. On output, the neighbor's face number augmented by orientation, so face is in 0..7.\nhang:[in,out] If not NULL, signals that q is bigger than the quadrant it came from. The child id of that originating quadrant is passed into hang. On output, hang holds the hanging face number of q that is in contact with its originator.\nowner_rank:[out] Filled with the rank of the owner if it is found and undefined otherwise.\n\nReturns\n\nReturns the local number of q if the quadrant exists in the local forest or in the ghost_layer. Otherwise, returns -2 for a domain boundary and -1 if not found.\n\nPrototype\n\np4est_locidx_t p4est_face_quadrant_exists (p4est_t * p4est, p4est_ghost_t * ghost, p4est_topidx_t treeid, const p4est_quadrant_t * q, int *face, int *hang, int *owner_rank);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_corner_transform-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_corner_transform","text":"p4est_find_corner_transform(connectivity, itree, icorner, ci)\n\nFills an array with information about corner neighbors.\n\nParameters\n\nitree:[in] The number of the originating tree.\nicorner:[in] The number of the originating corner.\nci:[in,out] A p4est_corner_info_t structure with initialized array.\n\nPrototype\n\nvoid p4est_find_corner_transform (p4est_connectivity_t * connectivity, p4est_topidx_t itree, int icorner, p4est_corner_info_t * ci);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_face_transform-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_face_transform","text":"p4est_find_face_transform(connectivity, itree, iface, ftransform)\n\nFill an array with the axis combinations of a tree neighbor transform.\n\nParameters\n\nitree:[in] The number of the originating tree.\niface:[in] The number of the originating tree's face.\nftransform:[out] This array holds 9 integers. [0,2] The coordinate axis sequence of the origin face. [3,5] The coordinate axis sequence of the target face. [6,8] Edge reverse flag for axis t; face code for axis n. [1,4,7] 0 (unused for compatibility with 3D).\n\nReturns\n\nThe face neighbor tree if it exists, -1 otherwise.\n\nPrototype\n\np4est_topidx_t p4est_find_face_transform (p4est_connectivity_t * connectivity, p4est_topidx_t itree, int iface, int ftransform[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_higher_bound-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_higher_bound","text":"p4est_find_higher_bound(array, q, guess)\n\nFind the highest position tq in a quadrant array such that tq <= q.\n\nReturns\n\nReturns the id of the matching quadrant or -1 if array > q or the array is empty.\n\nPrototype\n\nssize_t p4est_find_higher_bound (sc_array_t * array, const p4est_quadrant_t * q, size_t guess);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_lower_bound-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_lower_bound","text":"p4est_find_lower_bound(array, q, guess)\n\nFind the lowest position tq in a quadrant array such that tq >= q.\n\nReturns\n\nReturns the id of the matching quadrant or -1 if array < q or the array is empty.\n\nPrototype\n\nssize_t p4est_find_lower_bound (sc_array_t * array, const p4est_quadrant_t * q, size_t guess);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_partition-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_partition","text":"p4est_find_partition(num_procs, search_in, my_begin, my_end, _begin, _end)\n\nBinary search in partition array. Given two targets my_begin and my_end, find offsets such that search\\_in[begin] >= my\\_begin, my\\_end <= search\\_in[end]. If more than one index satisfies the conditions, then the minimal index is the result. If there is no index that satisfies the conditions, then begin and end are tried to set equal such that search\\_in[begin] >= my\\_end. If my_begin is less or equal than the smallest value of search_in begin is set to 0 and if my_end is bigger or equal than the largest value of search_in end is set to num_procs - 1. If none of the above conditions is satisfied, the output is not well defined. We require `my_begin <= my_begin'.\n\nParameters\n\nnum_procs:[in] Number of processes to get the length of search_in.\nsearch_in:[in] The sorted array (ascending) in that the function will search. If k indexes search_in, then 0 <= k < num\\_procs.\nmy_begin:[in] The first target that defines the start of the search window.\nmy_end:[in] The second target that defines the end of the search window.\nbegin:[in,out] The first offset such that search\\_in[begin] >= my\\_begin.\nend:[in,out] The second offset such that my\\_end <= search\\_in[end].\n\nPrototype\n\nvoid p4est_find_partition (const int num_procs, p4est_gloidx_t * search_in, p4est_gloidx_t my_begin, p4est_gloidx_t my_end, p4est_gloidx_t * begin, p4est_gloidx_t * end);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_quadrant_cumulative-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_quadrant_cumulative","text":"p4est_find_quadrant_cumulative(p4est_, cumulative_id, which_tree, quadrant_id)\n\nSearch a local quadrant by its cumulative number in the forest.\n\nWe perform a binary search over the processor-local trees, which means that it is advisable NOT to use this function if possible, and to try to maintain O(1) tree context information in the calling code.\n\nParameters\n\np4est:[in] Forest to be worked with.\ncumulative_id:[in] Cumulative index over all trees of quadrant.\nwhich_tree:[in,out] If not NULL, the input value can be -1 or an initial guess for the quadrant's tree. An initial guess must be the index of a nonempty local tree. Output is the tree of returned quadrant.\nquadrant_id:[out] If not NULL, the number of quadrant in tree.\n\nReturns\n\nThe identified quadrant.\n\nPrototype\n\np4est_quadrant_t *p4est_find_quadrant_cumulative (p4est_t * p4est, p4est_locidx_t cumulative_id, p4est_topidx_t * which_tree, p4est_locidx_t * quadrant_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_find_range_boundaries-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_find_range_boundaries","text":"p4est_find_range_boundaries(lq, uq, level, faces, corners)\n\nFind the boundary points touched by a range of quadrants.\n\nGiven two smallest quadrants, lq and uq, that mark the first and the last quadrant in a range of quadrants, determine which portions of the tree boundary the range touches.\n\nParameters\n\nlq:[in] The smallest quadrant at the start of the range: if NULL, the tree's first quadrant is taken to be the start of the range.\nuq:[in] The smallest quadrant at the end of the range: if NULL, the tree's last quadrant is taken to be the end of the range.\nlevel:[in] The level of the containing quadrant whose boundaries are tested: 0 if we want to test the boundaries of the whole tree.\nfaces:[in,out] An array of size 4 that is filled: faces[i] is true if the range touches that face.\ncorners:[in,out] An array of size 4 that is filled: corners[i] is true if the range touches that corner. faces or corners may be NULL.\n\nReturns\n\nReturns an int32_t encoded with the same information in faces and corners: the first (least) four bits represent the four faces, the next four bits represent the four corners.\n\nPrototype\n\nint32_t p4est_find_range_boundaries (p4est_quadrant_t * lq, p4est_quadrant_t * uq, int level, int faces[], int corners[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_get_plex_data_ext-NTuple{17, Any}","page":"API reference","title":"P4est.LibP4est.p4est_get_plex_data_ext","text":"p4est_get_plex_data_ext(p4est_, ghost, lnodes, ctype, overlap, first_local_quad, out_points_per_dim, out_cone_sizes, out_cones, out_cone_orientations, out_vertex_coords, out_children, out_parents, out_childids, out_leaves, out_remotes, custom_numbering)\n\nCreate the data necessary to create a PETsc DMPLEX representation of a forest, as well as the accompanying lnodes and ghost layer. The forest must be at least face balanced (see p4est_balance()). See test/test_plex2.c for example usage.\n\nAll arrays should be initialized to hold sizeof (p4est_locidx_t), except for out_remotes, which should be initialized to hold (2 * sizeof (p4est_locidx_t)).\n\nParameters\n\np4est:[in] the forest\nghost:[out] the ghost layer\nlnodes:[out] the lnodes\nctype:[in] the type of adjacency for the overlap\noverlap:[in] the number of layers of overlap (zero is acceptable)\nfirst_local_quad:[out] the local quadrants are assigned contiguous plex indices, starting with this index\nout_points_per_dim:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_cone_sizes:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_cones:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_cone_orientations:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_vertex_coords:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_children:[in,out] filled with argument for DMPlexSetTree()\nout_parents:[in,out] filled with argument for DMPlexSetTree()\nout_childids:[in,out] filled with argument for DMPlexSetTree()\nout_leaves:[in,out] filled with argument for PetscSFSetGraph()\nout_remotes:[in,out] filled with argument for PetscSFSetGraph()\ncustom_numbering:[in] Whether or use the default numbering (0) of DMPlex child ids or the custom (1).\n\nPrototype\n\nvoid p4est_get_plex_data_ext (p4est_t * p4est, p4est_ghost_t ** ghost, p4est_lnodes_t ** lnodes, p4est_connect_type_t ctype, int overlap, p4est_locidx_t * first_local_quad, sc_array_t * out_points_per_dim, sc_array_t * out_cone_sizes, sc_array_t * out_cones, sc_array_t * out_cone_orientations, sc_array_t * out_vertex_coords, sc_array_t * out_children, sc_array_t * out_parents, sc_array_t * out_childids, sc_array_t * out_leaves, sc_array_t * out_remotes, int custom_numbering);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_bsearch-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_bsearch","text":"p4est_ghost_bsearch(ghost, which_proc, which_tree, q)\n\nConduct binary search for exact match on a range of the ghost layer.\n\nParameters\n\nghost:[in] The ghost layer.\nwhich_proc:[in] The owner of the searched quadrant. Can be -1.\nwhich_tree:[in] The tree of the searched quadrant. Can be -1.\nq:[in] Valid quadrant is searched in the ghost layer.\n\nReturns\n\nOffset in the ghost layer, or -1 if not found.\n\nPrototype\n\nssize_t p4est_ghost_bsearch (p4est_ghost_t * ghost, int which_proc, p4est_topidx_t which_tree, const p4est_quadrant_t * q);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_checksum-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_checksum","text":"p4est_ghost_checksum(p4est_, ghost)\n\nCompute the parallel checksum of a ghost layer.\n\nParameters\n\np4est:[in] The MPI information of this p4est will be used.\nghost:[in] A ghost layer obtained from the p4est.\n\nReturns\n\nParallel checksum on rank 0, 0 otherwise.\n\nPrototype\n\nunsigned p4est_ghost_checksum (p4est_t * p4est, p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_contains-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_contains","text":"p4est_ghost_contains(ghost, which_proc, which_tree, q)\n\nConduct binary search for ancestor on range of the ghost layer.\n\nParameters\n\nghost:[in] The ghost layer.\nwhich_proc:[in] The owner of the searched quadrant. Can be -1.\nwhich_tree:[in] The tree of the searched quadrant. Can be -1.\nq:[in] Valid quadrant's ancestor is searched.\n\nReturns\n\nOffset in the ghost layer, or -1 if not found.\n\nPrototype\n\nssize_t p4est_ghost_contains (p4est_ghost_t * ghost, int which_proc, p4est_topidx_t which_tree, const p4est_quadrant_t * q);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_destroy","text":"p4est_ghost_destroy(ghost)\n\nFrees all memory used for the ghost layer.\n\nPrototype\n\nvoid p4est_ghost_destroy (p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom","text":"p4est_ghost_exchange_custom(p4est_, ghost, data_size, mirror_data, ghost_data)\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily.\n\nParameters\n\np4est:[in] The forest used for reference.\nghost:[in] The ghost layer used for reference.\ndata_size:[in] The data size to transfer per quadrant.\nmirror_data:[in] One data pointer per mirror quadrant as input.\nghost_data:[in,out] Pre-allocated contiguous data for all ghosts in sequence, which must hold at least data_size for each ghost.\n\nPrototype\n\nvoid p4est_ghost_exchange_custom (p4est_t * p4est, p4est_ghost_t * ghost, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_begin-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_begin","text":"p4est_ghost_exchange_custom_begin(p4est_, ghost, data_size, mirror_data, ghost_data)\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4est_ghost_exchange_custom. The return type is always non-NULL and must be passed to p4est_ghost_exchange_custom_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers.\n\nParameters\n\nmirror_data:[in] Not required to stay alive any longer.\nghost_data:[in,out] Must stay alive into the completion call.\n\nReturns\n\nTransient storage for messages in progress.\n\nPrototype\n\np4est_ghost_exchange_t *p4est_ghost_exchange_custom_begin (p4est_t * p4est, p4est_ghost_t * ghost, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_end","text":"p4est_ghost_exchange_custom_end(exc)\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications.\n\nParameters\n\nData:[in,out] created ONLY by p4est_ghost_exchange_custom_begin. It is deallocated before this function returns.\n\nPrototype\n\nvoid p4est_ghost_exchange_custom_end (p4est_ghost_exchange_t * exc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_levels-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_levels","text":"p4est_ghost_exchange_custom_levels(p4est_, ghost, minlevel, maxlevel, data_size, mirror_data, ghost_data)\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. This function restricts the transfer to a range of refinement levels. The memory for quadrants outside the level range is not dereferenced.\n\nParameters\n\np4est:[in] The forest used for reference.\nghost:[in] The ghost layer used for reference.\nminlevel:[in] Level of the largest quads to be exchanged. Use <= 0 for no restriction.\nmaxlevel:[in] Level of the smallest quads to be exchanged. Use >= P4EST_QMAXLEVEL for no restriction.\ndata_size:[in] The data size to transfer per quadrant.\nmirror_data:[in] One data pointer per mirror quadrant as input.\nghost_data:[in,out] Pre-allocated contiguous data for all ghosts in sequence, which must hold at least data_size for each ghost.\n\nPrototype\n\nvoid p4est_ghost_exchange_custom_levels (p4est_t * p4est, p4est_ghost_t * ghost, int minlevel, int maxlevel, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_levels_begin-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_levels_begin","text":"p4est_ghost_exchange_custom_levels_begin(p4est_, ghost, minlevel, maxlevel, data_size, mirror_data, ghost_data)\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4est_ghost_exchange_custom_levels. The return type is always non-NULL and must be passed to p4est_ghost_exchange_custom_levels_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers.\n\nParameters\n\nmirror_data:[in] Not required to stay alive any longer.\nghost_data:[in,out] Must stay alive into the completion call.\n\nReturns\n\nTransient storage for messages in progress.\n\nPrototype\n\np4est_ghost_exchange_t *p4est_ghost_exchange_custom_levels_begin (p4est_t * p4est, p4est_ghost_t * ghost, int minlevel, int maxlevel, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_levels_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_levels_end","text":"p4est_ghost_exchange_custom_levels_end(exc)\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications.\n\nParameters\n\nData:[in,out] created ONLY by p4est_ghost_exchange_custom_levels_begin. It is deallocated before this function returns.\n\nPrototype\n\nvoid p4est_ghost_exchange_custom_levels_end (p4est_ghost_exchange_t * exc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_data-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_data","text":"p4est_ghost_exchange_data(p4est_, ghost, ghost_data)\n\nTransfer data for local quadrants that are ghosts to other processors. Send the data stored in the quadrant's user_data. This is either the pointer variable itself if p4est->datasize is 0, or the content of the referenced memory field if p4est->data\\size is positive.\n\nParameters\n\np4est:[in] The forest used for reference.\nghost:[in] The ghost layer used for reference.\nghost_data:[in,out] Pre-allocated contiguous data for all ghost quadrants in sequence. If p4est->data_size is 0, must at least hold sizeof (void *) bytes for each, otherwise p4est->data_size each.\n\nPrototype\n\nvoid p4est_ghost_exchange_data (p4est_t * p4est, p4est_ghost_t * ghost, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_data_begin-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_data_begin","text":"p4est_ghost_exchange_data_begin(p4est_, ghost, ghost_data)\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4est_ghost_exchange_data. The return type is always non-NULL and must be passed to p4est_ghost_exchange_data_end to complete the exchange. The ghost data must not be accessed before completion.\n\nParameters\n\nghost_data:[in,out] Must stay alive into the completion call.\n\nReturns\n\nTransient storage for messages in progress.\n\nPrototype\n\np4est_ghost_exchange_t *p4est_ghost_exchange_data_begin (p4est_t * p4est, p4est_ghost_t * ghost, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_data_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_exchange_data_end","text":"p4est_ghost_exchange_data_end(exc)\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications.\n\nParameters\n\nData:[in,out] created ONLY by p4est_ghost_exchange_data_begin. It is deallocated before this function returns.\n\nPrototype\n\nvoid p4est_ghost_exchange_data_end (p4est_ghost_exchange_t * exc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_expand-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_expand","text":"p4est_ghost_expand(p4est_, ghost)\n\nExpand the size of the ghost layer and mirrors by one additional layer of adjacency.\n\nParameters\n\np4est:[in] The forest from which the ghost layer was generated.\nghost:[in,out] The ghost layer to be expanded.\n\nPrototype\n\nvoid p4est_ghost_expand (p4est_t * p4est, p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_expand_by_lnodes-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_expand_by_lnodes","text":"p4est_ghost_expand_by_lnodes(p4est_, lnodes, ghost)\n\nExpand the ghost layer as in p4est_ghost_expand(), but use node support to define adjacency instead of geometric adjacency.\n\nParameters\n\np4est:[in] The forest from which the ghost layer was generated.\nlnodes:[in] The nodes to support.\nghost:[in,out] The ghost layer to be expanded.\n\nPrototype\n\nvoid p4est_ghost_expand_by_lnodes (p4est_t * p4est, p4est_lnodes_t * lnodes, p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_is_valid-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_is_valid","text":"p4est_ghost_is_valid(p4est_, ghost)\n\nExamine if a ghost structure is valid. Test if within a ghost-structure the array ghosts is in p4est_quadrant_compare_piggy order. Test if local_num in piggy3 data member of the quadrants in ghosts and mirrors are in ascending order (ascending within each rank for ghost).\n\nTest if the p4est_locidx_t arrays are in ascending order (for mirror_proc_mirrors ascending within each rank)\n\nParameters\n\np4est:[in] the forest.\nghost:[in] Ghost layer structure.\n\nReturns\n\ntrue if ghost is valid\n\nPrototype\n\nint p4est_ghost_is_valid (p4est_t * p4est, p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_memory_used","text":"p4est_ghost_memory_used(ghost)\n\nCalculate the memory usage of the ghost layer.\n\nParameters\n\nghost:[in] Ghost layer structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p4est_ghost_memory_used (p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_new-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_new","text":"p4est_ghost_new(p4est_, btype)\n\nBuilds the ghost layer.\n\nThis will gather the quadrants from each neighboring proc to build one layer of face and corner based ghost elements around the ones they own.\n\nParameters\n\np4est:[in] The forest for which the ghost layer will be generated.\nbtype:[in] Which ghosts to include (across face, corner or full).\n\nReturns\n\nA fully initialized ghost layer.\n\nPrototype\n\np4est_ghost_t *p4est_ghost_new (p4est_t * p4est, p4est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_ghost_support_lnodes-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_ghost_support_lnodes","text":"p4est_ghost_support_lnodes(p4est_, lnodes, ghost)\n\nExpand the ghost layer to include the support of all nodes supported on the local partition.\n\nParameters\n\np4est:[in] The forest from which the ghost layer was generated.\nlnodes:[in] The nodes to support.\nghost:[in,out] The ghost layer to be expanded.\n\nPrototype\n\nvoid p4est_ghost_support_lnodes (p4est_t * p4est, p4est_lnodes_t * lnodes, p4est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_init-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_init","text":"p4est_init(log_handler, log_threshold)\n\nRegisters p4est with the SC Library and sets the logging behavior. This function is optional. This function must only be called before additional threads are created. If this function is not called or called with log_handler == NULL, the default SC log handler will be used. If this function is not called or called with log_threshold == SC_LP_DEFAULT, the default SC log threshold will be used. The default SC log settings can be changed with sc_set_log_defaults ().\n\nPrototype\n\nvoid p4est_init (sc_log_handler_t log_handler, int log_threshold);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_is_balanced-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_is_balanced","text":"p4est_is_balanced(p4est_, btype)\n\nCheck a forest to see if it is balanced.\n\nThis function builds the ghost layer and discards it when done.\n\nParameters\n\np4est:[in] The p4est to be tested.\nbtype:[in] Balance type (face, corner or default, full).\n\nReturns\n\nReturns true if balanced, false otherwise.\n\nPrototype\n\nint p4est_is_balanced (p4est_t * p4est, p4est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_iterate-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_iterate","text":"p4est_iterate(p4est_, ghost_layer, user_data, iter_volume, iter_face, iter_corner)\n\nExecute user supplied callbacks at every volume, face, and corner in the local forest.\n\np4est_iterate executes the user-supplied callback functions at every volume, face, and corner in the local forest. The ghost_layer may be NULL. The user_data pointer is not touched by p4est_iterate, but is passed to each of the callbacks. Any of the callbacks may be NULL. The callback functions are interspersed with each other, i.e. some face callbacks will occur between volume callbacks, and some corner callbacks will occur between face callbacks:\n\nvolume callbacks occur in the sorted Morton-index order. 2) a face callback is not executed until after the volume callbacks have been executed for the quadrants that share it. 3) a corner callback is not executed until the face callbacks have been executed for all faces that touch the corner. 4) it is not always the case that every face callback for a given quadrant is executed before any of the corner callbacks. 5) callbacks are not executed at faces or corners that only involve ghost quadrants, i.e. that are not adjacent in the local section of the forest.\n\nParameters\n\np4est:[in] the forest\nghost_layer:[in] optional: when not given, callbacks at the boundaries of the local partition cannot provide quadrant data about ghost quadrants: missing (p4est_quadrant_t *) pointers are set to NULL, missing indices are set to -1.\nuser_data:[in,out] optional context to supply to each callback\niter_volume:[in] callback function for every quadrant's interior\niter_face:[in] callback function for every face between quadrants\niter_corner:[in] callback function for every corner between quadrants\n\nPrototype\n\nvoid p4est_iterate (p4est_t * p4est, p4est_ghost_t * ghost_layer, void *user_data, p4est_iter_volume_t iter_volume, p4est_iter_face_t iter_face, p4est_iter_corner_t iter_corner);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_iterate_ext-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p4est_iterate_ext","text":"p4est_iterate_ext(p4est_, ghost_layer, user_data, iter_volume, iter_face, iter_corner, remote)\n\np4est_iterate_ext adds the option remote: if this is false, then it is the same as p4est_iterate; if this is true, then corner callbacks are also called on corners for hanging faces touched by local quadrants.\n\nPrototype\n\nvoid p4est_iterate_ext (p4est_t * p4est, p4est_ghost_t * ghost_layer, void *user_data, p4est_iter_volume_t iter_volume, p4est_iter_face_t iter_face, p4est_iter_corner_t iter_corner, int remote);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_add-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_add","text":"p4est_lid_add(a, b, result)\n\nAdds the uint128_t b to the uint128_t a. result == a or result == b is not allowed. a == b is allowed.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nb:[in] A pointer to a p4est_lid_t.\nresult:[out] A pointer to a p4est_lid_t. The sum a + b will be saved in result.\n\nPrototype\n\nvoid p4est_lid_add (const p4est_lid_t * a, const p4est_lid_t * b, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_add_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_add_inplace","text":"p4est_lid_add_inplace(a, b)\n\nAdds the p4est_lid_t b to the p4est_lid_t a. The result is saved in a. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a p4est_lid_t. a will be overwritten by a + b.\nb:[in] A pointer to a p4est_lid_t.\n\nPrototype\n\nvoid p4est_lid_add_inplace (p4est_lid_t * a, const p4est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_and-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_bitwise_and","text":"p4est_lid_bitwise_and(a, b, result)\n\nCalculates the bitwise and of the uint128_t a and the uint128_t b. a == result is allowed. Furthermore, a == result and/or b == result is allowed.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nb:[in] A pointer to a p4est_lid_t.\nresult:[out] A pointer to a p4est_lid_t. The bitwise and of a and b will be saved. in result.\n\nPrototype\n\nvoid p4est_lid_bitwise_and (const p4est_lid_t * a, const p4est_lid_t * b, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_and_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_bitwise_and_inplace","text":"p4est_lid_bitwise_and_inplace(a, b)\n\nCalculates the bitwise and of the uint128_t a and the uint128_t b. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a p4est_lid_t. The bitwise and will be saved in a.\nb:[in] A pointer to a p4est_lid_t.\n\nPrototype\n\nvoid p4est_lid_bitwise_and_inplace (p4est_lid_t * a, const p4est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_neg-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_bitwise_neg","text":"p4est_lid_bitwise_neg(a, result)\n\nCalculates the bitwise negation of the uint128_t a. a == result is allowed.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nresult:[out] A pointer to a p4est_lid_t. The bitwise negation of a will be saved in result.\n\nPrototype\n\nvoid p4est_lid_bitwise_neg (const p4est_lid_t * a, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_or-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_bitwise_or","text":"p4est_lid_bitwise_or(a, b, result)\n\nCalculates the bitwise or of the uint128_t a and b. a == result is allowed. Furthermore, a == result and/or b == result is allowed.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nb:[in] A pointer to a p4est_lid_t.\nresult:[out] A pointer to a p4est_lid_t. The bitwise or of a and b will be saved in result.\n\nPrototype\n\nvoid p4est_lid_bitwise_or (const p4est_lid_t * a, const p4est_lid_t * b, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_or_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_bitwise_or_inplace","text":"p4est_lid_bitwise_or_inplace(a, b)\n\nCalculates the bitwise or of the uint128_t a and the uint128_t b. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a p4est_lid_t. The bitwise or will be saved in a.\nb:[in] A pointer to a p4est_lid_t.\n\nPrototype\n\nvoid p4est_lid_bitwise_or_inplace (p4est_lid_t * a, const p4est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_chk_bit-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_chk_bit","text":"p4est_lid_chk_bit(input, bit_number)\n\nReturns the bit_number-th bit of input. This function checks a bit of an existing, initialized value.\n\nParameters\n\ninput:[in] A pointer to a p4est_lid_t.\nbit_number:[in] The bit (counted from the right hand side) that is checked by logical and. Require 0 <= bit_number < 64.\n\nReturns\n\nTrue if bit is set, false if not.\n\nPrototype\n\nint p4est_lid_chk_bit (const p4est_lid_t * input, int bit_number);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_compare","text":"p4est_lid_compare(a, b)\n\nCompare the p4est_lid_t a and the p4est_lid_t b.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nb:[in] A pointer to a p4est_lid_t.\n\nReturns\n\nReturns -1 if a < b, 1 if a > b and 0 if a == b.\n\nPrototype\n\nint p4est_lid_compare (const p4est_lid_t * a, const p4est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_copy","text":"p4est_lid_copy(input, output)\n\nCopies an initialized p4est_lid_t to a p4est_lid_t.\n\nParameters\n\ninput:[in] A pointer to the p4est_lid_t that is copied.\noutput:[in,out] A pointer to a p4est_lid_t. The low bits of output will be set to the low bits of input and high bits are ignored.\n\nPrototype\n\nvoid p4est_lid_copy (const p4est_lid_t * input, p4est_lid_t * output);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_init-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_init","text":"p4est_lid_init(input, high, low)\n\nInitializes an unsigned 64 bit integer. high is just a a placeholder to use the same interface in 3D.\n\nParameters\n\ninput:[in,out] A pointer to a p4est_lid_t that will be intialized.\nhigh:[in] The given high bits must be zero.\nlow:[in] The given low bits to initialize input.\n\nPrototype\n\nvoid p4est_lid_init (p4est_lid_t * input, uint64_t high, uint64_t low);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_is_equal-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_is_equal","text":"p4est_lid_is_equal(a, b)\n\nChecks if the p4est_lid_t a and the p4est_lid_t b are equal.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nb:[in] A pointer to a p4est_lid_t.\n\nReturns\n\nReturns a true value if a and b are equal, false otherwise\n\nPrototype\n\nint p4est_lid_is_equal (const p4est_lid_t * a, const p4est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_bit-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_set_bit","text":"p4est_lid_set_bit(input, bit_number)\n\nSets the exponent-th bit of a to one. This function modifies an existing, initialized value.\n\nParameters\n\ninput:[in,out] A pointer to a p4est_lid_t.\nbit_number:[in] The bit (counted from the right hand side) that is set to one by logical or. Require 0 <= bit_number < 64.\n\nPrototype\n\nvoid p4est_lid_set_bit (p4est_lid_t * input, int bit_number);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_one-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_set_one","text":"p4est_lid_set_one(input)\n\nInitializes a linear index to one.\n\nParameters\n\ninput:[out] A pointer to a p4est_lid_t that will be intialized.\n\nPrototype\n\nvoid p4est_lid_set_one (p4est_lid_t * input);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_uint64-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_set_uint64","text":"p4est_lid_set_uint64(input, u)\n\nInitializes a linear index to an unsigned 64 bit integer.\n\nParameters\n\ninput:[out] A pointer to a p4est_lid_t that will be intialized.\n\nPrototype\n\nvoid p4est_lid_set_uint64 (p4est_lid_t * input, uint64_t u);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_zero-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_set_zero","text":"p4est_lid_set_zero(input)\n\nInitializes a linear index to zero.\n\nParameters\n\ninput:[out] A pointer to a p4est_lid_t that will be intialized.\n\nPrototype\n\nvoid p4est_lid_set_zero (p4est_lid_t * input);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_shift_left-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_shift_left","text":"p4est_lid_shift_left(input, shift_count, result)\n\nCalculates the bit left shift of uint128_t input by shift_count bits. We shift in zeros from the right. If shift_count >= 64, result is 0. All bits left from the 63th bit (counted zero based from the right hand side) drop out. input == result is allowed.\n\nParameters\n\ninput:[in] A pointer to a p4est_lid_t.\nshift_count:[in] Bits to shift. shift_count >= 0.\nresult:[in,out] A pointer to a p4est_lid_t. The left shifted number will be saved in result.\n\nPrototype\n\nvoid p4est_lid_shift_left (const p4est_lid_t * input, unsigned shift_count, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_shift_right-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_shift_right","text":"p4est_lid_shift_right(input, shift_count, result)\n\nCalculates the bit right shift of uint128_t input by shift_count bits. We shift in zeros from the left. If shift_count >= 64, result is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. input == result is allowed.\n\nParameters\n\ninput:[in] A pointer to a p4est_lid_t.\nshift_count:[in] Bits to shift. shift_count >= 0.\nresult:[in,out] A pointer to a p4est_lid_t. The right shifted number will be saved in result.\n\nPrototype\n\nvoid p4est_lid_shift_right (const p4est_lid_t * input, unsigned shift_count, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_sub-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_sub","text":"p4est_lid_sub(a, b, result)\n\nSubstracts the p4est_lid_t b from the p4est_lid_t a. This function assumes that the result is >= 0. result == a or result == b is not allowed. a == b is allowed.\n\nParameters\n\na:[in] A pointer to a p4est_lid_t.\nb:[in] A pointer to a p4est_lid_t.\nresult:[out] A pointer to a p4est_lid_t. The difference a - b will be saved in result.\n\nPrototype\n\nvoid p4est_lid_sub (const p4est_lid_t * a, const p4est_lid_t * b, p4est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lid_sub_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lid_sub_inplace","text":"p4est_lid_sub_inplace(a, b)\n\nSubstracts the uint128_t b from the uint128_t a. The result is saved in a. a == b is allowed. This function assumes that the result is >= 0.\n\nParameters\n\na:[in,out] A pointer to a p4est_lid_t. a will be overwritten by a - b.\nb:[in] A pointer to a p4est_lid_t.\n\nPrototype\n\nvoid p4est_lid_sub_inplace (p4est_lid_t * a, const p4est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_buffer_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_buffer_destroy","text":"p4est_lnodes_buffer_destroy(buffer)\n\nPrototype\n\nvoid p4est_lnodes_buffer_destroy (p4est_lnodes_buffer_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_destroy","text":"p4est_lnodes_destroy(lnodes)\n\nPrototype\n\nvoid p4est_lnodes_destroy (p4est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_new-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_new","text":"p4est_lnodes_new(p4est_, ghost_layer, degree)\n\nPrototype\n\np4est_lnodes_t *p4est_lnodes_new (p4est_t * p4est, p4est_ghost_t * ghost_layer, int degree);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_all-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_share_all","text":"p4est_lnodes_share_all(node_data, lnodes)\n\nEquivalent to calling p4est_lnodes_share_all_end directly after p4est_lnodes_share_all_begin. Use if there is no local work that can be done to mask the communication cost.\n\nReturns\n\nA fully initialized buffer that contains the received data. After processing this data, the buffer must be freed with p4est_lnodes_buffer_destroy.\n\nPrototype\n\np4est_lnodes_buffer_t *p4est_lnodes_share_all (sc_array_t * node_data, p4est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_all_begin-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_share_all_begin","text":"p4est_lnodes_share_all_begin(node_data, lnodes)\n\np4est_lnodes_share_all_begin\n\nnode_data is a user_defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every process that shares an entry with the current one, the value in the node_data array of that process is written into a buffer->recvbuffers entry as described above. The user can then perform some arbitrary work that requires the data from all processes that share a node (such as reduce, max, min, etc.). When the work concludes, the buffer should be destroyed with [`p4estlnodesbufferdestroy`](@ref).\n\nValues of node_data are not guaranteed to be sent, and buffer->recvbuffer entries are not guaranteed to be received until the buffer created by [`p4estlnodesshareallbegin](@ref) is passed to [p4estlnodesshareall_end`](@ref).\n\nPrototype\n\np4est_lnodes_buffer_t *p4est_lnodes_share_all_begin (sc_array_t * node_data, p4est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_all_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_share_all_end","text":"p4est_lnodes_share_all_end(buffer)\n\nPrototype\n\nvoid p4est_lnodes_share_all_end (p4est_lnodes_buffer_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_owned-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_share_owned","text":"p4est_lnodes_share_owned(node_data, lnodes)\n\nEquivalent to calling p4est_lnodes_share_owned_end directly after p4est_lnodes_share_owned_begin. Use if there is no local work that can be done to mask the communication cost.\n\nPrototype\n\nvoid p4est_lnodes_share_owned (sc_array_t * node_data, p4est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_owned_begin-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_share_owned_begin","text":"p4est_lnodes_share_owned_begin(node_data, lnodes)\n\np4est_lnodes_share_owned_begin\n\nnode_data is a user-defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every local nodes entry that is owned by a process other than the current one, the value in the node_data array of the owning process is written directly into the node_data array of the current process. Values of node_data are not guaranteed to be sent or received until the buffer created by p4est_lnodes_share_owned_begin is passed to p4est_lnodes_share_owned_end.\n\nTo be memory neutral, the buffer created by p4est_lnodes_share_owned_begin must be destroying with p4est_lnodes_buffer_destroy (it is not destroyed by p4est_lnodes_share_owned_end).\n\nPrototype\n\np4est_lnodes_buffer_t *p4est_lnodes_share_owned_begin (sc_array_t * node_data, p4est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_owned_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_lnodes_share_owned_end","text":"p4est_lnodes_share_owned_end(buffer)\n\nPrototype\n\nvoid p4est_lnodes_share_owned_end (p4est_lnodes_buffer_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_load-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_load","text":"p4est_load(filename, mpicomm, data_size, load_data, user_pointer, connectivity)\n\nPrototype\n\np4est_t *p4est_load (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, void *user_pointer, p4est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_load_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p4est_load_ext","text":"p4est_load_ext(filename, mpicomm, data_size, load_data, autopartition, broadcasthead, user_pointer, connectivity)\n\nPrototype\n\np4est_t *p4est_load_ext (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, p4est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_memory_used","text":"p4est_memory_used(p4est_)\n\nCalculate local memory usage of a forest structure. Not collective. The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use p4est_connectivity_memory_usage (p4est->connectivity).\n\nParameters\n\np4est:[in] Valid forest structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p4est_memory_used (p4est_t * p4est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_destroy","text":"p4est_mesh_destroy(mesh)\n\nDestroy a p4est_mesh structure.\n\nParameters\n\nmesh:[in] Mesh structure previously created by p4est_mesh_new.\n\nPrototype\n\nvoid p4est_mesh_destroy (p4est_mesh_t * mesh);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_data-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_data","text":"p4est_mesh_face_neighbor_data(mfn, ghost_data)\n\nGet the user data for the current face neighbor.\n\nParameters\n\nmfn:[in] Internal status of the iterator.\nghost_data:[in] Data for the ghost quadrants that has been synchronized with p4est_ghost_exchange_data.\n\nReturns\n\nA pointer to the user data for the current neighbor.\n\nPrototype\n\nvoid *p4est_mesh_face_neighbor_data (p4est_mesh_face_neighbor_t * mfn, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_init-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_init","text":"p4est_mesh_face_neighbor_init(mfn, p4est_, ghost, mesh, which_tree, quadrant)\n\nInitialize a mesh neighbor iterator by quadrant pointer.\n\nParameters\n\nmfn:[out] A p4est_mesh_face_neighbor_t to be initialized.\nwhich_tree:[in] Tree of quadrant whose neighbors are looped over.\nquadrant:[in] Pointer to quadrant contained in which_tree.\n\nPrototype\n\nvoid p4est_mesh_face_neighbor_init (p4est_mesh_face_neighbor_t * mfn, p4est_t * p4est, p4est_ghost_t * ghost, p4est_mesh_t * mesh, p4est_topidx_t which_tree, p4est_quadrant_t * quadrant);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_init2-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_init2","text":"p4est_mesh_face_neighbor_init2(mfn, p4est_, ghost, mesh, which_tree, quadrant_id)\n\nInitialize a mesh neighbor iterator by quadrant index.\n\nParameters\n\nmfn:[out] A p4est_mesh_face_neighbor_t to be initialized.\nwhich_tree:[in] Tree of quadrant whose neighbors are looped over.\nquadrant_id:[in] Index relative to which_tree of quadrant.\n\nPrototype\n\nvoid p4est_mesh_face_neighbor_init2 (p4est_mesh_face_neighbor_t * mfn, p4est_t * p4est, p4est_ghost_t * ghost, p4est_mesh_t * mesh, p4est_topidx_t which_tree, p4est_locidx_t quadrant_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_next-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_next","text":"p4est_mesh_face_neighbor_next(mfn, ntree, nquad, nface, nrank)\n\nMove the iterator forward to loop around neighbors of the quadrant.\n\nParameters\n\nmfn:[in,out] Internal status of the iterator.\nntree:[out] If not NULL, the tree number of the neighbor.\nnquad:[out] If not NULL, the quadrant number within tree. For ghosts instead the number in ghost layer.\nnface:[out] If not NULL, neighbor's face as in p4est_mesh_t.\nnrank:[out] If not NULL, the owner process of the neighbor.\n\nReturns\n\nEither a real quadrant or one from the ghost layer. Returns NULL when the iterator is done.\n\nPrototype\n\np4est_quadrant_t *p4est_mesh_face_neighbor_next (p4est_mesh_face_neighbor_t * mfn, p4est_topidx_t * ntree, p4est_locidx_t * nquad, int *nface, int *nrank);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_get_neighbors-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_get_neighbors","text":"p4est_mesh_get_neighbors(p4est_, ghost, mesh, curr_quad_id, direction, neighboring_quads, neighboring_encs, neighboring_qids)\n\nLookup neighboring quads of quadrant in a specific direction.\n\nParameters\n\np4est:[in] Forest to be worked with.\nghost:[in] Ghost layer.\nmesh:[in] Mesh structure.\ncurr_quad_id:[in] Process-local id of current quad.\ndirection:[in] Direction i in which to look for adjacent quadrants is encoded as follows: 0 .. 3 neighbor(-s) across face i, 4 .. 7 neighbor(-s) across corner i-4. TODO: Allow any combination of empty output arrays.\nneighboring_quads:[out] Array containing neighboring quad(-s). Needs to be empty on input, size of p4est_quadrant_t *. May be NULL, then neighboring_qids must not be NULL.\nneighboring_qids:[out] Array containing quadrant ids for neighboring quadrants. May be NULL, then no neighboring qids are collected. If non-NULL the array needs to be empty and will contain int. CAUTION: Note, that the encodings differ from the encodings saved in the mesh. TODO: Encodings are the same as in p4est_mesh for all quadrants. TODO: Ghosts can be encoded by returning the quad_to_quad convention in qid. For ghost quadrants, we add -300 to the values in p4est_mesh. This means that values below -100 belong to ghosts, values above to locals. Positive values are for local quadrants, negative values indicate ghost quadrants. Faces: 1 .. 8 => same size neighbor (r * 4 + nf) + 1; nf = 0 .. 3 face index; r = 0 .. 1 relative orientation 9 .. 24 => double size neighbor 9 + h * 8 + r * 4 + nf; h = 0 .. 1 number of the subface; r, nf as above 25 .. 32 => half-size neighbors 25 + r * 4 + nf; r, nf as above Corners: 1 .. 4 => size not encoded for corners nc + 1; nc = 0 .. 3 corner index\nneighboring_encs:[out] Array containing encodings for neighboring quads. Needs to be empty, contains int.\n\nPrototype\n\np4est_locidx_t p4est_mesh_get_neighbors (p4est_t * p4est, p4est_ghost_t * ghost, p4est_mesh_t * mesh, p4est_locidx_t curr_quad_id, p4est_locidx_t direction, sc_array_t * neighboring_quads, sc_array_t * neighboring_encs, sc_array_t * neighboring_qids);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_get_quadrant-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_get_quadrant","text":"p4est_mesh_get_quadrant(p4est_, mesh, qid)\n\nAccess a process-local quadrant inside a forest. Needs a mesh with populated quad_to_tree array. This is a special case of p4estmeshquadrant_cumulative.\n\nParameters\n\np4est:[in] The forest.\nmesh:[in] The mesh.\nqid:[in] Process-local id of the quadrant (cumulative over trees).\n\nReturns\n\nA pointer to the requested quadrant.\n\nPrototype\n\np4est_quadrant_t *p4est_mesh_get_quadrant (p4est_t * p4est, p4est_mesh_t * mesh, p4est_locidx_t qid);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_memory_used","text":"p4est_mesh_memory_used(mesh)\n\nCalculate the memory usage of the mesh structure.\n\nParameters\n\nmesh:[in] Mesh structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p4est_mesh_memory_used (p4est_mesh_t * mesh);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_new-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_new","text":"p4est_mesh_new(p4est_, ghost, btype)\n\nCreate a p4est_mesh structure. This function does not populate the quad_to_tree and quad_level fields. To populate them, use p4estmeshnew_ext.\n\nParameters\n\np4est:[in] A forest that is fully 2:1 balanced.\nghost:[in] The ghost layer created from the provided p4est.\nbtype:[in] Determines the highest codimension of neighbors.\n\nReturns\n\nA fully allocated mesh structure.\n\nPrototype\n\np4est_mesh_t *p4est_mesh_new (p4est_t * p4est, p4est_ghost_t * ghost, p4est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_new_ext-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_new_ext","text":"p4est_mesh_new_ext(p4est_, ghost, compute_tree_index, compute_level_lists, btype)\n\nCreate a new mesh.\n\nParameters\n\np4est:[in] A forest that is fully 2:1 balanced.\nghost:[in] The ghost layer created from the provided p4est.\ncompute_tree_index:[in] Boolean to decide whether to allocate and compute the quad_to_tree list.\ncompute_level_lists:[in] Boolean to decide whether to compute the level lists in quad_level.\nbtype:[in] Currently ignored, only face neighbors are stored.\n\nReturns\n\nA fully allocated mesh structure.\n\nPrototype\n\np4est_mesh_t *p4est_mesh_new_ext (p4est_t * p4est, p4est_ghost_t * ghost, int compute_tree_index, int compute_level_lists, p4est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_mesh_quadrant_cumulative-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_mesh_quadrant_cumulative","text":"p4est_mesh_quadrant_cumulative(p4est_, mesh, cumulative_id, which_tree, quadrant_id)\n\nFind a quadrant based on its cumulative number in the local forest. If the quad_to_tree field of the mesh structure exists, this is O(1). Otherwise, we perform a binary search over the processor-local trees.\n\nParameters\n\np4est:[in] Forest to be worked with.\nmesh:[in] A mesh derived from the forest.\ncumulative_id:[in] Cumulative index over all trees of quadrant. Must refer to a local (non-ghost) quadrant.\nwhich_tree:[in,out] If not NULL, the input value can be -1 or an initial guess for the quadrant's tree and output is the tree of returned quadrant.\nquadrant_id:[out] If not NULL, the number of quadrant in tree.\n\nReturns\n\nThe identified quadrant.\n\nPrototype\n\np4est_quadrant_t *p4est_mesh_quadrant_cumulative (p4est_t * p4est, p4est_mesh_t * mesh, p4est_locidx_t cumulative_id, p4est_topidx_t * which_tree, p4est_locidx_t * quadrant_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_new-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_new","text":"p4est_new(mpicomm, connectivity, data_size, init_fn, user_pointer)\n\nPrototype\n\np4est_t *p4est_new (sc_MPI_Comm mpicomm, p4est_connectivity_t * connectivity, size_t data_size, p4est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_new_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p4est_new_ext","text":"p4est_new_ext(mpicomm, connectivity, min_quadrants, min_level, fill_uniform, data_size, init_fn, user_pointer)\n\nPrototype\n\np4est_t *p4est_new_ext (sc_MPI_Comm mpicomm, p4est_connectivity_t * connectivity, p4est_locidx_t min_quadrants, int min_level, int fill_uniform, size_t data_size, p4est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_partition-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_partition","text":"p4est_partition(p4est_, allow_for_coarsening, weight_fn)\n\nEqually partition the forest. The partition can be by element count or by a user-defined weight.\n\nThe forest will be partitioned between processors such that they have an approximately equal number of quadrants (or sum of weights).\n\nOn one process, the function noops and does not call the weight callback. Otherwise, the weight callback is called once per quadrant in order.\n\nParameters\n\np4est:[in,out] The forest that will be partitioned.\nallow_for_coarsening:[in] Slightly modify partition such that quadrant families are not split between ranks.\nweight_fn:[in] A weighting function or NULL for uniform partitioning. When running with mpisize == 1, never called. Otherwise, called in order for all quadrants if not NULL. A weighting function with constant weight 1 on each quadrant is equivalent to weight_fn == NULL but other constant weightings may result in different uniform partitionings.\n\nPrototype\n\nvoid p4est_partition (p4est_t * p4est, int allow_for_coarsening, p4est_weight_t weight_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_partition_ext-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_partition_ext","text":"p4est_partition_ext(p4est_, partition_for_coarsening, weight_fn)\n\nRepartition the forest.\n\nThe forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).\n\nParameters\n\np4est:[in,out] The forest that will be partitioned.\npartition_for_coarsening:[in] If true, the partition is modified to allow one level of coarsening.\nweight_fn:[in] A weighting function or NULL for uniform partitioning. A weighting function with constant weight 1 on each quadrant is equivalent to weight_fn == NULL but other constant weightings may result in different uniform partitionings.\n\nReturns\n\nThe global number of shipped quadrants\n\nPrototype\n\np4est_gloidx_t p4est_partition_ext (p4est_t * p4est, int partition_for_coarsening, p4est_weight_t weight_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_partition_for_coarsening-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_partition_for_coarsening","text":"p4est_partition_for_coarsening(p4est_, num_quadrants_in_proc)\n\nCorrect partition to allow one level of coarsening.\n\nParameters\n\np4est:[in] forest whose partition is corrected\nnum_quadrants_in_proc:[in,out] partition that will be corrected\n\nReturns\n\nabsolute number of moved quadrants\n\nPrototype\n\np4est_gloidx_t p4est_partition_for_coarsening (p4est_t * p4est, p4est_locidx_t * num_quadrants_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_partition_lnodes-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_partition_lnodes","text":"p4est_partition_lnodes(p4est_, ghost, degree, partition_for_coarsening)\n\nPartition using weights based on the number of nodes assigned to each element in lnodes\n\nParameters\n\np4est:[in,out] the forest to be repartitioned\nghost:[in] the ghost layer\ndegree:[in] the degree that would be passed to p4est_lnodes_new()\npartition_for_coarsening:[in] whether the partition should allow coarsening (i.e. group siblings who might merge)\n\nPrototype\n\nvoid p4est_partition_lnodes (p4est_t * p4est, p4est_ghost_t * ghost, int degree, int partition_for_coarsening);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_partition_lnodes_detailed-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_partition_lnodes_detailed","text":"p4est_partition_lnodes_detailed(p4est_, ghost, nodes_per_volume, nodes_per_face, nodes_per_corner, partition_for_coarsening)\n\nPartition using weights that are broken down by where they reside: in volumes, on faces, or on corners.\n\nPrototype\n\nvoid p4est_partition_lnodes_detailed (p4est_t * p4est, p4est_ghost_t * ghost, int nodes_per_volume, int nodes_per_face, int nodes_per_corner, int partition_for_coarsening);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_partition_to_p6est_partition-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_partition_to_p6est_partition","text":"p4est_partition_to_p6est_partition(p6est_, num_columns_in_proc, num_layers_in_proc)\n\nPrototype\n\nvoid p4est_partition_to_p6est_partition (p6est_t * p6est, p4est_locidx_t * num_columns_in_proc, p4est_locidx_t * num_layers_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_qcoord_to_vertex-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_qcoord_to_vertex","text":"p4est_qcoord_to_vertex(connectivity, treeid, x, y, vxyz)\n\nTransform a quadrant coordinate into the space spanned by tree vertices.\n\nParameters\n\nconnectivity:[in] Connectivity must provide the vertices.\ntreeid:[in] Identify the tree that contains x, y.\nx,:[in] y Quadrant coordinates relative to treeid.\nvxyz:[out] Transformed coordinates in vertex space.\n\nPrototype\n\nvoid p4est_qcoord_to_vertex (p4est_connectivity_t * connectivity, p4est_topidx_t treeid, p4est_qcoord_t x, p4est_qcoord_t y, double vxyz[3]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_exists-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p4est_quadrant_exists","text":"p4est_quadrant_exists(p4est_, ghost, treeid, q, exists_arr, rproc_arr, rquad_arr)\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nFor quadrants across tree corners it checks if the quadrant exists in any of the corner neighbors, thus it can execute multiple queries.\n\nParameters\n\np4est:[in] The forest in which to search for q\nghost:[in] The ghost layer in which to search for q\ntreeid:[in] The tree to which q belongs (can be extended).\nq:[in] The quadrant that is being searched for.\nexists_arr:[in,out] Must exist and be of of elem_size = sizeof (int) for inter-tree corner cases. Is resized by this function to one entry for each corner search and set to true/false depending on its existence in the local forest or ghost_layer.\nrproc_arr:[in,out] If not NULL is filled with one rank per query.\nrquad_arr:[in,out] If not NULL is filled with one quadrant per query. Its piggy3 member is defined as well.\n\nReturns\n\ntrue if the quadrant exists in the local forest or in the ghost_layer, and false if doesn't exist in either.\n\nPrototype\n\nint p4est_quadrant_exists (p4est_t * p4est, p4est_ghost_t * ghost, p4est_topidx_t treeid, const p4est_quadrant_t * q, sc_array_t * exists_arr, sc_array_t * rproc_arr, sc_array_t * rquad_arr);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_find_owner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_quadrant_find_owner","text":"p4est_quadrant_find_owner(p4est_, treeid, face, q)\n\nGets the processor id of a quadrant's owner. The quadrant can lie outside of a tree across faces (and only faces).\n\nwarning: Warning\nDoes not work for tree edge or corner neighbors.\n\nParameters\n\np4est:[in] The forest in which to search for a quadrant.\ntreeid:[in] The tree to which the quadrant belongs.\nface:[in] Supply a face direction if known, or -1 otherwise.\nq:[in] The quadrant that is being searched for.\n\nReturns\n\nProcessor id of the owner or -1 if the quadrant lies outside of the mesh.\n\nPrototype\n\nint p4est_quadrant_find_owner (p4est_t * p4est, p4est_topidx_t treeid, int face, const p4est_quadrant_t * q);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_linear_id_ext128-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_quadrant_linear_id_ext128","text":"p4est_quadrant_linear_id_ext128(quadrant, level, id)\n\nComputes the linear position as p4est_lid_t of a quadrant in a uniform grid. The grid and quadrant levels need not coincide. If they do, this is the inverse of p4estquadrantset_morton.\n\nnote: Note\nThe user_data of quadrant is never modified.\n\nParameters\n\nquadrant:[in] Quadrant whose linear index will be computed. If the quadrant is smaller than the grid (has a higher quadrant->level), the result is computed from its ancestor at the grid's level. If the quadrant has a smaller level than the grid (it is bigger than a grid cell), the grid cell sharing its lower left corner is used as reference.\nlevel:[in] The level of the regular grid compared to which the linear position is to be computed.\nid:[in,out] A pointer to an allocated or static p4est_lid_t. id will be the linear position of this quadrant on a uniform grid.\n\nPrototype\n\nvoid p4est_quadrant_linear_id_ext128 (const p4est_quadrant_t * quadrant, int level, p4est_lid_t * id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_set_morton_ext128-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_quadrant_set_morton_ext128","text":"p4est_quadrant_set_morton_ext128(quadrant, level, id)\n\nSet quadrant Morton indices based on linear position given as p4est_lid_t in uniform grid. This is the inverse operation of p4estquadrantlinear_id.\n\nnote: Note\nThe user_data of quadrant is never modified.\n\nParameters\n\nquadrant:[in,out] Quadrant whose Morton indices will be set.\nlevel:[in] Level of the grid and of the resulting quadrant.\nid:[in] Linear index of the quadrant on a uniform grid.\n\nPrototype\n\nvoid p4est_quadrant_set_morton_ext128 (p4est_quadrant_t * quadrant, int level, const p4est_lid_t * id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_refine-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_refine","text":"p4est_refine(p4est_, refine_recursive, refine_fn, init_fn)\n\nRefine a forest.\n\nParameters\n\np4est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nrefine_fn:[in] Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn gets called, or use p4est_refine_ext in p4est_extended.h and examine whether replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data of newly created quadrants, which is already allocated. This function pointer may be NULL.\n\nPrototype\n\nvoid p4est_refine (p4est_t * p4est, int refine_recursive, p4est_refine_t refine_fn, p4est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_refine_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p4est_refine_ext","text":"p4est_refine_ext(p4est_, refine_recursive, maxlevel, refine_fn, init_fn, replace_fn)\n\nRefine a forest with a bounded refinement level and a replace option.\n\nParameters\n\np4est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nmaxlevel:[in] Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in p4est.h.\nrefine_fn:[in] Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL.\n\nPrototype\n\nvoid p4est_refine_ext (p4est_t * p4est, int refine_recursive, int maxlevel, p4est_refine_t refine_fn, p4est_init_t init_fn, p4est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_reset_data-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_reset_data","text":"p4est_reset_data(p4est_, data_size, init_fn, user_pointer)\n\nReset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.\n\nParameters\n\ndata_size:[in] This is the size of data for each quadrant which can be zero. Then user_data_pool is set to NULL.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically. May be NULL.\nuser_pointer:[in] Assign to the user_pointer member of the p4est before init_fn is called the first time.\n\nPrototype\n\nvoid p4est_reset_data (p4est_t * p4est, size_t data_size, p4est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_revision-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p4est_revision","text":"p4est_revision(p4est_)\n\nReturn the revision counter of the forest. Not collective, even though the revision value is the same on all ranks. A newly created forest starts with a revision counter of zero. Every refine, coarsen, partition, and balance that actually changes the mesh increases the counter by one. Operations with no effect keep the old value.\n\nParameters\n\np8est:[in] The forest must be valid.\n\nReturns\n\nNon-negative number.\n\nPrototype\n\nlong p4est_revision (p4est_t * p4est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_save-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_save","text":"p4est_save(filename, p4est_, save_data)\n\nSave the complete connectivity/p4est data to disk.\n\nThis is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations.\n\nBy default, we write the current processor count and partition into the file header. This makes the file depend on mpisize. For changing this see p4est_save_ext() in p4est_extended.h.\n\nThe revision counter is not saved to the file, since that would make files different that come from different revisions but store the same mesh.\n\nnote: Note\nAborts on file errors.\n\nnote: Note\nIf p4est is not configured to use MPI-IO, some processes return from this function before the file is complete, in which case immediate read-access to the file may require a call to sc_MPI_Barrier.\n\nParameters\n\nfilename:[in] Name of the file to write.\np4est:[in] Valid forest structure.\nsave_data:[in] If true, the element data is saved. Otherwise, a data size of 0 is saved.\n\nPrototype\n\nvoid p4est_save (const char *filename, p4est_t * p4est, int save_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_save_ext-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_save_ext","text":"p4est_save_ext(filename, p4est_, save_data, save_partition)\n\nSave the complete connectivity/p4est data to disk. This is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p4est_load_ext for information on the autopartition parameter.\n\nnote: Note\nAborts on file errors.\n\nParameters\n\nfilename:[in] Name of the file to write.\np4est:[in] Valid forest structure.\nsave_data:[in] If true, the element data is saved. Otherwise, a data size of 0 is saved.\nsave_partition:[in] If false, save file as if 1 core was used. If true, save core count and partition. Advantage: Partition can be recovered on loading with same mpisize and autopartition false. Disadvantage: Makes the file depend on mpisize. Either way the file can be loaded with autopartition true.\n\nPrototype\n\nvoid p4est_save_ext (const char *filename, p4est_t * p4est, int save_data, int save_partition);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_search-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p4est_search","text":"p4est_search(p4est_, quadrant_fn, point_fn, points)\n\nThis function is provided for backwards compatibility. We call p4estsearchlocal with call_post = 0.\n\nPrototype\n\nvoid p4est_search (p4est_t * p4est, p4est_search_query_t quadrant_fn, p4est_search_query_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_search_all-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_search_all","text":"p4est_search_all(p4est_, call_post, quadrant_fn, point_fn, points)\n\nPerform a top-down search on the whole forest.\n\nThis function combines the functionality of p4estsearchlocal and p4estsearchpartition; their documentation applies for the most part.\n\nThe recursion proceeds from the root quadrant of each tree until (a) we encounter a remote quadrant that covers only one processor, or (b) we encounter a local leaf quadrant. In other words, we proceed with the recursion into a quadrant's children if (a) the quadrant is split between two or more processors, no matter whether one of them is the calling processor or not, or (b) if the quadrant is on the local processor but we have not reached a leaf yet.\n\nThe search can track one or more points, which are abstract placeholders. They are matched against the quadrants traversed using a callback function. The result of the callback function can be used to stop a recursion early. The user determines how a point is interpreted, we only pass it around.\n\nNote that in the remote case (a), we may terminate the recursion even if the quadrant is not a leaf, which we have no means of knowing. Still, this case is sufficient to determine the processor ownership of a point.\n\nnote: Note\nThis is a very powerful function that can become slow if not used carefully.\n\nnote: Note\nAs with the two other search functions in this file, calling it once with many points is generally much faster than calling it once for each point. Using multiple points also allows for a per-quadrant termination of the recursion in addition to a more costly per-point termination.\n\nnote: Note\nThis function works fine when used for the special cases that either the partition or the local quadrants are not of interest. However, in the case of querying only local information we expect that p4estsearchlocal will be faster since it employs specific local optimizations.\n\nParameters\n\np4est:[in] The forest to be searched.\ncall_post:[in] If true, call quadrant callback both pre and post.\nquadrant_fn:[in] Executed once for each quadrant that is entered. If the callback returns false, this quadrant and its descendants are excluded from the search, and the points in this branch are not queried further. Its point argument is always NULL. Callback may be NULL in which case it is ignored.\npoint_fn:[in] Executed once for each point that is relevant for a quadrant of the search. If it returns true, the point is tracked further down that branch, else it is discarded from the queries for the children. If points is not NULL, this callback must be not NULL. If points is NULL, it is not called.\npoints:[in] User-defined array of points. We do not interpret a point, just pass it into the callbacks. If NULL, only the quadrant_fn callback is executed. If that is NULL, the whole function noops. If not NULL, the point_fn is called on its members during the search.\n\nPrototype\n\nvoid p4est_search_all (p4est_t * p4est, int call_post, p4est_search_all_t quadrant_fn, p4est_search_all_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_search_local-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_search_local","text":"p4est_search_local(p4est_, call_post, quadrant_fn, point_fn, points)\n\nSearch through the local part of a forest. The search is especially efficient if multiple targets, called \"points\" below, are searched for simultaneously.\n\nThe search runs over all local quadrants and proceeds recursively top-down. For each tree, it may start at the root of that tree, or further down at the root of the subtree that contains all of the tree's local quadrants. Likewise, some intermediate levels in the recursion may be skipped if the processor-local part is contained in a single deeper subtree. The outer loop is thus a depth-first, processor-local forest traversal. Each quadrant in that loop either is a leaf, or a (direct or indirect) strict ancestor of a leaf. On entering a new quadrant, a user-provided quadrant-callback is executed.\n\nAs a convenience, the user may provide anonymous \"points\" that are tracked down the forest. This way one search call may be used for multiple targets. The set of points that potentially matches a given quadrant diminishes from the root down to the leaves: For each quadrant, an inner loop over the potentially matching points executes a point-callback for each candidate that determines whether the point may be a match. If not, it is discarded in the current branch, otherwise it is passed to the next deeper level. The callback is allowed to return true for the same point and more than one quadrant; in this case more than one matching quadrant may be identified. The callback is also allowed to return false for all children of a quadrant that it returned true for earlier. If the point callback returns false for all points relevant to a quadrant, the recursion stops. The points can really be anything, p4est does not perform any interpretation, just passes the pointer along to the callback function.\n\nIf points are present and the first quadrant callback returned true, we execute it a second time after calling the point callback for all current points. This can be used to gather and postprocess information about the points more easily. If it returns false, the recursion stops.\n\nIf the points are a NULL array, they are ignored and the recursion proceeds by querying the per-quadrant callback. If the points are not NULL but an empty array, the recursion will stop immediately!\n\nParameters\n\np4est:[in] The forest to be searched.\ncall_post:[in] If true, call quadrant callback both pre and post.\nquadrant_fn:[in] Executed once when a quadrant is entered, and once when it is left (the second time only if points are present and the first call returned true). This quadrant is always local, if not completely then at least one descendant of it. If the callback returns false, this quadrant and its descendants are excluded from the search recursion. Its point argument is always NULL. Callback may be NULL in which case it is ignored.\npoint_fn:[in] If points is not NULL, must be not NULL. Shall return true for any possible matching point. If points is NULL, this callback is ignored.\npoints:[in] User-defined array of \"points\". If NULL, only the quadrant_fn callback is executed. If that is NULL, this function noops. If not NULL, the point_fn is called on its members during the search.\n\nPrototype\n\nvoid p4est_search_local (p4est_t * p4est, int call_post, p4est_search_local_t quadrant_fn, p4est_search_local_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_search_partition-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p4est_search_partition","text":"p4est_search_partition(p4est_, call_post, quadrant_fn, point_fn, points)\n\nTraverse the global partition top-down. We proceed top-down through the partition, identically on all processors except for the results of two user-provided callbacks. The recursion will only go down branches that are split between multiple processors. The callback functions can be used to stop a branch recursion even for split branches. This function offers the option to search for arbitrary user-defined points analogously to p4estsearchlocal.\n\nnote: Note\nTraversing the whole processor partition will be at least O(P), so sensible use of the callback function is advised to cut it short.\n\nParameters\n\np4est:[in] The forest to traverse. Its local quadrants are never accessed.\ncall_post:[in] If true, call quadrant callback both pre and post.\nquadrant_fn:[in] This function controls the recursion, which only continues deeper if this callback returns true for a branch quadrant. It is allowed to set this to NULL.\npoint_fn:[in] This function decides per-point whether it is followed down the recursion. Must be non-NULL if points are not NULL.\npoints:[in] User-provided array of points that are passed to the callback point_fn. See p4estsearchlocal for details.\n\nPrototype\n\nvoid p4est_search_partition (p4est_t * p4est, int call_post, p4est_search_partition_t quadrant_fn, p4est_search_partition_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_source_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p4est_source_ext","text":"p4est_source_ext(src, mpicomm, data_size, load_data, autopartition, broadcasthead, user_pointer, connectivity)\n\nPrototype\n\np4est_t *p4est_source_ext (sc_io_source_t * src, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, p4est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_split_array-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p4est_split_array","text":"p4est_split_array(array, level, indices)\n\nSplit an array of quadrants by the children of an ancestor.\n\nGiven a sorted array of quadrants that have a common ancestor at level level, compute the indices of the first quadrant in each of the common ancestor's children at level level + 1.\n\nParameters\n\narray:[in] The sorted array of quadrants of level > level.\nlevel:[in] The level at which there is a common ancestor.\nindices:[in,out] The indices of the first quadrant in each of the ancestors's children, plus an additional index on the end. The quadrants of array that are descendants of child i have indices between indices[i] and indices[i + 1] - 1. If indices[i] = indices[i+1], this indicates that no quadrant in the array is contained in child i.\n\nPrototype\n\nvoid p4est_split_array (sc_array_t * array, int level, size_t indices[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_version-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_version","text":"p4est_version()\n\nReturn the full version of p4est.\n\nReturns\n\nReturn the version of p4est using the format VERSION\\_MAJOR.VERSION\\_MINOR.VERSION\\_POINT, where VERSION_POINT can contain dots and characters, e.g. to indicate the additional number of commits and a git commit hash.\n\nPrototype\n\nconst char *p4est_version (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_version_major-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_version_major","text":"p4est_version_major()\n\nReturn the major version of p4est.\n\nReturns\n\nReturn the major version of p4est.\n\nPrototype\n\nint p4est_version_major (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p4est_version_minor-Tuple{}","page":"API reference","title":"P4est.LibP4est.p4est_version_minor","text":"p4est_version_minor()\n\nReturn the minor version of p4est.\n\nReturns\n\nReturn the minor version of p4est.\n\nPrototype\n\nint p4est_version_minor (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_balance-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_balance","text":"p6est_balance(p6est_, btype, init_fn)\n\nBalance a forest.\n\nParameters\n\np6est:[in] The p6est to be worked on.\nbtype:[in] Balance type (face, corner or default, full).\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p6est_balance (p6est_t * p6est, p8est_connect_type_t btype, p6est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_balance_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_balance_ext","text":"p6est_balance_ext(p6est_, btype, max_diff, min_diff, init_fn, replace_fn)\n\n2:1 balance the size differences of neighboring elements in a forest.\n\nParameters\n\np6est:[in,out] The p6est to be worked on.\nbtype:[in] Balance type (face or corner/full). Corner balance is almost never required when discretizing a PDE; just causes smoother mesh grading.\nmax_diff:[in] The maximum difference between the horizontal refinement level and the vertical refinement level\nmin_diff:[in] The minimum difference between the horizontal refinement level and the vertical refinement level\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p6est_balance_ext (p6est_t * p6est, p8est_connect_type_t btype, int max_diff, int min_diff, p6est_init_t init_fn, p6est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_checksum-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p6est_checksum","text":"p6est_checksum(p6est_)\n\nCompute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize.\n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nPrototype\n\nunsigned p6est_checksum (p6est_t * p6est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_columns-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p6est_coarsen_columns","text":"p6est_coarsen_columns(p6est_, coarsen_recursive, coarsen_fn, init_fn)\n\nCoarsen the columns of a sheet.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncoarsen_fn:[in] Callback function that returns true if a family of columns shall be coarsened\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p6est_coarsen_columns (p6est_t * p6est, int coarsen_recursive, p6est_coarsen_column_t coarsen_fn, p6est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_columns_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_coarsen_columns_ext","text":"p6est_coarsen_columns_ext(p6est_, coarsen_recursive, callback_orphans, coarsen_fn, init_fn, replace_fn)\n\nHorizontally coarsen a forest.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncallback_orphans:[in] Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family.\ncoarsen_fn:[in] Callback function that returns true if a family of quadrants shall be coarsened.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p6est_coarsen_columns_ext (p6est_t * p6est, int coarsen_recursive, int callback_orphans, p6est_coarsen_column_t coarsen_fn, p6est_init_t init_fn, p6est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_layers-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p6est_coarsen_layers","text":"p6est_coarsen_layers(p6est_, coarsen_recursive, coarsen_fn, init_fn)\n\nCoarsen the layers of a sheet.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncoarsen_fn:[in] Callback function that returns true if a family of layers shall be coarsened\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p6est_coarsen_layers (p6est_t * p6est, int coarsen_recursive, p6est_coarsen_layer_t coarsen_fn, p6est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_layers_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_coarsen_layers_ext","text":"p6est_coarsen_layers_ext(p6est_, coarsen_recursive, callback_orphans, coarsen_fn, init_fn, replace_fn)\n\nVertically coarsen a forest.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncallback_orphans:[in] Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family.\ncoarsen_fn:[in] Callback function that returns true if a family of quadrants shall be coarsened.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p6est_coarsen_layers_ext (p6est_t * p6est, int coarsen_recursive, int callback_orphans, p6est_coarsen_layer_t coarsen_fn, p6est_init_t init_fn, p6est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_compress_columns-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p6est_compress_columns","text":"p6est_compress_columns(p6est_)\n\nPrototype\n\nvoid p6est_compress_columns (p6est_t * p6est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_connectivity_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p6est_connectivity_destroy","text":"p6est_connectivity_destroy(conn)\n\nDestroy a p6est_connectivity structure\n\nPrototype\n\nvoid p6est_connectivity_destroy (p6est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_connectivity_new-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_connectivity_new","text":"p6est_connectivity_new(conn4, top_vertices, height)\n\nCreate a p6est_connectivity_t from a p4est_connectivity_t. All fields are copied, so all inputs can be safey destroyed.\n\nParameters\n\nconn4:[in] the 2D connectivity\ntop_vertices:[in] if NULL, then the sheet has a uniform vertical profile; otherwise, top_vertices gives teh vertices of the top of the sheet; should be the same size as conn4->treetovertex\nheight:[in] if top_vertices == NULL, then this gives the offset fro the bottom of the sheet to the top.\n\nReturns\n\nthe 2D+1D connectivity information.\n\nPrototype\n\np6est_connectivity_t *p6est_connectivity_new (p4est_connectivity_t * conn4, double *top_vertices, double height[3]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_copy","text":"p6est_copy(input, copy_data)\n\nMake a deep copy of a p6est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless.\n\nParameters\n\ncopy_data:[in] If true, data are copied. If false, data_size is set to 0.\n\nReturns\n\nReturns a valid p6est that does not depend on the input.\n\nPrototype\n\np6est_t *p6est_copy (p6est_t * input, int copy_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_copy_ext-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_copy_ext","text":"p6est_copy_ext(input, copy_data, duplicate_mpicomm)\n\nMake a deep copy of a p6est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL.\n\nParameters\n\ncopy_data:[in] If true, data are copied. If false, data_size is set to 0.\nduplicate_mpicomm:[in] If true, MPI communicator is copied.\n\nReturns\n\nReturns a valid p6est that does not depend on the input.\n\nPrototype\n\np6est_t *p6est_copy_ext (p6est_t * input, int copy_data, int duplicate_mpicomm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p6est_destroy","text":"p6est_destroy(p6est_)\n\nDestroy a p6est.\n\nnote: Note\nThe connectivity structure is not destroyed with the p6est.\n\nPrototype\n\nvoid p6est_destroy (p6est_t * p6est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_load-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_load","text":"p6est_load(filename, mpicomm, data_size, load_data, user_pointer, connectivity)\n\nPrototype\n\np6est_t *p6est_load (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, void *user_pointer, p6est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_load_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p6est_load_ext","text":"p6est_load_ext(filename, mpicomm, data_size, load_data, autopartition, broadcasthead, user_pointer, connectivity)\n\nPrototype\n\np6est_t *p6est_load_ext (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, p6est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_new-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p6est_new","text":"p6est_new(mpicomm, connectivity, data_size, init_fn, user_pointer)\n\nPrototype\n\np6est_t *p6est_new (sc_MPI_Comm mpicomm, p6est_connectivity_t * connectivity, size_t data_size, p6est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_new_ext-NTuple{10, Any}","page":"API reference","title":"P4est.LibP4est.p6est_new_ext","text":"p6est_new_ext(mpicomm, connectivity, min_quadrants, min_level, min_zlevel, num_zroot, fill_uniform, data_size, init_fn, user_pointer)\n\nPrototype\n\np6est_t *p6est_new_ext (sc_MPI_Comm mpicomm, p6est_connectivity_t * connectivity, p4est_locidx_t min_quadrants, int min_level, int min_zlevel, int num_zroot, int fill_uniform, size_t data_size, p6est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_new_from_p4est-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p6est_new_from_p4est","text":"p6est_new_from_p4est(p4est_, top_vertices, height, min_zlevel, data_size, init_fn, user_pointer)\n\nCreate a new forest from an already created p4est that represents columns.\n\nParameters\n\np4est:[in] A valid p4est. A deep copy will be created, so this can be destroyed without affectin the new p6est object.\ntop_vertices:[in] the same as in p6est_conectivity_new()\nheight:[in] the same as in p6est_conectivity_new()\nmin_zlevel:[in] the same as in p6est_new()\ndata_size:[in] the same as in p6est_new()\ninit_fn:[in] the same as in p6est_new()\nuser_pointer:[in] the same as in p6est_new()\n\nReturns\n\nThis returns a valid forest. The user must destroy the connectivity for the new p6est independently.\n\nPrototype\n\np6est_t *p6est_new_from_p4est (p4est_t * p4est, double *top_vertices, double height[3], int min_zlevel, size_t data_size, p6est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_partition-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_partition","text":"p6est_partition(p6est_, weight_fn)\n\nEqually partition the forest.\n\nThe forest will be partitioned between processors where they each have an approximately equal number of quadrants.\n\nNote that p6est->layers and p6est->globalfirstlayers may change during this call. Address pointers referencing these objects from before p6est_partition is called become invalid.\n\nParameters\n\np6est:[in,out] The forest that will be partitioned.\nweight_fn:[in] A weighting function or NULL for uniform partitioning.\n\nPrototype\n\np4est_gloidx_t p6est_partition (p6est_t * p6est, p6est_weight_t weight_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_partition_correct-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_partition_correct","text":"p6est_partition_correct(p6est_, num_layers_in_proc)\n\nPrototype\n\nvoid p6est_partition_correct (p6est_t * p6est, p4est_locidx_t * num_layers_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_partition_ext-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_partition_ext","text":"p6est_partition_ext(p6est_, partition_for_coarsening, weight_fn)\n\nRepartition the forest.\n\nThe forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).\n\nParameters\n\np6est:[in,out] The forest that will be partitioned.\npartition_for_coarsening:[in] If true, the partition is modified to allow one level of coarsening.\nweight_fn:[in] A weighting function or NULL for uniform partitioning.\n\nReturns\n\nThe global number of shipped quadrants\n\nPrototype\n\np4est_gloidx_t p6est_partition_ext (p6est_t * p6est, int partition_for_coarsening, p6est_weight_t weight_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_partition_for_coarsening-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_partition_for_coarsening","text":"p6est_partition_for_coarsening(p6est_, num_layers_in_proc)\n\nPrototype\n\np4est_gloidx_t p6est_partition_for_coarsening (p6est_t * p6est, p4est_locidx_t * num_layers_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_partition_given-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_partition_given","text":"p6est_partition_given(p6est_, num_layers_in_proc)\n\nPrototype\n\np4est_gloidx_t p6est_partition_given (p6est_t * p6est, p4est_locidx_t * num_layers_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_partition_to_p4est_partition-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_partition_to_p4est_partition","text":"p6est_partition_to_p4est_partition(p6est_, num_layers_in_proc, num_columns_in_proc)\n\nPrototype\n\nvoid p6est_partition_to_p4est_partition (p6est_t * p6est, p4est_locidx_t * num_layers_in_proc, p4est_locidx_t * num_columns_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_qcoord_to_vertex-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_qcoord_to_vertex","text":"p6est_qcoord_to_vertex(connectivity, treeid, x, y, z, vxyz)\n\nTransform a quadrant coordinate into the space spanned by tree vertices.\n\nParameters\n\nconnectivity:[in] Connectivity must provide the vertices.\ntreeid:[in] Identify the tree that contains x, y.\nx,:[in] y Quadrant coordinates relative to treeid.\nvxy:[out] Transformed coordinates in vertex space.\n\nPrototype\n\nvoid p6est_qcoord_to_vertex (p6est_connectivity_t * connectivity, p4est_topidx_t treeid, p4est_qcoord_t x, p4est_qcoord_t y, p4est_qcoord_t z, double vxyz[3]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_refine_columns-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p6est_refine_columns","text":"p6est_refine_columns(p6est_, refine_recursive, refine_fn, init_fn)\n\nRefine the columns of a sheet.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nrefine_fn:[in] Callback function that must return true if a column shall be refined into smaller columns. If refine_recursive is true, refine_fn is called for every existing and newly created column. Otherwise, it is called for every existing column. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn gets called, or use p6est_refine_columns_ext in p6est_extended.h and examine whether replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data of newly created layers within columns, which are already allocated. This function pointer may be NULL.\n\nPrototype\n\nvoid p6est_refine_columns (p6est_t * p6est, int refine_recursive, p6est_refine_column_t refine_fn, p6est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_refine_columns_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_refine_columns_ext","text":"p6est_refine_columns_ext(p6est_, refine_recursive, maxlevel, refine_fn, init_fn, replace_fn)\n\nHorizontally refine a forest with a bounded refinement level and a replace option.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nmaxlevel:[in] Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in p4est.h.\nrefine_fn:[in] Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL.\n\nPrototype\n\nvoid p6est_refine_columns_ext (p6est_t * p6est, int refine_recursive, int maxlevel, p6est_refine_column_t refine_fn, p6est_init_t init_fn, p6est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_refine_layers-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p6est_refine_layers","text":"p6est_refine_layers(p6est_, refine_recursive, refine_fn, init_fn)\n\nRefine the layers within the columns of a sheet.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nrefine_fn:[in] Callback function that must return true if a layer shall be refined into smaller layers. If refine_recursive is true, refine_fn is called for every existing and newly created layer. Otherwise, it is called for every existing layer. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn gets called, or use p6est_refine_layers_ext in p6est_extended.h and examine whether replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data of newly created layers, which are already allocated. This function pointer may be NULL.\n\nPrototype\n\nvoid p6est_refine_layers (p6est_t * p6est, int refine_recursive, p6est_refine_layer_t refine_fn, p6est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_refine_layers_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p6est_refine_layers_ext","text":"p6est_refine_layers_ext(p6est_, refine_recursive, maxlevel, refine_fn, init_fn, replace_fn)\n\nVertically refine a forest with a bounded refinement level and a replace option.\n\nParameters\n\np6est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nmaxlevel:[in] Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in p4est.h.\nrefine_fn:[in] Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL.\n\nPrototype\n\nvoid p6est_refine_layers_ext (p6est_t * p6est, int refine_recursive, int maxlevel, p6est_refine_layer_t refine_fn, p6est_init_t init_fn, p6est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_reset_data-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p6est_reset_data","text":"p6est_reset_data(p6est_, data_size, init_fn, user_pointer)\n\nReset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.\n\nParameters\n\ndata_size:[in] This is the size of data for each quadrant which can be zero. Then user_data_pool is set to NULL.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nuser_pointer:[in] Assign to the user_pointer member of the p6est before init_fn is called the first time.\n\nPrototype\n\nvoid p6est_reset_data (p6est_t * p6est, size_t data_size, p6est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_save-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_save","text":"p6est_save(filename, p6est_, save_data)\n\nSave the complete connectivity/p6est data to disk. This is a collective\n\noperation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations.\n\nnote: Note\nAborts on file errors.\n\nParameters\n\nfilename:[in] Name of the file to write.\np6est:[in] Valid forest structure.\nsave_data:[in] If true, the element data is saved. Otherwise, a data size of 0 is saved.\n\nPrototype\n\nvoid p6est_save (const char *filename, p6est_t * p6est, int save_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_save_ext-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p6est_save_ext","text":"p6est_save_ext(filename, p6est_, save_data, save_partition)\n\nSave the complete connectivity/p6est data to disk.\n\nThis is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p6est_load_ext() for information on the autopartition parameter.\n\nnote: Note\nAborts on file errors.\n\nParameters\n\nfilename:[in] Name of the file to write.\np6est:[in] Valid forest structure.\nsave_data:[in] If true, the element data is saved. Otherwise, a data size of 0 is saved.\nsave_partition:[in] If false, save file as if 1 core was used. If true, save core count and partition. Advantage: Partition can be recovered on loading with same mpisize and autopartition false. Disadvantage: Makes the file depend on mpisize. Either way the file can be loaded with autopartition true.\n\nPrototype\n\nvoid p6est_save_ext (const char *filename, p6est_t * p6est, int save_data, int save_partition);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_tree_get_vertices-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p6est_tree_get_vertices","text":"p6est_tree_get_vertices(conn, which_tree, vertices)\n\nGet the vertices of the corners of a tree.\n\nParameters\n\nconn:[in] the 2D+1D connectivity structure\nwhich_tree:[in] a tree in the forest\nvertices:[out] the coordinates of the corners of the tree\n\nPrototype\n\nvoid p6est_tree_get_vertices (p6est_connectivity_t * conn, p4est_topidx_t which_tree, double vertices[24]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p6est_update_offsets-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p6est_update_offsets","text":"p6est_update_offsets(p6est_)\n\nPrototype\n\nvoid p6est_update_offsets (p6est_t * p6est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_balance-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_balance","text":"p8est_balance(p8est_, btype, init_fn)\n\n2:1 balance the size differences of neighboring elements in a forest.\n\nParameters\n\np8est:[in,out] The p8est to be worked on.\nbtype:[in] Balance type (face, edge, or corner/full). Examples: Finite volume or discontinuous Galerkin methods only require face balance. Continuous finite element methods usually require edge balance. Corner balance is almost never required mathematically; it just produces a smoother mesh grading.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p8est_balance (p8est_t * p8est, p8est_connect_type_t btype, p8est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_balance_ext-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_balance_ext","text":"p8est_balance_ext(p8est_, btype, init_fn, replace_fn)\n\n2:1 balance the size differences of neighboring elements in a forest.\n\nParameters\n\np8est:[in,out] The p8est to be worked on.\nbtype:[in] Balance type (face, edge, or corner/full). Corner balance is almost never required when discretizing a PDE; just causes smoother mesh grading.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p8est_balance_ext (p8est_t * p8est, p8est_connect_type_t btype, p8est_init_t init_fn, p8est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_balance_subtree_ext-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_balance_subtree_ext","text":"p8est_balance_subtree_ext(p8est_, btype, which_tree, init_fn, replace_fn)\n\nPrototype\n\nvoid p8est_balance_subtree_ext (p8est_t * p8est, p8est_connect_type_t btype, p4est_topidx_t which_tree, p8est_init_t init_fn, p8est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_checksum-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_checksum","text":"p8est_checksum(p8est_)\n\nCompute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize.\n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nPrototype\n\nunsigned p8est_checksum (p8est_t * p8est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_checksum_partition-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_checksum_partition","text":"p8est_checksum_partition(p8est_)\n\nCompute a partition-dependent checksum for a forest.\n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nPrototype\n\nunsigned p8est_checksum_partition (p8est_t * p8est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_coarsen-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_coarsen","text":"p8est_coarsen(p8est_, coarsen_recursive, coarsen_fn, init_fn)\n\nCoarsen a forest.\n\nParameters\n\np8est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncoarsen_fn:[in] Callback function that returns true if a family of quadrants shall be coarsened\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\n\nPrototype\n\nvoid p8est_coarsen (p8est_t * p8est, int coarsen_recursive, p8est_coarsen_t coarsen_fn, p8est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_coarsen_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_coarsen_ext","text":"p8est_coarsen_ext(p8est_, coarsen_recursive, callback_orphans, coarsen_fn, init_fn, replace_fn)\n\nCoarsen a forest.\n\nParameters\n\np8est:[in,out] The forest is changed in place.\ncoarsen_recursive:[in] Boolean to decide on recursive coarsening.\ncallback_orphans:[in] Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family. With coarsen_recursive false and callback_orphans true, it is guaranteed that every quadrant is passed exactly once into the coarsen_fn callback.\ncoarsen_fn:[in] Callback function that returns true if a family of quadrants shall be coarsened.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace.\n\nPrototype\n\nvoid p8est_coarsen_ext (p8est_t * p8est, int coarsen_recursive, int callback_orphans, p8est_coarsen_t coarsen_fn, p8est_init_t init_fn, p8est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connect_type_int-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connect_type_int","text":"p8est_connect_type_int(btype)\n\nConvert the p8est_connect_type_t into a number.\n\nParameters\n\nbtype:[in] The balance type to convert.\n\nReturns\n\nReturns 1, 2 or 3.\n\nPrototype\n\nint p8est_connect_type_int (p8est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connect_type_string-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connect_type_string","text":"p8est_connect_type_string(btype)\n\nConvert the p8est_connect_type_t into a const string.\n\nParameters\n\nbtype:[in] The balance type to convert.\n\nReturns\n\nReturns a pointer to a constant string.\n\nPrototype\n\nconst char *p8est_connect_type_string (p8est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_bcast-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_bcast","text":"p8est_connectivity_bcast(conn_in, root, comm)\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_bcast (p8est_connectivity_t * conn_in, int root, sc_MPI_Comm comm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_complete-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_complete","text":"p8est_connectivity_complete(conn)\n\nInternally connect a connectivity based on tree_to_vertex information. Periodicity that is not inherent in the list of vertices will be lost.\n\nParameters\n\nconn:[in,out] The connectivity needs to have proper vertices and tree_to_vertex fields. The tree_to_tree and tree_to_face fields must be allocated and satisfy p8est_connectivity_is_valid (conn) but will be overwritten. The edge and corner fields will be freed and allocated anew.\n\nPrototype\n\nvoid p8est_connectivity_complete (p8est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_deflate-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_deflate","text":"p8est_connectivity_deflate(conn, code)\n\nAllocate memory and store the connectivity information there.\n\nParameters\n\nconn:[in] The connectivity structure to be exported to memory.\ncode:[in] Encoding and compression method for serialization.\n\nReturns\n\nNewly created array that contains the information.\n\nPrototype\n\nsc_array_t *p8est_connectivity_deflate (p8est_connectivity_t * conn, p8est_connectivity_encode_t code);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_destroy","text":"p8est_connectivity_destroy(connectivity)\n\nDestroy a connectivity structure. Also destroy all attributes.\n\nPrototype\n\nvoid p8est_connectivity_destroy (p8est_connectivity_t * connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_edge_neighbor_corner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_edge_neighbor_corner","text":"p8est_connectivity_edge_neighbor_corner(c, e, ne, o)\n\nTransform a corner across one of the adjacent edges into a neighbor tree. This version expects the neighbor edge and orientation separately.\n\nParameters\n\nc:[in] A corner number in 0..7.\ne:[in] An edge 0..11 that touches the corner c.\nne:[in] A neighbor edge that is on the other side of .\no:[in] The orientation between tree boundary edges e and .\n\nReturns\n\nCorner number seen from the neighbor.\n\nPrototype\n\nint p8est_connectivity_edge_neighbor_corner (int c, int e, int ne, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_edge_neighbor_edge_corner-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_edge_neighbor_edge_corner","text":"p8est_connectivity_edge_neighbor_edge_corner(ec, o)\n\nTransform an edge corner across one of the adjacent edges into a neighbor tree.\n\nParameters\n\nec:[in] An edge corner number in 0..1.\no:[in] The orientation of a tree boundary edge connection.\n\nReturns\n\nThe edge corner number seen from the other tree.\n\nPrototype\n\nint p8est_connectivity_edge_neighbor_edge_corner (int ec, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_corner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_corner","text":"p8est_connectivity_face_neighbor_corner(c, f, nf, o)\n\nTransform a corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately.\n\n.\n\nParameters\n\nc:[in] A corner number in 0..7.\nf:[in] A face number that touches the corner c.\nnf:[in] A neighbor face that is on the other side of .\no:[in] The orientation between tree boundary faces f and\n\nReturns\n\nThe number of the corner seen from the neighbor tree.\n\nPrototype\n\nint p8est_connectivity_face_neighbor_corner (int c, int f, int nf, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_corner_set-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_corner_set","text":"p8est_connectivity_face_neighbor_corner_set(c, f, nf, set)\n\nTransform a corner across one of the adjacent faces into a neighbor tree. It expects a face permutation index that has been precomputed.\n\nParameters\n\nc:[in] A corner number in 0..7.\nf:[in] A face number that touches the corner c.\nnf:[in] A neighbor face that is on the other side of .\nset:[in] A value from p8estfacepermutation_sets that is obtained using f, nf, and a valid orientation: ref = p8est_face_permutation_refs[f][nf]; set = p8est_face_permutation_sets[ref][orientation];\n\nReturns\n\nThe corner number in 0..7 seen from the other face.\n\nPrototype\n\nint p8est_connectivity_face_neighbor_corner_set (int c, int f, int nf, int set);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_edge-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_edge","text":"p8est_connectivity_face_neighbor_edge(e, f, nf, o)\n\nTransform an edge across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately.\n\n.\n\nParameters\n\ne:[in] A edge number in 0..11.\nf:[in] A face 0..5 that touches the edge e.\nnf:[in] A neighbor face that is on the other side of .\no:[in] The orientation between tree boundary faces f and\n\nReturns\n\nThe edge's number seen from the neighbor.\n\nPrototype\n\nint p8est_connectivity_face_neighbor_edge (int e, int f, int nf, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_face_corner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_face_corner","text":"p8est_connectivity_face_neighbor_face_corner(fc, f, nf, o)\n\nTransform a face corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately.\n\n.\n\nParameters\n\nfc:[in] A face corner number in 0..3.\nf:[in] A face that the face corner fc is relative to.\nnf:[in] A neighbor face that is on the other side of .\no:[in] The orientation between tree boundary faces f and\n\nReturns\n\nThe face corner number relative to the neighbor's face.\n\nPrototype\n\nint p8est_connectivity_face_neighbor_face_corner (int fc, int f, int nf, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_face_edge-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_face_edge","text":"p8est_connectivity_face_neighbor_face_edge(fe, f, nf, o)\n\nTransform a face-edge across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately.\n\n.\n\nParameters\n\nfe:[in] A face edge number in 0..3.\nf:[in] A face number that touches the edge e.\nnf:[in] A neighbor face that is on the other side of .\no:[in] The orientation between tree boundary faces f and\n\nReturns\n\nThe face edge number seen from the neighbor tree.\n\nPrototype\n\nint p8est_connectivity_face_neighbor_face_edge (int fe, int f, int nf, int o);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_inflate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_inflate","text":"p8est_connectivity_inflate(buffer)\n\nCreate new connectivity from a memory buffer.\n\nParameters\n\nbuffer:[in] The connectivity is created from this memory buffer.\n\nReturns\n\nThe newly created connectivity, or NULL on error.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_inflate (sc_array_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_is_equal-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_is_equal","text":"p8est_connectivity_is_equal(conn1, conn2)\n\nCheck two connectivity structures for equality.\n\nReturns\n\nReturns true if structures are equal, false otherwise.\n\nPrototype\n\nint p8est_connectivity_is_equal (p8est_connectivity_t * conn1, p8est_connectivity_t * conn2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_is_equivalent-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_is_equivalent","text":"p8est_connectivity_is_equivalent(conn1, conn2)\n\np8est_connectivity_is_equivalent This function compares two connectivities for equivalence: it returns true if they are the same connectivity, or if they have the same topology. The definition of topological sameness is strict: there is no attempt made to determine whether permutation and/or rotation of the trees makes the connectivities equivalent.\n\nParameters\n\nconn1:[in] a valid connectivity\nconn2:[out] a valid connectivity\n\nPrototype\n\nint p8est_connectivity_is_equivalent (p8est_connectivity_t * conn1, p8est_connectivity_t * conn2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_is_valid-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_is_valid","text":"p8est_connectivity_is_valid(connectivity)\n\nExamine a connectivity structure.\n\nReturns\n\nReturns true if structure is valid, false otherwise.\n\nPrototype\n\nint p8est_connectivity_is_valid (p8est_connectivity_t * connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_join_faces-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_join_faces","text":"p8est_connectivity_join_faces(conn, tree_left, tree_right, face_left, face_right, orientation)\n\np8est_connectivity_join_faces This function takes an existing valid connectivity conn and modifies it by joining two tree faces that are currently boundary faces.\n\nParameters\n\nconn:[in,out] connectivity that will be altered.\ntree_left:[in] tree that will be on the left side of the joined faces.\ntree_right:[in] tree that will be on the right side of the joined faces.\nface_left:[in] face of tree_left that will be joined.\nface_right:[in] face of tree_right that will be joined.\norientation:[in] the orientation of face_left and face_right once joined (see the description of p8est_connectivity_t to understand orientation).\n\nPrototype\n\nvoid p8est_connectivity_join_faces (p8est_connectivity_t * conn, p4est_topidx_t tree_left, p4est_topidx_t tree_right, int face_left, int face_right, int orientation);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_load-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_load","text":"p8est_connectivity_load(filename, bytes)\n\nLoad a connectivity structure from disk.\n\nParameters\n\nfilename:[in] Name of the file to read.\nbytes:[out] Size in bytes of connectivity on disk or NULL.\n\nReturns\n\nReturns valid connectivity, or NULL on file error.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_load (const char *filename, size_t *bytes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_memory_used","text":"p8est_connectivity_memory_used(conn)\n\nCalculate memory usage of a connectivity structure.\n\nParameters\n\nconn:[in] Connectivity structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p8est_connectivity_memory_used (p8est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new","text":"p8est_connectivity_new(num_vertices, num_trees, num_edges, num_ett, num_corners, num_ctt)\n\nAllocate a connectivity structure. The attribute fields are initialized to NULL.\n\nParameters\n\nnum_vertices:[in] Number of total vertices (i.e. geometric points).\nnum_trees:[in] Number of trees in the forest.\nnum_edges:[in] Number of tree-connecting edges.\nnum_ett:[in] Number of total trees in edge_to_tree array.\nnum_corners:[in] Number of tree-connecting corners.\nnum_ctt:[in] Number of total trees in corner_to_tree array.\n\nReturns\n\nA connectivity structure with allocated arrays.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new (p4est_topidx_t num_vertices, p4est_topidx_t num_trees, p4est_topidx_t num_edges, p4est_topidx_t num_ett, p4est_topidx_t num_corners, p4est_topidx_t num_ctt);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_brick-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_brick","text":"p8est_connectivity_new_brick(m, n, p, periodic_a, periodic_b, periodic_c)\n\nAn m by n by p array with periodicity in x, y, and z if periodic_a, periodic_b, and periodic_c are true, respectively.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_brick (int m, int n, int p, int periodic_a, int periodic_b, int periodic_c);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_byname-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_byname","text":"p8est_connectivity_new_byname(name)\n\nCreate connectivity structure from predefined catalogue.\n\nParameters\n\nname:[in] Invokes connectivity_new_* function. brick235 brick (2, 3, 5, 0, 0, 0) periodic periodic rotcubes rotcubes rotwrap rotwrap shell shell sphere sphere twocubes twocubes twowrap twowrap unit unitcube\n\nReturns\n\nAn initialized connectivity if name is defined, NULL else.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_byname (const char *name);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_copy-NTuple{16, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_copy","text":"p8est_connectivity_new_copy(num_vertices, num_trees, num_edges, num_corners, vertices, ttv, ttt, ttf, tte, eoff, ett, ete, ttc, coff, ctt, ctc)\n\nAllocate a connectivity structure and populate from constants. The attribute fields are initialized to NULL.\n\nParameters\n\nnum_vertices:[in] Number of total vertices (i.e. geometric points).\nnum_trees:[in] Number of trees in the forest.\nnum_edges:[in] Number of tree-connecting edges.\nnum_corners:[in] Number of tree-connecting corners.\neoff:[in] Edge-to-tree offsets (num_edges + 1 values). This must always be non-NULL; in trivial cases it is just a pointer to a p4est_topix value of 0.\ncoff:[in] Corner-to-tree offsets (num_corners + 1 values). This must always be non-NULL; in trivial cases it is just a pointer to a p4est_topix value of 0.\n\nReturns\n\nThe connectivity is checked for validity.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_copy (p4est_topidx_t num_vertices, p4est_topidx_t num_trees, p4est_topidx_t num_edges, p4est_topidx_t num_corners, const double *vertices, const p4est_topidx_t * ttv, const p4est_topidx_t * ttt, const int8_t * ttf, const p4est_topidx_t * tte, const p4est_topidx_t * eoff, const p4est_topidx_t * ett, const int8_t * ete, const p4est_topidx_t * ttc, const p4est_topidx_t * coff, const p4est_topidx_t * ctt, const int8_t * ctc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_periodic-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_periodic","text":"p8est_connectivity_new_periodic()\n\nCreate a connectivity structure for an all-periodic unit cube.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_periodic (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_rotcubes-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_rotcubes","text":"p8est_connectivity_new_rotcubes()\n\nCreate a connectivity structure that contains a few cubes. These are rotated against each other to stress the topology routines.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_rotcubes (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_rotwrap-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_rotwrap","text":"p8est_connectivity_new_rotwrap()\n\nCreate a connectivity structure for a mostly periodic unit cube. The left and right faces are identified, and bottom and top rotated. Front and back are not identified.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_rotwrap (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_shell-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_shell","text":"p8est_connectivity_new_shell()\n\nCreate a connectivity structure that builds a spherical shell. It is made up of six connected parts [-1,1]x[-1,1]x[1,2]. This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8est_connectivity_complete.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_shell (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_sphere-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_sphere","text":"p8est_connectivity_new_sphere()\n\nCreate a connectivity structure that builds a solid sphere. It is made up of two layers and a cube in the center. This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8est_connectivity_complete.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_sphere (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_torus-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_torus","text":"p8est_connectivity_new_torus(nSegments)\n\nCreate a connectivity structure that builds a revolution torus.\n\nThis connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8est_connectivity_complete.\n\nThis connectivity reuses ideas from disk2d connectivity. More precisely the torus is divided into segments arround the revolution axis, each segments is made of 5 trees (à la disk2d). The total number of trees if 5 times the number of segments.\n\nThis connectivity is meant to be used with p8estgeometrynew_torus\n\nParameters\n\nnSegments:[in] number of trees along the great circle\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_torus (int nSegments);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_twocubes-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_twocubes","text":"p8est_connectivity_new_twocubes()\n\nCreate a connectivity structure that contains two cubes.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_twocubes (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_twotrees-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_twotrees","text":"p8est_connectivity_new_twotrees(l_face, r_face, orientation)\n\nCreate a connectivity structure for two trees being rotated w.r.t. each other in a user-defined way.\n\nParameters\n\nl_face:[in] index of left face\nr_face:[in] index of right face\norientation:[in] orientation of trees w.r.t. each other\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_twotrees (int l_face, int r_face, int orientation);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_twowrap-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_twowrap","text":"p8est_connectivity_new_twowrap()\n\nCreate a connectivity structure that contains two cubes where the two far ends are identified periodically.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_twowrap (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_unitcube-Tuple{}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_new_unitcube","text":"p8est_connectivity_new_unitcube()\n\nCreate a connectivity structure for the unit cube.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_new_unitcube (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_permute-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_permute","text":"p8est_connectivity_permute(conn, perm, is_current_to_new)\n\np8est_connectivity_permute Given a permutation perm of the trees in a connectivity conn, permute the trees of conn in place and update conn to match.\n\nParameters\n\nconn:[in,out] The connectivity whose trees are permuted.\nperm:[in] A permutation array, whose elements are size_t's.\nis_current_to_new:[in] if true, the jth entry of perm is the new index for the entry whose current index is j, otherwise the jth entry of perm is the current index of the tree whose index will be j after the permutation.\n\nPrototype\n\nvoid p8est_connectivity_permute (p8est_connectivity_t * conn, sc_array_t * perm, int is_current_to_new);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_read_inp-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_read_inp","text":"p8est_connectivity_read_inp(filename)\n\nCreate a p4est connectivity from an ABAQUS input file.\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below. The *Node section gives the vertex number and x, y, and z components for each vertex. The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4 3 +–––––––––-+ | | | | | | | | | | | | +–––––––––-+ 1 2\n\nand in 3D they are given as:\n\n8 7 +––––––––––-+ |\\ |\\ | \\ | \\ | \\ | \\ | \\ | \\ | 5+––––––––––-+6 | | | | +––|––––––––+ | 4\\ | 3 \\ | \\ | \\ | \\ | \\ | \\| \\| +––––––––––-+ 1 2\n\n *Heading\n  box.inp\n *Node\n     1,    5,   -5,    5\n     2,    5,    5,    5\n     3,    5,    0,    5\n     4,   -5,    5,    5\n     5,    0,    5,    5\n     6,   -5,   -5,    5\n     7,   -5,    0,    5\n     8,    0,   -5,    5\n     9,    0,    0,    5\n    10,    5,    5,   -5\n    11,    5,   -5,   -5\n    12,    5,    0,   -5\n    13,   -5,   -5,   -5\n    14,    0,   -5,   -5\n    15,   -5,    5,   -5\n    16,   -5,    0,   -5\n    17,    0,    5,   -5\n    18,    0,    0,   -5\n    19,   -5,   -5,    0\n    20,    5,   -5,    0\n    21,    0,   -5,    0\n    22,   -5,    5,    0\n    23,   -5,    0,    0\n    24,    5,    5,    0\n    25,    0,    5,    0\n    26,    5,    0,    0\n    27,    0,    0,    0\n *Element, type=C3D8, ELSET=EB1\n     1,       6,      19,      23,       7,       8,      21,      27,       9\n     2,      19,      13,      16,      23,      21,      14,      18,      27\n     3,       7,      23,      22,       4,       9,      27,      25,       5\n     4,      23,      16,      15,      22,      27,      18,      17,      25\n     5,       8,      21,      27,       9,       1,      20,      26,       3\n     6,      21,      14,      18,      27,      20,      11,      12,      26\n     7,       9,      27,      25,       5,       3,      26,      24,       2\n     8,      27,      18,      17,      25,      26,      12,      10,      24\n\nThis function reads a mesh from filename and returns an associated p4est connectivity.\n\nParameters\n\nfilename:[in] file to read the connectivity from\n\nReturns\n\nan allocated connectivity associated with the mesh in filename\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_read_inp (const char *filename);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_read_inp_stream-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_read_inp_stream","text":"p8est_connectivity_read_inp_stream(stream, num_vertices, num_trees, vertices, tree_to_vertex)\n\nRead an ABAQUS input file from a file stream.\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below. The *Node section gives the vertex number and x, y, and z components for each vertex. The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4 3 +–––––––––-+ | | | | | | | | | | | | +–––––––––-+ 1 2\n\nand in 3D they are given as:\n\n8 7 +––––––––––-+ |\\ |\\ | \\ | \\ | \\ | \\ | \\ | \\ | 5+––––––––––-+6 | | | | +––|––––––––+ | 4\\ | 3 \\ | \\ | \\ | \\ | \\ | \\| \\| +––––––––––-+ 1 2\n\n *Heading\n  box.inp\n *Node\n     1,    5,   -5,    5\n     2,    5,    5,    5\n     3,    5,    0,    5\n     4,   -5,    5,    5\n     5,    0,    5,    5\n     6,   -5,   -5,    5\n     7,   -5,    0,    5\n     8,    0,   -5,    5\n     9,    0,    0,    5\n    10,    5,    5,   -5\n    11,    5,   -5,   -5\n    12,    5,    0,   -5\n    13,   -5,   -5,   -5\n    14,    0,   -5,   -5\n    15,   -5,    5,   -5\n    16,   -5,    0,   -5\n    17,    0,    5,   -5\n    18,    0,    0,   -5\n    19,   -5,   -5,    0\n    20,    5,   -5,    0\n    21,    0,   -5,    0\n    22,   -5,    5,    0\n    23,   -5,    0,    0\n    24,    5,    5,    0\n    25,    0,    5,    0\n    26,    5,    0,    0\n    27,    0,    0,    0\n *Element, type=C3D8, ELSET=EB1\n     1,       6,      19,      23,       7,       8,      21,      27,       9\n     2,      19,      13,      16,      23,      21,      14,      18,      27\n     3,       7,      23,      22,       4,       9,      27,      25,       5\n     4,      23,      16,      15,      22,      27,      18,      17,      25\n     5,       8,      21,      27,       9,       1,      20,      26,       3\n     6,      21,      14,      18,      27,      20,      11,      12,      26\n     7,       9,      27,      25,       5,       3,      26,      24,       2\n     8,      27,      18,      17,      25,      26,      12,      10,      24\n\nThis code can be called two ways. The first, when vertex==NULL and tree_to_vertex==NULL, is used to count the number of trees and vertices in the connectivity to be generated by the .inp mesh in the stream. The second, when vertices!=NULL and tree_to_vertex!=NULL, fill vertices and tree_to_vertex. In this case num_vertices and num_trees need to be set to the maximum number of entries allocated in vertices and tree_to_vertex.\n\nParameters\n\nstream:[in,out] file stream to read the connectivity from\nnum_vertices:[in,out] the number of vertices in the connectivity\nnum_trees:[in,out] the number of trees in the connectivity\nvertices:[out] the list of vertices of the connectivity\ntree_to_vertex:[out] the tree_to_vertex map of the connectivity\n\nReturns\n\n0 if successful and nonzero if not\n\nPrototype\n\nint p8est_connectivity_read_inp_stream (FILE * stream, p4est_topidx_t * num_vertices, p4est_topidx_t * num_trees, double *vertices, p4est_topidx_t * tree_to_vertex);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_reduce-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_reduce","text":"p8est_connectivity_reduce(conn)\n\nRemoves corner and edge information of a connectivity such that enough information is left to run p8est_connectivity_complete successfully. The reduced connectivity still passes p8est_connectivity_is_valid.\n\nParameters\n\nconn:[in,out] The connectivity to be reduced.\n\nPrototype\n\nvoid p8est_connectivity_reduce (p8est_connectivity_t * conn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_refine-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_refine","text":"p8est_connectivity_refine(conn, num_per_edge)\n\nUniformly refine a connectivity. This is useful if you would like to uniformly refine by something other than a power of 2.\n\nParameters\n\nconn:[in] A valid connectivity\nnum_per_edge:[in] The number of new trees in each direction. Must use no more than P8ESTOLDQMAXLEVEL bits.\n\nReturns\n\na refined connectivity.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_refine (p8est_connectivity_t * conn, int num_per_edge);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_save-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_save","text":"p8est_connectivity_save(filename, connectivity)\n\nSave a connectivity structure to disk.\n\nParameters\n\nfilename:[in] Name of the file to write.\nconnectivity:[in] Valid connectivity structure.\n\nReturns\n\nReturns 0 on success, nonzero on file error.\n\nPrototype\n\nint p8est_connectivity_save (const char *filename, p8est_connectivity_t * connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_set_attr-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_set_attr","text":"p8est_connectivity_set_attr(conn, bytes_per_tree)\n\nAllocate or free the attribute fields in a connectivity.\n\nParameters\n\nconn:[in,out] The conn->*_to_attr fields must either be NULL or previously be allocated by this function.\nbytes_per_tree:[in] If 0, tree_to_attr is freed (being NULL is ok). If positive, requested space is allocated.\n\nPrototype\n\nvoid p8est_connectivity_set_attr (p8est_connectivity_t * conn, size_t bytes_per_tree);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_sink-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_sink","text":"p8est_connectivity_sink(conn, sink)\n\nWrite connectivity to a sink object.\n\nParameters\n\nconn:[in] The connectivity to be written.\nsink:[in,out] The connectivity is written into this sink.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint p8est_connectivity_sink (p8est_connectivity_t * conn, sc_io_sink_t * sink);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_source-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_connectivity_source","text":"p8est_connectivity_source(source)\n\nRead connectivity from a source object.\n\nParameters\n\nsource:[in,out] The connectivity is read from this source.\n\nReturns\n\nThe newly created connectivity, or NULL on error.\n\nPrototype\n\np8est_connectivity_t *p8est_connectivity_source (sc_io_source_t * source);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_copy","text":"p8est_copy(input, copy_data)\n\nMake a deep copy of a p8est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:[in] If true, data are copied. If false, data_size is set to 0.\n\nReturns\n\nReturns a valid p8est that does not depend on the input, except for borrowing the same connectivity. Its revision counter is 0.\n\nPrototype\n\np8est_t *p8est_copy (p8est_t * input, int copy_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_copy_ext-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_copy_ext","text":"p8est_copy_ext(input, copy_data, duplicate_mpicomm)\n\nMake a deep copy of a p8est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:[in] If true, data are copied. If false, data_size is set to 0.\nduplicate_mpicomm:[in] If true, MPI communicator is copied.\n\nReturns\n\nReturns a valid p8est that does not depend on the input, except for borrowing the same connectivity. Its revision counter is 0.\n\nPrototype\n\np8est_t *p8est_copy_ext (p8est_t * input, int copy_data, int duplicate_mpicomm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_destroy","text":"p8est_destroy(p8est_)\n\nDestroy a p8est.\n\nnote: Note\nThe connectivity structure is not destroyed with the p8est.\n\nPrototype\n\nvoid p8est_destroy (p8est_t * p8est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_expand_face_transform-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_expand_face_transform","text":"p8est_expand_face_transform(iface, nface, ftransform)\n\nFill an array with the axis combination of a face neighbor transform.\n\nParameters\n\niface:[in] The number of the originating face.\nnface:[in] Encoded as nface = r * 6 + nf, where nf = 0..5 is the neigbbor's connecting face number and r = 0..3 is the relative orientation to the neighbor's face. This encoding matches p8est_connectivity_t.\nftransform:[out] This array holds 9 integers. [0]..[2] The coordinate axis sequence of the origin face, the first two referring to the tangentials and the third to the normal. A permutation of (0, 1, 2). [3]..[5] The coordinate axis sequence of the target face. [6]..[8] Edge reversal flags for tangential axes (boolean); face code in [0, 3] for the normal coordinate q: 0: q' = -q 1: q' = q + 1 2: q' = q - 1 3: q' = 2 - q\n\nPrototype\n\nvoid p8est_expand_face_transform (int iface, int nface, int ftransform[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_face_quadrant_exists-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p8est_face_quadrant_exists","text":"p8est_face_quadrant_exists(p8est_, ghost, treeid, q, face, hang, owner_rank)\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nFor quadrants across tree boundaries it checks if the quadrant exists across any face, but not across edges or corners.\n\nParameters\n\np8est:[in] The forest in which to search for q.\nghost:[in] The ghost layer in which to search for q.\ntreeid:[in] The tree to which q belongs.\nq:[in] The quadrant that is being searched for.\nface:[in,out] On input, face id across which q was created. On output, the neighbor's face number augmented by orientation, so face is in 0..23.\nhang:[in,out] If not NULL, signals that q is bigger than the quadrant it came from. The child id of that originating quadrant is passed into hang. On output, hang holds the hanging face number of q that is in contact with its originator.\nowner_rank:[out] Filled with the rank of the owner if it is found and undefined otherwise.\n\nReturns\n\nReturns the local number of q if the quadrant exists in the local forest or in the ghost_layer. Otherwise, returns -2 for a domain boundary and -1 if not found.\n\nPrototype\n\np4est_locidx_t p8est_face_quadrant_exists (p8est_t * p8est, p8est_ghost_t * ghost, p4est_topidx_t treeid, const p8est_quadrant_t * q, int *face, int *hang, int *owner_rank);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_corner_transform-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_corner_transform","text":"p8est_find_corner_transform(connectivity, itree, icorner, ci)\n\nFills an array with information about corner neighbors.\n\nParameters\n\nitree:[in] The number of the originating tree.\nicorner:[in] The number of the originating corner.\nci:[in,out] A p8est_corner_info_t structure with initialized array.\n\nPrototype\n\nvoid p8est_find_corner_transform (p8est_connectivity_t * connectivity, p4est_topidx_t itree, int icorner, p8est_corner_info_t * ci);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_edge_transform-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_edge_transform","text":"p8est_find_edge_transform(connectivity, itree, iedge, ei)\n\nFills an array with information about edge neighbors.\n\nParameters\n\nitree:[in] The number of the originating tree.\niedge:[in] The number of the originating edge.\nei:[in,out] A p8est_edge_info_t structure with initialized array.\n\nPrototype\n\nvoid p8est_find_edge_transform (p8est_connectivity_t * connectivity, p4est_topidx_t itree, int iedge, p8est_edge_info_t * ei);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_face_transform-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_face_transform","text":"p8est_find_face_transform(connectivity, itree, iface, ftransform)\n\nFill an array with the axis combination of a face neighbor transform.\n\nParameters\n\nitree:[in] The number of the originating tree.\niface:[in] The number of the originating tree's face.\nftransform:[out] This array holds 9 integers. [0]..[2] The coordinate axis sequence of the origin face. [3]..[5] The coordinate axis sequence of the target face. [6]..[8] Edge reverse flag for axes t1, t2; face code for n.\n\nReturns\n\nThe face neighbor tree if it exists, -1 otherwise.\n\nPrototype\n\np4est_topidx_t p8est_find_face_transform (p8est_connectivity_t * connectivity, p4est_topidx_t itree, int iface, int ftransform[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_higher_bound-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_higher_bound","text":"p8est_find_higher_bound(array, q, guess)\n\nFind the highest position tq in a quadrant array such that tq <= q.\n\nReturns\n\nReturns the id of the matching quadrant or -1 if array > q or the array is empty.\n\nPrototype\n\nssize_t p8est_find_higher_bound (sc_array_t * array, const p8est_quadrant_t * q, size_t guess);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_lower_bound-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_lower_bound","text":"p8est_find_lower_bound(array, q, guess)\n\nFind the lowest position tq in a quadrant array such that tq >= q.\n\nReturns\n\nReturns the id of the matching quadrant or -1 if array < q or the array is empty.\n\nPrototype\n\nssize_t p8est_find_lower_bound (sc_array_t * array, const p8est_quadrant_t * q, size_t guess);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_partition-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_partition","text":"p8est_find_partition(num_procs, search_in, my_begin, my_end, _begin, _end)\n\nBinary search in partition array. Given two targets my_begin and my_end, find offsets such that search\\_in[begin] >= my\\_begin, my\\_end <= search\\_in[end]. If more than one index satisfies the conditions, then the minimal index is the result. If there is no index that satisfies the conditions, then begin and end are tried to set equal such that search\\_in[begin] >= my\\_end. If my_begin is less or equal than the smallest value of search_in begin is set to 0 and if my_end is bigger or equal than the largest value of search_in end is set to num_procs - 1. If none of the above conditions is satisfied, the output is not well defined. We require `my_begin <= my_begin'.\n\nParameters\n\nnum_procs:[in] Number of processes to get the length of search_in.\nsearch_in:[in] The sorted array (ascending) in that the function will search. If k indexes search_in, then 0 <= k < num\\_procs.\nmy_begin:[in] The first target that defines the start of the search window.\nmy_end:[in] The second target that defines the end of the search window.\nbegin:[in,out] The first offset such that search\\_in[begin] >= my\\_begin.\nend:[in,out] The second offset such that my\\_end <= search\\_in[end].\n\nPrototype\n\nvoid p8est_find_partition (const int num_procs, p4est_gloidx_t * search_in, p4est_gloidx_t my_begin, p4est_gloidx_t my_end, p4est_gloidx_t * begin, p4est_gloidx_t * end);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_quadrant_cumulative-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_quadrant_cumulative","text":"p8est_find_quadrant_cumulative(p8est_, cumulative_id, which_tree, quadrant_id)\n\nSearch a local quadrant by its cumulative number in the forest.\n\nWe perform a binary search over the processor-local trees, which means that it is advisable NOT to use this function if possible, and to try to maintain O(1) tree context information in the calling code.\n\nParameters\n\np8est:[in] Forest to be worked with.\ncumulative_id:[in] Cumulative index over all trees of quadrant.\nwhich_tree:[in,out] If not NULL, the input value can be -1 or an initial guess for the quadrant's tree. An initial guess must be the index of a nonempty local tree. Output is the tree of returned quadrant.\nquadrant_id:[out] If not NULL, the number of quadrant in tree.\n\nReturns\n\nThe identified quadrant.\n\nPrototype\n\np8est_quadrant_t *p8est_find_quadrant_cumulative (p8est_t * p8est, p4est_locidx_t cumulative_id, p4est_topidx_t * which_tree, p4est_locidx_t * quadrant_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_find_range_boundaries-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_find_range_boundaries","text":"p8est_find_range_boundaries(lq, uq, level, faces, edges, corners)\n\nFind the boundary points touched by a range of quadrants.\n\nGiven two smallest quadrants, lq and uq, that mark the first and the last quadrant in a range of quadrants, determine which portions of the tree boundary the range touches.\n\nParameters\n\nlq:[in] The smallest quadrant at the start of the range: if NULL, the tree's first quadrant is taken to be the start of the range.\nuq:[in] The smallest quadrant at the end of the range: if NULL, the tree's last quadrant is taken to be the end of the range.\nlevel:[in] The level of the containing quadrant whose boundaries are tested: 0 if we want to test the boundaries of the whole tree.\nfaces:[in,out] An array of size 6 that is filled: faces[i] is true if the range touches that face.\nedges:[in,out] An array of size 12 that is filled: edges[i] is true if the range touches that edge.\ncorners:[in,out] An array of size 8 that is filled: corners[i] is true if the range touches that corner. faces, edges or corners may be NULL.\n\nReturns\n\nReturns an int32_t encoded with the same information in faces, edges and corners: the first (least) six bits represent the six faces, the next twelve bits represent the twelve edges, the next eight bits represent the eight corners.\n\nPrototype\n\nint32_t p8est_find_range_boundaries (p8est_quadrant_t * lq, p8est_quadrant_t * uq, int level, int faces[], int edges[], int corners[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_get_plex_data_ext-NTuple{17, Any}","page":"API reference","title":"P4est.LibP4est.p8est_get_plex_data_ext","text":"p8est_get_plex_data_ext(p8est_, ghost, lnodes, ctype, overlap, first_local_quad, out_points_per_dim, out_cone_sizes, out_cones, out_cone_orientations, out_vertex_coords, out_children, out_parents, out_childids, out_leaves, out_remotes, custom_numbering)\n\nCreate the data necessary to create a PETsc DMPLEX representation of a forest, as well as the accompanying lnodes and ghost layer. The forest must be at least face balanced (see p4est_balance()). See test/test_plex2.c for example usage.\n\nAll arrays should be initialized to hold sizeof (p4est_locidx_t), except for out_remotes, which should be initialized to hold (2 * sizeof (p4est_locidx_t)).\n\nParameters\n\np8est:[in] the forest\nghost:[out] the ghost layer\nlnodes:[out] the lnodes\nctype:[in] the type of adjacency for the overlap\noverlap:[in] the number of layers of overlap (zero is acceptable)\nfirst_local_quad:[out] the local quadrants are assigned contiguous plex indices, starting with this index\nout_points_per_dim:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_cone_sizes:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_cones:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_cone_orientations:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_vertex_coords:[in,out] filled with argument for DMPlexCreateFromDAG()\nout_children:[in,out] filled with argument for DMPlexSetTree()\nout_parents:[in,out] filled with argument for DMPlexSetTree()\nout_childids:[in,out] filled with argument for DMPlexSetTree()\nout_leaves:[in,out] filled with argument for PetscSFSetGraph()\nout_remotes:[in,out] filled with argument for PetscSFSetGraph()\ncustom_numbering:[in] Whether or use the default numbering (0) of DMPlex child ids or the custom (1).\n\nPrototype\n\nvoid p8est_get_plex_data_ext (p8est_t * p8est, p8est_ghost_t ** ghost, p8est_lnodes_t ** lnodes, p8est_connect_type_t ctype, int overlap, p4est_locidx_t * first_local_quad, sc_array_t * out_points_per_dim, sc_array_t * out_cone_sizes, sc_array_t * out_cones, sc_array_t * out_cone_orientations, sc_array_t * out_vertex_coords, sc_array_t * out_children, sc_array_t * out_parents, sc_array_t * out_childids, sc_array_t * out_leaves, sc_array_t * out_remotes, int custom_numbering);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_bsearch-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_bsearch","text":"p8est_ghost_bsearch(ghost, which_proc, which_tree, q)\n\nConduct binary search for exact match on a range of the ghost layer.\n\nParameters\n\nghost:[in] The ghost layer.\nwhich_proc:[in] The owner of the searched quadrant. Can be -1.\nwhich_tree:[in] The tree of the searched quadrant. Can be -1.\nq:[in] Valid quadrant is searched in the ghost layer.\n\nReturns\n\nOffset in the ghost layer, or -1 if not found.\n\nPrototype\n\nssize_t p8est_ghost_bsearch (p8est_ghost_t * ghost, int which_proc, p4est_topidx_t which_tree, const p8est_quadrant_t * q);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_checksum-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_checksum","text":"p8est_ghost_checksum(p8est_, ghost)\n\nCompute the parallel checksum of a ghost layer.\n\nParameters\n\np8est:[in] The MPI information of this p8est will be used.\nghost:[in] A ghost layer obtained from the p8est.\n\nReturns\n\nParallel checksum on rank 0, 0 otherwise.\n\nPrototype\n\nunsigned p8est_ghost_checksum (p8est_t * p8est, p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_destroy","text":"p8est_ghost_destroy(ghost)\n\nFrees all memory used for the ghost layer.\n\nPrototype\n\nvoid p8est_ghost_destroy (p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom","text":"p8est_ghost_exchange_custom(p8est_, ghost, data_size, mirror_data, ghost_data)\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily.\n\nParameters\n\np8est:[in] The forest used for reference.\nghost:[in] The ghost layer used for reference.\ndata_size:[in] The data size to transfer per quadrant.\nmirror_data:[in] One data pointer per mirror quadrant.\nghost_data:[in,out] Pre-allocated contiguous data for all ghosts in sequence, which must hold at least data_size for each ghost.\n\nPrototype\n\nvoid p8est_ghost_exchange_custom (p8est_t * p8est, p8est_ghost_t * ghost, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_begin-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_begin","text":"p8est_ghost_exchange_custom_begin(p8est_, ghost, data_size, mirror_data, ghost_data)\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8est_ghost_exchange_custom. The return type is always non-NULL and must be passed to p8est_ghost_exchange_custom_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers.\n\nParameters\n\nmirror_data:[in] Not required to stay alive any longer.\nghost_data:[in,out] Must stay alive into the completion call.\n\nReturns\n\nTransient storage for messages in progress.\n\nPrototype\n\np8est_ghost_exchange_t *p8est_ghost_exchange_custom_begin (p8est_t * p8est, p8est_ghost_t * ghost, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_end","text":"p8est_ghost_exchange_custom_end(exc)\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications.\n\nParameters\n\nData:[in,out] created ONLY by p8est_ghost_exchange_custom_begin. It is deallocated before this function returns.\n\nPrototype\n\nvoid p8est_ghost_exchange_custom_end (p8est_ghost_exchange_t * exc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_levels-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_levels","text":"p8est_ghost_exchange_custom_levels(p8est_, ghost, minlevel, maxlevel, data_size, mirror_data, ghost_data)\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. This function restricts the transfer to a range of refinement levels. The memory for quadrants outside the level range is not dereferenced.\n\nParameters\n\np8est:[in] The forest used for reference.\nghost:[in] The ghost layer used for reference.\nminlevel:[in] Level of the largest quads to be exchanged. Use <= 0 for no restriction.\nmaxlevel:[in] Level of the smallest quads to be exchanged. Use >= P8EST_QMAXLEVEL for no restriction.\ndata_size:[in] The data size to transfer per quadrant.\nmirror_data:[in] One data pointer per mirror quadrant as input.\nghost_data:[in,out] Pre-allocated contiguous data for all ghosts in sequence, which must hold at least data_size for each ghost.\n\nPrototype\n\nvoid p8est_ghost_exchange_custom_levels (p8est_t * p8est, p8est_ghost_t * ghost, int minlevel, int maxlevel, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_levels_begin-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_levels_begin","text":"p8est_ghost_exchange_custom_levels_begin(p8est_, ghost, minlevel, maxlevel, data_size, mirror_data, ghost_data)\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8est_ghost_exchange_custom_levels. The return type is always non-NULL and must be passed to p8est_ghost_exchange_custom_levels_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers.\n\nParameters\n\nmirror_data:[in] Not required to stay alive any longer.\nghost_data:[in,out] Must stay alive into the completion call.\n\nReturns\n\nTransient storage for messages in progress.\n\nPrototype\n\np8est_ghost_exchange_t *p8est_ghost_exchange_custom_levels_begin (p8est_t * p8est, p8est_ghost_t * ghost, int minlevel, int maxlevel, size_t data_size, void **mirror_data, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_levels_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_levels_end","text":"p8est_ghost_exchange_custom_levels_end(exc)\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications.\n\nParameters\n\nexc:[in,out] created ONLY by p8est_ghost_exchange_custom_levels_begin. It is deallocated before this function returns.\n\nPrototype\n\nvoid p8est_ghost_exchange_custom_levels_end (p8est_ghost_exchange_t * exc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_data-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_data","text":"p8est_ghost_exchange_data(p8est_, ghost, ghost_data)\n\nTransfer data for local quadrants that are ghosts to other processors. Send the data stored in the quadrant's user_data. This is either the pointer variable itself if p8est->datasize is 0, or the content of the referenced memory field if p8est->data\\size is positive.\n\nParameters\n\np8est:[in] The forest used for reference.\nghost:[in] The ghost layer used for reference.\nghost_data:[in,out] Pre-allocated contiguous data for all ghost quadrants in sequence. If p8est->data_size is 0, must at least hold sizeof (void *) bytes for each, otherwise p8est->data_size each.\n\nPrototype\n\nvoid p8est_ghost_exchange_data (p8est_t * p8est, p8est_ghost_t * ghost, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_data_begin-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_data_begin","text":"p8est_ghost_exchange_data_begin(p8est_, ghost, ghost_data)\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8est_ghost_exchange_data. The return type is always non-NULL and must be passed to p8est_ghost_exchange_data_end to complete the exchange. The ghost data must not be accessed before completion.\n\nParameters\n\nghost_data:[in,out] Must stay alive into the completion call.\n\nReturns\n\nTransient storage for messages in progress.\n\nPrototype\n\np8est_ghost_exchange_t *p8est_ghost_exchange_data_begin (p8est_t * p8est, p8est_ghost_t * ghost, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_data_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_exchange_data_end","text":"p8est_ghost_exchange_data_end(exc)\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications.\n\nParameters\n\nexc:[in,out] Created ONLY by p8est_ghost_exchange_data_begin. It is deallocated before this function returns.\n\nPrototype\n\nvoid p8est_ghost_exchange_data_end (p8est_ghost_exchange_t * exc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_expand-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_expand","text":"p8est_ghost_expand(p8est_, ghost)\n\nExpand the size of the ghost layer and mirrors by one additional layer of adjacency.\n\nParameters\n\np8est:[in] The forest from which the ghost layer was generated.\nghost:[in,out] The ghost layer to be expanded.\n\nPrototype\n\nvoid p8est_ghost_expand (p8est_t * p8est, p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_expand_by_lnodes-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_expand_by_lnodes","text":"p8est_ghost_expand_by_lnodes(p4est_, lnodes, ghost)\n\nExpand the ghost layer as in p8est_ghost_expand(), but use node support to define adjacency instead of geometric adjacency.\n\nParameters\n\np8est:[in] The forest from which the ghost layer was generated.\nlnodes:[in] The nodes to support.\nghost:[in,out] The ghost layer to be expanded.\n\nPrototype\n\nvoid p8est_ghost_expand_by_lnodes (p8est_t * p4est, p8est_lnodes_t * lnodes, p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_is_valid-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_is_valid","text":"p8est_ghost_is_valid(p8est_, ghost)\n\nExamine if a ghost structure is valid as desribed above. Test if within a ghost-structure the arrays ghosts and mirrors are in p8est_quadrant_compare_piggy order. Test if local_num in piggy3 data member of the quadrants in ghosts and mirrors are in ascending order (ascending within each rank for ghost).\n\nTest if the p4est_locidx_t arrays are in ascending order (for mirror_proc_mirrors ascending within each rank)\n\nParameters\n\np8est:[in] the forest.\nghost:[in] Ghost layer structure.\n\nReturns\n\ntrue if ghost is valid\n\nPrototype\n\nint p8est_ghost_is_valid (p8est_t * p8est, p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_memory_used","text":"p8est_ghost_memory_used(ghost)\n\nCalculate the memory usage of the ghost layer.\n\nParameters\n\nghost:[in] Ghost layer structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p8est_ghost_memory_used (p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_new-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_new","text":"p8est_ghost_new(p8est_, btype)\n\nBuilds the ghost layer.\n\nThis will gather the quadrants from each neighboring proc to build one layer of face, edge and corner based ghost elements around the ones they own.\n\nParameters\n\np8est:[in] The forest for which the ghost layer will be generated.\nbtype:[in] Which ghosts to include (across face, edge, or corner/full).\n\nReturns\n\nA fully initialized ghost layer.\n\nPrototype\n\np8est_ghost_t *p8est_ghost_new (p8est_t * p8est, p8est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_support_lnodes-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_support_lnodes","text":"p8est_ghost_support_lnodes(p8est_, lnodes, ghost)\n\nExpand the ghost layer to include the support of all nodes supported on the local partition.\n\nParameters\n\np8est:[in] The forest from which the ghost layer was generated.\nlnodes:[in] The nodes to support.\nghost:[in,out] The ghost layer to be expanded.\n\nPrototype\n\nvoid p8est_ghost_support_lnodes (p8est_t * p8est, p8est_lnodes_t * lnodes, p8est_ghost_t * ghost);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_ghost_tree_contains-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_ghost_tree_contains","text":"p8est_ghost_tree_contains(ghost, which_proc, which_tree, q)\n\nConduct binary search for ancestor on range of the ghost layer.\n\nParameters\n\nghost:[in] The ghost layer.\nwhich_proc:[in] The owner of the searched quadrant. Can be -1.\nwhich_tree:[in] The tree of the searched quadrant. Can be -1.\nq:[in] Valid quadrant's ancestor is searched.\n\nReturns\n\nOffset in the ghost layer, or -1 if not found.\n\nPrototype\n\nssize_t p8est_ghost_tree_contains (p8est_ghost_t * ghost, int which_proc, p4est_topidx_t which_tree, const p8est_quadrant_t * q);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_is_balanced-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_is_balanced","text":"p8est_is_balanced(p8est_, btype)\n\nCheck a forest to see if it is balanced.\n\nThis function builds the ghost layer and discards it when done.\n\nParameters\n\np8est:[in] The p8est to be tested.\nbtype:[in] Balance type (face, edge, corner or default, full).\n\nReturns\n\nReturns true if balanced, false otherwise.\n\nPrototype\n\nint p8est_is_balanced (p8est_t * p8est, p8est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_iterate-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p8est_iterate","text":"p8est_iterate(p4est_, ghost_layer, user_data, iter_volume, iter_face, iter_edge, iter_corner)\n\nExecute the user-supplied callback functions at every volume, face, edge and corner in the local forest.\n\nThe ghost_layer may be NULL. The user_data pointer is not touched by p8est_iterate, but is passed to each of the callbacks. Any of the callback functions may be NULL. The callback functions are interspersed with each other, i.e. some face callbacks will occur between volume callbacks, and some edge callbacks will occur between face callbacks, etc.:\n\nvolume callbacks occur in the sorted Morton-index order. 2) a face callback is not executed until after the volume callbacks have been executed for the quadrants that share it. 3) an edge callback is not executed until the face callbacks have been executed for all faces that touch the edge. 4) a corner callback is not executed until the edge callbacks have been executed for all edges that touch the corner. 5) it is not always the case that every face callback for a given quadrant is executed before any of the edge or corner callbacks, and it is not always the case that every edge callback for a given quadrant is executed before any of the corner callbacks. 6) callbacks are not executed at faces, edges or corners that only involve ghost quadrants, i.e. that are not adjacent in the local section of the forest.\n\nParameters\n\np4est:[in] the forest\nghost_layer:[in] optional: when not given, callbacks at the boundaries of the local partition cannot provide quadrant data about ghost quadrants: missing (p8est_quadrant_t *) pointers are set to NULL, missing indices are set to -1.\nuser_data:[in,out] optional context to supply to each callback\niter_volume:[in] callback function for every quadrant's interior\niter_face:[in] callback function for every face between quadrants\niter_edge:[in] callback function for every edge between quadrants\niter_corner:[in] callback function for every corner between quadrants\n\nPrototype\n\nvoid p8est_iterate (p8est_t * p4est, p8est_ghost_t * ghost_layer, void *user_data, p8est_iter_volume_t iter_volume, p8est_iter_face_t iter_face, p8est_iter_edge_t iter_edge, p8est_iter_corner_t iter_corner);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_iterate_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p8est_iterate_ext","text":"p8est_iterate_ext(p8est_, ghost_layer, user_data, iter_volume, iter_face, iter_edge, iter_corner, remote)\n\np8est_iterate_ext adds the option remote: if this is false, then it is the same as p8est_iterate; if this is true, then corner/edge callbacks are also called on corners/edges for hanging faces/edges touched by local quadrants.\n\nPrototype\n\nvoid p8est_iterate_ext (p8est_t * p8est, p8est_ghost_t * ghost_layer, void *user_data, p8est_iter_volume_t iter_volume, p8est_iter_face_t iter_face, p8est_iter_edge_t iter_edge, p8est_iter_corner_t iter_corner, int remote);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_add-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_add","text":"p8est_lid_add(a, b, result)\n\nAdds the uint128_t b to the uint128_t a. result == a or result == b is not allowed. a == b is allowed.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nb:[in] A pointer to a p8est_lid_t.\nresult:[out] A pointer to a p8est_lid_t. The sum a + b will be saved in result.\n\nPrototype\n\nvoid p8est_lid_add (const p8est_lid_t * a, const p8est_lid_t * b, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_add_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_add_inplace","text":"p8est_lid_add_inplace(a, b)\n\nAdds the p8est_lid_t b to the p8est_lid_t a. The result is saved in a. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a p8est_lid_t. a will be overwritten by a + b.\nb:[in] A pointer to a p8est_lid_t.\n\nPrototype\n\nvoid p8est_lid_add_inplace (p8est_lid_t * a, const p8est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_and-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_bitwise_and","text":"p8est_lid_bitwise_and(a, b, result)\n\nCalculates the bitwise and of the uint128_t a and the uint128_t b. a == result is allowed. Furthermore, a == result and/or b == result is allowed.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nb:[in] A pointer to a p8est_lid_t.\nresult:[out] A pointer to a p8est_lid_t. The bitwise and of a and b will be saved. in result.\n\nPrototype\n\nvoid p8est_lid_bitwise_and (const p8est_lid_t * a, const p8est_lid_t * b, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_and_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_bitwise_and_inplace","text":"p8est_lid_bitwise_and_inplace(a, b)\n\nCalculates the bitwise and of the uint128_t a and the uint128_t b. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a p8est_lid_t. The bitwise and will be saved in a.\nb:[in] A pointer to a p8est_lid_t.\n\nPrototype\n\nvoid p8est_lid_bitwise_and_inplace (p8est_lid_t * a, const p8est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_neg-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_bitwise_neg","text":"p8est_lid_bitwise_neg(a, result)\n\nCalculates the bitwise negation of the uint128_t a. a == result is allowed.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nresult:[out] A pointer to a p8est_lid_t. The bitwise negation of a will be saved in result.\n\nPrototype\n\nvoid p8est_lid_bitwise_neg (const p8est_lid_t * a, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_or-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_bitwise_or","text":"p8est_lid_bitwise_or(a, b, result)\n\nCalculates the bitwise or of the uint128_t a and b. a == result is allowed. Furthermore, a == result and/or b == result is allowed.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nb:[in] A pointer to a p8est_lid_t.\nresult:[out] A pointer to a p8est_lid_t. The bitwise or of a and b will be saved in result.\n\nPrototype\n\nvoid p8est_lid_bitwise_or (const p8est_lid_t * a, const p8est_lid_t * b, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_or_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_bitwise_or_inplace","text":"p8est_lid_bitwise_or_inplace(a, b)\n\nCalculates the bitwise or of the uint128_t a and the uint128_t b. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a p8est_lid_t. The bitwise or will be saved in a.\nb:[in] A pointer to a p8est_lid_t.\n\nPrototype\n\nvoid p8est_lid_bitwise_or_inplace (p8est_lid_t * a, const p8est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_chk_bit-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_chk_bit","text":"p8est_lid_chk_bit(input, bit_number)\n\nReturns the bit_number-th bit of input. This function checks a bit of an existing, initialized value.\n\nParameters\n\ninput:[in] A pointer to a p8est_lid_t.\nbit_number:[in] The bit (counted from the right hand side) that is checked by logical and. Require 0 <= bit_number < 128.\n\nReturns\n\nTrue if bit is set, false if not.\n\nPrototype\n\nint p8est_lid_chk_bit (const p8est_lid_t * input, int bit_number);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_compare","text":"p8est_lid_compare(a, b)\n\nCompare the p8est_lid_t a and the p8est_lid_t b.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nb:[in] A pointer to a p8est_lid_t.\n\nReturns\n\nReturns -1 if a < b, 1 if a > b and 0 if a == b.\n\nPrototype\n\nint p8est_lid_compare (const p8est_lid_t * a, const p8est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_copy","text":"p8est_lid_copy(input, output)\n\nCopies an initialized p8est_lid_t to a p8est_lid_t.\n\nParameters\n\ninput:[in] A pointer to the sc_uint128 that is copied.\noutput:[in,out] A pointer to a p8est_lid_t. The high and low bits of output will be set to the high and low bits of input, respectively.\n\nPrototype\n\nvoid p8est_lid_copy (const p8est_lid_t * input, p8est_lid_t * output);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_init-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_init","text":"p8est_lid_init(input, high, low)\n\nInitializes a linear index to a given value.\n\nParameters\n\na:[in,out] A pointer to the p8est_lid_t that will be initialized.\nhigh:[in] The given high bits to intialize a.\nlow:[in] The given low bits to initialize a.\n\nPrototype\n\nvoid p8est_lid_init (p8est_lid_t * input, uint64_t high, uint64_t low);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_is_equal-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_is_equal","text":"p8est_lid_is_equal(a, b)\n\nChecks if the p8est_lid_t a and the p8est_lid_t b are equal.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nb:[in] A pointer to a p8est_lid_t.\n\nReturns\n\nReturns a true value if a and b are equal, false otherwise\n\nPrototype\n\nint p8est_lid_is_equal (const p8est_lid_t * a, const p8est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_bit-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_set_bit","text":"p8est_lid_set_bit(input, bit_number)\n\nSets the exponent-th bit of input to one. This function modifies an existing, initialized value.\n\nParameters\n\ninput:[in,out] A pointer to a p8est_lid_t.\nbit_number:[in] The bit (counted from the right hand side) that is set to one by logical or. Require 0 <= bit_number < 128.\n\nPrototype\n\nvoid p8est_lid_set_bit (p8est_lid_t * input, int bit_number);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_one-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_set_one","text":"p8est_lid_set_one(input)\n\nInitializes a linear index to one.\n\nParameters\n\ninput:[out] A pointer to a p4est_lid_t that will be intialized.\n\nPrototype\n\nvoid p8est_lid_set_one (p8est_lid_t * input);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_uint64-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_set_uint64","text":"p8est_lid_set_uint64(input, u)\n\nInitializes a linear index to an unsigned 64 bit integer.\n\nParameters\n\ninput:[out] A pointer to a p4est_lid_t that will be intialized.\n\nPrototype\n\nvoid p8est_lid_set_uint64 (p8est_lid_t * input, uint64_t u);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_zero-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_set_zero","text":"p8est_lid_set_zero(input)\n\nInitializes a linear index to zero.\n\nParameters\n\ninput:[out] A pointer to a p4est_lid_t that will be intialized.\n\nPrototype\n\nvoid p8est_lid_set_zero (p8est_lid_t * input);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_shift_left-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_shift_left","text":"p8est_lid_shift_left(input, shift_count, result)\n\nCalculates the bit left shift of uint128_t input by shift_count bits. We shift in zeros from the right. If shift_count >= 128, result is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. input == result is allowed.\n\nParameters\n\ninput:[in] A pointer to a p8est_lid_t.\nshift_count:[in] Bits to shift. shift_count >= 0.\nresult:[in,out] A pointer to a p8est_lid_t. The left shifted number will be saved in result.\n\nPrototype\n\nvoid p8est_lid_shift_left (const p8est_lid_t * input, unsigned shift_count, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_shift_right-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_shift_right","text":"p8est_lid_shift_right(input, shift_count, result)\n\nCalculates the bit right shift of uint128_t input by shift_count bits. We shift in zeros from the left. If shift_count >= 128, result is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. input == result is allowed.\n\nParameters\n\ninput:[in] A pointer to a p8est_lid_t.\nshift_count:[in] Bits to shift. shift_count >= 0.\nresult:[in,out] A pointer to a p8est_lid_t. The right shifted number will be saved in result.\n\nPrototype\n\nvoid p8est_lid_shift_right (const p8est_lid_t * input, unsigned shift_count, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_sub-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_sub","text":"p8est_lid_sub(a, b, result)\n\nSubstracts the p8est_lid_t b from the p8est_lid_t a. This function assumes that the result is >= 0. result == a or result == b is not allowed. a == b is allowed.\n\nParameters\n\na:[in] A pointer to a p8est_lid_t.\nb:[in] A pointer to a p8est_lid_t.\nresult:[out] A pointer to a p8est_lid_t. The difference a - b will be saved in result.\n\nPrototype\n\nvoid p8est_lid_sub (const p8est_lid_t * a, const p8est_lid_t * b, p8est_lid_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lid_sub_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lid_sub_inplace","text":"p8est_lid_sub_inplace(a, b)\n\nSubstracts the uint128_t b from the uint128_t a. The result is saved in a. a == b is allowed. This function assumes that the result is >= 0.\n\nParameters\n\na:[in,out] A pointer to a p8est_lid_t. a will be overwritten by a - b.\nb:[in] A pointer to a p8est_lid_t.\n\nPrototype\n\nvoid p8est_lid_sub_inplace (p8est_lid_t * a, const p8est_lid_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_buffer_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_buffer_destroy","text":"p8est_lnodes_buffer_destroy(buffer)\n\nPrototype\n\nvoid p8est_lnodes_buffer_destroy (p8est_lnodes_buffer_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_destroy","text":"p8est_lnodes_destroy(lnodes)\n\nPrototype\n\nvoid p8est_lnodes_destroy (p8est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_new-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_new","text":"p8est_lnodes_new(p8est_, ghost_layer, degree)\n\nPrototype\n\np8est_lnodes_t *p8est_lnodes_new (p8est_t * p8est, p8est_ghost_t * ghost_layer, int degree);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_all-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_share_all","text":"p8est_lnodes_share_all(node_data, lnodes)\n\nEquivalend to calling p8est_lnodes_share_all_end directly after p8est_lnodes_share_all_begin. Use if there is no local work that can be done to mask the communication cost.\n\nReturns\n\nA fully initialized buffer that contains the received data. After processing this data, the buffer must be freed with p8est_lnodes_buffer_destroy.\n\nPrototype\n\np8est_lnodes_buffer_t *p8est_lnodes_share_all (sc_array_t * node_data, p8est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_all_begin-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_share_all_begin","text":"p8est_lnodes_share_all_begin(node_data, lnodes)\n\np8est_lnodes_share_all_begin\n\nnode_data is a user_defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every process that shares an entry with the current one, the value in the node_data array of that process is written into a buffer->recvbuffers entry as described above. The user can then perform some arbitrary work that requires the data from all processes that share a node (such as reduce, max, min, etc.). When the work concludes, the buffer should be destroyed with [`p8estlnodesbufferdestroy`](@ref).\n\nValues of node_data are not guaranteed to be send, and buffer->recvbuffer entries are not guaranteed to be received until the buffer created by [`p8estlnodesshareallbegin](@ref) is passed to [p8estlnodesshareall_end`](@ref).\n\nPrototype\n\np8est_lnodes_buffer_t *p8est_lnodes_share_all_begin (sc_array_t * node_data, p8est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_all_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_share_all_end","text":"p8est_lnodes_share_all_end(buffer)\n\nPrototype\n\nvoid p8est_lnodes_share_all_end (p8est_lnodes_buffer_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_owned-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_share_owned","text":"p8est_lnodes_share_owned(node_data, lnodes)\n\nEquivalent to calling p8est_lnodes_share_owned_end directly after p8est_lnodes_share_owned_begin. Use if there is no local work that can be done to mask the communication cost.\n\nPrototype\n\nvoid p8est_lnodes_share_owned (sc_array_t * node_data, p8est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_owned_begin-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_share_owned_begin","text":"p8est_lnodes_share_owned_begin(node_data, lnodes)\n\np8est_lnodes_share_owned_begin\n\nnode_data is a user-defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every local nodes entry that is owned by a process other than the current one, the value in the node_data array of the owning process is written directly into the node_data array of the current process. Values of node_data are not guaranteed to be sent or received until the buffer created by p8est_lnodes_share_owned_begin is passed to p8est_lnodes_share_owned_end.\n\nTo be memory neutral, the buffer created by p8est_lnodes_share_owned_begin must be destroying with p8est_lnodes_buffer_destroy (it is not destroyed by p8est_lnodes_share_owned_end).\n\nPrototype\n\np8est_lnodes_buffer_t *p8est_lnodes_share_owned_begin (sc_array_t * node_data, p8est_lnodes_t * lnodes);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_owned_end-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_lnodes_share_owned_end","text":"p8est_lnodes_share_owned_end(buffer)\n\nPrototype\n\nvoid p8est_lnodes_share_owned_end (p8est_lnodes_buffer_t * buffer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_load-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_load","text":"p8est_load(filename, mpicomm, data_size, load_data, user_pointer, connectivity)\n\nPrototype\n\np8est_t *p8est_load (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, void *user_pointer, p8est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_load_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p8est_load_ext","text":"p8est_load_ext(filename, mpicomm, data_size, load_data, autopartition, broadcasthead, user_pointer, connectivity)\n\nPrototype\n\np8est_t *p8est_load_ext (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, p8est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_memory_used","text":"p8est_memory_used(p8est_)\n\nCalculate local memory usage of a forest structure. Not collective. The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use p8est_connectivity_memory_usage (p8est->connectivity).\n\nParameters\n\np8est:[in] Valid forest structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p8est_memory_used (p8est_t * p8est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_destroy","text":"p8est_mesh_destroy(mesh)\n\nDestroy a p8est_mesh structure.\n\nParameters\n\nmesh:[in] Mesh structure previously created by p8est_mesh_new.\n\nPrototype\n\nvoid p8est_mesh_destroy (p8est_mesh_t * mesh);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_data-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_data","text":"p8est_mesh_face_neighbor_data(mfn, ghost_data)\n\nGet the user data for the current face neighbor.\n\nParameters\n\nmfn:[in] Internal status of the iterator.\nghost_data:[in] Data for the ghost quadrants that has been synchronized with p4est_ghost_exchange_data.\n\nReturns\n\nA pointer to the user data for the current neighbor.\n\nPrototype\n\nvoid *p8est_mesh_face_neighbor_data (p8est_mesh_face_neighbor_t * mfn, void *ghost_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_init-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_init","text":"p8est_mesh_face_neighbor_init(mfn, p8est_, ghost, mesh, which_tree, quadrant)\n\nInitialize a mesh neighbor iterator by quadrant pointer.\n\nParameters\n\nmfn:[out] A p8est_mesh_face_neighbor_t to be initialized.\nwhich_tree:[in] Tree of quadrant whose neighbors are looped over.\nquadrant:[in] Pointer to quadrant contained in which_tree.\n\nPrototype\n\nvoid p8est_mesh_face_neighbor_init (p8est_mesh_face_neighbor_t * mfn, p8est_t * p8est, p8est_ghost_t * ghost, p8est_mesh_t * mesh, p4est_topidx_t which_tree, p8est_quadrant_t * quadrant);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_init2-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_init2","text":"p8est_mesh_face_neighbor_init2(mfn, p8est_, ghost, mesh, which_tree, quadrant_id)\n\nInitialize a mesh neighbor iterator by quadrant index.\n\nParameters\n\nmfn:[out] A p8est_mesh_face_neighbor_t to be initialized.\nwhich_tree:[in] Tree of quadrant whose neighbors are looped over.\nquadrant_id:[in] Index relative to which_tree of quadrant.\n\nPrototype\n\nvoid p8est_mesh_face_neighbor_init2 (p8est_mesh_face_neighbor_t * mfn, p8est_t * p8est, p8est_ghost_t * ghost, p8est_mesh_t * mesh, p4est_topidx_t which_tree, p4est_locidx_t quadrant_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_next-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_next","text":"p8est_mesh_face_neighbor_next(mfn, ntree, nquad, nface, nrank)\n\nMove the iterator forward to loop around neighbors of the quadrant.\n\nParameters\n\nmfn:[in,out] Internal status of the iterator.\nntree:[out] If not NULL, the tree number of the neighbor.\nnquad:[out] If not NULL, the quadrant number within tree. For ghosts instead the number in ghost layer.\nnface:[out] If not NULL, neighbor's face as in p8est_mesh_t.\nnrank:[out] If not NULL, the owner process of the neighbor.\n\nReturns\n\nEither a real quadrant or one from the ghost layer. Returns NULL when the iterator is done.\n\nPrototype\n\np8est_quadrant_t *p8est_mesh_face_neighbor_next (p8est_mesh_face_neighbor_t * mfn, p4est_topidx_t * ntree, p4est_locidx_t * nquad, int *nface, int *nrank);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_get_neighbors-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_get_neighbors","text":"p8est_mesh_get_neighbors(p4est_, ghost, mesh, curr_quad_id, direction, neighboring_quads, neighboring_encs, neighboring_qids)\n\nLookup neighboring quads of quadrant in a specific direction\n\nParameters\n\np4est:[in] Forest to be worked with.\nghost:[in] Ghost quadrants.\nmesh:[in] Mesh structure.\ncurr_quad_id:[in] Process-local ID of current quad.\ndirection:[in] Direction in which to look for adjacent quadrants is encoded as follows: 0 .. 5 neighbor(-s) across f_i, 6 .. 17 neighbor(-s) across e_{i-6} 18 .. 25 neighbor(-s) across c_{i-18}\nneighboring_quads:[out] Array containing neighboring quad(-s) Needs to be empty, contains p4est_quadrant_t*. May be NULL, then neighboring_qids must not be NULL.\nneighboring_encs:[out] Array containing encodings for neighboring quads as described below Needs to be empty, contains int. CAUTION: Note, that the encodings differ from the encodings saved in the mesh. Positive values are for local quadrants, negative values indicate ghost quadrants. Faces: 1 .. 24 => same size neighbor (r * 6 + nf) + 1; nf = 0 .. 5 face index; r = 0 .. 3 relative orientation 25 .. 120 => double size neighbor 25 + h * 24 + r * 6 + nf; h = 0 .. 3 number of the subface; r, nf as above 121 .. 144 => half size neighbors 121 + r * 6 + nf; r, nf as above Edges: 1 .. 24 => same size neighbor r * 12 + ne + 1; ne = 0 .. 11 edge index; r = 0 .. 1 relative orientation 25 .. 72 => double size neighbor 25 + h * 24 + r * 12 + ne; h = 0 .. 1 number of the subedge; r, ne as above 73 .. 96 => half size neighbors 73 + r * 12 + ne; r, ne as above Corners: 1 .. 8 => nc + 1; nc = 0 .. 7 corner index\nneighboring_qids:[out] Array containing quadrant ids for neighboring quadrants. May be NULL, then no neighboring qids are collected. If non-NULL the array needs to be empty and will contain int.\n\nPrototype\n\np4est_locidx_t p8est_mesh_get_neighbors (p8est_t * p4est, p8est_ghost_t * ghost, p8est_mesh_t * mesh, p4est_locidx_t curr_quad_id, p4est_locidx_t direction, sc_array_t * neighboring_quads, sc_array_t * neighboring_encs, sc_array_t * neighboring_qids);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_get_quadrant-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_get_quadrant","text":"p8est_mesh_get_quadrant(p4est_, mesh, qid)\n\nAccess a process-local quadrant inside a forest. Needs a mesh with populated quad_to_tree array. This is a special case of p8estmeshquadrant_cumulative.\n\nParameters\n\np4est:[in] The forest.\nmesh:[in] The mesh.\nqid:[in] Process-local id of the quadrant (cumulative over trees).\n\nReturns\n\nA pointer to the requested quadrant.\n\nPrototype\n\np8est_quadrant_t *p8est_mesh_get_quadrant (p8est_t * p4est, p8est_mesh_t * mesh, p4est_locidx_t qid);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_memory_used","text":"p8est_mesh_memory_used(mesh)\n\nCalculate the memory usage of the mesh structure.\n\nParameters\n\nmesh:[in] Mesh structure.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t p8est_mesh_memory_used (p8est_mesh_t * mesh);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_new-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_new","text":"p8est_mesh_new(p8est_, ghost, btype)\n\nCreate a p8est_mesh structure. This function does not populate the quad_to_tree and quad_level fields. To populate them, use p8estmeshnew_ext.\n\nParameters\n\np8est:[in] A forest that is fully 2:1 balanced.\nghost:[in] The ghost layer created from the provided p4est.\nbtype:[in] Determines the highest codimension of neighbors.\n\nReturns\n\nA fully allocated mesh structure.\n\nPrototype\n\np8est_mesh_t *p8est_mesh_new (p8est_t * p8est, p8est_ghost_t * ghost, p8est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_new_ext-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_new_ext","text":"p8est_mesh_new_ext(p4est_, ghost, compute_tree_index, compute_level_lists, btype)\n\nCreate a new mesh.\n\nParameters\n\np8est:[in] A forest that is fully 2:1 balanced.\nghost:[in] The ghost layer created from the provided p4est.\ncompute_tree_index:[in] Boolean to decide whether to allocate and compute the quad_to_tree list.\ncompute_level_lists:[in] Boolean to decide whether to compute the level lists in quad_level.\nbtype:[in] Currently ignored, only face neighbors are stored.\n\nReturns\n\nA fully allocated mesh structure.\n\nPrototype\n\np8est_mesh_t *p8est_mesh_new_ext (p8est_t * p4est, p8est_ghost_t * ghost, int compute_tree_index, int compute_level_lists, p8est_connect_type_t btype);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_mesh_quadrant_cumulative-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_mesh_quadrant_cumulative","text":"p8est_mesh_quadrant_cumulative(p8est_, mesh, cumulative_id, which_tree, quadrant_id)\n\nFind a quadrant based on its cumulative number in the local forest. If the quad_to_tree field of the mesh structure exists, this is O(1). Otherwise, we perform a binary search over the processor-local trees.\n\nParameters\n\np8est:[in] Forest to be worked with.\nmesh:[in] A mesh derived from the forest.\ncumulative_id:[in] Cumulative index over all trees of quadrant. Must refer to a local (non-ghost) quadrant.\nwhich_tree:[in,out] If not NULL, the input value can be -1 or an initial guess for the quadrant's tree and output is the tree of returned quadrant.\nquadrant_id:[out] If not NULL, the number of quadrant in tree.\n\nReturns\n\nThe identified quadrant.\n\nPrototype\n\np8est_quadrant_t *p8est_mesh_quadrant_cumulative (p8est_t * p8est, p8est_mesh_t * mesh, p4est_locidx_t cumulative_id, p4est_topidx_t * which_tree, p4est_locidx_t * quadrant_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_new-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_new","text":"p8est_new(mpicomm, connectivity, data_size, init_fn, user_pointer)\n\nPrototype\n\np8est_t *p8est_new (sc_MPI_Comm mpicomm, p8est_connectivity_t * connectivity, size_t data_size, p8est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_new_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p8est_new_ext","text":"p8est_new_ext(mpicomm, connectivity, min_quadrants, min_level, fill_uniform, data_size, init_fn, user_pointer)\n\nPrototype\n\np8est_t *p8est_new_ext (sc_MPI_Comm mpicomm, p8est_connectivity_t * connectivity, p4est_locidx_t min_quadrants, int min_level, int fill_uniform, size_t data_size, p8est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_partition-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_partition","text":"p8est_partition(p8est_, allow_for_coarsening, weight_fn)\n\nEqually partition the forest. The partition can be by element count or by a user-defined weight.\n\nThe forest will be partitioned between processors such that they have an approximately equal number of quadrants (or sum of weights).\n\nOn one process, the function noops and does not call the weight callback. Otherwise, the weight callback is called once per quadrant in order.\n\nParameters\n\np8est:[in,out] The forest that will be partitioned.\nallow_for_coarsening:[in] Slightly modify partition such that quadrant families are not split between ranks.\nweight_fn:[in] A weighting function or NULL for uniform partitioning. When running with mpisize == 1, never called. Otherwise, called in order for all quadrants if not NULL. A weighting function with constant weight 1 on each quadrant is equivalent to weight_fn == NULL but other constant weightings may result in different uniform partitionings.\n\nPrototype\n\nvoid p8est_partition (p8est_t * p8est, int allow_for_coarsening, p8est_weight_t weight_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_partition_ext-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_partition_ext","text":"p8est_partition_ext(p8est_, partition_for_coarsening, weight_fn)\n\nRepartition the forest.\n\nThe forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).\n\nParameters\n\np8est:[in,out] The forest that will be partitioned.\npartition_for_coarsening:[in] If true, the partition is modified to allow one level of coarsening.\nweight_fn:[in] A weighting function or NULL for uniform partitioning. A weighting function with constant weight 1 on each quadrant is equivalent to weight_fn == NULL but other constant weightings may result in different uniform partitionings.\n\nReturns\n\nThe global number of shipped quadrants\n\nPrototype\n\np4est_gloidx_t p8est_partition_ext (p8est_t * p8est, int partition_for_coarsening, p8est_weight_t weight_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_partition_for_coarsening-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_partition_for_coarsening","text":"p8est_partition_for_coarsening(p8est_, num_quadrants_in_proc)\n\nCorrect partition to allow one level of coarsening.\n\nParameters\n\np8est:[in] forest whose partition is corrected\nnum_quadrants_in_proc:[in,out] partition that will be corrected\n\nReturns\n\nabsolute number of moved quadrants\n\nPrototype\n\np4est_gloidx_t p8est_partition_for_coarsening (p8est_t * p8est, p4est_locidx_t * num_quadrants_in_proc);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_partition_lnodes-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_partition_lnodes","text":"p8est_partition_lnodes(p8est_, ghost, degree, partition_for_coarsening)\n\nPartition using weights based on the number of nodes assigned to each element in lnodes\n\nParameters\n\np8est:[in,out] the forest to be repartitioned\nghost:[in] the ghost layer\ndegree:[in] the degree that would be passed to p8est_lnodes_new()\npartition_for_coarsening:[in] whether the partition should allow coarsening (i.e. group siblings who might merge)\n\nPrototype\n\nvoid p8est_partition_lnodes (p8est_t * p8est, p8est_ghost_t * ghost, int degree, int partition_for_coarsening);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_partition_lnodes_detailed-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p8est_partition_lnodes_detailed","text":"p8est_partition_lnodes_detailed(p4est_, ghost, nodes_per_volume, nodes_per_face, nodes_per_edge, nodes_per_corner, partition_for_coarsening)\n\nPartition using weights that are broken down by where they reside: in volumes, on faces, on edges, or on corners.\n\nPrototype\n\nvoid p8est_partition_lnodes_detailed (p8est_t * p4est, p8est_ghost_t * ghost, int nodes_per_volume, int nodes_per_face, int nodes_per_edge, int nodes_per_corner, int partition_for_coarsening);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_qcoord_to_vertex-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_qcoord_to_vertex","text":"p8est_qcoord_to_vertex(connectivity, treeid, x, y, z, vxyz)\n\nTransform a quadrant coordinate into the space spanned by tree vertices.\n\nParameters\n\nconnectivity:[in] Connectivity must provide the vertices.\ntreeid:[in] Identify the tree that contains x, y, z.\nx,:[in] y, z Quadrant coordinates relative to treeid.\nvxyz:[out] Transformed coordinates in vertex space.\n\nPrototype\n\nvoid p8est_qcoord_to_vertex (p8est_connectivity_t * connectivity, p4est_topidx_t treeid, p4est_qcoord_t x, p4est_qcoord_t y, p4est_qcoord_t z, double vxyz[3]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_exists-NTuple{7, Any}","page":"API reference","title":"P4est.LibP4est.p8est_quadrant_exists","text":"p8est_quadrant_exists(p8est_, ghost, treeid, q, exists_arr, rproc_arr, rquad_arr)\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nFor quadrants across tree corners it checks if the quadrant exists in any of the corner neighbors, thus it can execute multiple queries.\n\nParameters\n\np8est:[in] The forest in which to search for q\nghost:[in] The ghost layer in which to search for q\ntreeid:[in] The tree to which q belongs (can be extended).\nq:[in] The quadrant that is being searched for.\nexists_arr:[in,out] Must exist and be of of elem_size = sizeof (int) for inter-tree corner cases. Is resized by this function to one entry for each corner search and set to true/false depending on its existence in the local forest or ghost_layer.\nrproc_arr:[in,out] If not NULL is filled with one rank per query.\nrquad_arr:[in,out] If not NULL is filled with one quadrant per query. Its piggy3 member is defined as well.\n\nReturns\n\ntrue if the quadrant exists in the local forest or in the ghost_layer, and false if doesn't exist in either.\n\nPrototype\n\nint p8est_quadrant_exists (p8est_t * p8est, p8est_ghost_t * ghost, p4est_topidx_t treeid, const p8est_quadrant_t * q, sc_array_t * exists_arr, sc_array_t * rproc_arr, sc_array_t * rquad_arr);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_find_owner-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_quadrant_find_owner","text":"p8est_quadrant_find_owner(p8est_, treeid, face, q)\n\nGets the processor id of a quadrant's owner. The quadrant can lie outside of a tree across faces (and only faces).\n\nwarning: Warning\nDoes not work for tree edge or corner neighbors.\n\nParameters\n\np8est:[in] The forest in which to search for a quadrant.\ntreeid:[in] The tree to which the quadrant belongs.\nface:[in] Supply a face direction if known, or -1 otherwise.\nq:[in] The quadrant that is being searched for.\n\nReturns\n\nProcessor id of the owner or -1 if the quadrant lies outside of the mesh.\n\nPrototype\n\nint p8est_quadrant_find_owner (p8est_t * p8est, p4est_topidx_t treeid, int face, const p8est_quadrant_t * q);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_linear_id_ext128-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_quadrant_linear_id_ext128","text":"p8est_quadrant_linear_id_ext128(quadrant, level, id)\n\nComputes the linear position as p8est_lid_t of a quadrant in a uniform grid. The grid and quadrant levels need not coincide. If they do, this is the inverse of p4estquadrantset_morton.\n\nnote: Note\nThe user_data of quadrant is never modified.\n\nParameters\n\nquadrant:[in] Quadrant whose linear index will be computed. If the quadrant is smaller than the grid (has a higher quadrant->level), the result is computed from its ancestor at the grid's level. If the quadrant has a smaller level than the grid (it is bigger than a grid cell), the grid cell sharing its lower left corner is used as reference.\nlevel:[in] The level of the regular grid compared to which the linear position is to be computed.\nid:[in,out] A pointer to an allocated or static p8est_lid_t. id will be the linear position of this quadrant on a uniform grid.\n\nPrototype\n\nvoid p8est_quadrant_linear_id_ext128 (const p8est_quadrant_t * quadrant, int level, p8est_lid_t * id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_set_morton_ext128-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_quadrant_set_morton_ext128","text":"p8est_quadrant_set_morton_ext128(quadrant, level, id)\n\nSet quadrant Morton indices based on linear position given as p8est_lid_t in uniform grid. This is the inverse operation of p4estquadrantlinear_id.\n\nnote: Note\nThe user_data of quadrant is never modified.\n\nParameters\n\nquadrant:[in,out] Quadrant whose Morton indices will be set.\nlevel:[in] Level of the grid and of the resulting quadrant.\nid:[in] Linear index of the quadrant on a uniform grid.\n\nPrototype\n\nvoid p8est_quadrant_set_morton_ext128 (p8est_quadrant_t * quadrant, int level, const p8est_lid_t * id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_refine-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_refine","text":"p8est_refine(p8est_, refine_recursive, refine_fn, init_fn)\n\nRefine a forest.\n\nParameters\n\np8est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nrefine_fn:[in] Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn gets called, or use p8est_refine_ext in p8est_extended.h and examine whether replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data of newly created quadrants, which is already allocated. This function pointer may be NULL.\n\nPrototype\n\nvoid p8est_refine (p8est_t * p8est, int refine_recursive, p8est_refine_t refine_fn, p8est_init_t init_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_refine_ext-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.p8est_refine_ext","text":"p8est_refine_ext(p8est_, refine_recursive, maxlevel, refine_fn, init_fn, replace_fn)\n\nRefine a forest with a bounded refinement level and a replace option.\n\nParameters\n\np8est:[in,out] The forest is changed in place.\nrefine_recursive:[in] Boolean to decide on recursive refinement.\nmaxlevel:[in] Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in p8est.h.\nrefine_fn:[in] Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called.\ninit_fn:[in] Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL.\nreplace_fn:[in] Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL.\n\nPrototype\n\nvoid p8est_refine_ext (p8est_t * p8est, int refine_recursive, int maxlevel, p8est_refine_t refine_fn, p8est_init_t init_fn, p8est_replace_t replace_fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_reset_data-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_reset_data","text":"p8est_reset_data(p8est_, data_size, init_fn, user_pointer)\n\nReset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.\n\nParameters\n\ndata_size:[in] This is the size of data for each quadrant which can be zero. Then user_data_pool is set to NULL.\ninit_fn:[in] Callback function to initialize the user_data which is already allocated automatically. May be NULL.\nuser_pointer:[in] Assign to the user_pointer member of the p8est before init_fn is called the first time.\n\nPrototype\n\nvoid p8est_reset_data (p8est_t * p8est, size_t data_size, p8est_init_t init_fn, void *user_pointer);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_revision-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.p8est_revision","text":"p8est_revision(p8est_)\n\nReturn the revision counter of the forest. Not collective, even though the revision value is the same on all ranks. A newly created forest starts with a revision counter of zero. Every refine, coarsen, partition, and balance that actually changes the mesh increases the counter by one. Operations with no effect keep the old value.\n\nParameters\n\np8est:[in] The forest must be valid.\n\nReturns\n\nNon-negative number.\n\nPrototype\n\nlong p8est_revision (p8est_t * p8est);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_save-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_save","text":"p8est_save(filename, p8est_, save_data)\n\nSave the complete connectivity/p8est data to disk.\n\nThis is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations.\n\nBy default, we write the current processor count and partition into the file header. This makes the file depend on mpisize. For changing this see p8est_save_ext() in p8est_extended.h.\n\nThe revision counter is not saved to the file, since that would make files different that come from different revisions but store the same mesh.\n\nnote: Note\nAborts on file errors.\n\nnote: Note\nIf p4est is not configured to use MPI-IO, some processes return from this function before the file is complete, in which case immediate read-access to the file may require a call to sc_MPI_Barrier.\n\nParameters\n\nfilename:[in] Name of the file to write.\np8est:[in] Valid forest structure.\nsave_data:[in] If true, the element data is saved. Otherwise, a data size of 0 is saved.\n\nPrototype\n\nvoid p8est_save (const char *filename, p8est_t * p8est, int save_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_save_ext-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_save_ext","text":"p8est_save_ext(filename, p8est_, save_data, save_partition)\n\nSave the complete connectivity/p8est data to disk. This is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p8est_load_ext for information on the autopartition parameter.\n\nnote: Note\nAborts on file errors.\n\nParameters\n\nfilename:[in] Name of the file to write.\np8est:[in] Valid forest structure.\nsave_data:[in] If true, the element data is saved. Otherwise, a data size of 0 is saved.\nsave_partition:[in] If false, save file as if 1 core was used. If true, save core count and partition. Advantage: Partition can be recovered on loading with same mpisize and autopartition false. Disadvantage: Makes the file depend on mpisize. Either way the file can be loaded with autopartition true.\n\nPrototype\n\nvoid p8est_save_ext (const char *filename, p8est_t * p8est, int save_data, int save_partition);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_search-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.p8est_search","text":"p8est_search(p4est_, quadrant_fn, point_fn, points)\n\nThis function is provided for backwards compatibility. We call p8estsearchlocal with call_post = 0.\n\nPrototype\n\nvoid p8est_search (p8est_t * p4est, p8est_search_query_t quadrant_fn, p8est_search_query_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_search_all-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_search_all","text":"p8est_search_all(p4est_, call_post, quadrant_fn, point_fn, points)\n\nPerform a top-down search on the whole forest.\n\nThis function combines the functionality of p4estsearchlocal and p4estsearchpartition; their documentation applies for the most part.\n\nThe recursion proceeds from the root quadrant of each tree until (a) we encounter a remote quadrant that covers only one processor, or (b) we encounter a local leaf quadrant. In other words, we proceed with the recursion into a quadrant's children if (a) the quadrant is split between two or more processors, no matter whether one of them is the calling processor or not, or (b) if the quadrant is on the local processor but we have not reached a leaf yet.\n\nThe search can track one or more points, which are abstract placeholders. They are matched against the quadrants traversed using a callback function. The result of the callback function can be used to stop a recursion early. The user determines how a point is interpreted, we only pass it around.\n\nNote that in the remote case (a), we may terminate the recursion even if the quadrant is not a leaf, which we have no means of knowing. Still, this case is sufficient to determine the processor ownership of a point.\n\nnote: Note\nThis is a very powerful function that can become slow if not used carefully.\n\nnote: Note\nAs with the two other search functions in this file, calling it once with many points is generally much faster than calling it once for each point. Using multiple points also allows for a per-quadrant termination of the recursion in addition to a more costly per-point termination.\n\nnote: Note\nThis function works fine when used for the special cases that either the partition or the local quadrants are not of interest. However, in the case of querying only local information we expect that p4estsearchlocal will be faster since it employs specific local optimizations.\n\nParameters\n\np4est:[in] The forest to be searched.\ncall_post:[in] If true, call quadrant callback both pre and post.\nquadrant_fn:[in] Executed once for each quadrant that is entered. If the callback returns false, this quadrant and its descendants are excluded from the search, and the points in this branch are not queried further. Its point argument is always NULL. Callback may be NULL in which case it is ignored.\npoint_fn:[in] Executed once for each point that is relevant for a quadrant of the search. If it returns true, the point is tracked further down that branch, else it is discarded from the queries for the children. If points is not NULL, this callback must be not NULL. If points is NULL, it is not called.\npoints:[in] User-defined array of points. We do not interpret a point, just pass it into the callbacks. If NULL, only the quadrant_fn callback is executed. If that is NULL, the whole function noops. If not NULL, the point_fn is called on its members during the search.\n\nPrototype\n\nvoid p8est_search_all (p8est_t * p4est, int call_post, p8est_search_all_t quadrant_fn, p8est_search_all_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_search_local-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_search_local","text":"p8est_search_local(p4est_, call_post, quadrant_fn, point_fn, points)\n\nSearch through the local part of a forest. The search is especially efficient if multiple targets, called \"points\" below, are searched for simultaneously.\n\nThe search runs over all local quadrants and proceeds recursively top-down. For each tree, it may start at the root of that tree, or further down at the root of the subtree that contains all of the tree's local quadrants. Likewise, some intermediate levels in the recursion may be skipped if the processor-local part is contained in a single deeper subtree. The outer loop is thus a depth-first, processor-local forest traversal. Each quadrant in that loop either is a leaf, or a (direct or indirect) strict ancestor of a leaf. On entering a new quadrant, a user-provided quadrant-callback is executed.\n\nAs a convenience, the user may provide anonymous \"points\" that are tracked down the forest. This way one search call may be used for multiple targets. The set of points that potentially matches a given quadrant diminishes from the root down to the leaves: For each quadrant, an inner loop over the potentially matching points executes a point-callback for each candidate that determines whether the point may be a match. If not, it is discarded in the current branch, otherwise it is passed to the next deeper level. The callback is allowed to return true for the same point and more than one quadrant; in this case more than one matching quadrant may be identified. The callback is also allowed to return false for all children of a quadrant that it returned true for earlier. If the point callback returns false for all points relevant to a quadrant, the recursion stops. The points can really be anything, p4est does not perform any interpretation, just passes the pointer along to the callback function.\n\nIf points are present and the first quadrant callback returned true, we execute it a second time after calling the point callback for all current points. This can be used to gather and postprocess information about the points more easily. If it returns false, the recursion stops.\n\nIf the points are a NULL array, they are ignored and the recursion proceeds by querying the per-quadrant callback. If the points are not NULL but an empty array, the recursion will stop immediately!\n\nParameters\n\np4est:[in] The forest to be searched.\ncall_post:[in] If true, call quadrant callback both pre and post.\nquadrant_fn:[in] Executed once when a quadrant is entered, and once when it is left (the second time only if points are present and the first call returned true). This quadrant is always local, if not completely than at least one descendant of it. If the callback returns false, this quadrant and its descendants are excluded from the search recursion. Its point argument is always NULL. Callback may be NULL in which case it is ignored.\npoint_fn:[in] If points is not NULL, must be not NULL. Shall return true for any possible matching point. If points is NULL, this callback is ignored.\npoints:[in] User-defined array of \"points\". If NULL, only the quadrant_fn callback is executed. If that is NULL, this function noops. If not NULL, the point_fn is called on its members during the search.\n\nPrototype\n\nvoid p8est_search_local (p8est_t * p4est, int call_post, p8est_search_local_t quadrant_fn, p8est_search_local_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_search_partition-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.p8est_search_partition","text":"p8est_search_partition(p4est_, call_post, quadrant_fn, point_fn, points)\n\nTraverse the global partition top-down. We proceed top-down through the partition, identically on all processors except for the results of two user-provided callbacks. The recursion will only go down branches that are split between multiple processors. The callback functions can be used to stop a branch recursion even for split branches. This function offers the option to search for arbitrary user-defined points analogously to p4estsearchlocal.\n\nnote: Note\nTraversing the whole processor partition will be at least O(P), so sensible use of the callback function is advised to cut it short.\n\nParameters\n\np4est:[in] The forest to traverse. Its local quadrants are never accessed.\ncall_post:[in] If true, call quadrant callback both pre and post.\nquadrant_fn:[in] This function controls the recursion, which only continues deeper if this callback returns true for a branch quadrant. It is allowed to set this to NULL.\npoint_fn:[in] This function decides per-point whether it is followed down the recursion. Must be non-NULL if points are not NULL.\npoints:[in] User-provided array of points that are passed to the callback point_fn. See p8estsearchlocal for details.\n\nPrototype\n\nvoid p8est_search_partition (p8est_t * p4est, int call_post, p8est_search_partition_t quadrant_fn, p8est_search_partition_t point_fn, sc_array_t * points);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_source_ext-NTuple{8, Any}","page":"API reference","title":"P4est.LibP4est.p8est_source_ext","text":"p8est_source_ext(src, mpicomm, data_size, load_data, autopartition, broadcasthead, user_pointer, connectivity)\n\nPrototype\n\np8est_t *p8est_source_ext (sc_io_source_t * src, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, p8est_connectivity_t ** connectivity);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.p8est_split_array-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.p8est_split_array","text":"p8est_split_array(array, level, indices)\n\nSplit an array of quadrants by the children of an ancestor.\n\nGiven a sorted array of quadrants that have a common ancestor at level level, compute the indices of the first quadrant in each of the common ancestor's children at level level + 1.\n\nParameters\n\narray:[in] The sorted array of quadrants of level > level.\nlevel:[in] The level at which there is a common ancestor.\nindices:[in,out] The indices of the first quadrant in each of the ancestors's children, plus an additional index on the end. The quadrants of array that are descendants of child i have indices between indices[i] and indices[i + 1] - 1. If indices[i] = indices[i+1], this indicates that no quadrant in the array is contained in child i.\n\nPrototype\n\nvoid p8est_split_array (sc_array_t * array, int level, size_t indices[]);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_abort-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_abort","text":"sc_abort()\n\nPrint a stack trace, call the abort handler and then call abort ().\n\nPrototype\n\nvoid sc_abort (void) __attribute__ ((noreturn));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_abort_collective-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_abort_collective","text":"sc_abort_collective(msg)\n\nCollective abort where only root prints a message\n\nPrototype\n\nvoid sc_abort_collective (const char *msg) __attribute__ ((noreturn));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_abort_verbose-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_abort_verbose","text":"sc_abort_verbose(filename, lineno, msg)\n\nPrint a message to stderr and then call sc_abort ().\n\nPrototype\n\nvoid sc_abort_verbose (const char *filename, int lineno, const char *msg) __attribute__ ((noreturn));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_bsearch-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_bsearch","text":"sc_array_bsearch(array, key, compar)\n\nPerforms a binary search on an array. The array must be sorted.\n\nParameters\n\narray:[in] A sorted array to search in.\nkey:[in] An element to be searched for.\ncompar:[in] The comparison function to be used.\n\nReturns\n\nReturns the index into array for the item found, or -1.\n\nPrototype\n\nssize_t sc_array_bsearch (sc_array_t * array, const void *key, int (*compar) (const void *, const void *));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_checksum-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_checksum","text":"sc_array_checksum(array)\n\nComputes the adler32 checksum of array data (see zlib documentation). This is a faster checksum than crc32, and it works with zeros as data.\n\nPrototype\n\nunsigned int sc_array_checksum (sc_array_t * array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_copy","text":"sc_array_copy(dest, src)\n\nCopy the contents of one array into another. Both arrays must have equal element sizes. The source array may be a view. We use memcpy (3): If the two arrays overlap, results are undefined.\n\nParameters\n\ndest:[in] Array (not a view) will be resized and get new data.\nsrc:[in] Array used as source of new data, will not be changed.\n\nPrototype\n\nvoid sc_array_copy (sc_array_t * dest, sc_array_t * src);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_copy_into-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_copy_into","text":"sc_array_copy_into(dest, dest_offset, src)\n\nCopy the contents of one array into some portion of another. Both arrays must have equal element sizes. Either array may be a view. The destination array must be large enough. We use memcpy (3): If the two arrays overlap, results are undefined.\n\nParameters\n\ndest:[in] Array will be written into. Its element count must be at least dest_offset + src->elem_count.\ndest_offset:[in] First index in dest array to be overwritten. As every index, it refers to elements, not bytes.\nsrc:[in] Array used as source of new data, will not be changed.\n\nPrototype\n\nvoid sc_array_copy_into (sc_array_t * dest, size_t dest_offset, sc_array_t * src);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_destroy","text":"sc_array_destroy(array)\n\nDestroys an array structure.\n\nParameters\n\narray:[in] The array to be destroyed.\n\nPrototype\n\nvoid sc_array_destroy (sc_array_t * array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_destroy_null-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_destroy_null","text":"sc_array_destroy_null(parray)\n\nDestroys an array structure and sets the pointer to NULL.\n\nParameters\n\nparray:[in,out] Pointer to address of array to be destroyed. On output, *parray is NULL.\n\nPrototype\n\nvoid sc_array_destroy_null (sc_array_t ** parray);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_init-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_init","text":"sc_array_init(array, elem_size)\n\nInitializes an already allocated (or static) array structure.\n\nParameters\n\narray:[in,out] Array structure to be initialized.\nelem_size:[in] Size of one array element in bytes.\n\nPrototype\n\nvoid sc_array_init (sc_array_t * array, size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_init_count-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_init_count","text":"sc_array_init_count(array, elem_size, elem_count)\n\nInitializes an already allocated (or static) array structure and allocates a given number of elements. This function supersedes scarrayinit_size.\n\nParameters\n\narray:[in,out] Array structure to be initialized.\nelem_size:[in] Size of one array element in bytes.\nelem_count:[in] Number of initial array elements.\n\nPrototype\n\nvoid sc_array_init_count (sc_array_t * array, size_t elem_size, size_t elem_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_init_data-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_init_data","text":"sc_array_init_data(view, base, elem_size, elem_count)\n\nInitializes an already allocated (or static) view from given plain C data. The array view returned does not require sc_array_reset (doesn't hurt though).\n\nParameters\n\nview:[in,out] Array structure to be initialized.\nbase:[in] The data must not be moved while view is alive.\nelem_size:[in] Size of one array element in bytes.\nelem_count:[in] The length of the view in element units. The view cannot be resized to exceed this length. It is not necessary to call sc_array_reset later.\n\nPrototype\n\nvoid sc_array_init_data (sc_array_t * view, void *base, size_t elem_size, size_t elem_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_init_size-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_init_size","text":"sc_array_init_size(array, elem_size, elem_count)\n\nInitializes an already allocated (or static) array structure and allocates a given number of elements. Deprecated: use scarrayinit_count.\n\nParameters\n\narray:[in,out] Array structure to be initialized.\nelem_size:[in] Size of one array element in bytes.\nelem_count:[in] Number of initial array elements.\n\nPrototype\n\nvoid sc_array_init_size (sc_array_t * array, size_t elem_size, size_t elem_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_init_view-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_init_view","text":"sc_array_init_view(view, array, offset, length)\n\nInitializes an already allocated (or static) view from existing sc_array_t. The array view returned does not require sc_array_reset (doesn't hurt though).\n\nParameters\n\nview:[in,out] Array structure to be initialized.\narray:[in] The array must not be resized while view is alive.\noffset:[in] The offset of the viewed section in element units. This offset cannot be changed until the view is reset.\nlength:[in] The length of the view in element units. The view cannot be resized to exceed this length. It is not necessary to call sc_array_reset later.\n\nPrototype\n\nvoid sc_array_init_view (sc_array_t * view, sc_array_t * array, size_t offset, size_t length);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_is_equal-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_is_equal","text":"sc_array_is_equal(array, other)\n\nCheck whether two arrays have equal size, count, and content. Either array may be a view. Both arrays will not be changed.\n\nParameters\n\narray:[in] One array to be compared.\nother:[in] A second array to be compared.\n\nReturns\n\nTrue if array and other are equal, false otherwise.\n\nPrototype\n\nint sc_array_is_equal (sc_array_t * array, sc_array_t * other);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_is_permutation-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_is_permutation","text":"sc_array_is_permutation(array)\n\nDetermine whether array is an array of size_t's whose entries include every integer 0 <= i < array->elem_count.\n\nParameters\n\narray:[in] An array.\n\nReturns\n\nReturns 1 if array contains size_t elements whose entries include every integer 0 <= i < array->elem_count, 0 otherwise.\n\nPrototype\n\nint sc_array_is_permutation (sc_array_t * array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_is_sorted-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_is_sorted","text":"sc_array_is_sorted(array, compar)\n\nCheck whether the array is sorted wrt. the comparison function.\n\nParameters\n\narray:[in] The array to check.\ncompar:[in] The comparison function to be used.\n\nReturns\n\nTrue if array is sorted, false otherwise.\n\nPrototype\n\nint sc_array_is_sorted (sc_array_t * array, int (*compar) (const void *, const void *));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_memory_used-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_memory_used","text":"sc_array_memory_used(array, is_dynamic)\n\nCalculate the memory used by an array.\n\nParameters\n\narray:[in] The array.\nis_dynamic:[in] True if created with sc_array_new, false if initialized with sc_array_init\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t sc_array_memory_used (sc_array_t * array, int is_dynamic);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_memset-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_memset","text":"sc_array_memset(array, c)\n\nRun memset on the array storage. We pass the character to memset unchanged. Thus, care must be taken when setting values below -1 or above 127, just as with standard memset (3).\n\nParameters\n\narray:[in,out] This array's storage will be overwritten.\nc:[in] Character to overwrite every byte with.\n\nPrototype\n\nvoid sc_array_memset (sc_array_t * array, int c);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_move_part-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_move_part","text":"sc_array_move_part(dest, dest_offset, src, src_offset, count)\n\nCopy part of one array into another using memmove (3). Both arrays must have equal element sizes. Either array may be a view. The destination array must be large enough. We use memmove (3): The two arrays may overlap.\n\nParameters\n\ndest:[in] Array will be written into. Its element count must be at least dest_offset + count.\ndest_offset:[in] First index in dest array to be overwritten. As every index, it refers to elements, not bytes.\nsrc:[in] Array will be read from. Its element count must be at least src_offset + count.\nsrc_offset:[in] First index in src array to be used. As every index, it refers to elements, not bytes.\ncount:[in] Number of entries copied.\n\nPrototype\n\nvoid sc_array_move_part (sc_array_t * dest, size_t dest_offset, sc_array_t * src, size_t src_offset, size_t count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_new-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_new","text":"sc_array_new(elem_size)\n\nCreates a new array structure with 0 elements.\n\nParameters\n\nelem_size:[in] Size of one array element in bytes.\n\nReturns\n\nReturn an allocated array of zero length.\n\nPrototype\n\nsc_array_t *sc_array_new (size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_new_count-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_new_count","text":"sc_array_new_count(elem_size, elem_count)\n\nCreates a new array structure with a given length (number of elements).\n\nParameters\n\nelem_size:[in] Size of one array element in bytes.\nelem_count:[in] Initial number of array elements.\n\nReturns\n\nReturn an allocated array with allocated but uninitialized elements.\n\nPrototype\n\nsc_array_t *sc_array_new_count (size_t elem_size, size_t elem_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_new_data-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_new_data","text":"sc_array_new_data(base, elem_size, elem_count)\n\nCreates a new view of an existing plain C array.\n\nParameters\n\nbase:[in] The data must not be moved while view is alive.\nelem_size:[in] Size of one array element in bytes.\nelem_count:[in] The length of the view in element units. The view cannot be resized to exceed this length.\n\nPrototype\n\nsc_array_t *sc_array_new_data (void *base, size_t elem_size, size_t elem_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_new_view-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_new_view","text":"sc_array_new_view(array, offset, length)\n\nCreates a new view of an existing sc_array_t.\n\nParameters\n\narray:[in] The array must not be resized while view is alive.\noffset:[in] The offset of the viewed section in element units. This offset cannot be changed until the view is reset.\nlength:[in] The length of the viewed section in element units. The view cannot be resized to exceed this length.\n\nPrototype\n\nsc_array_t *sc_array_new_view (sc_array_t * array, size_t offset, size_t length);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_permute-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_permute","text":"sc_array_permute(array, newindices, keepperm)\n\nGiven permutation newindices, permute array in place. The data that on input is contained in array[i] will be contained in array[newindices[i]] on output. The entries of newindices will be altered unless keepperm is true.\n\nParameters\n\narray:[in,out] An array.\nnewindices:[in,out] Permutation array (see sc_array_is_permutation).\nkeepperm:[in] If true, newindices will be unchanged by the algorithm; if false, newindices will be the identity permutation on output, but the algorithm will only use O(1) space.\n\nPrototype\n\nvoid sc_array_permute (sc_array_t * array, sc_array_t * newindices, int keepperm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_pqueue_add-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_pqueue_add","text":"sc_array_pqueue_add(array, temp, compar)\n\nAdds an element to a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. The priority queue is implemented as a heap in ascending order. A heap is a binary tree where the children are not less than their parent. Assumes that elements [0]..[elem_count-2] form a valid heap. Then propagates [elem_count-1] upward by swapping if necessary.\n\nnote: Note\nIf the return value is zero for all elements in an array, the array is sorted linearly and unchanged.\n\nParameters\n\ntemp:[in] Pointer to unused allocated memory of elem_size.\ncompar:[in] The comparison function to be used.\n\nReturns\n\nReturns the number of swap operations.\n\nPrototype\n\nsize_t sc_array_pqueue_add (sc_array_t * array, void *temp, int (*compar) (const void *, const void *));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_pqueue_pop-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_pqueue_pop","text":"sc_array_pqueue_pop(array, result, compar)\n\nPops the smallest element from a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. This function assumes that the array forms a valid heap in ascending order.\n\nnote: Note\nThis function resizes the array to elem_count-1.\n\nParameters\n\nresult:[out] Pointer to unused allocated memory of elem_size.\ncompar:[in] The comparison function to be used.\n\nReturns\n\nReturns the number of swap operations.\n\nPrototype\n\nsize_t sc_array_pqueue_pop (sc_array_t * array, void *result, int (*compar) (const void *, const void *));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_reset-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_reset","text":"sc_array_reset(array)\n\nSets the array count to zero and frees all elements. This function turns a view into a newly initialized array.\n\nnote: Note\nCalling sc_array_init, then any array operations, then sc_array_reset is memory neutral. As an exception, the two functions sc_array_init_view and sc_array_init_data do not require a subsequent call to sc_array_reset. Regardless, it is legal to call sc_array_reset anyway.\n\nParameters\n\narray:[in,out] Array structure to be reset.\n\nPrototype\n\nvoid sc_array_reset (sc_array_t * array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_resize-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_resize","text":"sc_array_resize(array, new_count)\n\nSets the element count to new_count. If the array is not a view, reallocation takes place occasionally. If the array is a view, new_count must not be greater than the element count of the view when it was created. The original offset of the view cannot be changed.\n\nParameters\n\narray:[in,out] The element count and address is modified.\nnew_count:[in] New element count of the array. If it is zero and the array is not a view, the effect equals scarrayreset.\n\nPrototype\n\nvoid sc_array_resize (sc_array_t * array, size_t new_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_rewind-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_rewind","text":"sc_array_rewind(array, new_count)\n\nShorten an array without reallocating it.\n\nParameters\n\narray:[in,out] The element count of this array is modified.\nnew_count:[in] Must be less or equal than the array's count. If it is less, the number of elements in the array is reduced without reallocating memory. The exception is a new_count of zero specified for an array that is not a view: In this case scarrayreset is equivalent.\n\nPrototype\n\nvoid sc_array_rewind (sc_array_t * array, size_t new_count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_sort-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_sort","text":"sc_array_sort(array, compar)\n\nSorts the array in ascending order wrt. the comparison function.\n\nParameters\n\narray:[in] The array to sort.\ncompar:[in] The comparison function to be used.\n\nPrototype\n\nvoid sc_array_sort (sc_array_t * array, int (*compar) (const void *, const void *));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_split-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_split","text":"sc_array_split(array, offsets, num_types, type_fn, data)\n\nCompute the offsets of groups of enumerable types in an array.\n\nParameters\n\narray:[in] Array that is sorted in ascending order by type. If k indexes array, then 0 <= type_fn (array, k, data) < num_types.\noffsets:[in,out] An initialized array of type size_t that is resized to num_types + 1 entries. The indices j of array that contain objects of type k are offsets[k] <= j < offsets[k + 1]. If there are no objects of type k, then offsets[k] = offset[k + 1].\nnum_types:[in] The number of possible types of objects in array.\ntype_fn:[in] Returns the type of an object in the array.\ndata:[in] Arbitrary user data passed to type_fn.\n\nPrototype\n\nvoid sc_array_split (sc_array_t * array, sc_array_t * offsets, size_t num_types, sc_array_type_t type_fn, void *data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_truncate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_array_truncate","text":"sc_array_truncate(array)\n\nSets the array count to zero, but does not free elements. Not allowed for views.\n\nnote: Note\nThis is intended to allow an sc_array to be used as a reusable buffer, where the \"high water mark\" of the buffer is preserved, so that O(log (max n)) reallocs occur over the life of the buffer.\n\nParameters\n\narray:[in,out] Array structure to be truncated.\n\nPrototype\n\nvoid sc_array_truncate (sc_array_t * array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_array_uniq-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_array_uniq","text":"sc_array_uniq(array, compar)\n\nRemoved duplicate entries from a sorted array. This function is not allowed for views.\n\nParameters\n\narray:[in,out] The array size will be reduced as necessary.\ncompar:[in] The comparison function to be used.\n\nPrototype\n\nvoid sc_array_uniq (sc_array_t * array, int (*compar) (const void *, const void *));\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_atoi-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_atoi","text":"sc_atoi(nptr)\n\nSafe version of the standard library atoi (3) function.\n\nParameters\n\nnptr:[in] NUL-terminated string.\n\nReturns\n\nConverted integer value. 0 if no valid number. INT_MAX on overflow, INT_MIN on underflow.\n\nPrototype\n\nint sc_atoi (const char *nptr);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_atol-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_atol","text":"sc_atol(nptr)\n\nSafe version of the standard library atol (3) function.\n\nParameters\n\nnptr:[in] NUL-terminated string.\n\nReturns\n\nConverted long value. 0 if no valid number. LONG_MAX on overflow, LONG_MIN on underflow.\n\nPrototype\n\nlong sc_atol (const char *nptr);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_calloc-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_calloc","text":"sc_calloc(package, nmemb, size)\n\nPrototype\n\nvoid *sc_calloc (int package, size_t nmemb, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_double_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_double_compare","text":"sc_double_compare(v1, v2)\n\nPrototype\n\nint sc_double_compare (const void *v1, const void *v2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_fflush_fsync_fclose-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_fflush_fsync_fclose","text":"sc_fflush_fsync_fclose(file)\n\nBest effort to flush a file's data to disc and close it.\n\nParameters\n\nfile:[in,out] File open for writing.\n\nPrototype\n\nvoid sc_fflush_fsync_fclose (FILE * file);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_finalize-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_finalize","text":"sc_finalize()\n\nUnregisters all packages, runs the memory check, removes the signal handlers and resets sc_identifier and sc_root_*. This function aborts on any inconsistency found unless the global variable default_abort_mismatch is false. This function is optional. This function does not require sc_init to be called first.\n\nPrototype\n\nvoid sc_finalize (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_finalize_noabort-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_finalize_noabort","text":"sc_finalize_noabort()\n\nUnregisters all packages, runs the memory check, removes the signal handlers and resets sc_identifier and sc_root_*. This function never aborts but returns the number of errors encountered. This function is optional. This function does not require sc_init to be called first.\n\nReturns\n\n0 when everything is consistent, nonzero otherwise.\n\nPrototype\n\nint sc_finalize_noabort (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_fread-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_fread","text":"sc_fread(ptr, size, nmemb, file, errmsg)\n\nRead file content into memory.\n\nnote: Note\nThis function aborts on file errors.\n\nParameters\n\nptr:[out] Data array to read from disk.\nsize:[in] Size of one array member.\nnmemb:[in] Number of array members.\nfile:[in,out] File pointer, must be opened for reading.\nerrmsg:[in] Error message passed to SC_CHECK_ABORT.\n\nPrototype\n\nvoid sc_fread (void *ptr, size_t size, size_t nmemb, FILE * file, const char *errmsg);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_free-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_free","text":"sc_free(package, ptr)\n\nPrototype\n\nvoid sc_free (int package, void *ptr);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_fwrite-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_fwrite","text":"sc_fwrite(ptr, size, nmemb, file, errmsg)\n\nWrite memory content to a file.\n\nnote: Note\nThis function aborts on file errors.\n\nParameters\n\nptr:[in] Data array to write to disk.\nsize:[in] Size of one array member.\nnmemb:[in] Number of array members.\nfile:[in,out] File pointer, must be opened for writing.\nerrmsg:[in] Error message passed to SC_CHECK_ABORT.\n\nPrototype\n\nvoid sc_fwrite (const void *ptr, size_t size, size_t nmemb, FILE * file, const char *errmsg);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_destroy","text":"sc_hash_array_destroy(hash_array)\n\nDestroy a hash array.\n\nPrototype\n\nvoid sc_hash_array_destroy (sc_hash_array_t * hash_array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_insert_unique-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_insert_unique","text":"sc_hash_array_insert_unique(hash_array, v, position)\n\nInsert an object into a hash array if it is not contained already. The object is not copied into the array. Use the return value for that. New objects are guaranteed to be added at the end of the array.\n\nParameters\n\nv:[in] A pointer to the object. Used for search only.\nposition:[out] If position != NULL, *position is set to the array position of the already contained, or if not present, the new object.\n\nReturns\n\nReturns NULL if the object is already contained. Otherwise returns its new address in the array.\n\nPrototype\n\nvoid *sc_hash_array_insert_unique (sc_hash_array_t * hash_array, void *v, size_t *position);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_is_valid-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_is_valid","text":"sc_hash_array_is_valid(hash_array)\n\nCheck the internal consistency of a hash array.\n\nPrototype\n\nint sc_hash_array_is_valid (sc_hash_array_t * hash_array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_lookup-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_lookup","text":"sc_hash_array_lookup(hash_array, v, position)\n\nCheck if an object is contained in a hash array.\n\nParameters\n\nv:[in] A pointer to the object.\nposition:[out] If position != NULL, *position is set to the array position of the already contained object if found.\n\nReturns\n\nReturns true if object is found, false otherwise.\n\nPrototype\n\nint sc_hash_array_lookup (sc_hash_array_t * hash_array, void *v, size_t *position);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_memory_used","text":"sc_hash_array_memory_used(ha)\n\nCalculate the memory used by a hash array.\n\nParameters\n\nha:[in] The hash array.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t sc_hash_array_memory_used (sc_hash_array_t * ha);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_new-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_new","text":"sc_hash_array_new(elem_size, hash_fn, equal_fn, user_data)\n\nCreate a new hash array.\n\nParameters\n\nelem_size:[in] Size of one array element in bytes.\nhash_fn:[in] Function to compute the hash value.\nequal_fn:[in] Function to test two objects for equality.\n\nPrototype\n\nsc_hash_array_t *sc_hash_array_new (size_t elem_size, sc_hash_function_t hash_fn, sc_equal_function_t equal_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_rip-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_rip","text":"sc_hash_array_rip(hash_array, rip)\n\nExtract the array data from a hash array and destroy everything else.\n\nParameters\n\nhash_array:[in] The hash array is destroyed after extraction.\nrip:[in] Array structure that will be overwritten. All previous array data (if any) will be leaked. The filled array can be freed with sc_array_reset.\n\nPrototype\n\nvoid sc_hash_array_rip (sc_hash_array_t * hash_array, sc_array_t * rip);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_array_truncate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_array_truncate","text":"sc_hash_array_truncate(hash_array)\n\nRemove all elements from the hash array.\n\nParameters\n\nhash_array:[in,out] Hash array to truncate.\n\nPrototype\n\nvoid sc_hash_array_truncate (sc_hash_array_t * hash_array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_destroy","text":"sc_hash_destroy(hash)\n\nDestroy a hash table.\n\nIf the allocator is owned, this runs in O(1), otherwise in O(N).\n\nnote: Note\nIf allocator was provided in sc_hash_new, it will not be destroyed.\n\nPrototype\n\nvoid sc_hash_destroy (sc_hash_t * hash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_destroy_null-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_destroy_null","text":"sc_hash_destroy_null(phash)\n\nDestroy a hash table and set its pointer to NULL. Destruction is done using schashdestroy.\n\nParameters\n\nphash:[in,out] Address of pointer to hash table. On output, pointer is NULLed.\n\nPrototype\n\nvoid sc_hash_destroy_null (sc_hash_t ** phash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_foreach-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_foreach","text":"sc_hash_foreach(hash, fn)\n\nInvoke a callback for every member of the hash table. The functions hash_fn and equal_fn are not called by this function.\n\nPrototype\n\nvoid sc_hash_foreach (sc_hash_t * hash, sc_hash_foreach_t fn);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_function_string-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_function_string","text":"sc_hash_function_string(s, u)\n\nCompute a hash value from a null-terminated string. This hash function is NOT cryptographically safe! Use libcrypt then.\n\nParameters\n\ns:[in] Null-terminated string to be hashed.\nu:[in] Not used.\n\nReturns\n\nThe computed hash value as an unsigned integer.\n\nPrototype\n\nunsigned int sc_hash_function_string (const void *s, const void *u);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_insert_unique-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_insert_unique","text":"sc_hash_insert_unique(hash, v, found)\n\nInsert an object into a hash table if it is not contained already.\n\nParameters\n\nv:[in] The object to be inserted.\nfound:[out] If found != NULL, *found is set to the address of the pointer to the already contained, or if not present, the new object. You can assign to **found to override.\n\nReturns\n\nReturns true if object is added, false if it is already contained.\n\nPrototype\n\nint sc_hash_insert_unique (sc_hash_t * hash, void *v, void ***found);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_lookup-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_lookup","text":"sc_hash_lookup(hash, v, found)\n\nCheck if an object is contained in the hash table.\n\nParameters\n\nv:[in] The object to be looked up.\nfound:[out] If found != NULL, *found is set to the address of the pointer to the already contained object if the object is found. You can assign to **found to override.\n\nReturns\n\nReturns true if object is found, false otherwise.\n\nPrototype\n\nint sc_hash_lookup (sc_hash_t * hash, void *v, void ***found);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_memory_used","text":"sc_hash_memory_used(hash)\n\nCalculate the memory used by a hash table.\n\nParameters\n\nhash:[in] The hash table.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t sc_hash_memory_used (sc_hash_t * hash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_new-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_new","text":"sc_hash_new(hash_fn, equal_fn, user_data, allocator)\n\nCreate a new hash table. The number of hash slots is chosen dynamically.\n\nParameters\n\nhash_fn:[in] Function to compute the hash value.\nequal_fn:[in] Function to test two objects for equality.\nuser_data:[in] User data passed through to the hash function.\nallocator:[in] Memory allocator for sc_link_t, can be NULL.\n\nPrototype\n\nsc_hash_t *sc_hash_new (sc_hash_function_t hash_fn, sc_equal_function_t equal_fn, void *user_data, sc_mempool_t * allocator);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_print_statistics-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_print_statistics","text":"sc_hash_print_statistics(package_id, log_priority, hash)\n\nCompute and print statistical information about the occupancy.\n\nPrototype\n\nvoid sc_hash_print_statistics (int package_id, int log_priority, sc_hash_t * hash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_remove-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_remove","text":"sc_hash_remove(hash, v, found)\n\nRemove an object from a hash table.\n\nParameters\n\nv:[in] The object to be removed.\nfound:[out] If found != NULL, *found is set to the object that is removed if that exists.\n\nReturns\n\nReturns true if object is found, false if is not contained.\n\nPrototype\n\nint sc_hash_remove (sc_hash_t * hash, void *v, void **found);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_truncate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_truncate","text":"sc_hash_truncate(hash)\n\nRemove all entries from a hash table in O(N).\n\nIf the allocator is owned, it calls sc_hash_unlink and sc_mempool_truncate. Otherwise, it calls sc_list_reset on every hash slot which is slower.\n\nPrototype\n\nvoid sc_hash_truncate (sc_hash_t * hash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_unlink-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_unlink","text":"sc_hash_unlink(hash)\n\nUnlink all hash elements without returning them to the mempool.\n\nIf the allocator is not owned, this runs faster than sc_hash_truncate, but is dangerous because of potential memory leaks.\n\nParameters\n\nhash:[in,out] Hash structure to be unlinked.\n\nPrototype\n\nvoid sc_hash_unlink (sc_hash_t * hash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_hash_unlink_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_hash_unlink_destroy","text":"sc_hash_unlink_destroy(hash)\n\nSame effect as unlink and destroy, but in O(1). This is dangerous because of potential memory leaks.\n\nParameters\n\nhash:[in] Hash structure to be unlinked and destroyed.\n\nPrototype\n\nvoid sc_hash_unlink_destroy (sc_hash_t * hash);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_init-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_init","text":"sc_init(mpicomm, catch_signals, print_backtrace, log_handler, log_threshold)\n\nPrototype\n\nvoid sc_init (sc_MPI_Comm mpicomm, int catch_signals, int print_backtrace, sc_log_handler_t log_handler, int log_threshold);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_int16_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_int16_compare","text":"sc_int16_compare(v1, v2)\n\nPrototype\n\nint sc_int16_compare (const void *v1, const void *v2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_int32_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_int32_compare","text":"sc_int32_compare(v1, v2)\n\nPrototype\n\nint sc_int32_compare (const void *v1, const void *v2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_int64_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_int64_compare","text":"sc_int64_compare(v1, v2)\n\nPrototype\n\nint sc_int64_compare (const void *v1, const void *v2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_int8_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_int8_compare","text":"sc_int8_compare(v1, v2)\n\nPrototype\n\nint sc_int8_compare (const void *v1, const void *v2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_int_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_int_compare","text":"sc_int_compare(v1, v2)\n\nPrototype\n\nint sc_int_compare (const void *v1, const void *v2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_sink_align-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_sink_align","text":"sc_io_sink_align(sink, bytes_align)\n\nAlign sink to a byte boundary by writing zeros.\n\nParameters\n\nsink:[in,out] The sink object to align.\nbytes_align:[in] Byte boundary.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_sink_align (sc_io_sink_t * sink, size_t bytes_align);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_sink_complete-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_sink_complete","text":"sc_io_sink_complete(sink, bytes_in, bytes_out)\n\nFlush all buffered output data to sink. This function may return SC_IO_ERROR_AGAIN if another write is required. Currently this may happen if BUFFER requires an integer multiple of bytes. If successful, the updated value of bytes read and written is returned in bytes_in/out, and the sink status is reset as if the sink had just been created. In particular, the bytes counters are reset to zero. The internal state of the sink is not changed otherwise. It is legal to continue writing to the sink hereafter. The sink actions taken depend on its type. BUFFER, FILEFILE: none. FILENAME: call fclose on sink->file.\n\nParameters\n\nsink:[in,out] The sink object to write to.\nbytes_in:[in,out] Bytes received since the last new or complete call. May be NULL.\nbytes_out:[in,out] Bytes written since the last new or complete call. May be NULL.\n\nReturns\n\n0 if completed, nonzero on error.\n\nPrototype\n\nint sc_io_sink_complete (sc_io_sink_t * sink, size_t * bytes_in, size_t * bytes_out);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_sink_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_io_sink_destroy","text":"sc_io_sink_destroy(sink)\n\nFree data sink. Calls sc_io_sink_complete and discards the final counts. Errors from complete lead to SC_IO_ERROR_FATAL returned from this function. Call sc_io_sink_complete yourself if bytes_out is of interest.\n\nParameters\n\nsink:[in,out] The sink object to complete and free.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_sink_destroy (sc_io_sink_t * sink);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_sink_write-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_sink_write","text":"sc_io_sink_write(sink, data, bytes_avail)\n\nWrite data to a sink. Data may be buffered and sunk in a later call. The internal counters sink->bytes_in and sink->bytes_out are updated.\n\nParameters\n\nsink:[in,out] The sink object to write to.\ndata:[in] Data passed into sink.\nbytes_avail:[in] Number of data bytes passed in.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_sink_write (sc_io_sink_t * sink, const void *data, size_t bytes_avail);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_source_activate_mirror-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_io_source_activate_mirror","text":"sc_io_source_activate_mirror(source)\n\nActivate a buffer that mirrors (i.e., stores) the data that was read.\n\nParameters\n\nsource:[in,out] The source object to activate mirror in.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_source_activate_mirror (sc_io_source_t * source);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_source_align-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_source_align","text":"sc_io_source_align(source, bytes_align)\n\nAlign source to a byte boundary by skipping.\n\nParameters\n\nsource:[in,out] The source object to align.\nbytes_align:[in] Byte boundary.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_source_align (sc_io_source_t * source, size_t bytes_align);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_source_complete-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_source_complete","text":"sc_io_source_complete(source, bytes_in, bytes_out)\n\nDetermine whether all data buffered from source has been returned by read. If it returns SC_IO_ERROR_AGAIN, another sc_io_source_read is required. If the call returns no error, the internal counters source->bytes_in and source->bytes_out are returned to the caller if requested, and reset to 0. The internal state of the source is not changed otherwise. It is legal to continue reading from the source hereafter.\n\nParameters\n\nsource:[in,out] The source object to read from.\nbytes_in:[in,out] If not NULL and true is returned, the total size of the data sourced.\nbytes_out:[in,out] If not NULL and true is returned, total bytes passed out by source_read.\n\nReturns\n\nSC_IO_ERROR_AGAIN if buffered data remaining. Otherwise return ERROR_NONE and reset counters.\n\nPrototype\n\nint sc_io_source_complete (sc_io_source_t * source, size_t * bytes_in, size_t * bytes_out);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_source_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_io_source_destroy","text":"sc_io_source_destroy(source)\n\nFree data source. Calls sc_io_source_complete and requires it to return no error. This is to avoid discarding buffered data that has not been passed to read.\n\nParameters\n\nsource:[in,out] The source object to free.\n\nReturns\n\n0 on success. Nonzero if an error is encountered or is_complete returns one.\n\nPrototype\n\nint sc_io_source_destroy (sc_io_source_t * source);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_source_read-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_source_read","text":"sc_io_source_read(source, data, bytes_avail, bytes_out)\n\nRead data from a source. The internal counters source->bytes_in and source->bytes_out are updated. Data is read until the data buffer has not enough room anymore, or source becomes empty. It is possible that data already read internally remains in the source object for the next call. Call sc_io_source_complete and check its return value to find out. Returns an error if bytes_out is NULL and less than bytes_avail are read.\n\nParameters\n\nsource:[in,out] The source object to read from.\ndata:[in] Data buffer for reading from sink. If NULL the output data will be thrown away.\nbytes_avail:[in] Number of bytes available in data buffer.\nbytes_out:[in,out] If not NULL, byte count read into data buffer. Otherwise, requires to read exactly bytes_avail.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_source_read (sc_io_source_t * source, void *data, size_t bytes_avail, size_t * bytes_out);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_io_source_read_mirror-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_io_source_read_mirror","text":"sc_io_source_read_mirror(source, data, bytes_avail, bytes_out)\n\nRead data from the source's mirror. Same behaviour as sc_io_source_read.\n\nParameters\n\nsource:[in,out] The source object to read mirror data from.\n\nReturns\n\n0 on success, nonzero on error.\n\nPrototype\n\nint sc_io_source_read_mirror (sc_io_source_t * source, void *data, size_t bytes_avail, size_t * bytes_out);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_is_root-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_is_root","text":"sc_is_root()\n\nIdentify the root process. Only meaningful between sc_init and sc_finalize and with a communicator that is not sc_MPI_COMM_NULL (otherwise always true).\n\nReturns\n\nReturn true for the root process and false otherwise.\n\nPrototype\n\nint sc_is_root (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_append-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_list_append","text":"sc_list_append(list, data)\n\nInsert a list element at the end of the list.\n\nParameters\n\nlist:[in,out] Valid list object.\ndata:[in] A new link is created holding this data.\n\nReturns\n\nThe link that has been created for data.\n\nPrototype\n\nsc_link_t *sc_list_append (sc_list_t * list, void *data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_list_destroy","text":"sc_list_destroy(list)\n\nDestroy a linked list structure in O(N).\n\nnote: Note\nIf allocator was provided in sc_list_new, it will not be destroyed.\n\nParameters\n\nlist:[in,out] All memory allocated for this list is freed.\n\nPrototype\n\nvoid sc_list_destroy (sc_list_t * list);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_init-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_list_init","text":"sc_list_init(list, allocator)\n\nInitialize a list object with an external link allocator.\n\nParameters\n\nlist:[in,out] List structure to be initialized.\nallocator:[in] External memory allocator for sc_link_t, which must exist already.\n\nPrototype\n\nvoid sc_list_init (sc_list_t * list, sc_mempool_t * allocator);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_insert-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_list_insert","text":"sc_list_insert(list, pred, data)\n\nInsert an element after a given list position.\n\nParameters\n\nlist:[in,out] Valid list object.\npred:[in,out] The predecessor of the element to be inserted.\ndata:[in] A new link is created holding this data.\n\nReturns\n\nThe link that has been created for data.\n\nPrototype\n\nsc_link_t *sc_list_insert (sc_list_t * list, sc_link_t * pred, void *data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_memory_used-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_list_memory_used","text":"sc_list_memory_used(list, is_dynamic)\n\nCalculate the total memory used by a list.\n\nParameters\n\nlist:[in] The list.\nis_dynamic:[in] True if created with sc_list_new, false if initialized with sc_list_init\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t sc_list_memory_used (sc_list_t * list, int is_dynamic);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_new-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_list_new","text":"sc_list_new(allocator)\n\nAllocate a new, empty linked list.\n\nParameters\n\nallocator:[in] Memory allocator for sc_link_t, can be NULL in which case an internal allocator is created.\n\nReturns\n\nPointer to a newly allocated, empty list object.\n\nPrototype\n\nsc_list_t *sc_list_new (sc_mempool_t * allocator);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_pop-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_list_pop","text":"sc_list_pop(list)\n\nRemove an element from the front of the list.\n\nParameters\n\nlist:[in,out] Valid, non-empty list object.\n\nReturns\n\nReturns the data of the removed first list element.\n\nPrototype\n\nvoid *sc_list_pop (sc_list_t * list);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_prepend-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_list_prepend","text":"sc_list_prepend(list, data)\n\nInsert a list element at the beginning of the list.\n\nParameters\n\nlist:[in,out] Valid list object.\ndata:[in] A new link is created holding this data.\n\nReturns\n\nThe link that has been created for data.\n\nPrototype\n\nsc_link_t *sc_list_prepend (sc_list_t * list, void *data);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_remove-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_list_remove","text":"sc_list_remove(list, pred)\n\nRemove an element after a given list position.\n\nParameters\n\nlist:[in,out] Valid, non-empty list object.\npred:[in] The predecessor of the element to be removed. If pred == NULL, the first element is removed, which is equivalent to calling sc_list_pop (list).\n\nReturns\n\nThe data of the removed and freed link.\n\nPrototype\n\nvoid *sc_list_remove (sc_list_t * list, sc_link_t * pred);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_reset-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_list_reset","text":"sc_list_reset(list)\n\nRemove all elements from a list in O(N).\n\nnote: Note\nCalling sc_list_init, then any list operations, then sc_list_reset is memory neutral.\n\nParameters\n\nlist:[in,out] List structure to be emptied.\n\nPrototype\n\nvoid sc_list_reset (sc_list_t * list);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_list_unlink-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_list_unlink","text":"sc_list_unlink(list)\n\nUnlink all list elements without returning them to the mempool. This runs in O(1) but is dangerous because the link memory stays alive.\n\nParameters\n\nlist:[in,out] List structure to be unlinked.\n\nPrototype\n\nvoid sc_list_unlink (sc_list_t * list);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_log-NTuple{6, Any}","page":"API reference","title":"P4est.LibP4est.sc_log","text":"sc_log(filename, lineno, package, category, priority, msg)\n\nThe central log function to be called by all packages. Dispatches the log calls by package and filters by category and priority.\n\nParameters\n\npackage:[in] Must be a registered package id or -1.\ncategory:[in] Must be SC_LC_NORMAL or SC_LC_GLOBAL.\npriority:[in] Must be > SC_LP_ALWAYS and < SC_LP_SILENT.\n\nPrototype\n\nvoid sc_log (const char *filename, int lineno, int package, int category, int priority, const char *msg);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_log_indent_pop-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_log_indent_pop","text":"sc_log_indent_pop()\n\nRemove one space from the start of a sc's default log format.\n\nPrototype\n\nvoid sc_log_indent_pop (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_log_indent_pop_count-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_log_indent_pop_count","text":"sc_log_indent_pop_count(package, count)\n\nRemove spaces from the start of a package's default log format.\n\nPrototype\n\nvoid sc_log_indent_pop_count (int package, int count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_log_indent_push-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_log_indent_push","text":"sc_log_indent_push()\n\nAdd one space to the start of sc's default log format.\n\nPrototype\n\nvoid sc_log_indent_push (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_log_indent_push_count-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_log_indent_push_count","text":"sc_log_indent_push_count(package, count)\n\nAdd spaces to the start of a package's default log format.\n\nPrototype\n\nvoid sc_log_indent_push_count (int package, int count);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_malloc-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_malloc","text":"sc_malloc(package, size)\n\nPrototype\n\nvoid *sc_malloc (int package, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_memory_check-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_memory_check","text":"sc_memory_check(package)\n\nPrototype\n\nvoid sc_memory_check (int package);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_memory_check_noerr-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_memory_check_noerr","text":"sc_memory_check_noerr(package)\n\nReturn error count or zero if all is ok.\n\nPrototype\n\nint sc_memory_check_noerr (int package);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_memory_status-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_memory_status","text":"sc_memory_status(package)\n\nPrototype\n\nint sc_memory_status (int package);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_destroy-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_destroy","text":"sc_mempool_destroy(mempool)\n\nDestroy a mempool structure. All elements that are still in use are invalidated.\n\nParameters\n\nmempool:[in,out] Its memory is freed.\n\nPrototype\n\nvoid sc_mempool_destroy (sc_mempool_t * mempool);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_destroy_null-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_destroy_null","text":"sc_mempool_destroy_null(pmempool)\n\nDestroy a mempool structure. All elements that are still in use are invalidated.\n\nParameters\n\npmempool:[in,out] Address of pointer to memory pool. Its memory is freed, pointer is NULLed.\n\nPrototype\n\nvoid sc_mempool_destroy_null (sc_mempool_t ** pmempool);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_init-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_init","text":"sc_mempool_init(mempool, elem_size)\n\nSame as sc_mempool_new, but for an already allocated sc_mempool_t pointer.\n\nPrototype\n\nvoid sc_mempool_init (sc_mempool_t * mempool, size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_memory_used","text":"sc_mempool_memory_used(mempool)\n\nCalculate the memory used by a memory pool.\n\nParameters\n\narray:[in] The memory pool.\n\nReturns\n\nMemory used in bytes.\n\nPrototype\n\nsize_t sc_mempool_memory_used (sc_mempool_t * mempool);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_new-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_new","text":"sc_mempool_new(elem_size)\n\nCreates a new mempool structure with the zero_and_persist option off. The contents of any elements returned by sc_mempool_alloc are undefined.\n\nParameters\n\nelem_size:[in] Size of one element in bytes.\n\nReturns\n\nReturns an allocated and initialized memory pool.\n\nPrototype\n\nsc_mempool_t *sc_mempool_new (size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_new_zero_and_persist-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_new_zero_and_persist","text":"sc_mempool_new_zero_and_persist(elem_size)\n\nCreates a new mempool structure with the zero_and_persist option on. The memory of newly created elements is zero'd out, and the contents of an element are not touched between freeing and re-returning it.\n\nParameters\n\nelem_size:[in] Size of one element in bytes.\n\nReturns\n\nReturns an allocated and initialized memory pool.\n\nPrototype\n\nsc_mempool_t *sc_mempool_new_zero_and_persist (size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_reset-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_reset","text":"sc_mempool_reset(mempool)\n\nSame as sc_mempool_destroy, but does not free the pointer\n\nPrototype\n\nvoid sc_mempool_reset (sc_mempool_t * mempool);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mempool_truncate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mempool_truncate","text":"sc_mempool_truncate(mempool)\n\nInvalidates all previously returned pointers, resets count to 0.\n\nPrototype\n\nvoid sc_mempool_truncate (sc_mempool_t * mempool);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_attach_node_comms-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_comm_attach_node_comms","text":"sc_mpi_comm_attach_node_comms(comm, processes_per_node)\n\nPrototype\n\nvoid sc_mpi_comm_attach_node_comms (sc_MPI_Comm comm, int processes_per_node);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_detach_node_comms-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_comm_detach_node_comms","text":"sc_mpi_comm_detach_node_comms(comm)\n\nPrototype\n\nvoid sc_mpi_comm_detach_node_comms (sc_MPI_Comm comm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_get_and_attach-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_comm_get_and_attach","text":"sc_mpi_comm_get_and_attach(comm)\n\nPrototype\n\nint sc_mpi_comm_get_and_attach (sc_MPI_Comm comm);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_get_node_comms-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_comm_get_node_comms","text":"sc_mpi_comm_get_node_comms(comm, intranode, internode)\n\nPrototype\n\nvoid sc_mpi_comm_get_node_comms (sc_MPI_Comm comm, sc_MPI_Comm * intranode, sc_MPI_Comm * internode);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_read-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_read","text":"sc_mpi_read(mpifile, ptr, zcount, t, errmsg)\n\nPrototype\n\nvoid sc_mpi_read (MPI_File mpifile, const void *ptr, size_t zcount, sc_MPI_Datatype t, const char *errmsg);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_sizeof-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_sizeof","text":"sc_mpi_sizeof(t)\n\nPrototype\n\nsize_t sc_mpi_sizeof (sc_MPI_Datatype t);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mpi_write-NTuple{5, Any}","page":"API reference","title":"P4est.LibP4est.sc_mpi_write","text":"sc_mpi_write(mpifile, ptr, zcount, t, errmsg)\n\nPrototype\n\nvoid sc_mpi_write (MPI_File mpifile, const void *ptr, size_t zcount, sc_MPI_Datatype t, const char *errmsg);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mstamp_alloc-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mstamp_alloc","text":"sc_mstamp_alloc(mst)\n\nReturn a new item. The memory returned will stay legal until container is destroyed or truncated.\n\nParameters\n\nProperly:[in,out] initialized stamp container.\n\nReturns\n\nPointer to an item ready to use. Legal until scstampdestroy or scstamptruncate is called on mst.\n\nPrototype\n\nvoid *sc_mstamp_alloc (sc_mstamp_t * mst);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mstamp_init-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_mstamp_init","text":"sc_mstamp_init(mst, stamp_unit, elem_size)\n\nInitialize a memory stamp container. We provide allocation of fixed-size memory items without allocating new memory in every request. Instead we block the allocations in what we call a stamp of multiple items. Even if no allocations are done, the container's internal memory must be freed eventually by scmstampreset.\n\nParameters\n\nmst:[in,out] Legal pointer to a stamp structure.\nstamp_unit:[in] Size of each memory block that we allocate. If it is larger than the element size, we may place more than one element in it. Passing 0 is legal and forces stamps that hold one item each.\nelem_size:[in] Size of each item. Passing 0 is legal. In that case, scmstampalloc returns NULL.\n\nPrototype\n\nvoid sc_mstamp_init (sc_mstamp_t * mst, size_t stamp_unit, size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mstamp_memory_used-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mstamp_memory_used","text":"sc_mstamp_memory_used(mst)\n\nReturn memory size in bytes of all data allocated in the container.\n\nParameters\n\nProperly:[in] initialized stamp container.\n\nReturns\n\nTotal container memory size in bytes.\n\nPrototype\n\nsize_t sc_mstamp_memory_used (sc_mstamp_t * mst);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mstamp_reset-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mstamp_reset","text":"sc_mstamp_reset(mst)\n\nFree all memory in a stamp structure and all items previously returned.\n\nParameters\n\nProperly:[in,out] initialized stamp container. On output, the structure is undefined.\n\nPrototype\n\nvoid sc_mstamp_reset (sc_mstamp_t * mst);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_mstamp_truncate-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_mstamp_truncate","text":"sc_mstamp_truncate(mst)\n\nFree all memory in a stamp structure and initialize it anew. Equivalent to calling scmstampreset followed by scmstampinit with the same stamp_unit and elem_size.\n\nParameters\n\nProperly:[in,out] initialized stamp container. On output, its elements have been freed and it is ready for further use.\n\nPrototype\n\nvoid sc_mstamp_truncate (sc_mstamp_t * mst);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_is_registered-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_package_is_registered","text":"sc_package_is_registered(package_id)\n\nQuery whether an identifier matches a registered package.\n\nParameters\n\npackage_id:[in] Only a non-negative id can be registered.\n\nReturns\n\nTrue if and only if the package id is non-negative and package is registered.\n\nPrototype\n\nint sc_package_is_registered (int package_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_lock-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_package_lock","text":"sc_package_lock(package_id)\n\nAcquire a pthread mutex lock. If configured without –enable-pthread, this function does nothing. This function must be followed with a matching scpackageunlock.\n\nParameters\n\npackage_id:[in] Either -1 for an undefined package or an id returned from scpackageregister. Depending on the value, the appropriate mutex is chosen. Thus, we may overlap locking calls with distinct package_id.\n\nPrototype\n\nvoid sc_package_lock (int package_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_print_summary-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_package_print_summary","text":"sc_package_print_summary(log_priority)\n\nPrint a summary of all packages registered with SC. Uses the SC_LC_GLOBAL log category which by default only prints on rank 0.\n\nParameters\n\nlog_priority:[in] Priority passed to sc log functions.\n\nPrototype\n\nvoid sc_package_print_summary (int log_priority);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_register-NTuple{4, Any}","page":"API reference","title":"P4est.LibP4est.sc_package_register","text":"sc_package_register(log_handler, log_threshold, name, full)\n\nRegister a software package with SC. This function must only be called before additional threads are created. The logging parameters are as in sc_set_log_defaults.\n\nReturns\n\nReturns a unique package id.\n\nPrototype\n\nint sc_package_register (sc_log_handler_t log_handler, int log_threshold, const char *name, const char *full);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_set_abort_alloc_mismatch-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_package_set_abort_alloc_mismatch","text":"sc_package_set_abort_alloc_mismatch(package_id, set_abort)\n\nSet the unregister behavior of sc_package_unregister().\n\nParameters\n\npackage_id:[in] Must be -1 for the default package or the identifier of a registered package.\nset_abort:[in] True if sc_package_unregister() should abort if the number of allocs does not match the number of frees; false otherwise.\n\nPrototype\n\nvoid sc_package_set_abort_alloc_mismatch (int package_id, int set_abort);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_set_verbosity-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_package_set_verbosity","text":"sc_package_set_verbosity(package_id, log_priority)\n\nSet the logging verbosity of a registered package. This can be called at any point in the program, any number of times. It can only lower the verbosity at and below the value of SC_LP_THRESHOLD.\n\nParameters\n\npackage_id:[in] Must be a registered package identifier.\n\nPrototype\n\nvoid sc_package_set_verbosity (int package_id, int log_priority);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_unlock-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_package_unlock","text":"sc_package_unlock(package_id)\n\nRelease a pthread mutex lock. If configured without –enable-pthread, this function does nothing. This function must be follow a matching scpackagelock.\n\nParameters\n\npackage_id:[in] Either -1 for an undefined package or an id returned from scpackageregister. Depending on the value, the appropriate mutex is chosen. Thus, we may overlap locking calls with distinct package_id.\n\nPrototype\n\nvoid sc_package_unlock (int package_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_package_unregister-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_package_unregister","text":"sc_package_unregister(package_id)\n\nUnregister a software package with SC. This function must only be called after additional threads are finished.\n\nPrototype\n\nvoid sc_package_unregister (int package_id);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_realloc-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_realloc","text":"sc_realloc(package, ptr, size)\n\nPrototype\n\nvoid *sc_realloc (int package, void *ptr, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_init-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_recycle_array_init","text":"sc_recycle_array_init(rec_array, elem_size)\n\nInitialize a recycle array.\n\nParameters\n\nelem_size:[in] Size of the objects to be stored in the array.\n\nPrototype\n\nvoid sc_recycle_array_init (sc_recycle_array_t * rec_array, size_t elem_size);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_insert-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_recycle_array_insert","text":"sc_recycle_array_insert(rec_array, position)\n\nInsert an object into the recycle array. The object is not copied into the array. Use the return value for that.\n\nParameters\n\nposition:[out] If position != NULL, *position is set to the array position of the inserted object.\n\nReturns\n\nReturns the new address of the object in the array.\n\nPrototype\n\nvoid *sc_recycle_array_insert (sc_recycle_array_t * rec_array, size_t *position);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_remove-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_recycle_array_remove","text":"sc_recycle_array_remove(rec_array, position)\n\nRemove an object from the recycle array. It must be valid.\n\nParameters\n\nposition:[in] Index into the array for the object to remove.\n\nReturns\n\nThe pointer to the removed object. Will be valid as long as no other function is called on this recycle array.\n\nPrototype\n\nvoid *sc_recycle_array_remove (sc_recycle_array_t * rec_array, size_t position);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_reset-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_recycle_array_reset","text":"sc_recycle_array_reset(rec_array)\n\nReset a recycle array.\n\nAs with all _reset functions, calling _init, then any array operations, then _reset is memory neutral.\n\nPrototype\n\nvoid sc_recycle_array_reset (sc_recycle_array_t * rec_array);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_set_abort_handler-Tuple{Any}","page":"API reference","title":"P4est.LibP4est.sc_set_abort_handler","text":"sc_set_abort_handler(abort_handler)\n\nControls the default SC abort behavior.\n\nParameters\n\nabort_handler:[in] Set default SC above handler (NULL selects builtin). ***This function should not return!***\n\nPrototype\n\nvoid sc_set_abort_handler (sc_abort_handler_t abort_handler);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_set_log_defaults-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_set_log_defaults","text":"sc_set_log_defaults(log_stream, log_handler, log_thresold)\n\nControls the default SC log behavior.\n\nParameters\n\nlog_stream:[in] Set stream to use by sc_logf (or NULL for stdout).\nlog_handler:[in] Set default SC log handler (NULL selects builtin).\nlog_threshold:[in] Set default SC log threshold (or SC_LP_DEFAULT). May be SC_LP_ALWAYS or SC_LP_SILENT.\n\nPrototype\n\nvoid sc_set_log_defaults (FILE * log_stream, sc_log_handler_t log_handler, int log_thresold);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_strcopy-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_strcopy","text":"sc_strcopy(dest, size, src)\n\nProvide a string copy function.\n\nParameters\n\ndest:[out] Buffer of length at least size. On output, not touched if NULL or size == 0.\nsize:[in] Allocation length of dest.\nsrc:[in] Null-terminated string.\n\nReturns\n\nEquivalent to sc_snprintf (dest, size, \"s\", src).\n\nPrototype\n\nvoid sc_strcopy (char *dest, size_t size, const char *src);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_strdup-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_strdup","text":"sc_strdup(package, s)\n\nPrototype\n\nchar *sc_strdup (int package, const char *s);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_add-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_add","text":"sc_uint128_add(a, b, result)\n\nAdds the uint128_t b to the uint128_t a. result == a or result == b is not allowed. a == b is allowed.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nb:[in] A pointer to a sc_uint128_t.\nresult:[out] A pointer to a sc_uint128_t. The sum a + b will be saved in result.\n\nPrototype\n\nvoid sc_uint128_add (const sc_uint128_t * a, const sc_uint128_t * b, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_add_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_add_inplace","text":"sc_uint128_add_inplace(a, b)\n\nAdds the uint128 b to the uint128_t a. The result is saved in a. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a sc_uint128_t. a will be overwritten by a + b.\nb:[in] A pointer to a sc_uint128_t.\n\nPrototype\n\nvoid sc_uint128_add_inplace (sc_uint128_t * a, const sc_uint128_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_and-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_bitwise_and","text":"sc_uint128_bitwise_and(a, b, result)\n\nCalculates the bitwise and of the uint128_t a and the uint128_t b. a == result is allowed. Furthermore, a == result and/or b == result is allowed.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nb:[in] A pointer to a sc_uint128_t.\nresult:[out] A pointer to a sc_uint128_t. The bitwise and of a and b will be saved. in result.\n\nPrototype\n\nvoid sc_uint128_bitwise_and (const sc_uint128_t * a, const sc_uint128_t * b, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_and_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_bitwise_and_inplace","text":"sc_uint128_bitwise_and_inplace(a, b)\n\nCalculates the bitwise and of the uint128_t a and the uint128_t b. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a sc_uint128_t. The bitwise and will be saved in a.\nb:[in] A pointer to a sc_uint128_t.\n\nPrototype\n\nvoid sc_uint128_bitwise_and_inplace (sc_uint128_t * a, const sc_uint128_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_neg-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_bitwise_neg","text":"sc_uint128_bitwise_neg(a, result)\n\nCalculates the bitwise negation of the uint128_t a. a == result is allowed.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nresult:[out] A pointer to a sc_uint128_t. The bitwise negation of a will be saved in result.\n\nPrototype\n\nvoid sc_uint128_bitwise_neg (const sc_uint128_t * a, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_or-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_bitwise_or","text":"sc_uint128_bitwise_or(a, b, result)\n\nCalculates the bitwise or of the uint128_t a and b. a == result is allowed. Furthermore, a == result and/or b == result is allowed.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nb:[in] A pointer to a sc_uint128_t.\nresult:[out] A pointer to a sc_uint128_t. The bitwise or of a and b will be saved in result.\n\nPrototype\n\nvoid sc_uint128_bitwise_or (const sc_uint128_t * a, const sc_uint128_t * b, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_or_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_bitwise_or_inplace","text":"sc_uint128_bitwise_or_inplace(a, b)\n\nCalculates the bitwise or of the uint128_t a and the uint128_t b. a == b is allowed.\n\nParameters\n\na:[in,out] A pointer to a sc_uint128_t. The bitwise or will be saved in a.\nb:[in] A pointer to a sc_uint128_t.\n\nPrototype\n\nvoid sc_uint128_bitwise_or_inplace (sc_uint128_t * a, const sc_uint128_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_chk_bit-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_chk_bit","text":"sc_uint128_chk_bit(input, exponent)\n\nReturns the bit_number-th bit of input. This function checks a bit of an existing, initialized value.\n\nParameters\n\ninput:[in] A pointer to a sc_uint128_t.\nbit_number:[in] The bit (counted from the right hand side) that is checked by logical and. Require 0 <= bit_number < 128.\n\nReturns\n\nTrue if the checked bit is set, false if not.\n\nPrototype\n\nint sc_uint128_chk_bit (const sc_uint128_t * input, int exponent);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_compare-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_compare","text":"sc_uint128_compare(a, b)\n\nCompare the sc_uint128_t a and the sc_uint128_t b.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nb:[in] A pointer to a sc_uint128_t.\n\nReturns\n\nReturns -1 if a < b, 1 if a > b and 0 if a == b.\n\nPrototype\n\nint sc_uint128_compare (const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_copy-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_copy","text":"sc_uint128_copy(input, output)\n\nCopies an initialized sc_uint128_t to a sc_uint128_t.\n\nParameters\n\ninput:[in] A pointer to the sc_uint128 that is copied.\noutput:[in,out] A pointer to a sc_uint128_t. The high and low bits of output will be set to the high and low bits of input, respectively.\n\nPrototype\n\nvoid sc_uint128_copy (const sc_uint128_t * input, sc_uint128_t * output);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_init-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_init","text":"sc_uint128_init(a, high, low)\n\nInitializes an unsigned 128 bit integer to a given value.\n\nParameters\n\na:[in,out] A pointer to the sc_uint128_t that will be initialized.\nhigh:[in] The given high bits to initialize a.\nlow:[in] The given low bits to initialize a.\n\nPrototype\n\nvoid sc_uint128_init (sc_uint128_t * a, uint64_t high, uint64_t low);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_is_equal-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_is_equal","text":"sc_uint128_is_equal(a, b)\n\nChecks if the sc_uint128_t a and the sc_uint128_t b are equal.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nb:[in] A pointer to a sc_uint128_t.\n\nReturns\n\nReturns a true value if a and b are equal, false otherwise.\n\nPrototype\n\nint sc_uint128_is_equal (const sc_uint128_t * a, const sc_uint128_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_set_bit-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_set_bit","text":"sc_uint128_set_bit(a, exponent)\n\nSets the exponent-th bit of a to one and keep all other bits. This function modifies an existing, initialized value.\n\nParameters\n\na:[in,out] A pointer to a sc_uint128_t.\nexponent:[in] The bit (0-based from the rightmost bit) that is set to one by logical or. 0 <= exponent < 128.\n\nPrototype\n\nvoid sc_uint128_set_bit (sc_uint128_t * a, int exponent);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_shift_left-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_shift_left","text":"sc_uint128_shift_left(input, shift_count, result)\n\nCalculates the bit left shift of uint128_t input by shift_count bits. We shift in zeros from the right. If shift_count >= 128, result is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. input == result is allowed.\n\nParameters\n\ninput:[in] A pointer to a sc_uint128_t.\nshift_count:[in] Bits to shift. shift_count >= 0.\nresult:[in,out] A pointer to a sc_uint128_t. The left shifted number will be saved in result.\n\nPrototype\n\nvoid sc_uint128_shift_left (const sc_uint128_t * input, int shift_count, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_shift_right-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_shift_right","text":"sc_uint128_shift_right(input, shift_count, result)\n\nCalculates the bit right shift of uint128_t input by shift_count bits. We shift in zeros from the left. If shift_count >= 128, result is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. input == result is allowed.\n\nParameters\n\ninput:[in] A pointer to a sc_uint128_t.\nshift_count:[in] Bits to shift. shift_count >= 0.\nresult:[in,out] A pointer to a sc_uint128_t. The right shifted number will be saved in result.\n\nPrototype\n\nvoid sc_uint128_shift_right (const sc_uint128_t * input, int shift_count, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_sub-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_sub","text":"sc_uint128_sub(a, b, result)\n\nSubtracts the uint128_t b from the uint128_t a. This function assumes that the result is >= 0. result == a or result == b is not allowed. a == b is allowed.\n\nParameters\n\na:[in] A pointer to a sc_uint128_t.\nb:[in] A pointer to a sc_uint128_t.\nresult:[out] A pointer to a sc_uint128_t. The difference a - b will be saved in result.\n\nPrototype\n\nvoid sc_uint128_sub (const sc_uint128_t * a, const sc_uint128_t * b, sc_uint128_t * result);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_uint128_sub_inplace-Tuple{Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_uint128_sub_inplace","text":"sc_uint128_sub_inplace(a, b)\n\nSubtracts the uint128_t b from the uint128_t a. The result is saved in a. a == b is allowed. This function assumes that the result is >= 0.\n\nParameters\n\na:[in,out] A pointer to a sc_uint128_t. a will be overwritten by a - b.\nb:[in] A pointer to a sc_uint128_t.\n\nPrototype\n\nvoid sc_uint128_sub_inplace (sc_uint128_t * a, const sc_uint128_t * b);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_version-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_version","text":"sc_version()\n\nReturn the full version of libsc.\n\nReturns\n\nReturn the version of libsc using the format VERSION\\_MAJOR.VERSION\\_MINOR.VERSION\\_POINT, where VERSION_POINT can contain dots and characters, e.g. to indicate the additional number of commits and a git commit hash.\n\nPrototype\n\nconst char *sc_version (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_version_major-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_version_major","text":"sc_version_major()\n\nReturn the major version of libsc.\n\nReturns\n\nReturn the major version of libsc.\n\nPrototype\n\nint sc_version_major (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_version_minor-Tuple{}","page":"API reference","title":"P4est.LibP4est.sc_version_minor","text":"sc_version_minor()\n\nReturn the minor version of libsc.\n\nReturns\n\nReturn the minor version of libsc.\n\nPrototype\n\nint sc_version_minor (void);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_vtk_write_binary-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_vtk_write_binary","text":"sc_vtk_write_binary(vtkfile, numeric_data, byte_length)\n\nThis function writes numeric binary data in VTK base64 encoding.\n\nParameters\n\nvtkfile: Stream opened for writing.\nnumeric_data: A pointer to a numeric data array.\nbyte_length: The length of the data array in bytes.\n\nReturns\n\nReturns 0 on success, -1 on file error.\n\nPrototype\n\nint sc_vtk_write_binary (FILE * vtkfile, char *numeric_data, size_t byte_length);\n\n\n\n\n\n","category":"method"},{"location":"reference/#P4est.LibP4est.sc_vtk_write_compressed-Tuple{Any, Any, Any}","page":"API reference","title":"P4est.LibP4est.sc_vtk_write_compressed","text":"sc_vtk_write_compressed(vtkfile, numeric_data, byte_length)\n\nThis function writes numeric binary data in VTK compressed format.\n\nParameters\n\nvtkfile: Stream opened for writing.\nnumeric_data: A pointer to a numeric data array.\nbyte_length: The length of the data array in bytes.\n\nReturns\n\nReturns 0 on success, -1 on file error.\n\nPrototype\n\nint sc_vtk_write_compressed (FILE * vtkfile, char *numeric_data, size_t byte_length);\n\n\n\n\n\n","category":"method"},{"location":"troubleshooting/#Troubleshooting-and-FAQ","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"","category":"section"},{"location":"troubleshooting/#undef-var-error","page":"Troubleshooting and FAQ","title":"using P4est gives UndefVarError: libp4est not defined","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"If you get the error message UndefVarError: libp4est not defined when using P4est the error is likely to be caused by the fact that P4est.jl uses a system provided MPI library, but no system provided p4est version. Therefore, check in your active project that the LocalPreferences.toml has a section [MPIPreferencs] as well as a section [P4est] with valid entry for libp4est. If you don't have any LocalPreferences.toml in your active project also check your default environment under ~/.julia/environments/vx.y/, where vx.y is the julia version you're using.","category":"page"},{"location":"troubleshooting/#catch-signals","page":"Troubleshooting and FAQ","title":"Julia crashes with multiple threads","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"If you call sc_init and run Julia with multiple threads and the garbage collector may be active, please make sure that you deactivate catching signals in sc_init. Internally, the Julia garbage collector uses SIGSEGV for threads synchronization, as described in the Julia dev docs. Thus, libsc must not catch this signal and abort execution.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"For example, to disable catching signals, backtraces, and non-error log messages, you can use the following code at the beginning of your P4est.jl session:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"using MPI, P4est\n\nMPI.Init()\n\nlet catch_signals = 0, print_backtrace = 0, log_handler = C_NULL\n    sc_init(MPI.COMM_WORLD, catch_signals, print_backtrace, log_handler, SC_LP_ERROR)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/trixi-framework/P4est.jl/blob/main/README.md\"","category":"page"},{"location":"#P4est.jl","page":"Home","title":"P4est.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs-stable) (Image: Slack) (Image: Build Status) (Image: Codecov) (Image: Coveralls) (Image: Aqua QA) (Image: License: MIT) (Image: Downloads)","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is a Julia package that wraps p4est, a C library to manage multiple connected adaptive quadtrees or octrees in parallel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl mainly provides low-level wrappers of functionality from p4est. The Julia package P4estTypes.jl builds on top of P4est.jl and provides a high-level interface.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, please follow the instructions for your operating system. P4est.jl works with Julia v1.6 and later.","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is a registered Julia package. Hence, you can install it by executing the following commands in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add([\"P4est\", \"MPI\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this command, you install both P4est.jl and MPI.jl. Currently, P4est.jl supports only builds of the C library p4est with MPI support, so you need to initialize MPI appropriately as described in the Usage section below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl depends on the binary distribution of the p4est library, which is available in the Julia package P4est_jll.jl and which is automatically installed as a dependency. The binaries provided by P4est_jll.jl support MPI and are compiled against the default MPI binaries of MPI.jl. At the time of writing, these are the binaries provided by MicrosoftMPI_jll.jl on Windows and MPICH_jll.jl on all other platforms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, P4est.jl provides pre-generated Julia bindings to all exported C functions of the underlying p4est library. If you want/need to generate new bindings, please follow the instructions in the dev folder and copy the generated files to the appropriate places in src.","category":"page"},{"location":"#Using-a-custom-version-of-MPI-and/or-p4est","page":"Home","title":"Using a custom version of MPI and/or p4est","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The C library p4est needs to be compiled against the same MPI implementation used by MPI.jl. Thus, if you want to configure MPI.jl to not use the default MPI binary provided by JLL wrappers, you also need to build the C library p4est locally using the same MPI implementation. This is typically the situation on HPC clusters. If you are just using a single workstation, the default installation instructions should be sufficient.","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl allows using a p4est binary different from the default one provided by P4est_jll.jl. To enable this, you first need to obtain a local binary installation of p4est. Next, you need to configure MPI.jl to use the same MPI implementation used to build your local installation of p4est, see the documentation of MPI.jl. At the time of writing, this can be done by first setting up the Preferences.jl setting containing the path to your local build of the shared library of p4est.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Preferences, UUIDs\n\njulia> set_preferences!(\n           UUID(\"7d669430-f675-4ae7-b43e-fab78ec5a902\"), # UUID of P4est.jl\n           \"libp4est\" => \"/path/to/your/libp4est.so\", force = true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can use the convenience function set_library_p4est! to set the path:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using P4est\n\njulia> P4est.set_library_p4est!(\"/path/to/your/libp4est.so\")\n[ Info: Please restart Julia and reload P4est.jl for the library changes to take effect","category":"page"},{"location":"","page":"Home","title":"Home","text":"On Windows you also need to set the path to the local build of the shared library of libsc, which is a subpackage of p4est. On other systems, this is not necessary as the library is already linked by libp4est.so, but it can be used to employ also a custom build of libsc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> set_preferences!(\n           UUID(\"7d669430-f675-4ae7-b43e-fab78ec5a902\"), # UUID of P4est.jl\n           \"libsc\" => \"/path/to/your/libsc.so\", force = true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Again, for convenience you can also use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> P4est.set_library_sc!(\"/path/to/your/libsc.so\")\n[ Info: Please restart Julia and reload P4est.jl for the library changes to take effect","category":"page"},{"location":"","page":"Home","title":"Home","text":"To delete the preferences again, you can call P4est.set_library_p4est!() and P4est.set_library_sc!(), respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that you should restart your Julia session after changing the preferences.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, you need to set up the preferences for MPI, which can be done by","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MPIPreferences\n\njulia> MPIPreferences.use_system_binary()","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you use the default system MPI binary installation to build p4est.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To sum up, follow these steps to use P4est.jl with a custom installation of the underlying C libraries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create a Julia project for your setup.\njulia> import Pkg; Pkg.activate(\".\")\nThis uses the Julia project in your current working directory or creates a new one if there is none.\nInstall the required packages.\njulia> Pkg.add([\"MPIPreferences\", \"MPI\", \"P4est\"])\nSet P4est.jl preferences.\njulia> using P4est\n\njulia> P4est.set_library_p4est!(\"/path/to/your/libp4est.so\")\n[ Info: Please restart Julia and reload P4est.jl for the library changes to take effect\n\njulia> P4est.set_library_sc!(\"/path/to/your/libsc.so\")\n[ Info: Please restart Julia and reload P4est.jl for the library changes to take effect\nSet MPI.jl preferences.\njulia> using MPIPreferences\n\njulia> MPIPreferences.use_system_binary()\nRestart the Julia REPL and load the packages.\njulia> import Pkg; Pkg.activate(\".\")\n\njulia> using P4est, MPI; MPI.Init()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, custom builds of p4est without MPI support are not supported.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The P4est.uses_mpi() function can be used to check if the p4est binaries that P4est.jl uses were compiled with MPI enabled. This returns true for the default binaries provided by the P4est_jll.jl package. In this case P4est.jl can be used as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the packages P4est.jl and MPI.jl in any order and initialize MPI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using P4est, MPI; MPI.Init()","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then access the full p4est API that is defined by the headers. For example, to create a periodic connectivity and check its validity, execute the following lines:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using P4est, MPI; MPI.Init()\n\njulia> connectivity = p4est_connectivity_new_periodic()\nPtr{p4est_connectivity} @0x0000000002412d20\n\njulia> p4est_connectivity_is_valid(connectivity)\n1\n\njulia> p4est = p4est_new_ext(MPI.COMM_WORLD, connectivity, 0, 2, 0, 0, C_NULL, C_NULL)\nInto p4est_new with min quadrants 0 level 2 uniform 0\nNew p4est with 1 trees on 1 processors\nInitial level 2 potential global quadrants 16 per tree 16\nDone p4est_new with 10 total quadrants\nPtr{p4est} @0x0000000002dd1fd0\n\njulia> p4est_obj = unsafe_load(p4est)\nP4est.LibP4est.p4est(1140850688, 1, 0, 0, 0x0000000000000000, Ptr{Nothing} @0x0000000000000000, 0, 0, 0, 10, 10, Ptr{Int64} @0x00000000021a5f70, Ptr{p4est_quadrant} @0x0000000002274330, Ptr{p4est_connectivity} @0x000000000255cdf0, Ptr{sc_array} @0x00000000023b64a0, Ptr{sc_mempool} @0x0000000000000000, Ptr{sc_mempool} @0x00000000023b1620, Ptr{p4est_inspect} @0x0000000000000000)\n\njulia> p4est_obj.connectivity == connectivity\ntrue\n\njulia> connectivity_obj = unsafe_load(p4est_obj.connectivity)\np4est_connectivity(4, 1, 1, Ptr{Float64} @0x00000000021e8170, Ptr{Int32} @0x00000000020d2450, 0x0000000000000000, Cstring(0x0000000000000000), Ptr{Int32} @0x0000000002468e10, Ptr{Int8} @0x00000000022035e0, Ptr{Int32} @0x0000000002667230, Ptr{Int32} @0x000000000219eea0, Ptr{Int32} @0x000000000279ae00, Ptr{Int8} @0x00000000021ff910)\n\njulia> connectivity_obj.num_trees\n1\n\njulia> p4est_destroy(p4est)\n\njulia> p4est_connectivity_destroy(connectivity)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As shown here, unsafe_load allows to convert pointers to p4est C structs to the corresponding Julia wrapper type generated by Clang.jl. They follow the basic C interface of Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you start Julia on multiple MPI ranks, you can check whether everything is set up correctly by the following extended smoke test. Copy the following code to a local file:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using P4est, MPI; MPI.Init()\nconnectivity = p4est_connectivity_new_periodic()\np4est = p4est_new_ext(MPI.COMM_WORLD, connectivity, 0, 2, 0, 0, C_NULL, C_NULL)\np4est_obj = unsafe_load(p4est)\nMPI.Barrier(MPI.COMM_WORLD)\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\n@info \"Setup\" rank p4est_obj.local_num_quadrants p4est_obj.global_num_quadrants\np4est_destroy(p4est)\np4est_connectivity_destroy(connectivity)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run Julia with the MPI implementation used by MPI.jl and execute the script shown above. You should get an output like","category":"page"},{"location":"","page":"Home","title":"Home","text":"Into p4est_new with min quadrants 0 level 2 uniform 0\nNew p4est with 1 trees on 2 processors\nInitial level 2 potential global quadrants 16 per tree 16\nInto p4est_new with min quadrants 0 level 2 uniform 0\nNew p4est with 1 trees on 2 processors\nInitial level 2 potential global quadrants 16 per tree 16\nDone p4est_new with 13 total quadrants\nDone p4est_new with 13 total quadrants\n┌ Info: Setup\n│   rank = 0\n│   p4est_obj.local_num_quadrants = 5\n└   p4est_obj.global_num_quadrants = 13\n┌ Info: Setup\n│   rank = 1\n│   p4est_obj.local_num_quadrants = 8\n└   p4est_obj.global_num_quadrants = 13","category":"page"},{"location":"","page":"Home","title":"Home","text":"To suppress the relatively verbose output of p4est in the example above, you can call P4est.init(C_NULL, SC_LP_ERROR) before calling other functions from p4est.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Many functions and types in p4est have been documented with comments by the p4est authors; you can access this documentation as you would for any Julia-native entity through ?:","category":"page"},{"location":"","page":"Home","title":"Home","text":"help?> p4est_memory_used\nsearch: p4est_memory_used p4est_mesh_memory_used p4est_ghost_memory_used p4est_connectivity_memory_used\n\n  p4est_memory_used(p4est_)\n\n  Calculate local memory usage of a forest structure. Not collective. The memory used on the current rank is\n  returned. The connectivity structure is not counted since it is not owned; use\n  p4est_connectivity_memory_usage (p4est->connectivity).\n\n  Parameters\n  ––––––––––––\n\n    •  p4est:[in] Valid forest structure.\n\n  Returns\n  –––––––––\n\n  Memory used in bytes.\n\n  Prototype\n  –––––––––––\n\n  size_t p4est_memory_used (p4est_t * p4est);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same is of course true for the higher-level interface functions provided by P4est.jl, e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"help?> P4est.init\n  P4est.init(log_handler, log_threshold)\n\n  Calls p4est_init if it has not already been called, otherwise do nothing. Thus, P4est.init can safely be\n  called multiple times.\n\n  To use the default log handler and suppress most output created by default by p4est, call this function as\n\n  P4est.init(C_NULL, SC_LP_ERROR)\n\n  before calling other functions from p4est.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on how to use p4est, please refer to the documentation for p4est itself or to the header files (*.h) in the p4est repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on how to use the Julia wrapper P4est.jl, please consult the documentation.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is mainly maintained by Joshua Lampert (University of Hamburg, Germany), Michael Schlottke-Lakemper (RWTH Aachen University/High-Performance Computing Center Stuttgart (HLRS), Germany), and Hendrik Ranocha (Johannes Gutenberg University Mainz, Germany). The full list of contributors can be found in Authors. The p4est library itself is written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is licensed under the MIT license (see License). p4est itself is licensed under the GNU General Public License, version 2.","category":"page"}]
}
