# This file is automatically generated.  Do not edit.
using CBinding: 𝐣𝐥
using P4est_jll: libp4est_path

𝐣𝐥.@cbindings libp4est_path begin
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:58](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:58:3)
	""" SC_TAG_AG_RECURSIVE_B
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:56:3)
	""" SC_TAG_AG_ALLTOALL
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:73](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:73:3)
	""" SC_TAG_PSORT_LO
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:60](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:60:3)
	""" SC_TAG_NOTIFY_CENSUS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:64](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:64:3)
	""" SC_TAG_NOTIFY_WRAPPER
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:71](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:71:3)
	""" SC_TAG_NOTIFY_NARY
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:68](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:68:3)
	""" SC_TAG_NOTIFY_SUPER_TRUE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:59](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:59:3)
	""" SC_TAG_AG_RECURSIVE_C
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:55](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:55:3)
	""" SC_TAG_FIRST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:69](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:69:3)
	""" SC_TAG_NOTIFY_SUPER_EXTRA
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:74](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:74:3)
	""" SC_TAG_PSORT_HI
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:70](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:70:3)
	""" SC_TAG_NOTIFY_RECURSIVE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:63](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:63:3)
	""" SC_TAG_NOTIFY_NBXV
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:57](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:57:3)
	""" SC_TAG_AG_RECURSIVE_A
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:75](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:75:3)
	""" SC_TAG_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:66](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:66:3)
	""" SC_TAG_NOTIFY_RANGES
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:61](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:61:3)
	""" SC_TAG_NOTIFY_CENSUSV
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:77](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:77:1)
	""" sc_tag_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:67](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:67:3)
	""" SC_TAG_NOTIFY_PAYLOAD
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:72](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:72:3)
	""" SC_TAG_REDUCE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:62](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:62:3)
	""" SC_TAG_NOTIFY_NBX
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:65](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:65:3)
	""" SC_TAG_NOTIFY_WRAPPERV
	export SC_TAG_AG_ALLTOALL, SC_TAG_AG_RECURSIVE_A, SC_TAG_AG_RECURSIVE_B, SC_TAG_AG_RECURSIVE_C, SC_TAG_FIRST, SC_TAG_LAST, SC_TAG_NOTIFY_CENSUS, SC_TAG_NOTIFY_CENSUSV, SC_TAG_NOTIFY_NARY, SC_TAG_NOTIFY_NBX, SC_TAG_NOTIFY_NBXV, SC_TAG_NOTIFY_PAYLOAD, SC_TAG_NOTIFY_RANGES, SC_TAG_NOTIFY_RECURSIVE, SC_TAG_NOTIFY_SUPER_EXTRA, SC_TAG_NOTIFY_SUPER_TRUE, SC_TAG_NOTIFY_WRAPPER, SC_TAG_NOTIFY_WRAPPERV, SC_TAG_PSORT_HI, SC_TAG_PSORT_LO, SC_TAG_REDUCE, sc_tag_t
	𝐣𝐥.@ctypedef sc_tag_t 𝐣𝐥.@cenum {
		SC_TAG_FIRST = 𝐣𝐥.Cuint(214)
		SC_TAG_AG_ALLTOALL = 𝐣𝐥.Cuint(214)
		SC_TAG_AG_RECURSIVE_A = 𝐣𝐥.Cuint(215)
		SC_TAG_AG_RECURSIVE_B = 𝐣𝐥.Cuint(216)
		SC_TAG_AG_RECURSIVE_C = 𝐣𝐥.Cuint(217)
		SC_TAG_NOTIFY_CENSUS = 𝐣𝐥.Cuint(218)
		SC_TAG_NOTIFY_CENSUSV = 𝐣𝐥.Cuint(219)
		SC_TAG_NOTIFY_NBX = 𝐣𝐥.Cuint(220)
		SC_TAG_NOTIFY_NBXV = 𝐣𝐥.Cuint(221)
		SC_TAG_NOTIFY_WRAPPER = 𝐣𝐥.Cuint(222)
		SC_TAG_NOTIFY_WRAPPERV = 𝐣𝐥.Cuint(223)
		SC_TAG_NOTIFY_RANGES = 𝐣𝐥.Cuint(224)
		SC_TAG_NOTIFY_PAYLOAD = 𝐣𝐥.Cuint(225)
		SC_TAG_NOTIFY_SUPER_TRUE = 𝐣𝐥.Cuint(226)
		SC_TAG_NOTIFY_SUPER_EXTRA = 𝐣𝐥.Cuint(227)
		SC_TAG_NOTIFY_RECURSIVE = 𝐣𝐥.Cuint(228)
		SC_TAG_NOTIFY_NARY = 𝐣𝐥.Cuint(260)
		SC_TAG_REDUCE = 𝐣𝐥.Cuint(292)
		SC_TAG_PSORT_LO = 𝐣𝐥.Cuint(293)
		SC_TAG_PSORT_HI = 𝐣𝐥.Cuint(294)
		SC_TAG_LAST = 𝐣𝐥.Cuint(295)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:262](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:262:21)
	""" sc_MPI_Comm
	export sc_MPI_Comm
	𝐣𝐥.@ctypedef sc_MPI_Comm 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:263](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:263:21)
	""" sc_MPI_Group
	export sc_MPI_Group
	𝐣𝐥.@ctypedef sc_MPI_Group 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:264](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:264:21)
	""" sc_MPI_Datatype
	export sc_MPI_Datatype
	𝐣𝐥.@ctypedef sc_MPI_Datatype 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:265](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:265:21)
	""" sc_MPI_Op
	export sc_MPI_Op
	𝐣𝐥.@ctypedef sc_MPI_Op 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:266](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:266:21)
	""" sc_MPI_Request
	export sc_MPI_Request
	𝐣𝐥.@ctypedef sc_MPI_Request 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## References
	
	[sc_mpi.h:267](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:267:16)
	
	[sc_mpi.h:275](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:275:1)
	""" sc_MPI_Status
	export sc_MPI_Status
	𝐣𝐥.@ctypedef sc_MPI_Status 𝐣𝐥.@cstruct sc_MPI_Status {
		count::𝐣𝐥.Cint
		cancelled::𝐣𝐥.Cint
		MPI_SOURCE::𝐣𝐥.Cint
		MPI_TAG::𝐣𝐥.Cint
		MPI_ERROR::𝐣𝐥.Cint
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Init(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:279](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:279:21)
	""" sc_MPI_Init
	export sc_MPI_Init
	𝐣𝐥.@cextern sc_MPI_Init(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Finalize()::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:282](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:282:21)
	""" sc_MPI_Finalize
	export sc_MPI_Finalize
	𝐣𝐥.@cextern sc_MPI_Finalize()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Abort(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:283](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:283:21)
	""" sc_MPI_Abort
	export sc_MPI_Abort
	𝐣𝐥.@cextern sc_MPI_Abort(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_dup(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:286](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:286:21)
	""" sc_MPI_Comm_dup
	export sc_MPI_Comm_dup
	𝐣𝐥.@cextern sc_MPI_Comm_dup(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_create(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:287](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:287:21)
	""" sc_MPI_Comm_create
	export sc_MPI_Comm_create
	𝐣𝐥.@cextern sc_MPI_Comm_create(var"?1?"::sc_MPI_Comm, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_split(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:289](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:289:21)
	""" sc_MPI_Comm_split
	export sc_MPI_Comm_split
	𝐣𝐥.@cextern sc_MPI_Comm_split(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Cint, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_free(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:290](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:290:21)
	""" sc_MPI_Comm_free
	export sc_MPI_Comm_free
	𝐣𝐥.@cextern sc_MPI_Comm_free(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_size(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:291](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:291:21)
	""" sc_MPI_Comm_size
	export sc_MPI_Comm_size
	𝐣𝐥.@cextern sc_MPI_Comm_size(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_rank(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:292](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:292:21)
	""" sc_MPI_Comm_rank
	export sc_MPI_Comm_rank
	𝐣𝐥.@cextern sc_MPI_Comm_rank(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_compare(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::sc_MPI_Comm, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:293](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:293:21)
	""" sc_MPI_Comm_compare
	export sc_MPI_Comm_compare
	𝐣𝐥.@cextern sc_MPI_Comm_compare(var"?1?"::sc_MPI_Comm, var"?2?"::sc_MPI_Comm, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_group(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:294](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:294:21)
	""" sc_MPI_Comm_group
	export sc_MPI_Comm_group
	𝐣𝐥.@cextern sc_MPI_Comm_group(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_free(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:296](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:296:21)
	""" sc_MPI_Group_free
	export sc_MPI_Group_free
	𝐣𝐥.@cextern sc_MPI_Group_free(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_size(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:297](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:297:21)
	""" sc_MPI_Group_size
	export sc_MPI_Group_size
	𝐣𝐥.@cextern sc_MPI_Group_size(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_rank(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:298](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:298:21)
	""" sc_MPI_Group_rank
	export sc_MPI_Group_rank
	𝐣𝐥.@cextern sc_MPI_Group_rank(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_translate_ranks(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::sc_MPI_Group, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:299:21)
	""" sc_MPI_Group_translate_ranks
	export sc_MPI_Group_translate_ranks
	𝐣𝐥.@cextern sc_MPI_Group_translate_ranks(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::sc_MPI_Group, var"?5?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_compare(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:301](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:301:21)
	""" sc_MPI_Group_compare
	export sc_MPI_Group_compare
	𝐣𝐥.@cextern sc_MPI_Group_compare(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_union(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:302](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:302:21)
	""" sc_MPI_Group_union
	export sc_MPI_Group_union
	𝐣𝐥.@cextern sc_MPI_Group_union(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_intersection(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:304](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:304:21)
	""" sc_MPI_Group_intersection
	export sc_MPI_Group_intersection
	𝐣𝐥.@cextern sc_MPI_Group_intersection(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_difference(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:306](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:306:21)
	""" sc_MPI_Group_difference
	export sc_MPI_Group_difference
	𝐣𝐥.@cextern sc_MPI_Group_difference(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_incl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:308](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:308:21)
	""" sc_MPI_Group_incl
	export sc_MPI_Group_incl
	𝐣𝐥.@cextern sc_MPI_Group_incl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_excl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:310](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:310:21)
	""" sc_MPI_Group_excl
	export sc_MPI_Group_excl
	𝐣𝐥.@cextern sc_MPI_Group_excl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_range_incl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:312](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:312:21)
	""" sc_MPI_Group_range_incl
	export sc_MPI_Group_range_incl
	𝐣𝐥.@cextern sc_MPI_Group_range_incl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_range_excl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:314](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:314:21)
	""" sc_MPI_Group_range_excl
	export sc_MPI_Group_range_excl
	𝐣𝐥.@cextern sc_MPI_Group_range_excl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Barrier(var\"?1?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:317](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:317:21)
	""" sc_MPI_Barrier
	export sc_MPI_Barrier
	𝐣𝐥.@cextern sc_MPI_Barrier(var"?1?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Bcast(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:318](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:318:21)
	""" sc_MPI_Bcast
	export sc_MPI_Bcast
	𝐣𝐥.@cextern sc_MPI_Bcast(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Gather(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::𝐣𝐥.Cint, var\"?8?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:320](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:320:21)
	""" sc_MPI_Gather
	export sc_MPI_Gather
	𝐣𝐥.@cextern sc_MPI_Gather(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Datatype, var"?7?"::𝐣𝐥.Cint, var"?8?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Gatherv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?6?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?7?\"::sc_MPI_Datatype, var\"?8?\"::𝐣𝐥.Cint, var\"?9?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:322](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:322:21)
	""" sc_MPI_Gatherv
	export sc_MPI_Gatherv
	𝐣𝐥.@cextern sc_MPI_Gatherv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?6?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?7?"::sc_MPI_Datatype, var"?8?"::𝐣𝐥.Cint, var"?9?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Allgather(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:325](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:325:21)
	""" sc_MPI_Allgather
	export sc_MPI_Allgather
	𝐣𝐥.@cextern sc_MPI_Allgather(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Datatype, var"?7?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Allgatherv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?6?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?7?\"::sc_MPI_Datatype, var\"?8?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:327](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:327:21)
	""" sc_MPI_Allgatherv
	export sc_MPI_Allgatherv
	𝐣𝐥.@cextern sc_MPI_Allgatherv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?6?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?7?"::sc_MPI_Datatype, var"?8?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Alltoall(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:330](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:330:21)
	""" sc_MPI_Alltoall
	export sc_MPI_Alltoall
	𝐣𝐥.@cextern sc_MPI_Alltoall(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Datatype, var"?7?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Reduce(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::𝐣𝐥.Cint, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:332](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:332:21)
	""" sc_MPI_Reduce
	export sc_MPI_Reduce
	𝐣𝐥.@cextern sc_MPI_Reduce(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::𝐣𝐥.Cint, var"?7?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Reduce_scatter_block(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:334](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:334:21)
	""" sc_MPI_Reduce_scatter_block
	export sc_MPI_Reduce_scatter_block
	𝐣𝐥.@cextern sc_MPI_Reduce_scatter_block(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Allreduce(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:337](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:337:21)
	""" sc_MPI_Allreduce
	export sc_MPI_Allreduce
	𝐣𝐥.@cextern sc_MPI_Allreduce(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Scan(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:339](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:339:21)
	""" sc_MPI_Scan
	export sc_MPI_Scan
	𝐣𝐥.@cextern sc_MPI_Scan(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Exscan(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:341](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:341:21)
	""" sc_MPI_Exscan
	export sc_MPI_Exscan
	𝐣𝐥.@cextern sc_MPI_Exscan(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Wtime()::𝐣𝐥.Cdouble
	```
	
	## Reference
	
	[sc_mpi.h:344](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:344:21)
	""" sc_MPI_Wtime
	export sc_MPI_Wtime
	𝐣𝐥.@cextern sc_MPI_Wtime()::𝐣𝐥.Cdouble
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Recv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:348](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:348:21)
	""" sc_MPI_Recv
	export sc_MPI_Recv
	𝐣𝐥.@cextern sc_MPI_Recv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm, var"?7?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Irecv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:350](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:350:21)
	""" sc_MPI_Irecv
	export sc_MPI_Irecv
	𝐣𝐥.@cextern sc_MPI_Irecv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm, var"?7?"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Send(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:352](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:352:21)
	""" sc_MPI_Send
	export sc_MPI_Send
	𝐣𝐥.@cextern sc_MPI_Send(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Isend(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:354](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:354:21)
	""" sc_MPI_Isend
	export sc_MPI_Isend
	𝐣𝐥.@cextern sc_MPI_Isend(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm, var"?7?"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Probe(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Comm, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:356](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:356:21)
	""" sc_MPI_Probe
	export sc_MPI_Probe
	𝐣𝐥.@cextern sc_MPI_Probe(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Comm, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Iprobe(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Comm, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?5?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:357](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:357:21)
	""" sc_MPI_Iprobe
	export sc_MPI_Iprobe
	𝐣𝐥.@cextern sc_MPI_Iprobe(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Comm, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?5?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Get_count(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Status}, var\"?2?\"::sc_MPI_Datatype, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:359](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:359:21)
	""" sc_MPI_Get_count
	export sc_MPI_Get_count
	𝐣𝐥.@cextern sc_MPI_Get_count(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Status}, var"?2?"::sc_MPI_Datatype, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Wait(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:364](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:364:21)
	""" sc_MPI_Wait
	export sc_MPI_Wait
	𝐣𝐥.@cextern sc_MPI_Wait(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Request}, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Waitsome(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?5?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:365](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:365:21)
	""" sc_MPI_Waitsome
	export sc_MPI_Waitsome
	𝐣𝐥.@cextern sc_MPI_Waitsome(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Request}, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?5?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Waitall(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:367](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:367:21)
	""" sc_MPI_Waitall
	export sc_MPI_Waitall
	𝐣𝐥.@cextern sc_MPI_Waitall(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Request}, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Init_thread(argc::𝐣𝐥.Ptr{𝐣𝐥.Cint}, argv::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}}, required::𝐣𝐥.Cint, provided::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:387](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:387:21)
	""" sc_MPI_Init_thread
	export sc_MPI_Init_thread
	𝐣𝐥.@cextern sc_MPI_Init_thread(argc::𝐣𝐥.Ptr{𝐣𝐥.Cint}, argv::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}}, required::𝐣𝐥.Cint, provided::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_sizeof(t::sc_MPI_Datatype)::size_t
	```
	
	 Return the size of MPI data types. 
	
	## Parameters
	
	  * `t`:    MPI data type.
	
	## Returns
	
	          Returns the size in bytes.
	
	## Reference
	
	[sc_mpi.h:396](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:396:21)
	""" sc_mpi_sizeof
	export sc_mpi_sizeof
	𝐣𝐥.@cextern sc_mpi_sizeof(t::sc_MPI_Datatype)::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_comm_attach_node_comms(comm::sc_MPI_Comm, processes_per_node::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Compute ``sc_intranode_comm'' and ``sc_internode_comm'' communicators and attach them to the current communicator.  This split takes *processes_per_node* passed by the user at face value: there is no hardware checking to see if this is the true affinity.
	
	## Parameters
	
	  * `comm`:                 MPI communicator
	  * `processes_per_node`:   the size of the intranode                                      communicators. if < 1,                                      sc will try to determine the correct                                      shared memory communicators.
	
	## Reference
	
	[sc_mpi.h:409](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:409:21)
	""" sc_mpi_comm_attach_node_comms
	export sc_mpi_comm_attach_node_comms
	𝐣𝐥.@cextern sc_mpi_comm_attach_node_comms(comm::sc_MPI_Comm, processes_per_node::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_comm_detach_node_comms(comm::sc_MPI_Comm)::𝐣𝐥.Cvoid
	```
	
	 Destroy ``sc_intranode_comm'' and ``sc_internode_comm'' communicators that are stored as attributes to communicator ``comm''. This routine enforces a call to the destroy callback for these attributes.
	
	## Parameters
	
	  * `comm`:                 MPI communicator
	
	## Reference
	
	[sc_mpi.h:418](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:418:21)
	""" sc_mpi_comm_detach_node_comms
	export sc_mpi_comm_detach_node_comms
	𝐣𝐥.@cextern sc_mpi_comm_detach_node_comms(comm::sc_MPI_Comm)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_comm_get_node_comms(comm::sc_MPI_Comm, intranode::𝐣𝐥.Ptr{sc_MPI_Comm}, internode::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cvoid
	```
	
	 Get the communicators computed in sc_mpi_comm_attach_node_comms() if they exist; return sc_MPI_COMM_NULL otherwise.
	
	## Parameters
	
	  * `comm`:            Super communicator
	  * `intranode`:      intranode communicator
	  * `internode`:      internode communicator
	
	## Reference
	
	[sc_mpi.h:427](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:427:21)
	""" sc_mpi_comm_get_node_comms
	export sc_mpi_comm_get_node_comms
	𝐣𝐥.@cextern sc_mpi_comm_get_node_comms(comm::sc_MPI_Comm, intranode::𝐣𝐥.Ptr{sc_MPI_Comm}, internode::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log2_lookup_table::𝐣𝐥.Cconst(𝐣𝐥.Cint)[256]
	```
	
	 Lookup table to provide fast base-2 logarithm of integers. 
	
	## Reference
	
	[sc.h:137](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:137:21)
	""" sc_log2_lookup_table
	export sc_log2_lookup_table
	𝐣𝐥.@cextern sc_log2_lookup_table::𝐣𝐥.Cconst(𝐣𝐥.Cint)[256]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_id::𝐣𝐥.Cint
	```
	
	 libsc allows for multiple packages to use their own log priorities etc. This is the package id for core sc functions, which is meant to be read only. It starts out with a value of -1, which is fine by itself. It is set to a non-negative value by the (optional) sc_init. 
	
	## Reference
	
	[sc.h:144](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:144:21)
	""" sc_package_id
	export sc_package_id
	𝐣𝐥.@cextern sc_package_id::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_trace_file::𝐣𝐥.Ptr{FILE}
	```
	
	 Optional trace file for logging (see sc_init). Initialized to NULL. 
	
	## Reference
	
	[sc.h:148](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:148:21)
	""" sc_trace_file
	export sc_trace_file
	𝐣𝐥.@cextern sc_trace_file::𝐣𝐥.Ptr{FILE}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_trace_prio::𝐣𝐥.Cint
	```
	
	 Optional minimum log priority for messages that go into the trace file. 
	
	## Reference
	
	[sc.h:151](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:151:21)
	""" sc_trace_prio
	export sc_trace_prio
	𝐣𝐥.@cextern sc_trace_prio::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_ABORTF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:177](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:177:21)
	""" SC_ABORTF
	export SC_ABORTF
	𝐣𝐥.@cextern SC_ABORTF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_CHECK_ABORTF(success::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:180](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:180:21)
	""" SC_CHECK_ABORTF
	export SC_CHECK_ABORTF
	𝐣𝐥.@cextern SC_CHECK_ABORTF(success::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GEN_LOGF(package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:351](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:351:21)
	""" SC_GEN_LOGF
	export SC_GEN_LOGF
	𝐣𝐥.@cextern SC_GEN_LOGF(package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:354](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:354:21)
	""" SC_GLOBAL_LOGF
	export SC_GLOBAL_LOGF
	𝐣𝐥.@cextern SC_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:356](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:356:21)
	""" SC_LOGF
	export SC_LOGF
	𝐣𝐥.@cextern SC_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:378](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:378:21)
	""" SC_GLOBAL_TRACEF
	export SC_GLOBAL_TRACEF
	𝐣𝐥.@cextern SC_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:380](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:380:21)
	""" SC_GLOBAL_LDEBUGF
	export SC_GLOBAL_LDEBUGF
	𝐣𝐥.@cextern SC_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:382](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:382:21)
	""" SC_GLOBAL_VERBOSEF
	export SC_GLOBAL_VERBOSEF
	𝐣𝐥.@cextern SC_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:384](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:384:21)
	""" SC_GLOBAL_INFOF
	export SC_GLOBAL_INFOF
	𝐣𝐥.@cextern SC_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:386](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:386:21)
	""" SC_GLOBAL_STATISTICSF
	export SC_GLOBAL_STATISTICSF
	𝐣𝐥.@cextern SC_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:388](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:388:21)
	""" SC_GLOBAL_PRODUCTIONF
	export SC_GLOBAL_PRODUCTIONF
	𝐣𝐥.@cextern SC_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:390](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:390:21)
	""" SC_GLOBAL_ESSENTIALF
	export SC_GLOBAL_ESSENTIALF
	𝐣𝐥.@cextern SC_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:392](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:392:21)
	""" SC_GLOBAL_LERRORF
	export SC_GLOBAL_LERRORF
	𝐣𝐥.@cextern SC_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:422](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:422:21)
	""" SC_TRACEF
	export SC_TRACEF
	𝐣𝐥.@cextern SC_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:424](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:424:21)
	""" SC_LDEBUGF
	export SC_LDEBUGF
	𝐣𝐥.@cextern SC_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:426](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:426:21)
	""" SC_VERBOSEF
	export SC_VERBOSEF
	𝐣𝐥.@cextern SC_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:428](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:428:21)
	""" SC_INFOF
	export SC_INFOF
	𝐣𝐥.@cextern SC_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:430](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:430:21)
	""" SC_STATISTICSF
	export SC_STATISTICSF
	𝐣𝐥.@cextern SC_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:432](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:432:21)
	""" SC_PRODUCTIONF
	export SC_PRODUCTIONF
	𝐣𝐥.@cextern SC_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:434](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:434:21)
	""" SC_ESSENTIALF
	export SC_ESSENTIALF
	𝐣𝐥.@cextern SC_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:436](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:436:21)
	""" SC_LERRORF
	export SC_LERRORF
	𝐣𝐥.@cextern SC_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:467](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:467:23)
	""" sc_handler_t
	export sc_handler_t
	𝐣𝐥.@ctypedef sc_handler_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:468](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:468:23)
	""" sc_log_handler_t
	export sc_log_handler_t
	𝐣𝐥.@ctypedef sc_log_handler_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{FILE}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:472](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:472:23)
	""" sc_abort_handler_t
	export sc_abort_handler_t
	𝐣𝐥.@ctypedef sc_abort_handler_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_malloc(package::𝐣𝐥.Cint, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[sc.h:476](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:476:21)
	""" sc_malloc
	export sc_malloc
	𝐣𝐥.@cextern sc_malloc(package::𝐣𝐥.Cint, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_calloc(package::𝐣𝐥.Cint, nmemb::size_t, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[sc.h:477](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:477:21)
	""" sc_calloc
	export sc_calloc
	𝐣𝐥.@cextern sc_calloc(package::𝐣𝐥.Cint, nmemb::size_t, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_realloc(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[sc.h:478](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:478:21)
	""" sc_realloc
	export sc_realloc
	𝐣𝐥.@cextern sc_realloc(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_strdup(package::𝐣𝐥.Cint, s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
	```
	
	## Reference
	
	[sc.h:479](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:479:21)
	""" sc_strdup
	export sc_strdup
	𝐣𝐥.@cextern sc_strdup(package::𝐣𝐥.Cint, s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_free(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:480](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:480:21)
	""" sc_free
	export sc_free
	𝐣𝐥.@cextern sc_free(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_memory_status(package::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:481](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:481:21)
	""" sc_memory_status
	export sc_memory_status
	𝐣𝐥.@cextern sc_memory_status(package::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_memory_check(package::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:482](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:482:21)
	""" sc_memory_check
	export sc_memory_check
	𝐣𝐥.@cextern sc_memory_check(package::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:486](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:486:21)
	""" sc_int_compare
	export sc_int_compare
	𝐣𝐥.@cextern sc_int_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int8_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:487](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:487:21)
	""" sc_int8_compare
	export sc_int8_compare
	𝐣𝐥.@cextern sc_int8_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int16_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:488](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:488:21)
	""" sc_int16_compare
	export sc_int16_compare
	𝐣𝐥.@cextern sc_int16_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int32_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:489](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:489:21)
	""" sc_int32_compare
	export sc_int32_compare
	𝐣𝐥.@cextern sc_int32_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int64_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:490](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:490:21)
	""" sc_int64_compare
	export sc_int64_compare
	𝐣𝐥.@cextern sc_int64_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_double_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:491](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:491:21)
	""" sc_double_compare
	export sc_double_compare
	𝐣𝐥.@cextern sc_double_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_atoi(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	```
	
	 Safe version of the standard library atoi (3) function. 
	
	## Parameters
	
	  * `nptr`:     NUL-terminated string.
	
	## Returns
	
	              Converted integer value.  0 if no valid number.                      INT_MAX on overflow, INT_MIN on underflow.
	
	## Reference
	
	[sc.h:498](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:498:21)
	""" sc_atoi
	export sc_atoi
	𝐣𝐥.@cextern sc_atoi(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_atol(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Clong
	```
	
	 Safe version of the standard library atol (3) function. 
	
	## Parameters
	
	  * `nptr`:     NUL-terminated string.
	
	## Returns
	
	              Converted long value.  0 if no valid number.                      LONG_MAX on overflow, LONG_MIN on underflow.
	
	## Reference
	
	[sc.h:505](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:505:21)
	""" sc_atol
	export sc_atol
	𝐣𝐥.@cextern sc_atol(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Clong
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_set_log_defaults(log_stream::𝐣𝐥.Ptr{FILE}, log_handler::sc_log_handler_t, log_thresold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Controls the default SC log behavior. 
	
	## Parameters
	
	  * `log_stream`:    Set stream to use by sc_logf (or NULL for stdout).
	  * `log_handler`:   Set default SC log handler (NULL selects builtin).
	  * `log_threshold`: Set default SC log threshold (or SC_LP_DEFAULT).                           May be SC_LP_ALWAYS or SC_LP_SILENT.
	
	## Reference
	
	[sc.h:513](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:513:21)
	""" sc_set_log_defaults
	export sc_set_log_defaults
	𝐣𝐥.@cextern sc_set_log_defaults(log_stream::𝐣𝐥.Ptr{FILE}, log_handler::sc_log_handler_t, log_thresold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_set_abort_handler(abort_handler::sc_abort_handler_t)::𝐣𝐥.Cvoid
	```
	
	 Controls the default SC abort behavior. 
	
	## Parameters
	
	  * `abort_handler`: Set default SC above handler (NULL selects                           builtin).  ***This function should not return!***
	
	## Reference
	
	[sc.h:521](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:521:21)
	""" sc_set_abort_handler
	export sc_set_abort_handler
	𝐣𝐥.@cextern sc_set_abort_handler(abort_handler::sc_abort_handler_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 The central log function to be called by all packages. Dispatches the log calls by package and filters by category and priority. 
	
	## Parameters
	
	  * `package`:   Must be a registered package id or -1.
	  * `category`:  Must be SC_LC_NORMAL or SC_LC_GLOBAL.
	  * `priority`:  Must be > SC_LP_ALWAYS and < SC_LP_SILENT.
	
	## Reference
	
	[sc.h:529](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:529:21)
	""" sc_log
	export sc_log
	𝐣𝐥.@cextern sc_log(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_logf(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:532](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:532:21)
	""" sc_logf
	export sc_logf
	𝐣𝐥.@cextern sc_logf(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_logv(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:536](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:536:21)
	""" sc_logv
	export sc_logv
	𝐣𝐥.@cextern sc_logv(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_push_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Add spaces to the start of a package's default log format. 
	
	## Reference
	
	[sc.h:541](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:541:21)
	""" sc_log_indent_push_count
	export sc_log_indent_push_count
	𝐣𝐥.@cextern sc_log_indent_push_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_pop_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Remove spaces from the start of a package's default log format. 
	
	## Reference
	
	[sc.h:544](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:544:21)
	""" sc_log_indent_pop_count
	export sc_log_indent_pop_count
	𝐣𝐥.@cextern sc_log_indent_pop_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_push()::𝐣𝐥.Cvoid
	```
	
	 Add one space to the start of sc's default log format. 
	
	## Reference
	
	[sc.h:547](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:547:21)
	""" sc_log_indent_push
	export sc_log_indent_push
	𝐣𝐥.@cextern sc_log_indent_push()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_pop()::𝐣𝐥.Cvoid
	```
	
	 Remove one space from the start of a sc's default log format. 
	
	## Reference
	
	[sc.h:550](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:550:21)
	""" sc_log_indent_pop
	export sc_log_indent_pop
	𝐣𝐥.@cextern sc_log_indent_pop()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort()::𝐣𝐥.Cvoid
	```
	
	 Print a stack trace, call the abort handler and then call abort (). 
	
	## Reference
	
	[sc.h:553](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:553:21)
	""" sc_abort
	export sc_abort
	𝐣𝐥.@cextern sc_abort()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_verbose(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Print a message to stderr and then call sc_abort (). 
	
	## Reference
	
	[sc.h:557](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:557:21)
	""" sc_abort_verbose
	export sc_abort_verbose
	𝐣𝐥.@cextern sc_abort_verbose(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_verbosef(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	 Print a message to stderr and then call sc_abort (). 
	
	## Reference
	
	[sc.h:562](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:562:21)
	""" sc_abort_verbosef
	export sc_abort_verbosef
	𝐣𝐥.@cextern sc_abort_verbosef(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_verbosev(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	```
	
	 Print a message to stderr and then call sc_abort (). 
	
	## Reference
	
	[sc.h:568](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:568:21)
	""" sc_abort_verbosev
	export sc_abort_verbosev
	𝐣𝐥.@cextern sc_abort_verbosev(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_collective(msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Collective abort where only root prints a message 
	
	## Reference
	
	[sc.h:573](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:573:21)
	""" sc_abort_collective
	export sc_abort_collective
	𝐣𝐥.@cextern sc_abort_collective(msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_register(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint, name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, full::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	```
	
	 Register a software package with SC. This function must only be called before additional threads are created. The logging parameters are as in sc_set_log_defaults. 
	
	## Returns
	
	                   Returns a unique package id.
	
	## Reference
	
	[sc.h:581](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:581:21)
	""" sc_package_register
	export sc_package_register
	𝐣𝐥.@cextern sc_package_register(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint, name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, full::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_is_registered(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Query whether an identifier matches a registered package. 
	
	## Parameters
	
	  * `package_id`:       Only a non-negative id can be registered.
	
	## Returns
	
	                      True if and only if the package id is                              non-negative and package is registered.
	
	## Reference
	
	[sc.h:590](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:590:21)
	""" sc_package_is_registered
	export sc_package_is_registered
	𝐣𝐥.@cextern sc_package_is_registered(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_lock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Acquire a pthread mutex lock. If configured without --enable-pthread, this function does nothing. This function must be followed with a matching sc_package_unlock. 
	
	## Parameters
	
	  * `package_id`:       Either -1 for an undefined package or                              an id returned from sc_package_register.                              Depending on the value, the appropriate mutex                              is chosen.  Thus, we may overlap locking calls                              with distinct package_id.
	
	## Reference
	
	[sc.h:601](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:601:21)
	""" sc_package_lock
	export sc_package_lock
	𝐣𝐥.@cextern sc_package_lock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_unlock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Release a pthread mutex lock. If configured without --enable-pthread, this function does nothing. This function must be follow a matching sc_package_lock. 
	
	## Parameters
	
	  * `package_id`:       Either -1 for an undefined package or                              an id returned from sc_package_register.                              Depending on the value, the appropriate mutex                              is chosen.  Thus, we may overlap locking calls                              with distinct package_id.
	
	## Reference
	
	[sc.h:612](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:612:21)
	""" sc_package_unlock
	export sc_package_unlock
	𝐣𝐥.@cextern sc_package_unlock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_set_verbosity(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Set the logging verbosity of a registered package. This can be called at any point in the program, any number of times. It can only lower the verbosity at and below the value of SC_LP_THRESHOLD. 
	
	## Parameters
	
	  * `package_id`:       Must be a registered package identifier.
	
	## Reference
	
	[sc.h:619](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:619:21)
	""" sc_package_set_verbosity
	export sc_package_set_verbosity
	𝐣𝐥.@cextern sc_package_set_verbosity(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_set_abort_alloc_mismatch(package_id::𝐣𝐥.Cint, set_abort::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Set the unregister behavior of sc_package_unregister().
	
	## Parameters
	
	  * `package_id`:    Must be -1 for the default package or                          the identifier of a registered package.
	  * `set_abort`:     True if sc_package_unregister() should abort if the                          number of allocs does not match the number of                          frees; false otherwise.
	
	## Reference
	
	[sc.h:630](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:630:21)
	""" sc_package_set_abort_alloc_mismatch
	export sc_package_set_abort_alloc_mismatch
	𝐣𝐥.@cextern sc_package_set_abort_alloc_mismatch(package_id::𝐣𝐥.Cint, set_abort::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_unregister(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Unregister a software package with SC. This function must only be called after additional threads are finished.
	
	## Reference
	
	[sc.h:636](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:636:21)
	""" sc_package_unregister
	export sc_package_unregister
	𝐣𝐥.@cextern sc_package_unregister(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_print_summary(log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Print a summary of all packages registered with SC. Uses the SC_LC_GLOBAL log category which by default only prints on rank 0. 
	
	## Parameters
	
	  * `log_priority`:     Priority passed to sc log functions.
	
	## Reference
	
	[sc.h:642](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:642:21)
	""" sc_package_print_summary
	export sc_package_print_summary
	𝐣𝐥.@cextern sc_package_print_summary(log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_init(mpicomm::sc_MPI_Comm, catch_signals::𝐣𝐥.Cint, print_backtrace::𝐣𝐥.Cint, log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Sets the global program identifier (e.g. the MPI rank) and some flags. This function is optional. This function must only be called before additional threads are created. If this function is not called or called with log_handler == NULL, the default SC log handler will be used. If this function is not called or called with log_threshold == SC_LP_DEFAULT, the default SC log threshold will be used. The default SC log settings can be changed with sc_set_log_defaults (). 
	
	## Parameters
	
	  * `mpicomm`:          MPI communicator, can be sc_MPI_COMM_NULL.                              If sc_MPI_COMM_NULL, the identifier is set to -1.                              Otherwise, sc_MPI_Init must have been called.                              Effectively, we just query size and rank.
	  * `catch_signals`:    If true, signals INT and SEGV are caught.
	  * `print_backtrace`:  If true, sc_abort prints a backtrace.
	
	## Reference
	
	[sc.h:659](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:659:21)
	""" sc_init
	export sc_init
	𝐣𝐥.@cextern sc_init(mpicomm::sc_MPI_Comm, catch_signals::𝐣𝐥.Cint, print_backtrace::𝐣𝐥.Cint, log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_finalize()::𝐣𝐥.Cvoid
	```
	
	 Unregisters all packages, runs the memory check, removes the signal handlers and resets sc_identifier and sc_root_*. This function is optional. This function does not require sc_init to be called first.
	
	## Reference
	
	[sc.h:668](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:668:21)
	""" sc_finalize
	export sc_finalize
	𝐣𝐥.@cextern sc_finalize()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_is_root()::𝐣𝐥.Cint
	```
	
	 Identify the root process. Only meaningful between sc_init and sc_finalize and with a communicator that is not sc_MPI_COMM_NULL (otherwise always true).
	
	## Returns
	
	          Return true for the root process and false otherwise.
	
	## Reference
	
	[sc.h:676](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:676:21)
	""" sc_is_root
	export sc_is_root
	𝐣𝐥.@cextern sc_is_root()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_strcopy(dest::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, src::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Provide a string copy function. 
	
	## Parameters
	
	  * `dest`:    Buffer of length at least *size.*                      On output, not touched if NULL or *size* == 0.
	  * `size`:     Allocation length of *dest.*
	  * `src`:      Null-terminated string.
	
	## Returns
	
	              Equivalent to sc_snprintf (dest, size, \"%s\", src).
	
	## Reference
	
	[sc.h:686](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:686:21)
	""" sc_strcopy
	export sc_strcopy
	𝐣𝐥.@cextern sc_strcopy(dest::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, src::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_snprintf(str::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, format::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	 Wrap the system snprintf function, allowing for truncation. The snprintf function may truncate the string written to the specified length. In some cases, compilers warn when this may occur. Here this is permitted behavior and we avoid the warning. 
	
	## Parameters
	
	  * `str`:     Buffer of length at least *size.*                      On output, not touched if NULL or *size* == 0.                      Otherwise, \"\" on snprintf error or the proper result.
	  * `size`:     Allocation length of *str.*
	  * `format`:   Format string as in man (3) snprintf.
	
	## Reference
	
	[sc.h:698](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:698:21)
	""" sc_snprintf
	export sc_snprintf
	𝐣𝐥.@cextern sc_snprintf(str::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, format::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	```
	
	 Return the full version of libsc.
	
	## Returns
	
	          Return the version of libsc using the format                  `VERSION_MAJOR.VERSION_MINOR.VERSION_POINT`,                  where `VERSION_POINT` can contain dots and                  characters, e.g. to indicate the additional                  number of commits and a git commit hash.
	
	## Reference
	
	[sc.h:710](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:710:21)
	""" sc_version
	export sc_version
	𝐣𝐥.@cextern sc_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_version_major()::𝐣𝐥.Cint
	```
	
	 Return the major version of libsc.
	
	## Returns
	
	          Return the major version of libsc.
	
	## Reference
	
	[sc.h:716](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:716:21)
	""" sc_version_major
	export sc_version_major
	𝐣𝐥.@cextern sc_version_major()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_version_minor()::𝐣𝐥.Cint
	```
	
	 Return the minor version of libsc.
	
	## Returns
	
	          Return the minor version of libsc.
	
	## Reference
	
	[sc.h:722](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:722:21)
	""" sc_version_minor
	export sc_version_minor
	𝐣𝐥.@cextern sc_version_minor()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	 Function to compute a hash value of an object. 
	
	## Parameters
	
	  * `v`:   The object to hash.
	  * `u`:   Arbitrary user data.
	
	## Returns
	
	 Returns an unsigned integer.
	
	## Reference
	
	[sc_containers.h:75](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:75:24)
	""" sc_hash_function_t
	export sc_hash_function_t
	𝐣𝐥.@ctypedef sc_hash_function_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cuint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Function to check equality of two objects. 
	
	## Parameters
	
	  * `u`:   Arbitrary user data.
	
	## Returns
	
	 Returns false if *v1 is unequal *v2 and true otherwise.
	
	## Reference
	
	[sc_containers.h:81](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:81:23)
	""" sc_equal_function_t
	export sc_equal_function_t
	𝐣𝐥.@ctypedef sc_equal_function_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Function to call on every data item of a hash table. 
	
	## Parameters
	
	  * `v`:   The address of the pointer to the current object.
	  * `u`:   Arbitrary user data.
	
	## Returns
	
	 Return true if the traversal should continue, false to stop.
	
	## Reference
	
	[sc_containers.h:89](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:89:23)
	""" sc_hash_foreach_t
	export sc_hash_foreach_t
	𝐣𝐥.@ctypedef sc_hash_foreach_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 The sc_array object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index.  Their address may change. The number of elements (== elem_count) of the array can be changed by  sc_array_resize and sc_array_rewind. Elements can be sorted with sc_array_sort. If the array is sorted, it can be searched with sc_array_bsearch. A priority queue is implemented with pqueue_add and pqueue_pop (untested).
	
	## Reference
	
	[sc_containers.h:99](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:99:16)
	""" sc_array
	𝐣𝐥.@doc """
	 The sc_array object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index.  Their address may change. The number of elements (== elem_count) of the array can be changed by  sc_array_resize and sc_array_rewind. Elements can be sorted with sc_array_sort. If the array is sorted, it can be searched with sc_array_bsearch. A priority queue is implemented with pqueue_add and pqueue_pop (untested).
	
	## Reference
	
	[sc_containers.h:113](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:113:1)
	""" sc_array_t
	export sc_array, sc_array_t
	𝐣𝐥.@ctypedef sc_array_t 𝐣𝐥.@cstruct sc_array {
		elem_size::size_t
		elem_count::size_t
		byte_alloc::ssize_t
		array::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_memory_used(array::𝐣𝐥.Ptr{sc_array_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	```
	
	 Calculate the memory used by an array. 
	
	## Parameters
	
	  * `array`:       The array.
	  * `is_dynamic`:  True if created with sc_array_new,                         false if initialized with sc_array_init
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:127](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:127:21)
	""" sc_array_memory_used
	export sc_array_memory_used
	𝐣𝐥.@cextern sc_array_memory_used(array::𝐣𝐥.Ptr{sc_array_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new array structure with 0 elements. 
	
	## Parameters
	
	  * `elem_size`:    Size of one array element in bytes.
	
	## Returns
	
	                  Return an allocated array of zero length.
	
	## Reference
	
	[sc_containers.h:133](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:133:21)
	""" sc_array_new
	export sc_array_new
	𝐣𝐥.@cextern sc_array_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new_count(elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new array structure with a given length (number of elements). 
	
	## Parameters
	
	  * `elem_size`:    Size of one array element in bytes.
	  * `elem_count`:   Initial number of array elements.
	
	## Returns
	
	                  Return an allocated array                          with allocated but uninitialized elements.
	
	## Reference
	
	[sc_containers.h:141](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:141:21)
	""" sc_array_new_count
	export sc_array_new_count
	𝐣𝐥.@cextern sc_array_new_count(elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new_view(array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new view of an existing sc_array_t. 
	
	## Parameters
	
	  * `array`:    The array must not be resized while view is alive.
	  * `offset`:   The offset of the viewed section in element units.                      This offset cannot be changed until the view is reset.
	  * `length`:   The length of the viewed section in element units.                      The view cannot be resized to exceed this length.
	
	## Reference
	
	[sc_containers.h:153](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:153:21)
	""" sc_array_new_view
	export sc_array_new_view
	𝐣𝐥.@cextern sc_array_new_view(array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new_data(base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new view of an existing plain C array. 
	
	## Parameters
	
	  * `base`:         The data must not be moved while view is alive.
	  * `elem_size`:    Size of one array element in bytes.
	  * `elem_count`:   The length of the view in element units.                          The view cannot be resized to exceed this length.
	
	## Reference
	
	[sc_containers.h:162](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:162:21)
	""" sc_array_new_data
	export sc_array_new_data
	𝐣𝐥.@cextern sc_array_new_data(base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_destroy(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Destroys an array structure. 
	
	## Parameters
	
	  * `array`:    The array to be destroyed.
	
	## Reference
	
	[sc_containers.h:168](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:168:21)
	""" sc_array_destroy
	export sc_array_destroy
	𝐣𝐥.@cextern sc_array_destroy(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_destroy_null(parray::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_array_t}})::𝐣𝐥.Cvoid
	```
	
	 Destroys an array structure and sets the pointer to NULL. 
	
	## Parameters
	
	  * `parray`:       Pointer to address of array to be destroyed.                              On output, *parray is NULL.
	
	## Reference
	
	[sc_containers.h:174](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:174:21)
	""" sc_array_destroy_null
	export sc_array_destroy_null
	𝐣𝐥.@cextern sc_array_destroy_null(parray::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_array_t}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) array structure. 
	
	## Parameters
	
	  * `array`:       Array structure to be initialized.
	  * `elem_size`:        Size of one array element in bytes.
	
	## Reference
	
	[sc_containers.h:180](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:180:21)
	""" sc_array_init
	export sc_array_init
	𝐣𝐥.@cextern sc_array_init(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_size(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) array structure and allocates a given number of elements. Deprecated: use sc_array_init_count. 
	
	## Parameters
	
	  * `array`:       Array structure to be initialized.
	  * `elem_size`:        Size of one array element in bytes.
	  * `elem_count`:       Number of initial array elements.
	
	## Reference
	
	[sc_containers.h:189](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:189:21)
	""" sc_array_init_size
	export sc_array_init_size
	𝐣𝐥.@cextern sc_array_init_size(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_count(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) array structure and allocates a given number of elements. This function supersedes sc_array_init_size. 
	
	## Parameters
	
	  * `array`:       Array structure to be initialized.
	  * `elem_size`:        Size of one array element in bytes.
	  * `elem_count`:       Number of initial array elements.
	
	## Reference
	
	[sc_containers.h:199](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:199:21)
	""" sc_array_init_count
	export sc_array_init_count
	𝐣𝐥.@cextern sc_array_init_count(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_view(view::𝐣𝐥.Ptr{sc_array_t}, array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) view from existing sc_array_t. The array view returned does not require sc_array_reset (doesn't hurt though). 
	
	## Parameters
	
	  * `view`:  Array structure to be initialized.
	  * `array`:     The array must not be resized while view is alive.
	  * `offset`:    The offset of the viewed section in element units.                       This offset cannot be changed until the view is reset.
	  * `length`:    The length of the view in element units.                       The view cannot be resized to exceed this length.                       It is not necessary to call sc_array_reset later.
	
	## Reference
	
	[sc_containers.h:212](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:212:21)
	""" sc_array_init_view
	export sc_array_init_view
	𝐣𝐥.@cextern sc_array_init_view(view::𝐣𝐥.Ptr{sc_array_t}, array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_data(view::𝐣𝐥.Ptr{sc_array_t}, base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) view from given plain C data. The array view returned does not require sc_array_reset (doesn't hurt though). 
	
	## Parameters
	
	  * `view`:     Array structure to be initialized.
	  * `base`:         The data must not be moved while view is alive.
	  * `elem_size`:    Size of one array element in bytes.
	  * `elem_count`:   The length of the view in element units.                          The view cannot be resized to exceed this length.                          It is not necessary to call sc_array_reset later.
	
	## Reference
	
	[sc_containers.h:224](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:224:21)
	""" sc_array_init_data
	export sc_array_init_data
	𝐣𝐥.@cextern sc_array_init_data(view::𝐣𝐥.Ptr{sc_array_t}, base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_memset(array::𝐣𝐥.Ptr{sc_array_t}, c::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Run memset on the array storage. We pass the character to memset unchanged.  Thus, care must be taken when setting values below -1 or above 127, just as with standard memset (3). 
	
	## Parameters
	
	  * `array`:    This array's storage will be overwritten.
	  * `c`:            Character to overwrite every byte with.
	
	## Reference
	
	[sc_containers.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:233:21)
	""" sc_array_memset
	export sc_array_memset
	𝐣𝐥.@cextern sc_array_memset(array::𝐣𝐥.Ptr{sc_array_t}, c::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_reset(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Sets the array count to zero and frees all elements. This function turns a view into a newly initialized array. 
	
	## Parameters
	
	  * `array`:       Array structure to be reset.
	
	NOTE: Calling sc_array_init, then any array operations,       then sc_array_reset is memory neutral.       As an exception, the two functions sc_array_init_view and       sc_array_init_data do not require a subsequent call to sc_array_reset.       Regardless, it is legal to call sc_array_reset anyway.
	
	## Reference
	
	[sc_containers.h:244](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:244:21)
	""" sc_array_reset
	export sc_array_reset
	𝐣𝐥.@cextern sc_array_reset(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_truncate(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Sets the array count to zero, but does not free elements. Not allowed for views. 
	
	## Parameters
	
	  * `array`:       Array structure to be truncated.
	
	NOTE: This is intended to allow an sc_array to be used as a reusable buffer, where the \"high water mark\" of the buffer is preserved, so that O(log (max n)) reallocs occur over the life of the buffer.
	
	## Reference
	
	[sc_containers.h:253](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:253:21)
	""" sc_array_truncate
	export sc_array_truncate
	𝐣𝐥.@cextern sc_array_truncate(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_rewind(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Shorten an array without reallocating it. 
	
	## Parameters
	
	  * `array`:    The element count of this array is modified.
	  * `new_count`:    Must be less or equal than the **array's** count.                          If it is less, the number of elements in the                          array is reduced without reallocating memory.                          The exception is a **new_count** of zero                          specified for an array that is not a view:                          In this case sc_array_reset is equivalent.
	
	## Reference
	
	[sc_containers.h:264](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:264:21)
	""" sc_array_rewind
	export sc_array_rewind
	𝐣𝐥.@cextern sc_array_rewind(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_resize(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Sets the element count to new_count. If the array is not a view, reallocation takes place occasionally. If the array is a view, new_count must not be greater than the element count of the view when it was created.  The original offset of the view cannot be changed. 
	
	## Parameters
	
	  * `array`:    The element count and address is modified.
	  * `new_count`:    New element count of the array.                          If it is zero and the array is not a view,                          the effect equals sc_array_reset.
	
	## Reference
	
	[sc_containers.h:276](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:276:21)
	""" sc_array_resize
	export sc_array_resize
	𝐣𝐥.@cextern sc_array_resize(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_copy(dest::𝐣𝐥.Ptr{sc_array_t}, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Copy the contents of one array into another. Both arrays must have equal element sizes. The source array may be a view. We use memcpy (3):  If the two arrays overlap, results are undefined. 
	
	## Parameters
	
	  * `dest`:     Array (not a view) will be resized and get new data.
	  * `src`:      Array used as source of new data, will not be changed.
	
	## Reference
	
	[sc_containers.h:285](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:285:21)
	""" sc_array_copy
	export sc_array_copy
	𝐣𝐥.@cextern sc_array_copy(dest::𝐣𝐥.Ptr{sc_array_t}, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_copy_into(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Copy the contents of one array into some portion of another. Both arrays must have equal element sizes. Either array may be a view.  The destination array must be large enough. We use memcpy (3):  If the two arrays overlap, results are undefined. 
	
	## Parameters
	
	  * `dest`:     Array will be written into.  Its element count must                      be at least **dest_offset** + **src->elem_count.**
	  * `dest_offset`:  First index in **dest** array to be overwritten.                      As every index, it refers to elements, not bytes.
	  * `src`:      Array used as source of new data, will not be changed.
	
	## Reference
	
	[sc_containers.h:297](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:297:21)
	""" sc_array_copy_into
	export sc_array_copy_into
	𝐣𝐥.@cextern sc_array_copy_into(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_move_part(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t}, src_offset::size_t, count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Copy part of one array into another using memmove (3). Both arrays must have equal element sizes. Either array may be a view.  The destination array must be large enough. We use memmove (3):  The two arrays may overlap. 
	
	## Parameters
	
	  * `dest`:     Array will be written into.  Its element count must                      be at least **dest_offset** + **count.**
	  * `dest_offset`:  First index in **dest** array to be overwritten.                      As every index, it refers to elements, not bytes.
	  * `src`:      Array will be read from.  Its element count must                      be at least **src_offset** + **count.**
	  * `src_offset`:   First index in **src** array to be used.                      As every index, it refers to elements, not bytes.
	  * `count`:    Number of entries copied.
	
	## Reference
	
	[sc_containers.h:314](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:314:21)
	""" sc_array_move_part
	export sc_array_move_part
	𝐣𝐥.@cextern sc_array_move_part(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t}, src_offset::size_t, count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_sort(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	```
	
	 Sorts the array in ascending order wrt. the comparison function. 
	
	## Parameters
	
	  * `array`:    The array to sort.
	  * `compar`:   The comparison function to be used.
	
	## Reference
	
	[sc_containers.h:322](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:322:21)
	""" sc_array_sort
	export sc_array_sort
	𝐣𝐥.@cextern sc_array_sort(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_is_sorted(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cint
	```
	
	 Check whether the array is sorted wrt. the comparison function. 
	
	## Parameters
	
	  * `array`:    The array to check.
	  * `compar`:   The comparison function to be used.
	
	## Returns
	
	              True if array is sorted, false otherwise.
	
	## Reference
	
	[sc_containers.h:331](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:331:21)
	""" sc_array_is_sorted
	export sc_array_is_sorted
	𝐣𝐥.@cextern sc_array_is_sorted(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_is_equal(array::𝐣𝐥.Ptr{sc_array_t}, other::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	```
	
	 Check whether two arrays have equal size, count, and content. Either array may be a view.  Both arrays will not be changed. 
	
	## Parameters
	
	  * `array`:   One array to be compared.
	  * `other`:   A second array to be compared.
	
	## Returns
	
	              True if array and other are equal, false otherwise.
	
	## Reference
	
	[sc_containers.h:341](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:341:21)
	""" sc_array_is_equal
	export sc_array_is_equal
	𝐣𝐥.@cextern sc_array_is_equal(array::𝐣𝐥.Ptr{sc_array_t}, other::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_uniq(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	```
	
	 Removed duplicate entries from a sorted array. This function is not allowed for views. 
	
	## Parameters
	
	  * `array`:  The array size will be reduced as necessary.
	  * `compar`:     The comparison function to be used.
	
	## Reference
	
	[sc_containers.h:349](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:349:21)
	""" sc_array_uniq
	export sc_array_uniq
	𝐣𝐥.@cextern sc_array_uniq(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_bsearch(array::𝐣𝐥.Ptr{sc_array_t}, key::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::ssize_t
	```
	
	 Performs a binary search on an array. The array must be sorted. 
	
	## Parameters
	
	  * `array`:   A sorted array to search in.
	  * `key`:     An element to be searched for.
	  * `compar`:  The comparison function to be used.
	
	## Returns
	
	 Returns the index into array for the item found, or -1.
	
	## Reference
	
	[sc_containers.h:359](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:359:21)
	""" sc_array_bsearch
	export sc_array_bsearch
	𝐣𝐥.@cextern sc_array_bsearch(array::𝐣𝐥.Ptr{sc_array_t}, key::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::ssize_t
	
	𝐣𝐥.@doc """
	 Function to determine the enumerable type of an object in an array. 
	
	## Parameters
	
	  * `array`:   Array containing the object.
	  * `index`:   The location of the object.
	  * `data`:    Arbitrary user data.
	
	## Reference
	
	[sc_containers.h:369](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:369:23)
	""" sc_array_type_t
	export sc_array_type_t
	𝐣𝐥.@ctypedef sc_array_type_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{size_t, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{sc_array_t}, size_t, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_split(array::𝐣𝐥.Ptr{sc_array_t}, offsets::𝐣𝐥.Ptr{sc_array_t}, num_types::size_t, type_fn::sc_array_type_t, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Compute the offsets of groups of enumerable types in an array. 
	
	## Parameters
	
	  * `array`:         Array that is sorted in ascending order by type.                           If k indexes *array,* then                           0 <= *type_fn* (*array,* k, *data)* <                           *num_types.*
	  * `offsets`:   An initialized array of type size_t that is                           resized to *num_types* + 1 entries.  The indices                           j of *array* that contain objects of type k are                           *offsets[k]* <= j < *offsets[k* + 1].                           If there are no objects of type k, then                           *offsets[k]* = *offset[k* + 1].
	  * `num_types`:     The number of possible types of objects in                           *array.*
	  * `type_fn`:       Returns the type of an object in the array.
	  * `data`:          Arbitrary user data passed to *type_fn.*
	
	## Reference
	
	[sc_containers.h:388](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:388:21)
	""" sc_array_split
	export sc_array_split
	𝐣𝐥.@cextern sc_array_split(array::𝐣𝐥.Ptr{sc_array_t}, offsets::𝐣𝐥.Ptr{sc_array_t}, num_types::size_t, type_fn::sc_array_type_t, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_is_permutation(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	```
	
	 Determine whether *array* is an array of size_t's whose entries include every integer 0 <= i < array->elem_count. 
	
	## Parameters
	
	  * `array`:         An array.
	
	## Returns
	
	                   Returns 1 if array contains size_t elements whose                           entries include every integer                           0 <= i < *array->elem_count,* 0 otherwise.
	
	## Reference
	
	[sc_containers.h:399](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:399:21)
	""" sc_array_is_permutation
	export sc_array_is_permutation
	𝐣𝐥.@cextern sc_array_is_permutation(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_permute(array::𝐣𝐥.Ptr{sc_array_t}, newindices::𝐣𝐥.Ptr{sc_array_t}, keepperm::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Given permutation *newindices,* permute *array* in place.  The data that on input is contained in *array[i]* will be contained in *array[newindices[i]]* on output.  The entries of newindices will be altered unless *keepperm* is true. 
	
	## Parameters
	
	  * `array`:      An array.
	  * `newindices`: Permutation array (see sc_array_is_permutation).
	  * `keepperm`:   If true, *newindices* will be unchanged by the                            algorithm; if false, *newindices* will be the                            identity permutation on output, but the                            algorithm will only use O(1) space.
	
	## Reference
	
	[sc_containers.h:412](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:412:21)
	""" sc_array_permute
	export sc_array_permute
	𝐣𝐥.@cextern sc_array_permute(array::𝐣𝐥.Ptr{sc_array_t}, newindices::𝐣𝐥.Ptr{sc_array_t}, keepperm::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_checksum(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cuint
	```
	
	 Computes the adler32 checksum of array data (see zlib documentation). This is a faster checksum than crc32, and it works with zeros as data.
	
	## Reference
	
	[sc_containers.h:418](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:418:21)
	""" sc_array_checksum
	export sc_array_checksum
	𝐣𝐥.@cextern sc_array_checksum(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_pqueue_add(array::𝐣𝐥.Ptr{sc_array_t}, temp::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	```
	
	 Adds an element to a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. The priority queue is implemented as a heap in ascending order. A heap is a binary tree where the children are not less than their parent. Assumes that elements [0]..[elem_count-2] form a valid heap. Then propagates [elem_count-1] upward by swapping if necessary. 
	
	## Parameters
	
	  * `temp`:    Pointer to unused allocated memory of elem_size.
	  * `compar`:  The comparison function to be used.
	
	## Returns
	
	 Returns the number of swap operations. 
	
	NOTE:  If the return value is zero for all elements in an array,        the array is sorted linearly and unchanged.
	
	## Reference
	
	[sc_containers.h:433](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:433:21)
	""" sc_array_pqueue_add
	export sc_array_pqueue_add
	𝐣𝐥.@cextern sc_array_pqueue_add(array::𝐣𝐥.Ptr{sc_array_t}, temp::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_pqueue_pop(array::𝐣𝐥.Ptr{sc_array_t}, result::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	```
	
	 Pops the smallest element from a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. This function assumes that the array forms a valid heap in ascending order. 
	
	## Parameters
	
	  * `result`:  Pointer to unused allocated memory of elem_size.
	  * `compar`:  The comparison function to be used.
	
	## Returns
	
	 Returns the number of swap operations. 
	
	NOTE: This function resizes the array to elem_count-1.
	
	## Reference
	
	[sc_containers.h:447](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:447:21)
	""" sc_array_pqueue_pop
	export sc_array_pqueue_pop
	𝐣𝐥.@cextern sc_array_pqueue_pop(array::𝐣𝐥.Ptr{sc_array_t}, result::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	
	𝐣𝐥.@doc """
	 A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See sc_mempool_t for that purpose.
	
	## Reference
	
	[sc_containers.h:613](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:613:1)
	""" sc_mstamp_t
	𝐣𝐥.@doc """
	 A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See sc_mempool_t for that purpose.
	
	## Reference
	
	[sc_containers.h:604](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:604:16)
	""" sc_mstamp
	export sc_mstamp, sc_mstamp_t
	𝐣𝐥.@ctypedef sc_mstamp_t 𝐣𝐥.@cstruct sc_mstamp {
		elem_size::size_t
		per_stamp::size_t
		stamp_size::size_t
		cur_snext::size_t
		current::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
		remember::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_init(mst::𝐣𝐥.Ptr{sc_mstamp_t}, stamp_unit::size_t, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initialize a memory stamp container. We provide allocation of fixed-size memory items without allocating new memory in every request. Instead we block the allocations in what we call a stamp of multiple items. Even if no allocations are done, the container's internal memory must be freed eventually by sc_mstamp_reset.
	
	## Parameters
	
	  * `mst`:          Legal pointer to a stamp structure.
	  * `stamp_unit`:       Size of each memory block that we allocate.                              If it is larger than the element size,                              we may place more than one element in it.                              Passing 0 is legal and forces                              stamps that hold one item each.
	  * `elem_size`:        Size of each item.                              Passing 0 is legal.  In that case,                              sc_mstamp_alloc returns NULL.
	
	## Reference
	
	[sc_containers.h:632](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:632:21)
	""" sc_mstamp_init
	export sc_mstamp_init
	𝐣𝐥.@cextern sc_mstamp_init(mst::𝐣𝐥.Ptr{sc_mstamp_t}, stamp_unit::size_t, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_reset(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	```
	
	 Free all memory in a stamp structure and all items previously returned. 
	
	## Parameters
	
	  * `Properly`: initialized stamp container.                              On output, the structure is undefined.
	
	## Reference
	
	[sc_containers.h:639](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:639:21)
	""" sc_mstamp_reset
	export sc_mstamp_reset
	𝐣𝐥.@cextern sc_mstamp_reset(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_truncate(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	```
	
	 Free all memory in a stamp structure and initialize it anew. Equivalent to calling sc_mstamp_reset followed by                       sc_mstamp_init with the same                            stamp_unit and elem_size.
	
	## Parameters
	
	  * `Properly`: initialized stamp container.                              On output, its elements have been freed                              and it is ready for further use.
	
	## Reference
	
	[sc_containers.h:650](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:650:21)
	""" sc_mstamp_truncate
	export sc_mstamp_truncate
	𝐣𝐥.@cextern sc_mstamp_truncate(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_alloc(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Return a new item. The memory returned will stay legal until container is destroyed or truncated. 
	
	## Parameters
	
	  * `Properly`: initialized stamp container.
	
	## Returns
	
	                      Pointer to an item ready to use.                              Legal until sc_stamp_destroy or                              sc_stamp_truncate is called on mst.
	
	## Reference
	
	[sc_containers.h:660](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:660:21)
	""" sc_mstamp_alloc
	export sc_mstamp_alloc
	𝐣𝐥.@cextern sc_mstamp_alloc(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_memory_used(mst::𝐣𝐥.Ptr{sc_mstamp_t})::size_t
	```
	
	 Return memory size in bytes of all data allocated in the container. 
	
	## Parameters
	
	  * `Properly`: initialized stamp container.
	
	## Returns
	
	                      Total container memory size in bytes.
	
	## Reference
	
	[sc_containers.h:666](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:666:21)
	""" sc_mstamp_memory_used
	export sc_mstamp_memory_used
	𝐣𝐥.@cextern sc_mstamp_memory_used(mst::𝐣𝐥.Ptr{sc_mstamp_t})::size_t
	
	𝐣𝐥.@doc """
	 The sc_mempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool)    and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.
	
	## Reference
	
	[sc_containers.h:677](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:677:16)
	""" sc_mempool
	𝐣𝐥.@doc """
	 The sc_mempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool)    and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.
	
	## Reference
	
	[sc_containers.h:692](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:692:1)
	""" sc_mempool_t
	export sc_mempool, sc_mempool_t
	𝐣𝐥.@ctypedef sc_mempool_t 𝐣𝐥.@cstruct sc_mempool {
		elem_size::size_t
		elem_count::size_t
		zero_and_persist::𝐣𝐥.Cint
		mstamp::sc_mstamp_t
		freed::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_memory_used(mempool::𝐣𝐥.Ptr{sc_mempool_t})::size_t
	```
	
	 Calculate the memory used by a memory pool. 
	
	## Parameters
	
	  * `array`:       The memory pool.
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:698](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:698:21)
	""" sc_mempool_memory_used
	export sc_mempool_memory_used
	𝐣𝐥.@cextern sc_mempool_memory_used(mempool::𝐣𝐥.Ptr{sc_mempool_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	```
	
	 Creates a new mempool structure with the zero_and_persist option off. The contents of any elements returned by sc_mempool_alloc are undefined. 
	
	## Parameters
	
	  * `elem_size`:  Size of one element in bytes.
	
	## Returns
	
	 Returns an allocated and initialized memory pool.
	
	## Reference
	
	[sc_containers.h:705](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:705:21)
	""" sc_mempool_new
	export sc_mempool_new
	𝐣𝐥.@cextern sc_mempool_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_new_zero_and_persist(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	```
	
	 Creates a new mempool structure with the zero_and_persist option on. The memory of newly created elements is zero'd out, and the contents of an element are not touched between freeing and re-returning it. 
	
	## Parameters
	
	  * `elem_size`:  Size of one element in bytes.
	
	## Returns
	
	 Returns an allocated and initialized memory pool.
	
	## Reference
	
	[sc_containers.h:713](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:713:21)
	""" sc_mempool_new_zero_and_persist
	export sc_mempool_new_zero_and_persist
	𝐣𝐥.@cextern sc_mempool_new_zero_and_persist(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_init(mempool::𝐣𝐥.Ptr{sc_mempool_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Same as sc_mempool_new, but for an already allocated sc_mempool_t pointer. 
	
	## Reference
	
	[sc_containers.h:716](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:716:21)
	""" sc_mempool_init
	export sc_mempool_init
	𝐣𝐥.@cextern sc_mempool_init(mempool::𝐣𝐥.Ptr{sc_mempool_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_destroy(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a mempool structure. All elements that are still in use are invalidated. 
	
	## Parameters
	
	  * `mempool`:      Its memory is freed.
	
	## Reference
	
	[sc_containers.h:723](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:723:21)
	""" sc_mempool_destroy
	export sc_mempool_destroy
	𝐣𝐥.@cextern sc_mempool_destroy(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_destroy_null(pmempool::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_mempool_t}})::𝐣𝐥.Cvoid
	```
	
	 Destroy a mempool structure. All elements that are still in use are invalidated. 
	
	## Parameters
	
	  * `pmempool`:     Address of pointer to memory pool.                              Its memory is freed, pointer is NULLed.
	
	## Reference
	
	[sc_containers.h:730](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:730:21)
	""" sc_mempool_destroy_null
	export sc_mempool_destroy_null
	𝐣𝐥.@cextern sc_mempool_destroy_null(pmempool::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_mempool_t}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_reset(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Same as sc_mempool_destroy, but does not free the pointer 
	
	## Reference
	
	[sc_containers.h:733](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:733:21)
	""" sc_mempool_reset
	export sc_mempool_reset
	𝐣𝐥.@cextern sc_mempool_reset(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_truncate(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Invalidates all previously returned pointers, resets count to 0.
	
	## Reference
	
	[sc_containers.h:737](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:737:21)
	""" sc_mempool_truncate
	export sc_mempool_truncate
	𝐣𝐥.@cextern sc_mempool_truncate(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 The sc_link structure is one link of a linked list.
	
	## Reference
	
	[sc_containers.h:799](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:799:16)
	""" sc_link
	𝐣𝐥.@doc """
	 The sc_link structure is one link of a linked list.
	
	## Reference
	
	[sc_containers.h:804](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:804:1)
	""" sc_link_t
	export sc_link, sc_link_t
	𝐣𝐥.@ctypedef sc_link_t 𝐣𝐥.@cstruct sc_link {
		data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		next::𝐣𝐥.Ptr{𝐣𝐥.@cstruct sc_link}
	}
	
	𝐣𝐥.@doc """
	 The sc_list object provides a linked list.
	
	## Reference
	
	[sc_containers.h:808](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:808:16)
	""" sc_list
	𝐣𝐥.@doc """
	 The sc_list object provides a linked list.
	
	## Reference
	
	[sc_containers.h:819](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:819:1)
	""" sc_list_t
	export sc_list, sc_list_t
	𝐣𝐥.@ctypedef sc_list_t 𝐣𝐥.@cstruct sc_list {
		elem_count::size_t
		first::𝐣𝐥.Ptr{sc_link_t}
		last::𝐣𝐥.Ptr{sc_link_t}
		allocator_owned::𝐣𝐥.Cint
		allocator::𝐣𝐥.Ptr{sc_mempool_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_memory_used(list::𝐣𝐥.Ptr{sc_list_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	```
	
	 Calculate the total memory used by a list. 
	
	## Parameters
	
	  * `list`:        The list.
	  * `is_dynamic`:  True if created with sc_list_new,                         false if initialized with sc_list_init
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:827](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:827:21)
	""" sc_list_memory_used
	export sc_list_memory_used
	𝐣𝐥.@cextern sc_list_memory_used(list::𝐣𝐥.Ptr{sc_list_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_new(allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_list_t}
	```
	
	 Allocate a new, empty linked list. 
	
	## Parameters
	
	  * `allocator`:    Memory allocator for sc_link_t, can be NULL                          in which case an internal allocator is created.
	
	## Returns
	
	                  Pointer to a newly allocated, empty list object.
	
	## Reference
	
	[sc_containers.h:834](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:834:21)
	""" sc_list_new
	export sc_list_new
	𝐣𝐥.@cextern sc_list_new(allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_list_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_destroy(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a linked list structure in O(N). 
	
	## Parameters
	
	  * `list`:     All memory allocated for this list is freed.
	
	NOTE: If allocator was provided in sc_list_new, it will not be destroyed.
	
	## Reference
	
	[sc_containers.h:840](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:840:21)
	""" sc_list_destroy
	export sc_list_destroy
	𝐣𝐥.@cextern sc_list_destroy(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_init(list::𝐣𝐥.Ptr{sc_list_t}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Initialize a list object with an external link allocator. 
	
	## Parameters
	
	  * `list`:       List structure to be initialized.
	  * `allocator`:  External memory allocator for sc_link_t,                             which must exist already.
	
	## Reference
	
	[sc_containers.h:847](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:847:21)
	""" sc_list_init
	export sc_list_init
	𝐣𝐥.@cextern sc_list_init(list::𝐣𝐥.Ptr{sc_list_t}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_reset(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	```
	
	 Remove all elements from a list in O(N). 
	
	## Parameters
	
	  * `list`:       List structure to be emptied.
	
	NOTE: Calling sc_list_init, then any list operations,       then sc_list_reset is memory neutral.
	
	## Reference
	
	[sc_containers.h:854](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:854:21)
	""" sc_list_reset
	export sc_list_reset
	𝐣𝐥.@cextern sc_list_reset(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_unlink(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	```
	
	 Unlink all list elements without returning them to the mempool. This runs in O(1) but is dangerous because the link memory stays alive. 
	
	## Parameters
	
	  * `list`:       List structure to be unlinked.
	
	## Reference
	
	[sc_containers.h:860](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:860:21)
	""" sc_list_unlink
	export sc_list_unlink
	𝐣𝐥.@cextern sc_list_unlink(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_prepend(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	```
	
	 Insert a list element at the beginning of the list. 
	
	## Parameters
	
	  * `list`:     Valid list object.
	  * `data`:         A new link is created holding this data.
	
	## Returns
	
	                  The link that has been created for data.
	
	## Reference
	
	[sc_containers.h:867](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:867:21)
	""" sc_list_prepend
	export sc_list_prepend
	𝐣𝐥.@cextern sc_list_prepend(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_append(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	```
	
	 Insert a list element at the end of the list. 
	
	## Parameters
	
	  * `list`:     Valid list object.
	  * `data`:         A new link is created holding this data.
	
	## Returns
	
	                  The link that has been created for data.
	
	## Reference
	
	[sc_containers.h:874](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:874:21)
	""" sc_list_append
	export sc_list_append
	𝐣𝐥.@cextern sc_list_append(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_insert(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	```
	
	 Insert an element after a given list position. 
	
	## Parameters
	
	  * `list`:     Valid list object.
	  * `pred`:     The predecessor of the element to be inserted.
	  * `data`:         A new link is created holding this data.
	
	## Returns
	
	                  The link that has been created for data.
	
	## Reference
	
	[sc_containers.h:882](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:882:21)
	""" sc_list_insert
	export sc_list_insert
	𝐣𝐥.@cextern sc_list_insert(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_remove(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Remove an element after a given list position. 
	
	## Parameters
	
	  * `list`:     Valid, non-empty list object.
	  * `pred`:  The predecessor of the element to be removed.                   If *pred* == NULL, the first element is removed,                   which is equivalent to calling sc_list_pop (list).
	
	## Returns
	
	           The data of the removed and freed link.
	
	## Reference
	
	[sc_containers.h:892](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:892:21)
	""" sc_list_remove
	export sc_list_remove
	𝐣𝐥.@cextern sc_list_remove(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_pop(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Remove an element from the front of the list. 
	
	## Parameters
	
	  * `list`:     Valid, non-empty list object.
	
	## Returns
	
	 Returns the data of the removed first list element.
	
	## Reference
	
	[sc_containers.h:898](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:898:21)
	""" sc_list_pop
	export sc_list_pop
	𝐣𝐥.@cextern sc_list_pop(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	 The sc_hash implements a hash table. It uses an array which has linked lists as elements.
	
	## Reference
	
	[sc_containers.h:917](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:917:1)
	""" sc_hash_t
	𝐣𝐥.@doc """
	 The sc_hash implements a hash table. It uses an array which has linked lists as elements.
	
	## Reference
	
	[sc_containers.h:903](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:903:16)
	""" sc_hash
	export sc_hash, sc_hash_t
	𝐣𝐥.@ctypedef sc_hash_t 𝐣𝐥.@cstruct sc_hash {
		elem_count::size_t
		slots::𝐣𝐥.Ptr{sc_array_t}
		user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		hash_fn::sc_hash_function_t
		equal_fn::sc_equal_function_t
		(resize_checks, resize_actions)::size_t
		allocator_owned::𝐣𝐥.Cint
		allocator::𝐣𝐥.Ptr{sc_mempool_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_function_string(s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, u::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cuint
	```
	
	 Compute a hash value from a null-terminated string. This hash function is NOT cryptographically safe! Use libcrypt then. 
	
	## Parameters
	
	  * `s`:        Null-terminated string to be hashed.
	  * `u`:        Not used.
	
	## Returns
	
	              The computed hash value as an unsigned integer.
	
	## Reference
	
	[sc_containers.h:925](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:925:21)
	""" sc_hash_function_string
	export sc_hash_function_string
	𝐣𝐥.@cextern sc_hash_function_string(s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, u::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_memory_used(hash::𝐣𝐥.Ptr{sc_hash_t})::size_t
	```
	
	 Calculate the memory used by a hash table. 
	
	## Parameters
	
	  * `hash`:        The hash table.
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:931](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:931:21)
	""" sc_hash_memory_used
	export sc_hash_memory_used
	𝐣𝐥.@cextern sc_hash_memory_used(hash::𝐣𝐥.Ptr{sc_hash_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_new(hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_hash_t}
	```
	
	 Create a new hash table. The number of hash slots is chosen dynamically. 
	
	## Parameters
	
	  * `hash_fn`:     Function to compute the hash value.
	  * `equal_fn`:    Function to test two objects for equality.
	  * `user_data`:   User data passed through to the hash function.
	  * `allocator`:   Memory allocator for sc_link_t, can be NULL.
	
	## Reference
	
	[sc_containers.h:940](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:940:21)
	""" sc_hash_new
	export sc_hash_new
	𝐣𝐥.@cextern sc_hash_new(hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_hash_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a hash table.
	
	## Details
	
	 If the allocator is owned, this runs in O(1), otherwise in O(N). 
	
	NOTE: If allocator was provided in sc_hash_new, it will not be destroyed.
	
	## Reference
	
	[sc_containers.h:949](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:949:21)
	""" sc_hash_destroy
	export sc_hash_destroy
	𝐣𝐥.@cextern sc_hash_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_destroy_null(phash::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_hash_t}})::𝐣𝐥.Cvoid
	```
	
	 Destroy a hash table and set its pointer to NULL. Destruction is done using sc_hash_destroy. 
	
	## Parameters
	
	  * `phash`:        Address of pointer to hash table.                              On output, pointer is NULLed.
	
	## Reference
	
	[sc_containers.h:956](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:956:21)
	""" sc_hash_destroy_null
	export sc_hash_destroy_null
	𝐣𝐥.@cextern sc_hash_destroy_null(phash::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_hash_t}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_truncate(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Remove all entries from a hash table in O(N).
	
	## Details
	
	 If the allocator is owned, it calls sc_hash_unlink and sc_mempool_truncate. Otherwise, it calls sc_list_reset on every hash slot which is slower.
	
	## Reference
	
	[sc_containers.h:963](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:963:21)
	""" sc_hash_truncate
	export sc_hash_truncate
	𝐣𝐥.@cextern sc_hash_truncate(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_unlink(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Unlink all hash elements without returning them to the mempool.
	
	## Details
	
	 If the allocator is not owned, this runs faster than sc_hash_truncate,    but is dangerous because of potential memory leaks. 
	
	## Parameters
	
	  * `hash`:       Hash structure to be unlinked.
	
	## Reference
	
	[sc_containers.h:971](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:971:21)
	""" sc_hash_unlink
	export sc_hash_unlink
	𝐣𝐥.@cextern sc_hash_unlink(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_unlink_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Same effect as unlink and destroy, but in O(1). This is dangerous because of potential memory leaks. 
	
	## Parameters
	
	  * `hash`:       Hash structure to be unlinked and destroyed.
	
	## Reference
	
	[sc_containers.h:977](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:977:21)
	""" sc_hash_unlink_destroy
	export sc_hash_unlink_destroy
	𝐣𝐥.@cextern sc_hash_unlink_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_lookup(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	```
	
	 Check if an object is contained in the hash table. 
	
	## Parameters
	
	  * `v`:      The object to be looked up.
	  * `found`:  If found != NULL, *found is set to the address of the                     pointer to the already contained object if the object                     is found.  You can assign to **found to override.
	
	## Returns
	
	 Returns true if object is found, false otherwise.
	
	## Reference
	
	[sc_containers.h:986](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:986:21)
	""" sc_hash_lookup
	export sc_hash_lookup
	𝐣𝐥.@cextern sc_hash_lookup(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_insert_unique(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	```
	
	 Insert an object into a hash table if it is not contained already. 
	
	## Parameters
	
	  * `v`:      The object to be inserted.
	  * `found`:  If found != NULL, *found is set to the address of the                     pointer to the already contained, or if not present,                     the new object.  You can assign to **found to override.
	
	## Returns
	
	 Returns true if object is added, false if it is already contained.
	
	## Reference
	
	[sc_containers.h:995](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:995:21)
	""" sc_hash_insert_unique
	export sc_hash_insert_unique
	𝐣𝐥.@cextern sc_hash_insert_unique(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_remove(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}})::𝐣𝐥.Cint
	```
	
	 Remove an object from a hash table. 
	
	## Parameters
	
	  * `v`:      The object to be removed.
	  * `found`:  If found != NULL, *found is set to the object                       that is removed if that exists.
	
	## Returns
	
	 Returns true if object is found, false if is not contained.
	
	## Reference
	
	[sc_containers.h:1004](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1004:21)
	""" sc_hash_remove
	export sc_hash_remove
	𝐣𝐥.@cextern sc_hash_remove(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_foreach(hash::𝐣𝐥.Ptr{sc_hash_t}, fn::sc_hash_foreach_t)::𝐣𝐥.Cvoid
	```
	
	 Invoke a callback for every member of the hash table. The functions hash_fn and equal_fn are not called by this function.
	
	## Reference
	
	[sc_containers.h:1009](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1009:21)
	""" sc_hash_foreach
	export sc_hash_foreach
	𝐣𝐥.@cextern sc_hash_foreach(hash::𝐣𝐥.Ptr{sc_hash_t}, fn::sc_hash_foreach_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_print_statistics(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint, hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Compute and print statistical information about the occupancy.
	
	## Reference
	
	[sc_containers.h:1013](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1013:21)
	""" sc_hash_print_statistics
	export sc_hash_print_statistics
	𝐣𝐥.@cextern sc_hash_print_statistics(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint, hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_containers.h:1025](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1025:1)
	""" sc_hash_array_data_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_containers.h:1017](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1017:16)
	""" sc_hash_array_data
	export sc_hash_array_data, sc_hash_array_data_t
	𝐣𝐥.@ctypedef sc_hash_array_data_t 𝐣𝐥.@cstruct sc_hash_array_data {
		pa::𝐣𝐥.Ptr{sc_array_t}
		hash_fn::sc_hash_function_t
		equal_fn::sc_equal_function_t
		user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		current_item::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	}
	
	𝐣𝐥.@doc """
	 The sc_hash_array implements an array backed up by a hash table. This enables O(1) access for array elements.
	
	## Reference
	
	[sc_containers.h:1037](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1037:1)
	""" sc_hash_array_t
	𝐣𝐥.@doc """
	 The sc_hash_array implements an array backed up by a hash table. This enables O(1) access for array elements.
	
	## Reference
	
	[sc_containers.h:1030](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1030:16)
	""" sc_hash_array
	export sc_hash_array, sc_hash_array_t
	𝐣𝐥.@ctypedef sc_hash_array_t 𝐣𝐥.@cstruct sc_hash_array {
		a::sc_array_t
		internal_data::sc_hash_array_data_t
		h::𝐣𝐥.Ptr{sc_hash_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_memory_used(ha::𝐣𝐥.Ptr{sc_hash_array_t})::size_t
	```
	
	 Calculate the memory used by a hash array. 
	
	## Parameters
	
	  * `ha`:          The hash array.
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:1043](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1043:21)
	""" sc_hash_array_memory_used
	export sc_hash_array_memory_used
	𝐣𝐥.@cextern sc_hash_array_memory_used(ha::𝐣𝐥.Ptr{sc_hash_array_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_new(elem_size::size_t, hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_hash_array_t}
	```
	
	 Create a new hash array. 
	
	## Parameters
	
	  * `elem_size`:   Size of one array element in bytes.
	  * `hash_fn`:     Function to compute the hash value.
	  * `equal_fn`:    Function to test two objects for equality.
	
	## Reference
	
	[sc_containers.h:1050](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1050:21)
	""" sc_hash_array_new
	export sc_hash_array_new
	𝐣𝐥.@cextern sc_hash_array_new(elem_size::size_t, hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_hash_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_destroy(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a hash array.
	
	## Reference
	
	[sc_containers.h:1057](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1057:21)
	""" sc_hash_array_destroy
	export sc_hash_array_destroy
	𝐣𝐥.@cextern sc_hash_array_destroy(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_is_valid(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cint
	```
	
	 Check the internal consistency of a hash array.
	
	## Reference
	
	[sc_containers.h:1061](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1061:21)
	""" sc_hash_array_is_valid
	export sc_hash_array_is_valid
	𝐣𝐥.@cextern sc_hash_array_is_valid(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_truncate(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	```
	
	 Remove all elements from the hash array. 
	
	## Parameters
	
	  * `hash_array`:   Hash array to truncate.
	
	## Reference
	
	[sc_containers.h:1066](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1066:21)
	""" sc_hash_array_truncate
	export sc_hash_array_truncate
	𝐣𝐥.@cextern sc_hash_array_truncate(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_lookup(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Check if an object is contained in a hash array.
	
	## Parameters
	
	  * `v`:          A pointer to the object.
	  * `position`:   If position != NULL, *position is set to the                         array position of the already contained object                         if found.
	
	## Returns
	
	                 Returns true if object is found, false otherwise.
	
	## Reference
	
	[sc_containers.h:1076](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1076:21)
	""" sc_hash_array_lookup
	export sc_hash_array_lookup
	𝐣𝐥.@cextern sc_hash_array_lookup(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_insert_unique(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Insert an object into a hash array if it is not contained already. The object is not copied into the array.  Use the return value for that. New objects are guaranteed to be added at the end of the array.
	
	## Parameters
	
	  * `v`:          A pointer to the object.  Used for search only.
	  * `position`:   If position != NULL, *position is set to the                         array position of the already contained, or if                         not present, the new object.
	
	## Returns
	
	                 Returns NULL if the object is already contained.                         Otherwise returns its new address in the array.
	
	## Reference
	
	[sc_containers.h:1090](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1090:21)
	""" sc_hash_array_insert_unique
	export sc_hash_array_insert_unique
	𝐣𝐥.@cextern sc_hash_array_insert_unique(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_rip(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, rip::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Extract the array data from a hash array and destroy everything else. 
	
	## Parameters
	
	  * `hash_array`:   The hash array is destroyed after extraction.
	  * `rip`:          Array structure that will be overwritten.                          All previous array data (if any) will be leaked.                          The filled array can be freed with sc_array_reset.
	
	## Reference
	
	[sc_containers.h:1099](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1099:21)
	""" sc_hash_array_rip
	export sc_hash_array_rip
	𝐣𝐥.@cextern sc_hash_array_rip(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, rip::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 The sc_recycle_array object provides an array of slots that can be reused.
	
	## Details
	
	 It keeps a list of free slots in the array which will be used for insertion while available.  Otherwise, the array is grown.
	
	## Reference
	
	[sc_containers.h:1116](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1116:1)
	""" sc_recycle_array_t
	𝐣𝐥.@doc """
	 The sc_recycle_array object provides an array of slots that can be reused.
	
	## Details
	
	 It keeps a list of free slots in the array which will be used for insertion while available.  Otherwise, the array is grown.
	
	## Reference
	
	[sc_containers.h:1107](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1107:16)
	""" sc_recycle_array
	export sc_recycle_array, sc_recycle_array_t
	𝐣𝐥.@ctypedef sc_recycle_array_t 𝐣𝐥.@cstruct sc_recycle_array {
		elem_count::size_t
		a::sc_array_t
		f::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_init(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initialize a recycle array.
	
	## Parameters
	
	  * `elem_size`:   Size of the objects to be stored in the array.
	
	## Reference
	
	[sc_containers.h:1122](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1122:21)
	""" sc_recycle_array_init
	export sc_recycle_array_init
	𝐣𝐥.@cextern sc_recycle_array_init(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_reset(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t})::𝐣𝐥.Cvoid
	```
	
	 Reset a recycle array.
	
	## Details
	
	 As with all _reset functions, calling _init, then any array operations, then _reset is memory neutral.
	
	## Reference
	
	[sc_containers.h:1130](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1130:21)
	""" sc_recycle_array_reset
	export sc_recycle_array_reset
	𝐣𝐥.@cextern sc_recycle_array_reset(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_insert(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Insert an object into the recycle array. The object is not copied into the array.  Use the return value for that.
	
	## Parameters
	
	  * `position`:   If position != NULL, *position is set to the                         array position of the inserted object.
	
	## Returns
	
	                 Returns the new address of the object in the array.
	
	## Reference
	
	[sc_containers.h:1139](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1139:21)
	""" sc_recycle_array_insert
	export sc_recycle_array_insert
	𝐣𝐥.@cextern sc_recycle_array_insert(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_remove(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Remove an object from the recycle array.  It must be valid.
	
	## Parameters
	
	  * `position`:   Index into the array for the object to remove.
	
	## Returns
	
	                The pointer to the removed object.  Will be valid                        as long as no other function is called                        on this recycle array.
	
	## Reference
	
	[sc_containers.h:1149](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_containers.h:1149:21)
	""" sc_recycle_array_remove
	export sc_recycle_array_remove
	𝐣𝐥.@cextern sc_recycle_array_remove(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	 The value of zero means no error. 
	
	## Reference
	
	[sc_io.h:36](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:36:3)
	""" SC_IO_ERROR_NONE
	𝐣𝐥.@doc """
	 The io object is now disfunctional. 
	
	## Reference
	
	[sc_io.h:37](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:37:3)
	""" SC_IO_ERROR_FATAL
	𝐣𝐥.@doc """
	 Another io operation may resolve it.                                The function just returned was a noop. 
	
	## Reference
	
	[sc_io.h:38](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:38:3)
	""" SC_IO_ERROR_AGAIN
	𝐣𝐥.@doc """
	 Error values for io.
	
	## Reference
	
	[sc_io.h:41](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:41:1)
	""" sc_io_error_t
	export SC_IO_ERROR_AGAIN, SC_IO_ERROR_FATAL, SC_IO_ERROR_NONE, sc_io_error_t
	𝐣𝐥.@ctypedef sc_io_error_t 𝐣𝐥.@cenum {
		SC_IO_ERROR_NONE = 𝐣𝐥.Cint(0)
		SC_IO_ERROR_FATAL = 𝐣𝐥.Cint(-1)
		SC_IO_ERROR_AGAIN = 𝐣𝐥.Cint(-2)
	}
	
	𝐣𝐥.@doc """
	 Semantics as \"a\" in fopen. 
	
	## Reference
	
	[sc_io.h:46](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:46:3)
	""" SC_IO_MODE_APPEND
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:49](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:49:1)
	""" sc_io_mode_t
	𝐣𝐥.@doc """
	 Invalid entry to close list 
	
	## Reference
	
	[sc_io.h:47](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:47:3)
	""" SC_IO_MODE_LAST
	𝐣𝐥.@doc """
	 Semantics as \"w\" in fopen. 
	
	## Reference
	
	[sc_io.h:45](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:45:3)
	""" SC_IO_MODE_WRITE
	export SC_IO_MODE_APPEND, SC_IO_MODE_LAST, SC_IO_MODE_WRITE, sc_io_mode_t
	𝐣𝐥.@ctypedef sc_io_mode_t 𝐣𝐥.@cenum {
		SC_IO_MODE_WRITE = 𝐣𝐥.Cuint(0)
		SC_IO_MODE_APPEND = 𝐣𝐥.Cuint(1)
		SC_IO_MODE_LAST = 𝐣𝐥.Cuint(2)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:53](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:53:3)
	""" SC_IO_ENCODE_NONE
	𝐣𝐥.@doc """
	 Invalid entry to close list 
	
	## Reference
	
	[sc_io.h:54](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:54:3)
	""" SC_IO_ENCODE_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:56:1)
	""" sc_io_encode_t
	export SC_IO_ENCODE_LAST, SC_IO_ENCODE_NONE, sc_io_encode_t
	𝐣𝐥.@ctypedef sc_io_encode_t 𝐣𝐥.@cenum {
		SC_IO_ENCODE_NONE = 𝐣𝐥.Cuint(0)
		SC_IO_ENCODE_LAST = 𝐣𝐥.Cuint(1)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:65](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:65:1)
	""" sc_io_type_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:60](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:60:3)
	""" SC_IO_TYPE_BUFFER
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:61](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:61:3)
	""" SC_IO_TYPE_FILENAME
	𝐣𝐥.@doc """
	 Invalid entry to close list 
	
	## Reference
	
	[sc_io.h:63](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:63:3)
	""" SC_IO_TYPE_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:62](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:62:3)
	""" SC_IO_TYPE_FILEFILE
	export SC_IO_TYPE_BUFFER, SC_IO_TYPE_FILEFILE, SC_IO_TYPE_FILENAME, SC_IO_TYPE_LAST, sc_io_type_t
	𝐣𝐥.@ctypedef sc_io_type_t 𝐣𝐥.@cenum {
		SC_IO_TYPE_BUFFER = 𝐣𝐥.Cuint(0)
		SC_IO_TYPE_FILENAME = 𝐣𝐥.Cuint(1)
		SC_IO_TYPE_FILEFILE = 𝐣𝐥.Cuint(2)
		SC_IO_TYPE_LAST = 𝐣𝐥.Cuint(3)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:78](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:78:1)
	""" sc_io_sink_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:67](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:67:16)
	""" sc_io_sink
	export sc_io_sink, sc_io_sink_t
	𝐣𝐥.@ctypedef sc_io_sink_t 𝐣𝐥.@cstruct sc_io_sink {
		iotype::sc_io_type_t
		mode::sc_io_mode_t
		encode::sc_io_encode_t
		buffer::𝐣𝐥.Ptr{sc_array_t}
		buffer_bytes::size_t
		file::𝐣𝐥.Ptr{FILE}
		bytes_in::size_t
		bytes_out::size_t
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:92:1)
	""" sc_io_source_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:80](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:80:16)
	""" sc_io_source
	export sc_io_source, sc_io_source_t
	𝐣𝐥.@ctypedef sc_io_source_t 𝐣𝐥.@cstruct sc_io_source {
		iotype::sc_io_type_t
		encode::sc_io_encode_t
		buffer::𝐣𝐥.Ptr{sc_array_t}
		buffer_bytes::size_t
		file::𝐣𝐥.Ptr{FILE}
		bytes_in::size_t
		bytes_out::size_t
		mirror::𝐣𝐥.Ptr{sc_io_sink_t}
		mirror_buffer::𝐣𝐥.Ptr{sc_array_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_new(iotype::sc_io_type_t, mode::sc_io_mode_t, encode::sc_io_encode_t, var\"?vararg?\"...)::𝐣𝐥.Ptr{sc_io_sink_t}
	```
	
	 Create a generic data sink. 
	
	## Parameters
	
	  * `iotype`:           Type of the sink.                              Depending on iotype, varargs must follow:                              BUFFER: sc_array_t * (existing array).                              FILENAME: const char * (name of file to open).                              FILEFILE: FILE * (file open for writing).                              These buffers are only borrowed by the sink.
	  * `mode`:             Mode to add data to sink.                              For type FILEFILE, data is always appended.
	  * `encode`:           Type of data encoding.
	
	## Returns
	
	                      Newly allocated sink, or NULL on error.
	
	## Reference
	
	[sc_io.h:106](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:106:21)
	""" sc_io_sink_new
	export sc_io_sink_new
	𝐣𝐥.@cextern sc_io_sink_new(iotype::sc_io_type_t, mode::sc_io_mode_t, encode::sc_io_encode_t, var"?vararg?"...)::𝐣𝐥.Ptr{sc_io_sink_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_destroy(sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	```
	
	 Free data sink. Calls sc_io_sink_complete and discards the final counts. Errors from complete lead to SC_IO_ERROR_FATAL returned from this function. Call sc_io_sink_complete yourself if bytes_out is of interest. 
	
	## Parameters
	
	  * `sink`:         The sink object to complete and free.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:117](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:117:21)
	""" sc_io_sink_destroy
	export sc_io_sink_destroy
	𝐣𝐥.@cextern sc_io_sink_destroy(sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_write(sink::𝐣𝐥.Ptr{sc_io_sink_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, bytes_avail::size_t)::𝐣𝐥.Cint
	```
	
	 Write data to a sink.  Data may be buffered and sunk in a later call. The internal counters sink->bytes_in and sink->bytes_out are updated. 
	
	## Parameters
	
	  * `sink`:         The sink object to write to.
	  * `data`:             Data passed into sink.
	  * `bytes_avail`:      Number of data bytes passed in.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:126](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:126:21)
	""" sc_io_sink_write
	export sc_io_sink_write
	𝐣𝐥.@cextern sc_io_sink_write(sink::𝐣𝐥.Ptr{sc_io_sink_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, bytes_avail::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_complete(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Flush all buffered output data to sink. This function may return SC_IO_ERROR_AGAIN if another write is required. Currently this may happen if BUFFER requires an integer multiple of bytes. If successful, the updated value of bytes read and written is returned in bytes_in/out, and the sink status is reset as if the sink had just been created.  In particular, the bytes counters are reset to zero. The internal state of the sink is not changed otherwise. It is legal to continue writing to the sink hereafter. The sink actions taken depend on its type. BUFFER, FILEFILE: none. FILENAME: call fclose on sink->file. 
	
	## Parameters
	
	  * `sink`:         The sink object to write to.
	  * `bytes_in`:     Bytes received since the last new or complete                              call.  May be NULL.
	  * `bytes_out`:    Bytes written since the last new or complete                              call.  May be NULL.
	
	## Returns
	
	                      0 if completed, nonzero on error.
	
	## Reference
	
	[sc_io.h:147](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:147:21)
	""" sc_io_sink_complete
	export sc_io_sink_complete
	𝐣𝐥.@cextern sc_io_sink_complete(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_align(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_align::size_t)::𝐣𝐥.Cint
	```
	
	 Align sink to a byte boundary by writing zeros. 
	
	## Parameters
	
	  * `sink`:         The sink object to align.
	  * `bytes_align`:      Byte boundary.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:156](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:156:21)
	""" sc_io_sink_align
	export sc_io_sink_align
	𝐣𝐥.@cextern sc_io_sink_align(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_align::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_new(iotype::sc_io_type_t, encode::sc_io_encode_t, var\"?vararg?\"...)::𝐣𝐥.Ptr{sc_io_source_t}
	```
	
	 Create a generic data source. 
	
	## Parameters
	
	  * `iotype`:           Type of the source.                              Depending on iotype, varargs must follow:                              BUFFER: sc_array_t * (existing array).                              FILENAME: const char * (name of file to open).                              FILEFILE: FILE * (file open for reading).
	  * `encode`:           Type of data encoding.
	
	## Returns
	
	                      Newly allocated source, or NULL on error.
	
	## Reference
	
	[sc_io.h:168](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:168:21)
	""" sc_io_source_new
	export sc_io_source_new
	𝐣𝐥.@cextern sc_io_source_new(iotype::sc_io_type_t, encode::sc_io_encode_t, var"?vararg?"...)::𝐣𝐥.Ptr{sc_io_source_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_destroy(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	```
	
	 Free data source. Calls sc_io_source_complete and requires it to return no error. This is to avoid discarding buffered data that has not been passed to read. 
	
	## Parameters
	
	  * `source`:       The source object to free.
	
	## Returns
	
	                      0 on success.  Nonzero if an error is                              encountered or is_complete returns one.
	
	## Reference
	
	[sc_io.h:178](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:178:21)
	""" sc_io_source_destroy
	export sc_io_source_destroy
	𝐣𝐥.@cextern sc_io_source_destroy(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_read(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Read data from a source. The internal counters source->bytes_in and source->bytes_out are updated. Data is read until the data buffer has not enough room anymore, or source becomes empty.  It is possible that data already read internally remains in the source object for the next call.  Call sc_io_source_complete and check its return value to find out. Returns an error if bytes_out is NULL and less than bytes_avail are read. 
	
	## Parameters
	
	  * `source`:       The source object to read from.
	  * `data`:             Data buffer for reading from sink.                              If NULL the output data will be thrown away.
	  * `bytes_avail`:      Number of bytes available in data buffer.
	  * `bytes_out`:    If not NULL, byte count read into data buffer.                              Otherwise, requires to read exactly bytes_avail.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:195](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:195:21)
	""" sc_io_source_read
	export sc_io_source_read
	𝐣𝐥.@cextern sc_io_source_read(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_complete(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Determine whether all data buffered from source has been returned by read. If it returns SC_IO_ERROR_AGAIN, another sc_io_source_read is required. If the call returns no error, the internal counters source->bytes_in and source->bytes_out are returned to the caller if requested, and reset to 0. The internal state of the source is not changed otherwise. It is legal to continue reading from the source hereafter.
	
	## Parameters
	
	  * `source`:       The source object to read from.
	  * `bytes_in`:     If not NULL and true is returned,                              the total size of the data sourced.
	  * `bytes_out`:    If not NULL and true is returned,                              total bytes passed out by source_read.
	
	## Returns
	
	                      SC_IO_ERROR_AGAIN if buffered data remaining.                              Otherwise return ERROR_NONE and reset counters.
	
	## Reference
	
	[sc_io.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:214:21)
	""" sc_io_source_complete
	export sc_io_source_complete
	𝐣𝐥.@cextern sc_io_source_complete(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_align(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_align::size_t)::𝐣𝐥.Cint
	```
	
	 Align source to a byte boundary by skipping. 
	
	## Parameters
	
	  * `source`:       The source object to align.
	  * `bytes_align`:      Byte boundary.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:223](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:223:21)
	""" sc_io_source_align
	export sc_io_source_align
	𝐣𝐥.@cextern sc_io_source_align(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_align::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_activate_mirror(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	```
	
	 Activate a buffer that mirrors (i.e., stores) the data that was read. 
	
	## Parameters
	
	  * `source`:       The source object to activate mirror in.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:230](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:230:21)
	""" sc_io_source_activate_mirror
	export sc_io_source_activate_mirror
	𝐣𝐥.@cextern sc_io_source_activate_mirror(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_read_mirror(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Read data from the source's mirror. Same behaviour as sc_io_source_read. 
	
	## Parameters
	
	  * `source`:       The source object to read mirror data from.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:237](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:237:21)
	""" sc_io_source_read_mirror
	export sc_io_source_read_mirror
	𝐣𝐥.@cextern sc_io_source_read_mirror(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_vtk_write_binary(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	```
	
	 This function writes numeric binary data in VTK base64 encoding. 
	
	## Parameters
	
	  * `vtkfile`:        Stream opened for writing.
	  * `numeric_data`:   A pointer to a numeric data array.
	  * `byte_length`:    The length of the data array in bytes.
	
	## Returns
	
	               Returns 0 on success, -1 on file error.
	
	## Reference
	
	[sc_io.h:248](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:248:21)
	""" sc_vtk_write_binary
	export sc_vtk_write_binary
	𝐣𝐥.@cextern sc_vtk_write_binary(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_vtk_write_compressed(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	```
	
	 This function writes numeric binary data in VTK compressed format. 
	
	## Parameters
	
	  * `vtkfile`:        Stream opened for writing.
	  * `numeric_data`:   A pointer to a numeric data array.
	  * `byte_length`:    The length of the data array in bytes.
	
	## Returns
	
	               Returns 0 on success, -1 on file error.
	
	## Reference
	
	[sc_io.h:257](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:257:21)
	""" sc_vtk_write_compressed
	export sc_vtk_write_compressed
	𝐣𝐥.@cextern sc_vtk_write_compressed(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_fwrite(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Write memory content to a file. 
	
	## Parameters
	
	  * `ptr`:      Data array to write to disk.
	  * `size`:     Size of one array member.
	  * `nmemb`:    Number of array members.
	  * `file`: File pointer, must be opened for writing.
	  * `errmsg`:   Error message passed to SC_CHECK_ABORT.
	
	NOTE:                This function aborts on file errors.
	
	## Reference
	
	[sc_io.h:269](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:269:21)
	""" sc_fwrite
	export sc_fwrite
	𝐣𝐥.@cextern sc_fwrite(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_fread(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Read file content into memory. 
	
	## Parameters
	
	  * `ptr`:     Data array to read from disk.
	  * `size`:     Size of one array member.
	  * `nmemb`:    Number of array members.
	  * `file`: File pointer, must be opened for reading.
	  * `errmsg`:   Error message passed to SC_CHECK_ABORT.
	
	NOTE:                This function aborts on file errors.
	
	## Reference
	
	[sc_io.h:280](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:280:21)
	""" sc_fread
	export sc_fread
	𝐣𝐥.@cextern sc_fread(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_fflush_fsync_fclose(file::𝐣𝐥.Ptr{FILE})::𝐣𝐥.Cvoid
	```
	
	 Best effort to flush a file's data to disc and close it. 
	
	## Parameters
	
	  * `file`:         File open for writing.
	
	## Reference
	
	[sc_io.h:286](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_io.h:286:21)
	""" sc_fflush_fsync_fclose
	export sc_fflush_fsync_fclose
	𝐣𝐥.@cextern sc_fflush_fsync_fclose(file::𝐣𝐥.Ptr{FILE})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 Typedef for quadrant coordinates. 
	
	## Reference
	
	[p4est_base.h:78](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:78:21)
	""" p4est_qcoord_t
	export p4est_qcoord_t
	𝐣𝐥.@ctypedef p4est_qcoord_t int32_t
	
	𝐣𝐥.@doc """
	 Typedef for counting topological entities (trees, tree vertices). 
	
	## Reference
	
	[p4est_base.h:90](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:90:21)
	""" p4est_topidx_t
	export p4est_topidx_t
	𝐣𝐥.@ctypedef p4est_topidx_t int32_t
	
	𝐣𝐥.@doc """
	 Typedef for processor-local indexing of quadrants and nodes. 
	
	## Reference
	
	[p4est_base.h:103](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:103:21)
	""" p4est_locidx_t
	export p4est_locidx_t
	𝐣𝐥.@ctypedef p4est_locidx_t int32_t
	
	𝐣𝐥.@doc """
	 Typedef for globally unique indexing of quadrants. 
	
	## Reference
	
	[p4est_base.h:115](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:115:21)
	""" p4est_gloidx_t
	export p4est_gloidx_t
	𝐣𝐥.@ctypedef p4est_gloidx_t int64_t
	
	𝐣𝐥.@doc """
	 Tags for MPI messages 
	
	## Reference
	
	[p4est_base.h:127](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:127:14)
	""" p4est_comm_tag
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:153](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:153:3)
	""" P4EST_COMM_LNODES_ALL
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:136](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:136:3)
	""" P4EST_COMM_PARTITION_WEIGHTED_LOW
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:135](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:135:3)
	""" P4EST_COMM_PARTITION_GIVEN
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:138](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:138:3)
	""" P4EST_COMM_PARTITION_CORRECTION
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:143](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:143:3)
	""" P4EST_COMM_GHOST_EXPAND_LOAD
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:148](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:148:3)
	""" P4EST_COMM_NODES_REPLY
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:139](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:139:3)
	""" P4EST_COMM_GHOST_COUNT
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:134](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:134:3)
	""" P4EST_COMM_BALANCE_SECOND_LOAD
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:133](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:133:3)
	""" P4EST_COMM_BALANCE_SECOND_COUNT
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:137](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:137:3)
	""" P4EST_COMM_PARTITION_WEIGHTED_HIGH
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:146](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:146:3)
	""" P4EST_COMM_GHOST_CHECKSUM
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:130](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:130:3)
	""" P4EST_COMM_COUNT_PERTREE
	𝐣𝐥.@doc """
	 Tags for MPI messages 
	
	## Reference
	
	[p4est_base.h:156](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:156:1)
	""" p4est_comm_tag_t
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:154](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:154:3)
	""" P4EST_COMM_TAG_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:144](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:144:3)
	""" P4EST_COMM_GHOST_SUPPORT_COUNT
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:152](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:152:3)
	""" P4EST_COMM_LNODES_OWNED
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:140](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:140:3)
	""" P4EST_COMM_GHOST_LOAD
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:141](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:141:3)
	""" P4EST_COMM_GHOST_EXCHANGE
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:147](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:147:3)
	""" P4EST_COMM_NODES_QUERY
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:151](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:151:3)
	""" P4EST_COMM_LNODES_PASS
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:142](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:142:3)
	""" P4EST_COMM_GHOST_EXPAND_COUNT
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:131](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:131:3)
	""" P4EST_COMM_BALANCE_FIRST_COUNT
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:149](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:149:3)
	""" P4EST_COMM_SAVE
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:145](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:145:3)
	""" P4EST_COMM_GHOST_SUPPORT_LOAD
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:150](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:150:3)
	""" P4EST_COMM_LNODES_TEST
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:129](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:129:3)
	""" P4EST_COMM_TAG_FIRST
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:132](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:132:3)
	""" P4EST_COMM_BALANCE_FIRST_LOAD
	export P4EST_COMM_BALANCE_FIRST_COUNT, P4EST_COMM_BALANCE_FIRST_LOAD, P4EST_COMM_BALANCE_SECOND_COUNT, P4EST_COMM_BALANCE_SECOND_LOAD, P4EST_COMM_COUNT_PERTREE, P4EST_COMM_GHOST_CHECKSUM, P4EST_COMM_GHOST_COUNT, P4EST_COMM_GHOST_EXCHANGE, P4EST_COMM_GHOST_EXPAND_COUNT, P4EST_COMM_GHOST_EXPAND_LOAD, P4EST_COMM_GHOST_LOAD, P4EST_COMM_GHOST_SUPPORT_COUNT, P4EST_COMM_GHOST_SUPPORT_LOAD, P4EST_COMM_LNODES_ALL, P4EST_COMM_LNODES_OWNED, P4EST_COMM_LNODES_PASS, P4EST_COMM_LNODES_TEST, P4EST_COMM_NODES_QUERY, P4EST_COMM_NODES_REPLY, P4EST_COMM_PARTITION_CORRECTION, P4EST_COMM_PARTITION_GIVEN, P4EST_COMM_PARTITION_WEIGHTED_HIGH, P4EST_COMM_PARTITION_WEIGHTED_LOW, P4EST_COMM_SAVE, P4EST_COMM_TAG_FIRST, P4EST_COMM_TAG_LAST, p4est_comm_tag, p4est_comm_tag_t
	𝐣𝐥.@ctypedef p4est_comm_tag_t 𝐣𝐥.@cenum p4est_comm_tag {
		P4EST_COMM_TAG_FIRST = 𝐣𝐥.Cuint(214)
		P4EST_COMM_COUNT_PERTREE = 𝐣𝐥.Cuint(295)
		P4EST_COMM_BALANCE_FIRST_COUNT = 𝐣𝐥.Cuint(296)
		P4EST_COMM_BALANCE_FIRST_LOAD = 𝐣𝐥.Cuint(297)
		P4EST_COMM_BALANCE_SECOND_COUNT = 𝐣𝐥.Cuint(298)
		P4EST_COMM_BALANCE_SECOND_LOAD = 𝐣𝐥.Cuint(299)
		P4EST_COMM_PARTITION_GIVEN = 𝐣𝐥.Cuint(300)
		P4EST_COMM_PARTITION_WEIGHTED_LOW = 𝐣𝐥.Cuint(301)
		P4EST_COMM_PARTITION_WEIGHTED_HIGH = 𝐣𝐥.Cuint(302)
		P4EST_COMM_PARTITION_CORRECTION = 𝐣𝐥.Cuint(303)
		P4EST_COMM_GHOST_COUNT = 𝐣𝐥.Cuint(304)
		P4EST_COMM_GHOST_LOAD = 𝐣𝐥.Cuint(305)
		P4EST_COMM_GHOST_EXCHANGE = 𝐣𝐥.Cuint(306)
		P4EST_COMM_GHOST_EXPAND_COUNT = 𝐣𝐥.Cuint(307)
		P4EST_COMM_GHOST_EXPAND_LOAD = 𝐣𝐥.Cuint(308)
		P4EST_COMM_GHOST_SUPPORT_COUNT = 𝐣𝐥.Cuint(309)
		P4EST_COMM_GHOST_SUPPORT_LOAD = 𝐣𝐥.Cuint(310)
		P4EST_COMM_GHOST_CHECKSUM = 𝐣𝐥.Cuint(311)
		P4EST_COMM_NODES_QUERY = 𝐣𝐥.Cuint(312)
		P4EST_COMM_NODES_REPLY = 𝐣𝐥.Cuint(313)
		P4EST_COMM_SAVE = 𝐣𝐥.Cuint(314)
		P4EST_COMM_LNODES_TEST = 𝐣𝐥.Cuint(315)
		P4EST_COMM_LNODES_PASS = 𝐣𝐥.Cuint(316)
		P4EST_COMM_LNODES_OWNED = 𝐣𝐥.Cuint(317)
		P4EST_COMM_LNODES_ALL = 𝐣𝐥.Cuint(318)
		P4EST_COMM_TAG_LAST = 𝐣𝐥.Cuint(319)
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:214:21)
	""" P4EST_GLOBAL_LOGF
	export P4EST_GLOBAL_LOGF
	𝐣𝐥.@cextern P4EST_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:216](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:216:21)
	""" P4EST_LOGF
	export P4EST_LOGF
	𝐣𝐥.@cextern P4EST_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:234](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:234:21)
	""" P4EST_GLOBAL_TRACEF
	export P4EST_GLOBAL_TRACEF
	𝐣𝐥.@cextern P4EST_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:236](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:236:21)
	""" P4EST_GLOBAL_LDEBUGF
	export P4EST_GLOBAL_LDEBUGF
	𝐣𝐥.@cextern P4EST_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:238](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:238:21)
	""" P4EST_GLOBAL_VERBOSEF
	export P4EST_GLOBAL_VERBOSEF
	𝐣𝐥.@cextern P4EST_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:240](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:240:21)
	""" P4EST_GLOBAL_INFOF
	export P4EST_GLOBAL_INFOF
	𝐣𝐥.@cextern P4EST_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:242](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:242:21)
	""" P4EST_GLOBAL_STATISTICSF
	export P4EST_GLOBAL_STATISTICSF
	𝐣𝐥.@cextern P4EST_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:244](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:244:21)
	""" P4EST_GLOBAL_PRODUCTIONF
	export P4EST_GLOBAL_PRODUCTIONF
	𝐣𝐥.@cextern P4EST_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:246](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:246:21)
	""" P4EST_GLOBAL_ESSENTIALF
	export P4EST_GLOBAL_ESSENTIALF
	𝐣𝐥.@cextern P4EST_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:248](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:248:21)
	""" P4EST_GLOBAL_LERRORF
	export P4EST_GLOBAL_LERRORF
	𝐣𝐥.@cextern P4EST_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:280](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:280:21)
	""" P4EST_TRACEF
	export P4EST_TRACEF
	𝐣𝐥.@cextern P4EST_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:282](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:282:21)
	""" P4EST_LDEBUGF
	export P4EST_LDEBUGF
	𝐣𝐥.@cextern P4EST_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:284](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:284:21)
	""" P4EST_VERBOSEF
	export P4EST_VERBOSEF
	𝐣𝐥.@cextern P4EST_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:286](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:286:21)
	""" P4EST_INFOF
	export P4EST_INFOF
	𝐣𝐥.@cextern P4EST_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:288](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:288:21)
	""" P4EST_STATISTICSF
	export P4EST_STATISTICSF
	𝐣𝐥.@cextern P4EST_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:290](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:290:21)
	""" P4EST_PRODUCTIONF
	export P4EST_PRODUCTIONF
	𝐣𝐥.@cextern P4EST_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:292](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:292:21)
	""" P4EST_ESSENTIALF
	export P4EST_ESSENTIALF
	𝐣𝐥.@cextern P4EST_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_base.h:294](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:294:21)
	""" P4EST_LERRORF
	export P4EST_LERRORF
	𝐣𝐥.@cextern P4EST_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_package_id::𝐣𝐥.Cint
	```
	
	 the libsc package id for p4est (set in p4est_init()) 
	
	## Reference
	
	[p4est_base.h:319](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:319:21)
	""" p4est_package_id
	export p4est_package_id
	𝐣𝐥.@cextern p4est_package_id::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_init(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Registers p4est with the SC Library and sets the logging behavior. This function is optional. This function must only be called before additional threads are created. If this function is not called or called with log_handler == NULL, the default SC log handler will be used. If this function is not called or called with log_threshold == SC_LP_DEFAULT, the default SC log threshold will be used. The default SC log settings can be changed with sc_set_log_defaults ().
	
	## Reference
	
	[p4est_base.h:342](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:342:21)
	""" p4est_init
	export p4est_init
	𝐣𝐥.@cextern p4est_init(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	```
	
	 Return the full version of p4est.
	
	## Returns
	
	          Return the version of p4est using the format                  `VERSION_MAJOR.VERSION_MINOR.VERSION_POINT`,                  where `VERSION_POINT` can contain dots and                  characters, e.g. to indicate the additional                  number of commits and a git commit hash.
	
	## Reference
	
	[p4est_base.h:530](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:530:21)
	""" p4est_version
	export p4est_version
	𝐣𝐥.@cextern p4est_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_version_major()::𝐣𝐥.Cint
	```
	
	 Return the major version of p4est.
	
	## Returns
	
	          Return the major version of p4est.
	
	## Reference
	
	[p4est_base.h:536](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:536:21)
	""" p4est_version_major
	export p4est_version_major
	𝐣𝐥.@cextern p4est_version_major()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_version_minor()::𝐣𝐥.Cint
	```
	
	 Return the minor version of p4est.
	
	## Returns
	
	          Return the minor version of p4est.
	
	## Reference
	
	[p4est_base.h:542](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:542:21)
	""" p4est_version_minor
	export p4est_version_minor
	𝐣𝐥.@cextern p4est_version_minor()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	 Characterize a type of adjacency.
	
	## Details
	
	 Several functions involve relationships between neighboring trees and/or quadrants, and their behavior depends on how one defines adjacency: 1) entities are adjacent if they share a face, or 2) entities are adjacent if they share a face or corner. p4est_connect_type_t is used to choose the desired behavior. This enum must fit into an int8_t.
	
	## Reference
	
	[p4est_connectivity.h:94](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:94:1)
	""" p4est_connect_type_t
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:91](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:91:3)
	""" P4EST_CONNECT_CORNER
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:90](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:90:3)
	""" P4EST_CONNECT_FACE
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:92:3)
	""" P4EST_CONNECT_FULL
	export P4EST_CONNECT_CORNER, P4EST_CONNECT_FACE, P4EST_CONNECT_FULL, p4est_connect_type_t
	𝐣𝐥.@ctypedef p4est_connect_type_t 𝐣𝐥.@cenum {
		P4EST_CONNECT_FACE = 𝐣𝐥.Cuint(21)
		P4EST_CONNECT_CORNER = 𝐣𝐥.Cuint(22)
		P4EST_CONNECT_FULL = 𝐣𝐥.Cuint(22)
	}
	
	𝐣𝐥.@doc """
	 Invalid entry to close the list. 
	
	## Reference
	
	[p4est_connectivity.h:104](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:104:3)
	""" P4EST_CONN_ENCODE_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:103](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:103:3)
	""" P4EST_CONN_ENCODE_NONE
	𝐣𝐥.@doc """
	 Typedef for serialization method. 
	
	## Reference
	
	[p4est_connectivity.h:106](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:106:1)
	""" p4est_connectivity_encode_t
	export P4EST_CONN_ENCODE_LAST, P4EST_CONN_ENCODE_NONE, p4est_connectivity_encode_t
	𝐣𝐥.@ctypedef p4est_connectivity_encode_t 𝐣𝐥.@cenum {
		P4EST_CONN_ENCODE_NONE = 𝐣𝐥.Cuint(0)
		P4EST_CONN_ENCODE_LAST = 𝐣𝐥.Cuint(1)
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connect_type_int(btype::p4est_connect_type_t)::𝐣𝐥.Cint
	```
	
	 Convert the p4est_connect_type_t into a number. 
	
	## Parameters
	
	  * `btype`:    The balance type to convert.
	
	## Returns
	
	              Returns 1 or 2.
	
	## Reference
	
	[p4est_connectivity.h:112](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:112:21)
	""" p4est_connect_type_int
	export p4est_connect_type_int
	𝐣𝐥.@cextern p4est_connect_type_int(btype::p4est_connect_type_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connect_type_string(btype::p4est_connect_type_t)::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	```
	
	 Convert the p4est_connect_type_t into a const string. 
	
	## Parameters
	
	  * `btype`:    The balance type to convert.
	
	## Returns
	
	              Returns a pointer to a constant string.
	
	## Reference
	
	[p4est_connectivity.h:118](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:118:21)
	""" p4est_connect_type_string
	export p4est_connect_type_string
	𝐣𝐥.@cextern p4est_connect_type_string(btype::p4est_connect_type_t)::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	
	𝐣𝐥.@doc """
	 This structure holds the 2D inter-tree connectivity information. Identification of arbitrary faces and corners is possible.
	
	## Details
	
	 The arrays tree_to_* are stored in z ordering. For corners the order wrt. yx is 00 01 10 11. For faces the order is -x +x -y +y. They are allocated [0][0]..[0][3]..[num_trees-1][0]..[num_trees-1][3].
	
	 The values for tree_to_face are 0..7 where ttf % 4 gives the face number and ttf / 4 the face orientation code. The orientation is 0 for edges that are aligned in z-order, and 1 for edges that are running opposite in z-order.
	
	 It is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].
	
	 The corners are only stored when they connect trees. In this case tree_to_corner indexes into *ctt_offset.* Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.
	
	 The arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].
	
	 The *_to_attr arrays may have arbitrary contents defined by the user.
	
	## Reference
	
	[p4est_connectivity.h:151](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:151:16)
	""" p4est_connectivity
	𝐣𝐥.@doc """
	 This structure holds the 2D inter-tree connectivity information. Identification of arbitrary faces and corners is possible.
	
	## Details
	
	 The arrays tree_to_* are stored in z ordering. For corners the order wrt. yx is 00 01 10 11. For faces the order is -x +x -y +y. They are allocated [0][0]..[0][3]..[num_trees-1][0]..[num_trees-1][3].
	
	 The values for tree_to_face are 0..7 where ttf % 4 gives the face number and ttf / 4 the face orientation code. The orientation is 0 for edges that are aligned in z-order, and 1 for edges that are running opposite in z-order.
	
	 It is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].
	
	 The corners are only stored when they connect trees. In this case tree_to_corner indexes into *ctt_offset.* Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.
	
	 The arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].
	
	 The *_to_attr arrays may have arbitrary contents defined by the user.
	
	## Reference
	
	[p4est_connectivity.h:181](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:181:1)
	""" p4est_connectivity_t
	export p4est_connectivity, p4est_connectivity_t
	𝐣𝐥.@ctypedef p4est_connectivity_t 𝐣𝐥.@cstruct p4est_connectivity {
		num_vertices::p4est_topidx_t
		num_trees::p4est_topidx_t
		num_corners::p4est_topidx_t
		vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}
		tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t}
		tree_attr_bytes::size_t
		tree_to_attr::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
		tree_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		tree_to_face::𝐣𝐥.Ptr{int8_t}
		tree_to_corner::𝐣𝐥.Ptr{p4est_topidx_t}
		ctt_offset::𝐣𝐥.Ptr{p4est_topidx_t}
		corner_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		corner_to_corner::𝐣𝐥.Ptr{int8_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_memory_used(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::size_t
	```
	
	 Calculate memory usage of a connectivity structure. 
	
	## Parameters
	
	  * `conn`:   Connectivity structure.
	
	## Returns
	
	            Memory used in bytes.
	
	## Reference
	
	[p4est_connectivity.h:187](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:187:21)
	""" p4est_connectivity_memory_used
	export p4est_connectivity_memory_used
	𝐣𝐥.@cextern p4est_connectivity_memory_used(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::size_t
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:195](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:195:1)
	""" p4est_corner_transform_t
	export p4est_corner_transform_t
	𝐣𝐥.@ctypedef p4est_corner_transform_t 𝐣𝐥.@cstruct {
		ntree::p4est_topidx_t
		ncorner::int8_t
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:202](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:202:1)
	""" p4est_corner_info_t
	export p4est_corner_info_t
	𝐣𝐥.@ctypedef p4est_corner_info_t 𝐣𝐥.@cstruct {
		icorner::p4est_topidx_t
		corner_transforms::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[4]
	```
	
	 Store the corner numbers 0..4 for each tree face. 
	
	## Reference
	
	[p4est_connectivity.h:205](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:205:21)
	""" p4est_face_corners
	export p4est_face_corners
	𝐣𝐥.@cextern p4est_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[4]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_face_dual::𝐣𝐥.Cconst(𝐣𝐥.Cint)[4]
	```
	
	 Store the face numbers in the face neighbor's system. 
	
	## Reference
	
	[p4est_connectivity.h:208](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:208:21)
	""" p4est_face_dual
	export p4est_face_dual
	𝐣𝐥.@cextern p4est_face_dual::𝐣𝐥.Cconst(𝐣𝐥.Cint)[4]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[4]
	```
	
	 Store the face numbers 0..3 for each tree corner. 
	
	## Reference
	
	[p4est_connectivity.h:211](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:211:21)
	""" p4est_corner_faces
	export p4est_corner_faces
	𝐣𝐥.@cextern p4est_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[4]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_corner_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[4]
	```
	
	 Store the face corner numbers for the faces touching a tree corner. 
	
	## Reference
	
	[p4est_connectivity.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:214:21)
	""" p4est_corner_face_corners
	export p4est_corner_face_corners
	𝐣𝐥.@cextern p4est_corner_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[4]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_child_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[4]
	```
	
	 Store the faces for each child and corner, can be -1. 
	
	## Reference
	
	[p4est_connectivity.h:217](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:217:21)
	""" p4est_child_corner_faces
	export p4est_child_corner_faces
	𝐣𝐥.@cextern p4est_child_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[4]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_face_neighbor_face_corner(fc::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a face corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. 
	
	## Parameters
	
	  * `fc`:   A face corner number in 0..1.
	  * `f`:    A face that the face corner number *fc* is relative to.
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `o`:    The orientation between tree boundary faces *f* and nothing.
	
	## Returns
	
	          The face corner number relative to the neighbor's face.
	
	## Reference
	
	[p4est_connectivity.h:227](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:227:21)
	""" p4est_connectivity_face_neighbor_face_corner
	export p4est_connectivity_face_neighbor_face_corner
	𝐣𝐥.@cextern p4est_connectivity_face_neighbor_face_corner(fc::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_face_neighbor_corner(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. 
	
	## Parameters
	
	  * `c`:    A corner number in 0..3.
	  * `f`:    A face number that touches the corner *c.*
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `o`:    The orientation between tree boundary faces *f* and nothing.
	
	## Returns
	
	          The number of the corner seen from the neighbor tree.
	
	## Reference
	
	[p4est_connectivity.h:238](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:238:21)
	""" p4est_connectivity_face_neighbor_corner
	export p4est_connectivity_face_neighbor_corner
	𝐣𝐥.@cextern p4est_connectivity_face_neighbor_corner(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_corners::p4est_topidx_t, num_ctt::p4est_topidx_t)::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Allocate a connectivity structure. The attribute fields are initialized to NULL. 
	
	## Parameters
	
	  * `num_vertices`:   Number of total vertices (i.e. geometric points).
	  * `num_trees`:      Number of trees in the forest.
	  * `num_corners`:    Number of tree-connecting corners.
	  * `num_ctt`:        Number of total trees in corner_to_tree array.
	
	## Returns
	
	                    A connectivity structure with allocated arrays.
	
	## Reference
	
	[p4est_connectivity.h:249](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:249:23)
	""" p4est_connectivity_new
	export p4est_connectivity_new
	𝐣𝐥.@cextern p4est_connectivity_new(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_corners::p4est_topidx_t, num_ctt::p4est_topidx_t)::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_copy(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_corners::p4est_topidx_t, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cdouble)}, ttv::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttf::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, ttc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, coff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)})::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Allocate a connectivity structure and populate from constants. The attribute fields are initialized to NULL. 
	
	## Parameters
	
	  * `num_vertices`:   Number of total vertices (i.e. geometric points).
	  * `num_trees`:      Number of trees in the forest.
	  * `num_corners`:    Number of tree-connecting corners.
	  * `coff`:           Corner-to-tree offsets (num_corners + 1 values).                            This must always be non-NULL; in trivial cases                            it is just a pointer to a p4est_topix value of 0.
	
	## Returns
	
	                    The connectivity is checked for validity.
	
	## Reference
	
	[p4est_connectivity.h:264](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:264:23)
	""" p4est_connectivity_new_copy
	export p4est_connectivity_new_copy
	𝐣𝐥.@cextern p4est_connectivity_new_copy(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_corners::p4est_topidx_t, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cdouble)}, ttv::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttf::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, ttc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, coff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)})::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_bcast(conn_in::𝐣𝐥.Ptr{p4est_connectivity_t}, root::𝐣𝐥.Cint, comm::sc_MPI_Comm)::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Broadcast a connectivity structure that exists only on one process to all.  On the other processors, it will be allocated using p4est_connectivity_new.  
	
	## Parameters
	
	  * `conn_in`: For the root process the connectivity to be broadcast,                      for the other processes it must be NULL.
	  * `root`:    The rank of the process that provides the connectivity.
	  * `comm`:    The MPI communicator.
	
	## Returns
	
	             For the root process this is a pointer to *conn_in.*                      Else, a pointer to a newly allocated connectivity                      structure with the same values as *conn_in* on the                      root process.
	
	## Reference
	
	[p4est_connectivity.h:289](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:289:23)
	""" p4est_connectivity_bcast
	export p4est_connectivity_bcast
	𝐣𝐥.@cextern p4est_connectivity_bcast(conn_in::𝐣𝐥.Ptr{p4est_connectivity_t}, root::𝐣𝐥.Cint, comm::sc_MPI_Comm)::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_destroy(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a connectivity structure.  Also destroy all attributes.
	
	## Reference
	
	[p4est_connectivity.h:295](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:295:21)
	""" p4est_connectivity_destroy
	export p4est_connectivity_destroy
	𝐣𝐥.@cextern p4est_connectivity_destroy(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_set_attr(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, bytes_per_tree::size_t)::𝐣𝐥.Cvoid
	```
	
	 Allocate or free the attribute fields in a connectivity. 
	
	## Parameters
	
	  * `conn`:         The conn->*_to_attr fields must either be NULL                              or previously be allocated by this function.
	  * `bytes_per_tree`:   If 0, tree_to_attr is freed (being NULL is ok).                              If positive, requested space is allocated.
	
	## Reference
	
	[p4est_connectivity.h:304](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:304:21)
	""" p4est_connectivity_set_attr
	export p4est_connectivity_set_attr
	𝐣𝐥.@cextern p4est_connectivity_set_attr(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, bytes_per_tree::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_is_valid(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 Examine a connectivity structure. 
	
	## Returns
	
	          Returns true if structure is valid, false otherwise.
	
	## Reference
	
	[p4est_connectivity.h:310](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:310:21)
	""" p4est_connectivity_is_valid
	export p4est_connectivity_is_valid
	𝐣𝐥.@cextern p4est_connectivity_is_valid(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_is_equal(conn1::𝐣𝐥.Ptr{p4est_connectivity_t}, conn2::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 Check two connectivity structures for equality. 
	
	## Returns
	
	          Returns true if structures are equal, false otherwise.
	
	## Reference
	
	[p4est_connectivity.h:316](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:316:21)
	""" p4est_connectivity_is_equal
	export p4est_connectivity_is_equal
	𝐣𝐥.@cextern p4est_connectivity_is_equal(conn1::𝐣𝐥.Ptr{p4est_connectivity_t}, conn2::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_sink(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	```
	
	 Write connectivity to a sink object. 
	
	## Parameters
	
	  * `conn`:     The connectivity to be written.
	  * `sink`: The connectivity is written into this sink.
	
	## Returns
	
	              0 on success, nonzero on error.
	
	## Reference
	
	[p4est_connectivity.h:325](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:325:21)
	""" p4est_connectivity_sink
	export p4est_connectivity_sink
	𝐣𝐥.@cextern p4est_connectivity_sink(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_deflate(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, code::p4est_connectivity_encode_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Allocate memory and store the connectivity information there. 
	
	## Parameters
	
	  * `conn`:     The connectivity structure to be exported to memory.
	  * `code`:     Encoding and compression method for serialization.
	
	## Returns
	
	              Newly created array that contains the information.
	
	## Reference
	
	[p4est_connectivity.h:333](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:333:21)
	""" p4est_connectivity_deflate
	export p4est_connectivity_deflate
	𝐣𝐥.@cextern p4est_connectivity_deflate(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, code::p4est_connectivity_encode_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 Save a connectivity structure to disk. 
	
	## Parameters
	
	  * `filename`:         Name of the file to write.
	  * `connectivity`:     Valid connectivity structure.
	
	## Returns
	
	                      Returns 0 on success, nonzero on file error.
	
	## Reference
	
	[p4est_connectivity.h:342](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:342:21)
	""" p4est_connectivity_save
	export p4est_connectivity_save
	𝐣𝐥.@cextern p4est_connectivity_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_source(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Read connectivity from a source object. 
	
	## Parameters
	
	  * `source`:       The connectivity is read from this source.
	
	## Returns
	
	              The newly created connectivity, or NULL on error.
	
	## Reference
	
	[p4est_connectivity.h:350](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:350:23)
	""" p4est_connectivity_source
	export p4est_connectivity_source
	𝐣𝐥.@cextern p4est_connectivity_source(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_inflate(buffer::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create new connectivity from a memory buffer. 
	
	## Parameters
	
	  * `buffer`:   The connectivity is created from this memory buffer.
	
	## Returns
	
	              The newly created connectivity, or NULL on error.
	
	## Reference
	
	[p4est_connectivity.h:356](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:356:23)
	""" p4est_connectivity_inflate
	export p4est_connectivity_inflate
	𝐣𝐥.@cextern p4est_connectivity_inflate(buffer::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, bytes::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Load a connectivity structure from disk. 
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `bytes`:        Size in bytes of connectivity on disk or NULL.
	
	## Returns
	
	              Returns valid connectivity, or NULL on file error.
	
	## Reference
	
	[p4est_connectivity.h:363](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:363:23)
	""" p4est_connectivity_load
	export p4est_connectivity_load
	𝐣𝐥.@cextern p4est_connectivity_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, bytes::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_unitsquare()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for the unit square.
	
	## Reference
	
	[p4est_connectivity.h:368](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:368:23)
	""" p4est_connectivity_new_unitsquare
	export p4est_connectivity_new_unitsquare
	𝐣𝐥.@cextern p4est_connectivity_new_unitsquare()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_periodic()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for an all-periodic unit square.
	
	## Reference
	
	[p4est_connectivity.h:372](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:372:23)
	""" p4est_connectivity_new_periodic
	export p4est_connectivity_new_periodic
	𝐣𝐥.@cextern p4est_connectivity_new_periodic()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_rotwrap()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for a periodic unit square. The left and right faces are identified, and bottom and top opposite.
	
	## Reference
	
	[p4est_connectivity.h:377](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:377:23)
	""" p4est_connectivity_new_rotwrap
	export p4est_connectivity_new_rotwrap
	𝐣𝐥.@cextern p4est_connectivity_new_rotwrap()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_twotrees(l_face::𝐣𝐥.Cint, r_face::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for two trees being rotated w.r.t. each other in a user-defined way 
	
	## Parameters
	
	  * `l_face`:      index of left face
	  * `r_face`:      index of right face
	  * `orientation`: orientation of trees w.r.t. each other
	
	## Reference
	
	[p4est_connectivity.h:385](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:385:23)
	""" p4est_connectivity_new_twotrees
	export p4est_connectivity_new_twotrees
	𝐣𝐥.@cextern p4est_connectivity_new_twotrees(l_face::𝐣𝐥.Cint, r_face::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_corner()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for a three-tree mesh around a corner.
	
	## Reference
	
	[p4est_connectivity.h:391](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:391:23)
	""" p4est_connectivity_new_corner
	export p4est_connectivity_new_corner
	𝐣𝐥.@cextern p4est_connectivity_new_corner()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_pillow()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for two trees on top of each other.
	
	## Reference
	
	[p4est_connectivity.h:395](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:395:23)
	""" p4est_connectivity_new_pillow
	export p4est_connectivity_new_pillow
	𝐣𝐥.@cextern p4est_connectivity_new_pillow()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_moebius()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for a five-tree moebius band.
	
	## Reference
	
	[p4est_connectivity.h:399](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:399:23)
	""" p4est_connectivity_new_moebius
	export p4est_connectivity_new_moebius
	𝐣𝐥.@cextern p4est_connectivity_new_moebius()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_star()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for a six-tree star.
	
	## Reference
	
	[p4est_connectivity.h:403](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:403:23)
	""" p4est_connectivity_new_star
	export p4est_connectivity_new_star
	𝐣𝐥.@cextern p4est_connectivity_new_star()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_cubed()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for the six sides of a unit cube. The ordering of the trees is as follows: 0 1                                            2 3 <-- 3: axis-aligned top side                                              4 5. This choice has been made for maximum symmetry (see tree_to_* in .c file).
	
	## Reference
	
	[p4est_connectivity.h:411](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:411:23)
	""" p4est_connectivity_new_cubed
	export p4est_connectivity_new_cubed
	𝐣𝐥.@cextern p4est_connectivity_new_cubed()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_disk_nonperiodic()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for a five-tree flat spherical disk. This disk can just as well be used as a square to test non-Cartesian maps. Without any mapping this connectivity covers the square [-3, 3]**2. 
	
	## Returns
	
	                      Initialized and usable connectivity.
	
	## Reference
	
	[p4est_connectivity.h:418](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:418:23)
	""" p4est_connectivity_new_disk_nonperiodic
	export p4est_connectivity_new_disk_nonperiodic
	𝐣𝐥.@cextern p4est_connectivity_new_disk_nonperiodic()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_disk(periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure for a five-tree flat spherical disk. This disk can just as well be used as a square to test non-Cartesian maps. Without any mapping this connectivity covers the square [-3, 3]**2. 
	
	## Details
	
	NOTE: The API of this function has changed to accept two arguments.       You can query the #define P4EST_CONN_DISK_PERIODIC to check       whether the new version with the argument is in effect.
	
	 The ordering of the trees is as follows:   4                                          1 2 3                                            0.
	
	 The outside x faces may be identified topologically. The outside y faces may be identified topologically. Both identifications may be specified simultaneously. The general shape and periodicity are the same as those obtained with p4est_connectivity_new_brick (1, 1, periodic_a, periodic_b).
	
	 When setting *periodic_a* and *periodic_b* to false, the result is the same as that of p4est_connectivity_new_disk_nonperiodic.
	
	## Parameters
	
	  * `periodic_a`:       Bool to make disk periodic in x direction.
	  * `periodic_b`:       Bool to make disk periodic in y direction.
	
	## Returns
	
	                      Initialized and usable connectivity.
	
	## Reference
	
	[p4est_connectivity.h:444](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:444:23)
	""" p4est_connectivity_new_disk
	export p4est_connectivity_new_disk
	𝐣𝐥.@cextern p4est_connectivity_new_disk(periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_icosahedron()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity for mapping the sphere using an icosahedron.
	
	## Details
	
	 The regular icosadron is a polyhedron with 20 faces, each of which is an equilateral triangle. To build the p4est connectivity, we group faces 2 by 2 to from 10 quadrangles, and thus 10 trees.
	
	 This connectivity is meant to be used together with p4est_geometry_new_icosahedron to map the sphere.
	
	 The flat connectivity looks like that: Vextex numbering:
	
	    A00   A01   A02   A03   A04   /   \\ /   \\ /   \\ /   \\ /   \\ A05---A06---A07---A08---A09---A10   \\   / \\   / \\   / \\   / \\   / \\    A11---A12---A13---A14---A15---A16      \\  /  \\  /  \\  /  \\  /  \\  /      A17   A18   A19   A20   A21
	
	 Origin in A05.
	
	 Tree numbering:
	
	 0  2  4  6  8  1  3  5  7  9
	
	## Reference
	
	[p4est_connectivity.h:475](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:475:23)
	""" p4est_connectivity_new_icosahedron
	export p4est_connectivity_new_icosahedron
	𝐣𝐥.@cextern p4est_connectivity_new_icosahedron()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_shell2d()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure that builds a 2d spherical shell. p8est_connectivity_new_shell 
	
	## Reference
	
	[p4est_connectivity.h:480](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:480:23)
	""" p4est_connectivity_new_shell2d
	export p4est_connectivity_new_shell2d
	𝐣𝐥.@cextern p4est_connectivity_new_shell2d()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_disk2d()::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a connectivity structure that maps a 2d disk.
	
	## Details
	
	 This is a 5 trees connectivity meant to be used together with p4est_geometry_new_disk2d to map the disk.
	
	## Reference
	
	[p4est_connectivity.h:487](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:487:23)
	""" p4est_connectivity_new_disk2d
	export p4est_connectivity_new_disk2d
	𝐣𝐥.@cextern p4est_connectivity_new_disk2d()::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_brick(mi::𝐣𝐥.Cint, ni::𝐣𝐥.Cint, periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 A rectangular m by n array of trees with configurable periodicity. The brick is periodic in x and y if periodic_a and periodic_b are true, respectively.
	
	## Reference
	
	[p4est_connectivity.h:493](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:493:23)
	""" p4est_connectivity_new_brick
	export p4est_connectivity_new_brick
	𝐣𝐥.@cextern p4est_connectivity_new_brick(mi::𝐣𝐥.Cint, ni::𝐣𝐥.Cint, periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_new_byname(name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create connectivity structure from predefined catalogue. 
	
	## Parameters
	
	  * `name`:            Invokes connectivity_new_* function.              brick23         brick (2, 3, 0, 0)              corner          corner              cubed           cubed              disk            disk              moebius         moebius              periodic        periodic              pillow          pillow              rotwrap         rotwrap              star            star              unit            unitsquare
	
	## Returns
	
	      An initialized connectivity if name is defined, NULL else.
	
	## Reference
	
	[p4est_connectivity.h:511](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:511:23)
	""" p4est_connectivity_new_byname
	export p4est_connectivity_new_byname
	𝐣𝐥.@cextern p4est_connectivity_new_byname(name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_refine(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, num_per_edge::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Uniformly refine a connectivity. This is useful if you would like to uniformly refine by something other than a power of 2.
	
	## Parameters
	
	  * `conn`:         A valid connectivity
	  * `num_per_edge`: The number of new trees in each direction.                      Must use no more than P4EST_OLD_QMAXLEVEL bits.
	
	## Returns
	
	 a refined connectivity.
	
	## Reference
	
	[p4est_connectivity.h:523](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:523:23)
	""" p4est_connectivity_refine
	export p4est_connectivity_refine
	𝐣𝐥.@cextern p4est_connectivity_refine(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, num_per_edge::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_expand_face_transform(iface::𝐣𝐥.Cint, nface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::𝐣𝐥.Cvoid
	```
	
	 Fill an array with the axis combination of a face neighbor transform. 
	
	## Parameters
	
	  * `iface`:       The number of the originating face.
	  * `nface`:       Encoded as nface = r * 4 + nf, where nf = 0..3 is                          the neigbbor's connecting face number and r = 0..1                          is the relative orientation to the neighbor's face.                          This encoding matches p4est_connectivity_t.
	  * `ftransform`:  This array holds 9 integers.              [0,2]       The coordinate axis sequence of the origin face,                          the first referring to the tangential and the second                          to the normal.  A permutation of (0, 1).              [3,5]       The coordinate axis sequence of the target face.              [6,8]       Edge reversal flag for tangential axis (boolean);                          face code in [0, 3] for the normal coordinate q:                          0: q' = -q                          1: q' = q + 1                          2: q' = q - 1                          3: q' = 2 - q              [1,4,7]     0 (unused for compatibility with 3D).
	
	## Reference
	
	[p4est_connectivity.h:545](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:545:21)
	""" p4est_expand_face_transform
	export p4est_expand_face_transform
	𝐣𝐥.@cextern p4est_expand_face_transform(iface::𝐣𝐥.Cint, nface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_find_face_transform(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, itree::p4est_topidx_t, iface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::p4est_topidx_t
	```
	
	 Fill an array with the axis combinations of a tree neighbor transform. 
	
	## Parameters
	
	  * `itree`:       The number of the originating tree.
	  * `iface`:       The number of the originating tree's face.
	  * `ftransform`:  This array holds 9 integers.              [0,2]       The coordinate axis sequence of the origin face.              [3,5]       The coordinate axis sequence of the target face.              [6,8]       Edge reverse flag for axis t; face code for axis n.              [1,4,7]     0 (unused for compatibility with 3D).
	
	## Returns
	
	                  The face neighbor tree if it exists, -1 otherwise.
	
	## Reference
	
	[p4est_connectivity.h:558](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:558:21)
	""" p4est_find_face_transform
	export p4est_find_face_transform
	𝐣𝐥.@cextern p4est_find_face_transform(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, itree::p4est_topidx_t, iface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::p4est_topidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_find_corner_transform(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, itree::p4est_topidx_t, icorner::𝐣𝐥.Cint, ci::𝐣𝐥.Ptr{p4est_corner_info_t})::𝐣𝐥.Cvoid
	```
	
	 Fills an array with information about corner neighbors. 
	
	## Parameters
	
	  * `itree`:    The number of the originating tree.
	  * `icorner`:  The number of the originating corner.
	  * `ci`:   A p4est_corner_info_t structure with initialized array.
	
	## Reference
	
	[p4est_connectivity.h:568](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:568:21)
	""" p4est_find_corner_transform
	export p4est_find_corner_transform
	𝐣𝐥.@cextern p4est_find_corner_transform(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, itree::p4est_topidx_t, icorner::𝐣𝐥.Cint, ci::𝐣𝐥.Ptr{p4est_corner_info_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_complete(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Internally connect a connectivity based on tree_to_vertex information. Periodicity that is not inherent in the list of vertices will be lost. 
	
	## Parameters
	
	  * `conn`:     The connectivity needs to have proper vertices                          and tree_to_vertex fields.  The tree_to_tree                          and tree_to_face fields must be allocated                          and satisfy p4est_connectivity_is_valid (conn)                          but will be overwritten.  The corner                          fields will be freed and allocated anew.
	
	## Reference
	
	[p4est_connectivity.h:583](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:583:21)
	""" p4est_connectivity_complete
	export p4est_connectivity_complete
	𝐣𝐥.@cextern p4est_connectivity_complete(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_reduce(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Removes corner information of a connectivity  such that enough information is left to run p4est_connectivity_complete successfully.  The reduced connectivity still passes p4est_connectivity_is_valid. 
	
	## Parameters
	
	  * `conn`:     The connectivity to be reduced.
	
	## Reference
	
	[p4est_connectivity.h:590](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:590:21)
	""" p4est_connectivity_reduce
	export p4est_connectivity_reduce
	𝐣𝐥.@cextern p4est_connectivity_reduce(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_permute(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, perm::𝐣𝐥.Ptr{sc_array_t}, is_current_to_new::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 p4est_connectivity_permute Given a permutation *perm* of the trees in a connectivity *conn,* permute the trees of *conn* in place and update *conn* to match. 
	
	## Parameters
	
	  * `conn`:                The connectivity whose trees are                                     permuted.
	  * `perm`:                    A permutation array, whose elements are                                     size_t's.
	  * `is_current_to_new`:       if true, the jth entry of perm is the                                     new index for the entry whose current                                     index is j, otherwise the jth entry of                                     perm is the current index of the tree                                     whose index will be j after the                                     permutation.
	
	## Reference
	
	[p4est_connectivity.h:606](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:606:21)
	""" p4est_connectivity_permute
	export p4est_connectivity_permute
	𝐣𝐥.@cextern p4est_connectivity_permute(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, perm::𝐣𝐥.Ptr{sc_array_t}, is_current_to_new::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_join_faces(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, tree_left::p4est_topidx_t, tree_right::p4est_topidx_t, face_left::𝐣𝐥.Cint, face_right::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 p4est_connectivity_join_faces This function takes an existing valid connectivity *conn* and modifies it by joining two tree faces that are currently boundary faces. 
	
	## Parameters
	
	  * `conn`:        connectivity that will be altered.
	  * `tree_left`:   tree that will be on the left side of the joined                             faces.
	  * `tree_right`:  tree that will be on the right side of the                             joined faces.
	  * `face_left`:   face of *tree_left* that will be joined.
	  * `face_right`:  face of *tree_right* that will be joined.
	  * `orientation`: the orientation of *face_left* and                             *face_right* once joined (see the description                             of p4est_connectivity_t to understand                             orientation).
	
	## Reference
	
	[p4est_connectivity.h:654](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:654:21)
	""" p4est_connectivity_join_faces
	export p4est_connectivity_join_faces
	𝐣𝐥.@cextern p4est_connectivity_join_faces(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, tree_left::p4est_topidx_t, tree_right::p4est_topidx_t, face_left::𝐣𝐥.Cint, face_right::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_is_equivalent(conn1::𝐣𝐥.Ptr{p4est_connectivity_t}, conn2::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 p4est_connectivity_is_equivalent This function compares two connectivities for equivalence: it returns *true* if they are the same connectivity, or if they have the same topology.  The definition of topological sameness is strict: there is no attempt made to determine whether permutation and/or rotation of the trees makes the connectivities equivalent.
	
	## Parameters
	
	  * `conn1`:    a valid connectivity
	  * `conn2`:    a valid connectivity
	
	## Reference
	
	[p4est_connectivity.h:672](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:672:21)
	""" p4est_connectivity_is_equivalent
	export p4est_connectivity_is_equivalent
	𝐣𝐥.@cextern p4est_connectivity_is_equivalent(conn1::𝐣𝐥.Ptr{p4est_connectivity_t}, conn2::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_read_inp_stream(stream::𝐣𝐥.Ptr{FILE}, num_vertices::𝐣𝐥.Ptr{p4est_topidx_t}, num_trees::𝐣𝐥.Ptr{p4est_topidx_t}, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t})::𝐣𝐥.Cint
	```
	
	 Read an ABAQUS input file from a file stream.
	
	## Details
	
	 This utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.
	
	 A basic 2D mesh is given below.  The `*Node` section gives the vertex number and x, y, and z components for each vertex.  The `*Element` section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:
	
	   4                     3   +-------------------+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +-------------------+   1                   2
	
	 and in 3D they are given as:
	
	 8                     7  +---------------------+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+---------------------+6  |    |                |    |  +----|----------------+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +---------------------+       1                     2
	
	```
	 *Heading
	  box.inp
	 *Node
	 1,  -5, -5, 0
	 2,   5, -5, 0
	 3,   5,  5, 0
	 4,  -5,  5, 0
	 5,   0, -5, 0
	 6,   5,  0, 0
	 7,   0,  5, 0
	 8,  -5,  0, 0
	 9,   1, -1, 0
	 10,  0,  0, 0
	 11, -2,  1, 0
	 *Element, type=CPS4, ELSET=Surface1
	 1,  1, 10, 11, 8
	 2,  3, 10, 9,  6
	 3,  9, 10, 1,  5
	 4,  7,  4, 8, 11
	 5, 11, 10, 3,  7
	 6,  2,  6, 9,  5
	```
	
	 This code can be called two ways.  The first, when `vertex==NULL` and `tree_to_vertex==NULL,` is used to count the number of trees and vertices in the connectivity to be generated by the `.inp` mesh in the *stream.*  The second, when `vertices!=NULL` and `tree_to_vertex!=NULL,` fill `vertices` and `tree_to_vertex.`  In this case `num_vertices` and `num_trees` need to be set to the maximum number of entries allocated in `vertices` and `tree_to_vertex.`
	
	## Parameters
	
	  * `stream`:         file stream to read the connectivity from
	  * `num_vertices`:   the number of vertices in the connectivity
	  * `num_trees`:      the number of trees in the connectivity
	  * `vertices`:       the list of `vertices` of the connectivity
	  * `tree_to_vertex`: the `tree_to_vertex` map of the connectivity
	
	## Returns
	
	 0 if successful and nonzero if not
	
	## Reference
	
	[p4est_connectivity.h:770](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:770:21)
	""" p4est_connectivity_read_inp_stream
	export p4est_connectivity_read_inp_stream
	𝐣𝐥.@cextern p4est_connectivity_read_inp_stream(stream::𝐣𝐥.Ptr{FILE}, num_vertices::𝐣𝐥.Ptr{p4est_topidx_t}, num_trees::𝐣𝐥.Ptr{p4est_topidx_t}, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_connectivity_read_inp(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p4est_connectivity_t}
	```
	
	 Create a p4est connectivity from an ABAQUS input file.
	
	## Details
	
	 This utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.
	
	 A basic 2D mesh is given below.  The `*Node` section gives the vertex number and x, y, and z components for each vertex.  The `*Element` section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:
	
	   4                     3   +-------------------+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +-------------------+   1                   2
	
	 and in 3D they are given as:
	
	 8                     7  +---------------------+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+---------------------+6  |    |                |    |  +----|----------------+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +---------------------+       1                     2
	
	```
	 *Heading
	  box.inp
	 *Node
	 1,  -5, -5, 0
	 2,   5, -5, 0
	 3,   5,  5, 0
	 4,  -5,  5, 0
	 5,   0, -5, 0
	 6,   5,  0, 0
	 7,   0,  5, 0
	 8,  -5,  0, 0
	 9,   1, -1, 0
	 10,  0,  0, 0
	 11, -2,  1, 0
	 *Element, type=CPS4, ELSET=Surface1
	 1,  1, 10, 11, 8
	 2,  3, 10, 9,  6
	 3,  9, 10, 1,  5
	 4,  7,  4, 8, 11
	 5, 11, 10, 3,  7
	 6,  2,  6, 9,  5
	```
	
	 This function reads a mesh from *filename* and returns an associated p4est connectivity.
	
	## Parameters
	
	  * `filename`:         file to read the connectivity from
	
	## Returns
	
	  an allocated connectivity associated with the mesh in *filename*          or NULL if an error occurred.
	
	## Reference
	
	[p4est_connectivity.h:851](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:851:23)
	""" p4est_connectivity_read_inp
	export p4est_connectivity_read_inp
	𝐣𝐥.@cextern p4est_connectivity_read_inp(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p4est_connectivity_t}
	
	𝐣𝐥.@doc """
	 The 2D quadrant datatype 
	
	## Reference
	
	[p4est.h:71](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:71:16)
	""" p4est_quadrant
	𝐣𝐥.@doc """
	 The 2D quadrant datatype 
	
	## Reference
	
	[p4est.h:111](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:111:1)
	""" p4est_quadrant_t
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:79](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:79:9)
	""" p4est_quadrant_data
	export p4est_quadrant, p4est_quadrant_data, p4est_quadrant_t
	𝐣𝐥.@ctypedef p4est_quadrant_t 𝐣𝐥.@cstruct p4est_quadrant {
		(x, y)::p4est_qcoord_t
		(level, pad8)::int8_t
		pad16::int16_t
		p::𝐣𝐥.@cunion p4est_quadrant_data {
			user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
			user_long::𝐣𝐥.Clong
			user_int::𝐣𝐥.Cint
			which_tree::p4est_topidx_t
			piggy1::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				owner_rank::𝐣𝐥.Cint
			}
			piggy2::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				from_tree::p4est_topidx_t
			}
			piggy3::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				local_num::p4est_locidx_t
			}
		}
	}
	
	𝐣𝐥.@doc """
	 The p4est tree datatype 
	
	## Reference
	
	[p4est.h:114](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:114:16)
	""" p4est_tree
	𝐣𝐥.@doc """
	 The p4est tree datatype 
	
	## Reference
	
	[p4est.h:126](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:126:1)
	""" p4est_tree_t
	export p4est_tree, p4est_tree_t
	𝐣𝐥.@ctypedef p4est_tree_t 𝐣𝐥.@cstruct p4est_tree {
		quadrants::sc_array_t
		(first_desc, last_desc)::p4est_quadrant_t
		quadrants_offset::p4est_locidx_t
		quadrants_per_level::p4est_locidx_t[31]
		maxlevel::int8_t
	}
	
	𝐣𝐥.@doc """
	 Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p4est main structure. Declared in p4est_extended.h.  Used to profile important algorithms.
	
	## Reference
	
	[p4est.h:132](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:132:30)
	""" p4est_inspect_t
	export p4est_inspect_t
	𝐣𝐥.@ctypedef p4est_inspect_t 𝐣𝐥.@cstruct p4est_inspect
	
	𝐣𝐥.@doc """
	 The p4est forest datatype 
	
	## Reference
	
	[p4est.h:173](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:173:1)
	""" p4est_t
	𝐣𝐥.@doc """
	 The p4est forest datatype 
	
	## Reference
	
	[p4est.h:135](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:135:16)
	""" p4est
	export p4est, p4est_t
	𝐣𝐥.@ctypedef p4est_t 𝐣𝐥.@cstruct p4est {
		mpicomm::sc_MPI_Comm
		(mpisize, mpirank)::𝐣𝐥.Cint
		mpicomm_owned::𝐣𝐥.Cint
		data_size::size_t
		user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		revision::𝐣𝐥.Clong
		first_local_tree::p4est_topidx_t
		last_local_tree::p4est_topidx_t
		local_num_quadrants::p4est_locidx_t
		global_num_quadrants::p4est_gloidx_t
		global_first_quadrant::𝐣𝐥.Ptr{p4est_gloidx_t}
		global_first_position::𝐣𝐥.Ptr{p4est_quadrant_t}
		connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}
		trees::𝐣𝐥.Ptr{sc_array_t}
		user_data_pool::𝐣𝐥.Ptr{sc_mempool_t}
		quadrant_pool::𝐣𝐥.Ptr{sc_mempool_t}
		inspect::𝐣𝐥.Ptr{p4est_inspect_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_memory_used(p4est::𝐣𝐥.Ptr{p4est_t})::size_t
	```
	
	 Calculate local memory usage of a forest structure. Not collective.  The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use p4est_connectivity_memory_usage (p4est->connectivity). 
	
	## Parameters
	
	  * `p4est`:    Valid forest structure.
	
	## Returns
	
	              Memory used in bytes.
	
	## Reference
	
	[p4est.h:182](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:182:21)
	""" p4est_memory_used
	export p4est_memory_used
	𝐣𝐥.@cextern p4est_memory_used(p4est::𝐣𝐥.Ptr{p4est_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_revision(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Clong
	```
	
	 Return the revision counter of the forest. Not collective, even though the revision value is the same on all ranks. A newly created forest starts with a revision counter of zero. Every refine, coarsen, partition, and balance that actually changes the mesh increases the counter by one.  Operations with no effect keep the old value. 
	
	## Parameters
	
	  * `p8est`:    The forest must be valid.
	
	## Returns
	
	              Non-negative number.
	
	## Reference
	
	[p4est.h:192](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:192:21)
	""" p4est_revision
	export p4est_revision
	𝐣𝐥.@cextern p4est_revision(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Clong
	
	𝐣𝐥.@doc """
	 Callback function prototype to initialize the quadrant's user data. 
	
	## Parameters
	
	  * `p4est`:         the forest
	  * `which_tree`:    the tree containing *quadrant*
	  * `quadrant`:  the quadrant to be initialized: if data_size > 0,                           the data to be initialized is at                           *quadrant->p.user_data;* otherwise, the                           non-pointer user data (such as                           *quadrant->p.user_int)* can be initialized
	
	## Reference
	
	[p4est.h:203](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:203:23)
	""" p4est_init_t
	export p4est_init_t
	𝐣𝐥.@ctypedef p4est_init_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide for refinement. 
	
	## Parameters
	
	  * `p4est`:       the forest
	  * `which_tree`:  the tree containing *quadrant*
	  * `quadrant`:    the quadrant that may be refined
	
	## Returns
	
	 nonzero if the quadrant shall be refined.
	
	## Reference
	
	[p4est.h:213](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:213:23)
	""" p4est_refine_t
	export p4est_refine_t
	𝐣𝐥.@ctypedef p4est_refine_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide for coarsening. 
	
	## Parameters
	
	  * `p4est`:       the forest
	  * `which_tree`:  the tree containing *quadrant*
	  * `quadrants`:   Pointers to 4 siblings in Morton ordering.
	
	## Returns
	
	 nonzero if the quadrants shall be replaced with their parent.
	
	## Reference
	
	[p4est.h:223](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:223:23)
	""" p4est_coarsen_t
	export p4est_coarsen_t
	𝐣𝐥.@ctypedef p4est_coarsen_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to calculate weights for partitioning. 
	
	## Parameters
	
	  * `p4est`:       the forest
	  * `which_tree`:  the tree containing *quadrant*
	
	## Returns
	
	 a 32bit integer >= 0 as the quadrant weight. 
	
	NOTE:    Global sum of weights must fit into a 64bit integer.
	
	## Reference
	
	[p4est.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:233:23)
	""" p4est_weight_t
	export p4est_weight_t
	𝐣𝐥.@ctypedef p4est_weight_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P4EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[p4est.h:237](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:237:21)
	""" P4EST_DATA_UNINITIALIZED
	export P4EST_DATA_UNINITIALIZED
	𝐣𝐥.@cextern P4EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid
	```
	
	 Transform a quadrant coordinate into the space spanned by tree vertices. 
	
	## Parameters
	
	  * `connectivity`:     Connectivity must provide the vertices.
	  * `treeid`:           Identify the tree that contains x, y.
	  * `x,`: y             Quadrant coordinates relative to treeid.
	  * `vxyz`:            Transformed coordinates in vertex space.
	
	## Reference
	
	[p4est.h:249](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:249:21)
	""" p4est_qcoord_to_vertex
	export p4est_qcoord_to_vertex
	𝐣𝐥.@cextern p4est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_t}
	```
	
	 Create a new forest with an initial coarse mesh. The new forest consists of equi-partitioned root quadrants. When there are more processors than trees, some processors are empty.
	
	## Parameters
	
	  * `mpicomm`:       A valid MPI communicator.
	  * `connectivity`:  This is the connectivity information that                           the forest is built with.  Note the p4est                           does not take ownership of the memory.
	  * `data_size`:     This is the size of data for each quadrant which                           can be zero.  Then user_data_pool is set to NULL.
	  * `init_fn`:       Callback function to initialize the user_data                           which is already allocated automatically.
	  * `user_pointer`:  Assign to the user_pointer member of the p4est                           before init_fn is called the first time.
	
	## Returns
	
	 This returns a valid forest.
	
	NOTE: The connectivity structure must not be destroyed       during the lifetime of this forest.
	
	## Reference
	
	[p4est.h:275](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:275:21)
	""" p4est_new
	export p4est_new
	𝐣𝐥.@cextern p4est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_destroy(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a p4est.
	
	## Details
	
	NOTE: The connectivity structure is not destroyed with the p4est.
	
	## Reference
	
	[p4est.h:284](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:284:21)
	""" p4est_destroy
	export p4est_destroy
	𝐣𝐥.@cextern p4est_destroy(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_copy(input::𝐣𝐥.Ptr{p4est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_t}
	```
	
	 Make a deep copy of a p4est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.
	
	## Parameters
	
	  * `copy_data`:  If true, data are copied.                         If false, data_size is set to 0.
	
	## Returns
	
	  Returns a valid p4est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.
	
	## Reference
	
	[p4est.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:299:21)
	""" p4est_copy
	export p4est_copy
	𝐣𝐥.@cextern p4est_copy(input::𝐣𝐥.Ptr{p4est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_reset_data(p4est::𝐣𝐥.Ptr{p4est_t}, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Reset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.
	
	## Parameters
	
	  * `data_size`:     This is the size of data for each quadrant which                           can be zero.  Then user_data_pool is set to NULL.
	  * `init_fn`:       Callback function to initialize the user_data                           which is already allocated automatically.                           May be NULL.
	  * `user_pointer`:  Assign to the user_pointer member of the p4est                           before init_fn is called the first time.
	
	## Reference
	
	[p4est.h:314](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:314:21)
	""" p4est_reset_data
	export p4est_reset_data
	𝐣𝐥.@cextern p4est_reset_data(p4est::𝐣𝐥.Ptr{p4est_t}, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_refine(p4est::𝐣𝐥.Ptr{p4est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p4est_refine_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Refine a forest. 
	
	## Parameters
	
	  * `p4est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `refine_fn`: Callback function that must return true if a quadrant                       shall be refined.  If refine_recursive is true,                       refine_fn is called for every existing and newly                       created quadrant.  Otherwise, it is called for every                       existing quadrant.  It is possible that a refinement                       request made by the callback is ignored.  To catch                       this case, you can examine whether init_fn gets                       called, or use p4est_refine_ext in p4est_extended.h                       and examine whether replace_fn gets called.
	  * `init_fn`:   Callback function to initialize the user_data of newly                       created quadrants, which is already allocated.  This                       function pointer may be NULL.
	
	## Reference
	
	[p4est.h:334](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:334:21)
	""" p4est_refine
	export p4est_refine
	𝐣𝐥.@cextern p4est_refine(p4est::𝐣𝐥.Ptr{p4est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p4est_refine_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_coarsen(p4est::𝐣𝐥.Ptr{p4est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p4est_coarsen_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Coarsen a forest. 
	
	## Parameters
	
	  * `p4est`:  The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `coarsen_fn`: Callback function that returns true if a                        family of quadrants shall be coarsened
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	
	## Reference
	
	[p4est.h:347](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:347:21)
	""" p4est_coarsen
	export p4est_coarsen
	𝐣𝐥.@cextern p4est_coarsen(p4est::𝐣𝐥.Ptr{p4est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p4est_coarsen_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_balance(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid
	```
	
	 2:1 balance the size differences of neighboring elements in a forest. 
	
	## Parameters
	
	  * `p4est`:  The p4est to be worked on.
	  * `btype`:      Balance type (face or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	
	## Reference
	
	[p4est.h:360](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:360:21)
	""" p4est_balance
	export p4est_balance
	𝐣𝐥.@cextern p4est_balance(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_partition(p4est::𝐣𝐥.Ptr{p4est_t}, allow_for_coarsening::𝐣𝐥.Cint, weight_fn::p4est_weight_t)::𝐣𝐥.Cvoid
	```
	
	 Equally partition the forest. The partition can be by element count or by a user-defined weight.
	
	## Details
	
	 The forest will be partitioned between processors such that they have an approximately equal number of quadrants (or sum of weights).
	
	 On one process, the function noops and does not call the weight callback. Otherwise, the weight callback is called once per quadrant in order.
	
	## Parameters
	
	  * `p4est`:      The forest that will be partitioned.
	  * `allow_for_coarsening`: Slightly modify partition such that                            quadrant families are not split between ranks.
	  * `weight_fn`:  A weighting function or NULL                            for uniform partitioning.                            When running with mpisize == 1, never called.                            Otherwise, called in order for all quadrants                            if not NULL. A weighting function with constant                            weight 1 on each quadrant is equivalent                            to weight_fn == NULL but other constant weightings                            may result in different uniform partitionings.
	
	## Reference
	
	[p4est.h:385](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:385:21)
	""" p4est_partition
	export p4est_partition
	𝐣𝐥.@cextern p4est_partition(p4est::𝐣𝐥.Ptr{p4est_t}, allow_for_coarsening::𝐣𝐥.Cint, weight_fn::p4est_weight_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_checksum(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cuint
	```
	
	 Compute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize. 
	
	## Returns
	
	  Returns the checksum on processor 0 only. 0 on other processors.
	
	## Reference
	
	[p4est.h:393](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:393:21)
	""" p4est_checksum
	export p4est_checksum
	𝐣𝐥.@cextern p4est_checksum(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_checksum_partition(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cuint
	```
	
	 Compute a partition-dependent checksum for a forest. 
	
	## Returns
	
	  Returns the checksum on processor 0 only. 0 on other processors.
	
	## Reference
	
	[p4est.h:398](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:398:21)
	""" p4est_checksum_partition
	export p4est_checksum_partition
	𝐣𝐥.@cextern p4est_checksum_partition(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p4est::𝐣𝐥.Ptr{p4est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Save the complete connectivity/p4est data to disk.
	
	## Details
	
	 This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations.
	
	 By default, we write the current processor count and partition into the file header.  This makes the file depend on mpisize.  For changing this see p4est_save_ext() in p4est_extended.h.
	
	 The revision counter is not saved to the file, since that would make files different that come from different revisions but store the same mesh.
	
	## Parameters
	
	  * `filename`:    Name of the file to write.
	  * `p4est`:       Valid forest structure.
	  * `save_data`:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.
	
	NOTE:            Aborts on file errors. 
	
	NOTE:            If p4est is not configured to use MPI-IO, some processes                  return from this function before the file is complete, in                  which case immediate read-access to the file may require a                  call to sc_MPI_Barrier.
	
	## Reference
	
	[p4est.h:423](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:423:21)
	""" p4est_save
	export p4est_save
	𝐣𝐥.@cextern p4est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p4est::𝐣𝐥.Ptr{p4est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}
	```
	
	 Load the complete connectivity/p4est structure from disk.
	
	## Details
	
	 This is a collective operation that all MPI processes need to call.  All processes read from the same file, so the filename given needs to be identical over all parallel invocations.
	
	 By default, a file can only be loaded with the same number of processors that it was stored with.  The defaults can be changed with p4est_load_ext() in p4est_extended.h.
	
	 The revision counter of the loaded p4est is set to zero.
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `mpicomm`:          A valid MPI communicator.
	  * `data_size`:        Size of data for each quadrant which can be                              zero.  Then user_data_pool is set to NULL.                              If data_size is zero, load_data is ignored.
	  * `load_data`:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.
	  * `user_pointer`:     Assign to the user_pointer member of the p4est                              before init_fn is called the first time.
	  * `connectivity`:    Connectivity must be destroyed separately.
	
	## Returns
	
	          Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument. 
	
	NOTE:            Aborts on file errors or invalid file contents.
	
	## Reference
	
	[p4est.h:454](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:454:21)
	""" p4est_load
	export p4est_load
	𝐣𝐥.@cextern p4est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	 quadrants that neighbor the local domain 
	
	## Reference
	
	[p4est_ghost.h:79](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:79:1)
	""" p4est_ghost_t
	export p4est_ghost_t
	𝐣𝐥.@ctypedef p4est_ghost_t 𝐣𝐥.@cstruct {
		mpisize::𝐣𝐥.Cint
		num_trees::p4est_topidx_t
		btype::p4est_connect_type_t
		ghosts::sc_array_t
		tree_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		proc_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		mirrors::sc_array_t
		mirror_tree_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_mirrors::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_fronts::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_front_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_is_valid(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cint
	```
	
	 Examine if a ghost structure is valid. Test if within a ghost-structure the array ghosts is in p4est_quadrant_compare_piggy order. Test if local_num in piggy3 data member of the quadrants in ghosts and mirrors are in ascending order (ascending within each rank for ghost).
	
	## Details
	
	 Test if the p4est_locidx_t arrays are in ascending order (for mirror_proc_mirrors ascending within each rank) 
	
	## Parameters
	
	  * `p4est`:    the forest.
	  * `ghost`:    Ghost layer structure.
	
	## Returns
	
	 true if *ghost* is valid
	
	## Reference
	
	[p4est_ghost.h:93](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:93:21)
	""" p4est_ghost_is_valid
	export p4est_ghost_is_valid
	𝐣𝐥.@cextern p4est_ghost_is_valid(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_memory_used(ghost::𝐣𝐥.Ptr{p4est_ghost_t})::size_t
	```
	
	 Calculate the memory usage of the ghost layer. 
	
	## Parameters
	
	  * `ghost`:    Ghost layer structure.
	
	## Returns
	
	              Memory used in bytes.
	
	## Reference
	
	[p4est_ghost.h:100](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:100:21)
	""" p4est_ghost_memory_used
	export p4est_ghost_memory_used
	𝐣𝐥.@cextern p4est_ghost_memory_used(ghost::𝐣𝐥.Ptr{p4est_ghost_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_quadrant_find_owner(p4est::𝐣𝐥.Ptr{p4est_t}, treeid::p4est_topidx_t, face::𝐣𝐥.Cint, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::𝐣𝐥.Cint
	```
	
	 Gets the processor id of a quadrant's owner. The quadrant can lie outside of a tree across faces (and only faces).
	
	## Parameters
	
	  * `p4est`:  The forest in which to search for a quadrant.
	  * `treeid`: The tree to which the quadrant belongs.
	  * `face`:   Supply a face direction if known, or -1 otherwise.
	  * `q`:      The quadrant that is being searched for.
	
	## Returns
	
	 Processor id of the owner                or -1 if the quadrant lies outside of the mesh.
	
	WARNING: Does not work for tree edge or corner neighbors.
	
	## Reference
	
	[p4est_ghost.h:115](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:115:21)
	""" p4est_quadrant_find_owner
	export p4est_quadrant_find_owner
	𝐣𝐥.@cextern p4est_quadrant_find_owner(p4est::𝐣𝐥.Ptr{p4est_t}, treeid::p4est_topidx_t, face::𝐣𝐥.Cint, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_new(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_ghost_t}
	```
	
	 Builds the ghost layer.
	
	## Details
	
	 This will gather the quadrants from each neighboring proc to build one layer of face and corner based ghost elements around the ones they own.
	
	## Parameters
	
	  * `p4est`:            The forest for which the ghost layer will be                              generated.
	  * `btype`:            Which ghosts to include (across face, corner                              or full).
	
	## Returns
	
	                      A fully initialized ghost layer.
	
	## Reference
	
	[p4est_ghost.h:131](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:131:21)
	""" p4est_ghost_new
	export p4est_ghost_new
	𝐣𝐥.@cextern p4est_ghost_new(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_ghost_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_destroy(ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Frees all memory used for the ghost layer. 
	
	## Reference
	
	[p4est_ghost.h:135](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:135:21)
	""" p4est_ghost_destroy
	export p4est_ghost_destroy
	𝐣𝐥.@cextern p4est_ghost_destroy(ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_bsearch(ghost::𝐣𝐥.Ptr{p4est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::ssize_t
	```
	
	 Conduct binary search for exact match on a range of the ghost layer. 
	
	## Parameters
	
	  * `ghost`:            The ghost layer.
	  * `which_proc`:       The owner of the searched quadrant.  Can be -1.
	  * `which_tree`:       The tree of the searched quadrant.  Can be -1.
	  * `q`:                Valid quadrant is searched in the ghost layer.
	
	## Returns
	
	                      Offset in the ghost layer, or -1 if not found.
	
	## Reference
	
	[p4est_ghost.h:144](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:144:21)
	""" p4est_ghost_bsearch
	export p4est_ghost_bsearch
	𝐣𝐥.@cextern p4est_ghost_bsearch(ghost::𝐣𝐥.Ptr{p4est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::ssize_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_contains(ghost::𝐣𝐥.Ptr{p4est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::ssize_t
	```
	
	 Conduct binary search for ancestor on range of the ghost layer. 
	
	## Parameters
	
	  * `ghost`:            The ghost layer.
	  * `which_proc`:       The owner of the searched quadrant.  Can be -1.
	  * `which_tree`:       The tree of the searched quadrant.  Can be -1.
	  * `q`:                Valid quadrant's ancestor is searched.
	
	## Returns
	
	                      Offset in the ghost layer, or -1 if not found.
	
	## Reference
	
	[p4est_ghost.h:156](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:156:21)
	""" p4est_ghost_contains
	export p4est_ghost_contains
	𝐣𝐥.@cextern p4est_ghost_contains(ghost::𝐣𝐥.Ptr{p4est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::ssize_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_face_quadrant_exists(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, face::𝐣𝐥.Ptr{𝐣𝐥.Cint}, hang::𝐣𝐥.Ptr{𝐣𝐥.Cint}, owner_rank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::p4est_locidx_t
	```
	
	 Checks if quadrant exists in the local forest or the ghost layer.
	
	## Details
	
	 For quadrants across tree boundaries it checks if the quadrant exists across any face, but not across corners.
	
	## Parameters
	
	  * `p4est`:        The forest in which to search for *q.*
	  * `ghost`:        The ghost layer in which to search for *q.*
	  * `treeid`:       The tree to which *q* belongs.
	  * `q`:            The quadrant that is being searched for.
	  * `face`:      On input, face id across which *q* was created.                           On output, the neighbor's face number augmented                           by orientation, so face is in 0..7.
	  * `hang`:      If not NULL, signals that q is bigger than                           the quadrant it came from.  The child id                           of that originating quadrant is passed into hang.                           On output, hang holds the hanging face number                           of *q* that is in contact with its originator.
	  * `owner_rank`:   Filled with the rank of the owner if it is found                           and undefined otherwise.
	
	## Returns
	
	      Returns the local number of *q* if the quadrant exists              in the local forest or in the ghost_layer.  Otherwise,              returns -2 for a domain boundary and -1 if not found.
	
	## Reference
	
	[p4est_ghost.h:185](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:185:21)
	""" p4est_face_quadrant_exists
	export p4est_face_quadrant_exists
	𝐣𝐥.@cextern p4est_face_quadrant_exists(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, face::𝐣𝐥.Ptr{𝐣𝐥.Cint}, hang::𝐣𝐥.Ptr{𝐣𝐥.Cint}, owner_rank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::p4est_locidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_quadrant_exists(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, exists_arr::𝐣𝐥.Ptr{sc_array_t}, rproc_arr::𝐣𝐥.Ptr{sc_array_t}, rquad_arr::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	```
	
	 Checks if quadrant exists in the local forest or the ghost layer.
	
	## Details
	
	 For quadrants across tree corners it checks if the quadrant exists in any of the corner neighbors, thus it can execute multiple queries.
	
	## Parameters
	
	  * `p4est`:        The forest in which to search for *q*
	  * `ghost`:        The ghost layer in which to search for *q*
	  * `treeid`:       The tree to which *q* belongs (can be extended).
	  * `q`:            The quadrant that is being searched for.
	  * `exists_arr`: Must exist and be of of elem_size = sizeof (int)                           for inter-tree corner cases.  Is resized by this                           function to one entry for each corner search                           and set to true/false depending on its existence                           in the local forest or ghost_layer.
	  * `rproc_arr`: If not NULL is filled with one rank per query.
	  * `rquad_arr`: If not NULL is filled with one quadrant per query.                           Its piggy3 member is defined as well.
	
	## Returns
	
	 true if the quadrant exists in the local forest or in the                  ghost_layer, and false if doesn't exist in either.
	
	## Reference
	
	[p4est_ghost.h:213](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:213:21)
	""" p4est_quadrant_exists
	export p4est_quadrant_exists
	𝐣𝐥.@cextern p4est_quadrant_exists(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, exists_arr::𝐣𝐥.Ptr{sc_array_t}, rproc_arr::𝐣𝐥.Ptr{sc_array_t}, rquad_arr::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_is_balanced(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t)::𝐣𝐥.Cint
	```
	
	 Check a forest to see if it is balanced.
	
	## Details
	
	 This function builds the ghost layer and discards it when done.
	
	## Parameters
	
	  * `p4est`:    The p4est to be tested.
	  * `btype`:    Balance type (face, corner or default, full).
	
	## Returns
	
	 Returns true if balanced, false otherwise.
	
	## Reference
	
	[p4est_ghost.h:229](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:229:21)
	""" p4est_is_balanced
	export p4est_is_balanced
	𝐣𝐥.@cextern p4est_is_balanced(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_checksum(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cuint
	```
	
	 Compute the parallel checksum of a ghost layer. 
	
	## Parameters
	
	  * `p4est`:   The MPI information of this p4est will be used.
	  * `ghost`:   A ghost layer obtained from the p4est.
	
	## Returns
	
	             Parallel checksum on rank 0, 0 otherwise.
	
	## Reference
	
	[p4est_ghost.h:237](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:237:21)
	""" p4est_ghost_checksum
	export p4est_ghost_checksum
	𝐣𝐥.@cextern p4est_ghost_checksum(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_data(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Transfer data for local quadrants that are ghosts to other processors. Send the data stored in the quadrant's user_data.  This is either the pointer variable itself if `p4est->data_size` is 0, or the content of the referenced memory field if p4est->data_size is positive. 
	
	## Parameters
	
	  * `p4est`:            The forest used for reference.
	  * `ghost`:            The ghost layer used for reference.
	  * `ghost_data`:   Pre-allocated contiguous data for all ghost                              quadrants in sequence.  If p4est->data_size is                              0, must at least hold sizeof (void *) bytes for                              each, otherwise p4est->data_size each.
	
	## Reference
	
	[p4est_ghost.h:251](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:251:21)
	""" p4est_ghost_exchange_data
	export p4est_ghost_exchange_data
	𝐣𝐥.@cextern p4est_ghost_exchange_data(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 Transient storage for asynchronous ghost exchange. 
	
	## Reference
	
	[p4est_ghost.h:256](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:256:16)
	""" p4est_ghost_exchange
	𝐣𝐥.@doc """
	 Transient storage for asynchronous ghost exchange. 
	
	## Reference
	
	[p4est_ghost.h:269](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:269:1)
	""" p4est_ghost_exchange_t
	export p4est_ghost_exchange, p4est_ghost_exchange_t
	𝐣𝐥.@ctypedef p4est_ghost_exchange_t 𝐣𝐥.@cstruct p4est_ghost_exchange {
		is_custom::𝐣𝐥.Cint
		is_levels::𝐣𝐥.Cint
		p4est::𝐣𝐥.Ptr{p4est_t}
		ghost::𝐣𝐥.Ptr{p4est_ghost_t}
		(minlevel, maxlevel)::𝐣𝐥.Cint
		data_size::size_t
		ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		(qactive::𝐣𝐥.Ptr{_}, qbuffer::𝐣𝐥.Ptr{_})::𝐣𝐥.Cint
		(requests, sbuffers)::sc_array_t
		(rrequests, rbuffers)::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_data_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}
	```
	
	 Begin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4est_ghost_exchange_data. The return type is always non-NULL and must be passed to p4est_ghost_exchange_data_end to complete the exchange. The ghost data must not be accessed before completion. 
	
	## Parameters
	
	  * `ghost_data`:  Must stay alive into the completion call.
	
	## Returns
	
	          Transient storage for messages in progress.
	
	## Reference
	
	[p4est_ghost.h:279](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:279:25)
	""" p4est_ghost_exchange_data_begin
	export p4est_ghost_exchange_data_begin
	𝐣𝐥.@cextern p4est_ghost_exchange_data_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_data_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid
	```
	
	 Complete an asynchronous ghost data exchange. This function waits for all pending MPI communications. 
	
	## Parameters
	
	  * `Data`: created ONLY by p4est_ghost_exchange_data_begin.                  It is deallocated before this function returns.
	
	## Reference
	
	[p4est_ghost.h:287](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:287:21)
	""" p4est_ghost_exchange_data_end
	export p4est_ghost_exchange_data_end
	𝐣𝐥.@cextern p4est_ghost_exchange_data_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_custom(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Transfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. 
	
	## Parameters
	
	  * `p4est`:            The forest used for reference.
	  * `ghost`:            The ghost layer used for reference.
	  * `data_size`:        The data size to transfer per quadrant.
	  * `mirror_data`:      One data pointer per mirror quadrant as input.
	  * `ghost_data`:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least `data_size` for each ghost.
	
	## Reference
	
	[p4est_ghost.h:300](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:300:21)
	""" p4est_ghost_exchange_custom
	export p4est_ghost_exchange_custom
	𝐣𝐥.@cextern p4est_ghost_exchange_custom(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}
	```
	
	 Begin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4est_ghost_exchange_custom. The return type is always non-NULL and must be passed to p4est_ghost_exchange_custom_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. 
	
	## Parameters
	
	  * `mirror_data`: Not required to stay alive any longer.
	  * `ghost_data`:  Must stay alive into the completion call.
	
	## Returns
	
	          Transient storage for messages in progress.
	
	## Reference
	
	[p4est_ghost.h:317](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:317:25)
	""" p4est_ghost_exchange_custom_begin
	export p4est_ghost_exchange_custom_begin
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid
	```
	
	 Complete an asynchronous ghost data exchange. This function waits for all pending MPI communications. 
	
	## Parameters
	
	  * `Data`: created ONLY by p4est_ghost_exchange_custom_begin.                  It is deallocated before this function returns.
	
	## Reference
	
	[p4est_ghost.h:326](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:326:21)
	""" p4est_ghost_exchange_custom_end
	export p4est_ghost_exchange_custom_end
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Transfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. This function restricts the transfer to a range of refinement levels. The memory for quadrants outside the level range is not dereferenced. 
	
	## Parameters
	
	  * `p4est`:            The forest used for reference.
	  * `ghost`:            The ghost layer used for reference.
	  * `minlevel`:         Level of the largest quads to be exchanged.                              Use <= 0 for no restriction.
	  * `maxlevel`:         Level of the smallest quads to be exchanged.                              Use >= P4EST_QMAXLEVEL for no restriction.
	  * `data_size`:        The data size to transfer per quadrant.
	  * `mirror_data`:      One data pointer per mirror quadrant as input.
	  * `ghost_data`:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least `data_size` for each ghost.
	
	## Reference
	
	[p4est_ghost.h:345](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:345:21)
	""" p4est_ghost_exchange_custom_levels
	export p4est_ghost_exchange_custom_levels
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}
	```
	
	 Begin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4est_ghost_exchange_custom_levels. The return type is always non-NULL and must be passed to p4est_ghost_exchange_custom_levels_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. 
	
	## Parameters
	
	  * `mirror_data`: Not required to stay alive any longer.
	  * `ghost_data`:  Must stay alive into the completion call.
	
	## Returns
	
	          Transient storage for messages in progress.
	
	## Reference
	
	[p4est_ghost.h:364](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:364:25)
	""" p4est_ghost_exchange_custom_levels_begin
	export p4est_ghost_exchange_custom_levels_begin
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid
	```
	
	 Complete an asynchronous ghost data exchange. This function waits for all pending MPI communications. 
	
	## Parameters
	
	  * `Data`: created ONLY by p4est_ghost_exchange_custom_levels_begin.                  It is deallocated before this function returns.
	
	## Reference
	
	[p4est_ghost.h:373](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:373:21)
	""" p4est_ghost_exchange_custom_levels_end
	export p4est_ghost_exchange_custom_levels_end
	𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_expand(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Expand the size of the ghost layer and mirrors by one additional layer of adjacency. 
	
	## Parameters
	
	  * `p4est`:            The forest from which the ghost layer was                              generated.
	  * `ghost`:        The ghost layer to be expanded.
	
	## Reference
	
	[p4est_ghost.h:382](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_ghost.h:382:21)
	""" p4est_ghost_expand
	export p4est_ghost_expand
	𝐣𝐥.@cextern p4est_ghost_expand(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 This structure contains complete mesh information on a 2:1 balanced forest. It stores the locally relevant neighborhood, that is, all locally owned quadrants and one layer of adjacent ghost quadrants and their owners.
	
	## Details
	
	 For each local quadrant, its tree number is stored in quad_to_tree. The quad_to_tree array is NULL by default and can be enabled using p4est_mesh_new_ext. For each ghost quadrant, its owner rank is stored in ghost_to_proc. For each level, an array of local quadrant numbers is stored in quad_level. The quad_level array is NULL by default and can be enabled using p4est_mesh_new_ext.
	
	 The quad_to_quad list stores one value for each local quadrant's face. This value is in 0..local_num_quadrants-1 for local quadrants, or in local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
	
	 The quad_to_face list has equally many entries that are either: 1. A value of v = 0..7 indicates one same-size neighbor.    This value is decoded as v = r * 4 + nf, where nf = 0..3 is the    neighbor's connecting face number and r = 0..1 is the relative    orientation of the neighbor's face; see p4est_connectivity.h. 2. A value of v = 8..23 indicates a double-size neighbor.    This value is decoded as v = 8 + h * 8 + r * 4 + nf, where    r and nf are as above and h = 0..1 is the number of the subface.    h designates the subface of the large neighbor that the quadrant    touches (this is the same as the large neighbor's face corner). 3. A value of v = -8..-1 indicates two half-size neighbors.    In this case the corresponding quad_to_quad index points into the    quad_to_half array that stores two quadrant numbers per index,    and the orientation of the smaller faces follows from 8 + v.    The entries of quad_to_half encode between local and ghost quadrant    in the same way as the quad_to_quad values described above.    The small neighbors in quad_to_half are stored in the sequence    of the face corners of this, i.e., the large quadrant.
	
	 A quadrant on the boundary of the forest sees itself and its face number.
	
	 The quad_to_corner list stores corner neighbors that are not face neighbors. On the inside of a tree, there is precisely one such neighbor per corner. In this case, its index is encoded as described above for quad_to_quad. The neighbor's matching corner number is always diagonally opposite, that is, corner number ^ 3.
	
	 On the inside of an inter-tree face, we have precisely one corner neighbor. If a corner is an inter-tree corner, then the number of corner neighbors may be any non-negative number.  In both cases, the quad_to_corner value is in    local_num_quadrants + local_num_ghosts + [0 .. local_num_corners - 1]. After subtracting the number of local and ghost quadrants, it indexes into corner_offset, which encodes a group of corner neighbors. Each group contains the quadrant numbers encoded as usual for quad_to_quad in corner_quad, and the corner number from the neighbor as corner_corner.
	
	 Corners with no diagonal neighbor at all are assigned the value -3.  This only happens on the domain boundary, which is necessarily a tree boundary. Corner-neighbors for hanging nodes are assigned the value -1.
	
	 TODO: In case of an inter-tree corner neighbor relation in a brick-like       situation (exactly one neighbor, diagonally opposite corner number),       use the same encoding as for corners within a tree.
	
	## Reference
	
	[p4est_mesh.h:128](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:128:1)
	""" p4est_mesh_t
	export p4est_mesh_t
	𝐣𝐥.@ctypedef p4est_mesh_t 𝐣𝐥.@cstruct {
		local_num_quadrants::p4est_locidx_t
		ghost_num_quadrants::p4est_locidx_t
		quad_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		ghost_to_proc::𝐣𝐥.Ptr{𝐣𝐥.Cint}
		quad_to_quad::𝐣𝐥.Ptr{p4est_locidx_t}
		quad_to_face::𝐣𝐥.Ptr{int8_t}
		quad_to_half::𝐣𝐥.Ptr{sc_array_t}
		quad_level::𝐣𝐥.Ptr{sc_array_t}
		local_num_corners::p4est_locidx_t
		quad_to_corner::𝐣𝐥.Ptr{p4est_locidx_t}
		corner_offset::𝐣𝐥.Ptr{sc_array_t}
		corner_quad::𝐣𝐥.Ptr{sc_array_t}
		corner_corner::𝐣𝐥.Ptr{sc_array_t}
	}
	
	𝐣𝐥.@doc """
	 This structure can be used as the status of a face neighbor iterator. It always contains the face and subface of the neighbor to be processed.
	
	## Reference
	
	[p4est_mesh.h:152](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:152:1)
	""" p4est_mesh_face_neighbor_t
	export p4est_mesh_face_neighbor_t
	𝐣𝐥.@ctypedef p4est_mesh_face_neighbor_t 𝐣𝐥.@cstruct {
		p4est::𝐣𝐥.Ptr{p4est_t}
		ghost::𝐣𝐥.Ptr{p4est_ghost_t}
		mesh::𝐣𝐥.Ptr{p4est_mesh_t}
		which_tree::p4est_topidx_t
		quadrant_id::p4est_locidx_t
		quadrant_code::p4est_locidx_t
		face::𝐣𝐥.Cint
		subface::𝐣𝐥.Cint
		current_qtq::p4est_locidx_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_memory_used(mesh::𝐣𝐥.Ptr{p4est_mesh_t})::size_t
	```
	
	 Calculate the memory usage of the mesh structure. 
	
	## Parameters
	
	  * `mesh`:     Mesh structure.
	
	## Returns
	
	              Memory used in bytes.
	
	## Reference
	
	[p4est_mesh.h:158](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:158:21)
	""" p4est_mesh_memory_used
	export p4est_mesh_memory_used
	𝐣𝐥.@cextern p4est_mesh_memory_used(mesh::𝐣𝐥.Ptr{p4est_mesh_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_new(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_mesh_t}
	```
	
	 Create a p4est_mesh structure. This function does not populate the quad_to_tree and quad_level fields. To populate them, use p4est_mesh_new_ext. 
	
	## Parameters
	
	  * `p4est`:    A forest that is fully 2:1 balanced.
	  * `ghost`:    The ghost layer created from the provided p4est.
	  * `btype`:    Determines the highest codimension of neighbors.
	
	## Returns
	
	              A fully allocated mesh structure.
	
	## Reference
	
	[p4est_mesh.h:168](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:168:21)
	""" p4est_mesh_new
	export p4est_mesh_new
	𝐣𝐥.@cextern p4est_mesh_new(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_mesh_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_destroy(mesh::𝐣𝐥.Ptr{p4est_mesh_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a p4est_mesh structure. 
	
	## Parameters
	
	  * `mesh`:     Mesh structure previously created by p4est_mesh_new.
	
	## Reference
	
	[p4est_mesh.h:175](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:175:21)
	""" p4est_mesh_destroy
	export p4est_mesh_destroy
	𝐣𝐥.@cextern p4est_mesh_destroy(mesh::𝐣𝐥.Ptr{p4est_mesh_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_get_quadrant(p4est::𝐣𝐥.Ptr{p4est_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, qid::p4est_locidx_t)::𝐣𝐥.Ptr{p4est_quadrant_t}
	```
	
	 Access a process-local quadrant inside a forest. Needs a mesh with populated quad_to_tree array. This is a special case of p4est_mesh_quadrant_cumulative.
	
	## Parameters
	
	  * `p4est`:  The forest.
	  * `mesh`:   The mesh.
	  * `qid`:    Process-local id of the quadrant (cumulative over trees).
	
	## Returns
	
	            A pointer to the requested quadrant.
	
	## Reference
	
	[p4est_mesh.h:186](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:186:21)
	""" p4est_mesh_get_quadrant
	export p4est_mesh_get_quadrant
	𝐣𝐥.@cextern p4est_mesh_get_quadrant(p4est::𝐣𝐥.Ptr{p4est_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, qid::p4est_locidx_t)::𝐣𝐥.Ptr{p4est_quadrant_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_get_neighbors(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, curr_quad_id::p4est_locidx_t, direction::p4est_locidx_t, neighboring_quads::𝐣𝐥.Ptr{sc_array_t}, neighboring_encs::𝐣𝐥.Ptr{sc_array_t}, neighboring_qids::𝐣𝐥.Ptr{sc_array_t})::p4est_locidx_t
	```
	
	 Lookup neighboring quads of quadrant in a specific direction. 
	
	## Parameters
	
	  * `p4est`:              Forest to be worked with.
	  * `ghost`:              Ghost layer.
	  * `mesh`:               Mesh structure.
	  * `curr_quad_id`:       Process-local id of current quad.
	  * `direction`:          Direction i in which to look for adjacent                                 quadrants is encoded as follows:                                  0 .. 3 neighbor(-s) across face i,                                  4 .. 7 neighbor(-s) across corner i-4. TODO: Allow any combination of empty output arrays.
	  * `neighboring_quads`:  Array containing neighboring quad(-s).                                 Needs to be empty on input, size of                                 p4est_quadrant_t *.  May be NULL, then                                 **neighboring_qids** must not be NULL.
	  * `neighboring_qids`:   Array containing quadrant ids for neighboring                                 quadrants. May be NULL, then no neighboring                                 qids are collected.                                 If non-NULL the array needs to be empty and                                 will contain int. CAUTION: Note, that the encodings differ from the encodings saved in the          mesh. TODO: Encodings are the same as in p4est_mesh for all quadrants. TODO: Ghosts can be encoded by returning the quad_to_quad convention in qid.       For ghost quadrants, we add -300 to the values in p4est_mesh.       This means that values below -100 belong to ghosts, values above to locals.          Positive values are for local quadrants, negative values indicate          ghost quadrants.          Faces:     1 ..   8 => same size neighbor                                 (r * 4 + nf) + 1; nf = 0 .. 3 face index;                                 r = 0 .. 1 relative orientation                     9 ..  24 => double size neighbor                                 9 + h * 8 + r * 4 + nf; h = 0 .. 1 number                                 of the subface; r, nf as above                    25 ..  32 => half-size neighbors                                 25 + r * 4 + nf; r, nf as above          Corners:   1 ..   4 => size not encoded for corners                                 nc + 1; nc = 0 .. 3 corner index
	  * `neighboring_encs`:   Array containing encodings for neighboring                                 quads.                                 Needs to be empty, contains int.
	
	## Reference
	
	[p4est_mesh.h:232](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:232:21)
	""" p4est_mesh_get_neighbors
	export p4est_mesh_get_neighbors
	𝐣𝐥.@cextern p4est_mesh_get_neighbors(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, curr_quad_id::p4est_locidx_t, direction::p4est_locidx_t, neighboring_quads::𝐣𝐥.Ptr{sc_array_t}, neighboring_encs::𝐣𝐥.Ptr{sc_array_t}, neighboring_qids::𝐣𝐥.Ptr{sc_array_t})::p4est_locidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_quadrant_cumulative(p4est::𝐣𝐥.Ptr{p4est_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, cumulative_id::p4est_locidx_t, which_tree::𝐣𝐥.Ptr{p4est_topidx_t}, quadrant_id::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Ptr{p4est_quadrant_t}
	```
	
	 Find a quadrant based on its cumulative number in the local forest. If the quad_to_tree field of the mesh structure exists, this is O(1). Otherwise, we perform a binary search over the processor-local trees.
	
	## Parameters
	
	  * `p4est`:           Forest to be worked with.
	  * `mesh`:            A mesh derived from the forest.
	  * `cumulative_id`:   Cumulative index over all trees of quadrant.                              Must refer to a local (non-ghost) quadrant.
	  * `which_tree`:   If not NULL, the input value can be -1                              or an initial guess for the quadrant's tree                              and output is the tree of returned quadrant.
	  * `quadrant_id`:     If not NULL, the number of quadrant in tree.
	
	## Returns
	
	                      The identified quadrant.
	
	## Reference
	
	[p4est_mesh.h:255](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:255:21)
	""" p4est_mesh_quadrant_cumulative
	export p4est_mesh_quadrant_cumulative
	𝐣𝐥.@cextern p4est_mesh_quadrant_cumulative(p4est::𝐣𝐥.Ptr{p4est_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, cumulative_id::p4est_locidx_t, which_tree::𝐣𝐥.Ptr{p4est_topidx_t}, quadrant_id::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Ptr{p4est_quadrant_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_init2(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, which_tree::p4est_topidx_t, quadrant_id::p4est_locidx_t)::𝐣𝐥.Cvoid
	```
	
	 Initialize a mesh neighbor iterator by quadrant index. 
	
	## Parameters
	
	  * `mfn`:         A p4est_mesh_face_neighbor_t to be initialized.
	  * `which_tree`:  Tree of quadrant whose neighbors are looped over.
	  * `quadrant_id`: Index relative to which_tree of quadrant.
	
	## Reference
	
	[p4est_mesh.h:269](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:269:21)
	""" p4est_mesh_face_neighbor_init2
	export p4est_mesh_face_neighbor_init2
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_init2(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, which_tree::p4est_topidx_t, quadrant_id::p4est_locidx_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_init(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, which_tree::p4est_topidx_t, quadrant::𝐣𝐥.Ptr{p4est_quadrant_t})::𝐣𝐥.Cvoid
	```
	
	 Initialize a mesh neighbor iterator by quadrant pointer. 
	
	## Parameters
	
	  * `mfn`:         A p4est_mesh_face_neighbor_t to be initialized.
	  * `which_tree`:  Tree of quadrant whose neighbors are looped over.
	  * `quadrant`:    Pointer to quadrant contained in which_tree.
	
	## Reference
	
	[p4est_mesh.h:282](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:282:21)
	""" p4est_mesh_face_neighbor_init
	export p4est_mesh_face_neighbor_init
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_init(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, which_tree::p4est_topidx_t, quadrant::𝐣𝐥.Ptr{p4est_quadrant_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_next(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, ntree::𝐣𝐥.Ptr{p4est_topidx_t}, nquad::𝐣𝐥.Ptr{p4est_locidx_t}, nface::𝐣𝐥.Ptr{𝐣𝐥.Cint}, nrank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Ptr{p4est_quadrant_t}
	```
	
	 Move the iterator forward to loop around neighbors of the quadrant. 
	
	## Parameters
	
	  * `mfn`:      Internal status of the iterator.
	  * `ntree`:    If not NULL, the tree number of the neighbor.
	  * `nquad`:    If not NULL, the quadrant number within tree.                          For ghosts instead the number in ghost layer.
	  * `nface`:    If not NULL, neighbor's face as in p4est_mesh_t.
	  * `nrank`:    If not NULL, the owner process of the neighbor.
	
	## Returns
	
	                  Either a real quadrant or one from the ghost layer.                          Returns NULL when the iterator is done.
	
	## Reference
	
	[p4est_mesh.h:300](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:300:21)
	""" p4est_mesh_face_neighbor_next
	export p4est_mesh_face_neighbor_next
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_next(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, ntree::𝐣𝐥.Ptr{p4est_topidx_t}, nquad::𝐣𝐥.Ptr{p4est_locidx_t}, nface::𝐣𝐥.Ptr{𝐣𝐥.Cint}, nrank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Ptr{p4est_quadrant_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_data(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Get the user data for the current face neighbor. 
	
	## Parameters
	
	  * `mfn`:           Internal status of the iterator.
	  * `ghost_data`:    Data for the ghost quadrants that has been                               synchronized with p4est_ghost_exchange_data.
	
	## Returns
	
	                       A pointer to the user data for the current                               neighbor.
	
	## Reference
	
	[p4est_mesh.h:313](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_mesh.h:313:21)
	""" p4est_mesh_face_neighbor_data
	export p4est_mesh_face_neighbor_data
	𝐣𝐥.@cextern p4est_mesh_face_neighbor_data(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p4est_iter_volume_t callback function.
	
	## Details
	
	 *treeid* gives the index in *p4est->trees* of the tree to which    *quad* belongs. *quadid* gives the index of *quad* within *tree's* quadrants array.
	
	## Reference
	
	[p4est_iterate.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:56:1)
	""" p4est_iter_volume_info_t
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p4est_iter_volume_t callback function.
	
	## Details
	
	 *treeid* gives the index in *p4est->trees* of the tree to which    *quad* belongs. *quadid* gives the index of *quad* within *tree's* quadrants array.
	
	## Reference
	
	[p4est_iterate.h:47](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:47:16)
	""" p4est_iter_volume_info
	export p4est_iter_volume_info, p4est_iter_volume_info_t
	𝐣𝐥.@ctypedef p4est_iter_volume_info_t 𝐣𝐥.@cstruct p4est_iter_volume_info {
		p4est::𝐣𝐥.Ptr{p4est_t}
		ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}
		quad::𝐣𝐥.Ptr{p4est_quadrant_t}
		quadid::p4est_locidx_t
		treeid::p4est_topidx_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p4est_iterate will execute at every quadrant local to the current process. 
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p4est_iterate()
	
	## Reference
	
	[p4est_iterate.h:63](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:63:23)
	""" p4est_iter_volume_t
	export p4est_iter_volume_t
	𝐣𝐥.@ctypedef p4est_iter_volume_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_iter_volume_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_iterate.h:82](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:82:9)
	""" p4est_iter_face_side_data
	𝐣𝐥.@doc """
	 Information about one side of a face in the forest.
	
	## Details
	
	 If a *quad* is local (*is_ghost* is false), then its *quadid* indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order.  If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.
	
	## Reference
	
	[p4est_iterate.h:75](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:75:16)
	""" p4est_iter_face_side
	𝐣𝐥.@doc """
	 Information about one side of a face in the forest.
	
	## Details
	
	 If a *quad* is local (*is_ghost* is false), then its *quadid* indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order.  If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.
	
	## Reference
	
	[p4est_iterate.h:103](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:103:1)
	""" p4est_iter_face_side_t
	export p4est_iter_face_side, p4est_iter_face_side_data, p4est_iter_face_side_t
	𝐣𝐥.@ctypedef p4est_iter_face_side_t 𝐣𝐥.@cstruct p4est_iter_face_side {
		treeid::p4est_topidx_t
		face::int8_t
		is_hanging::int8_t
		is::𝐣𝐥.@cunion p4est_iter_face_side_data {
			full::𝐣𝐥.@cstruct {
				is_ghost::int8_t
				quad::𝐣𝐥.Ptr{p4est_quadrant_t}
				quadid::p4est_locidx_t
			}
			hanging::𝐣𝐥.@cstruct {
				is_ghost::int8_t[2]
				quad::𝐣𝐥.Ptr{p4est_quadrant_t}[2]
				quadid::p4est_locidx_t[2]
			}
		}
	}
	
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p4est_iter_face_t callback.
	
	## Details
	
	 The orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside boundary of the forest, then there is only one side.  If tree_boundary is false, the face is on the interior of a tree.  When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P4EST_CONNECT_FACE.
	
	## Reference
	
	[p4est_iterate.h:127](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:127:1)
	""" p4est_iter_face_info_t
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p4est_iter_face_t callback.
	
	## Details
	
	 The orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside boundary of the forest, then there is only one side.  If tree_boundary is false, the face is on the interior of a tree.  When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P4EST_CONNECT_FACE.
	
	## Reference
	
	[p4est_iterate.h:116](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:116:16)
	""" p4est_iter_face_info
	export p4est_iter_face_info, p4est_iter_face_info_t
	𝐣𝐥.@ctypedef p4est_iter_face_info_t 𝐣𝐥.@cstruct p4est_iter_face_info {
		p4est::𝐣𝐥.Ptr{p4est_t}
		ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}
		orientation::int8_t
		tree_boundary::int8_t
		sides::sc_array_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p4est_iterate will execute wherever two quadrants share a face: the face can be a 2:1 hanging face, it does not have to be conformal.
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p4est_iterate()
	
	NOTE: the forest must be face balanced for p4est_iterate() to execute a callback function on faces (see p4est_balance()).
	
	## Reference
	
	[p4est_iterate.h:139](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:139:23)
	""" p4est_iter_face_t
	export p4est_iter_face_t
	𝐣𝐥.@ctypedef p4est_iter_face_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_iter_face_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Information about one side of a corner in the forest.  If a *quad* is local (*is_ghost* is false), then its *quadid* indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.
	
	## Details
	
	 the *faces* field provides some additional information about the local topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that there is a common face between these two sides of the corner.
	
	## Reference
	
	[p4est_iterate.h:152](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:152:16)
	""" p4est_iter_corner_side
	𝐣𝐥.@doc """
	 Information about one side of a corner in the forest.  If a *quad* is local (*is_ghost* is false), then its *quadid* indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.
	
	## Details
	
	 the *faces* field provides some additional information about the local topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that there is a common face between these two sides of the corner.
	
	## Reference
	
	[p4est_iterate.h:162](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:162:1)
	""" p4est_iter_corner_side_t
	export p4est_iter_corner_side, p4est_iter_corner_side_t
	𝐣𝐥.@ctypedef p4est_iter_corner_side_t 𝐣𝐥.@cstruct p4est_iter_corner_side {
		treeid::p4est_topidx_t
		corner::int8_t
		is_ghost::int8_t
		quad::𝐣𝐥.Ptr{p4est_quadrant_t}
		quadid::p4est_locidx_t
		faces::int8_t[2]
	}
	
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p4est_iter_corner_t callback.
	
	## Details
	
	 If tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P4EST_CONNECT_FACE/CORNER depending on the location of the corner relative to the tree.
	
	## Reference
	
	[p4est_iterate.h:181](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:181:1)
	""" p4est_iter_corner_info_t
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p4est_iter_corner_t callback.
	
	## Details
	
	 If tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P4EST_CONNECT_FACE/CORNER depending on the location of the corner relative to the tree.
	
	## Reference
	
	[p4est_iterate.h:173](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:173:16)
	""" p4est_iter_corner_info
	export p4est_iter_corner_info, p4est_iter_corner_info_t
	𝐣𝐥.@ctypedef p4est_iter_corner_info_t 𝐣𝐥.@cstruct p4est_iter_corner_info {
		p4est::𝐣𝐥.Ptr{p4est_t}
		ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}
		tree_boundary::int8_t
		sides::sc_array_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p4est_iterate will execute wherever quadrants meet at a conformal corner
	
	## Details
	
	 i.e. the callback will not execute on a hanging corner.
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p4est_iterate()
	
	NOTE: the forest does not need to be corner balanced for p4est_iterate() to correctly execute a callback function at corners, only face balanced (see p4est_balance()).
	
	## Reference
	
	[p4est_iterate.h:195](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:195:23)
	""" p4est_iter_corner_t
	export p4est_iter_corner_t
	𝐣𝐥.@ctypedef p4est_iter_corner_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_iter_corner_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_iterate(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p4est_iter_volume_t, iter_face::p4est_iter_face_t, iter_corner::p4est_iter_corner_t)::𝐣𝐥.Cvoid
	```
	
	 Execute user supplied callbacks at every volume, face, and corner in the local forest.
	
	## Details
	
	 p4est_iterate executes the user-supplied callback functions at every volume, face, and corner in the local forest. The ghost_layer may be NULL. The *user_data* pointer is not touched by p4est_iterate, but is passed to each of the callbacks.  Any of the callbacks may be NULL. The callback functions are interspersed with each other, i.e. some face callbacks will occur between volume callbacks, and some corner callbacks will occur between face callbacks:
	
	 1) volume callbacks occur in the sorted Morton-index order. 2) a face callback is not executed until after the volume callbacks have    been executed for the quadrants that share it. 3) a corner callback is not executed until the face callbacks have been    executed for all faces that touch the corner. 4) it is not always the case that every face callback for a given quadrant    is executed before any of the corner callbacks. 5) callbacks are not executed at faces or corners that only involve ghost    quadrants, i.e. that are not adjacent in the local section of the    forest.
	
	## Parameters
	
	  * `p4est`:          the forest
	  * `ghost_layer`:    optional: when not given, callbacks at the                           boundaries of the local partition cannot provide                           quadrant data about ghost quadrants: missing                           (p4est_quadrant_t *) pointers are set to NULL,                           missing indices are set to -1.
	  * `user_data`:  optional context to supply to each callback
	  * `iter_volume`:    callback function for every quadrant's interior
	  * `iter_face`:      callback function for every face between                           quadrants
	  * `iter_corner`:    callback function for every corner between                           quadrants
	
	## Reference
	
	[p4est_iterate.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_iterate.h:233:21)
	""" p4est_iterate
	export p4est_iterate
	𝐣𝐥.@cextern p4est_iterate(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p4est_iter_volume_t, iter_face::p4est_iter_face_t, iter_corner::p4est_iter_corner_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_lnodes.h:33](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:33:21)
	""" p4est_lnodes_code_t
	export p4est_lnodes_code_t
	𝐣𝐥.@ctypedef p4est_lnodes_code_t int8_t
	
	𝐣𝐥.@doc """
	 Store a parallel numbering of Lobatto points of a given degree > 0.
	
	## Details
	
	 Each element has degree+1 nodes per face and vnodes = (degree+1)^2 nodes per volume. num_local_elements is the number of local quadrants in the p4est. element_nodes is of dimension vnodes * num_local_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); so for degree == 2, this is the layout of nodes:
	
	         f_3  c_2           c_3      6---7---8      |       | f_0  3   4   5  f_1      |       |      0---1---2  c_0           c_1         f_2
	
	 element_nodes indexes into the set of local nodes, layed out as follows: local nodes = [<-----owned_count----->|<-----nonlocal_nodes----->]             = [<----------------num_local_nodes----------------->] nonlocal_nodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.
	
	 Whether nodes are hanging or not is decided based on the element faces. This information is encoded in face_code with one int8_t per element. If no faces are hanging, the value is zero, otherwise the face_code is interpreted by p4est_lnodes_decode.
	
	 Independent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree *touching* the node.
	
	 What is meant by *touching*? A quadrant is said to touch all faces/corners that are incident on it, and by extension all nodes that are contained in those faces/corners.
	
	         X +-----------+         o |           |         o |           | +-----+ o |     p     | |  q  | o |           | |     | o |           | +-----+ O +-----------+
	
	 In this example degree = 6.  There are 5 nodes that live on the face between q and p, and one at each corner of that face.  The face is incident on q, so q owns the nodes on the face (provided q is from a lower tree or has a lower index than p).  The lower corner is incident on q, so q owns it as well.  The upper corner is not incident on q, so q cannot own it.
	
	 global_owned_count contains the number of independent nodes owned by each process.
	
	 The sharers array contains items of type p4est_lnodes_rank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.
	
	 degree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces and corners) rather than the \$C^0\$ Lobatto nodes:
	
	 if degree == -1, then one node is assigned per face, and no nodes are assigned per volume or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 4, and the nodes are listed in face-order:
	
	         f_3  c_2           c_3      +---3---+      |       | f_0  0       1  f_1      |       |      +---2---+  c_0           c_1         f_2
	
	 if degree == -2, then one node is assigned per face and per corner and no nodes are assigned per volume.  In this case, vnodes == 8, and the nodes are listed in face-order, followed by corner-order:
	
	         f_3  c_2           c_3      6---3---7      |       | f_0  0       1  f_1      |       |      4---2---5  c_0           c_1         f_2
	
	## Reference
	
	[p4est_lnodes.h:132](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:132:16)
	""" p4est_lnodes
	𝐣𝐥.@doc """
	 Store a parallel numbering of Lobatto points of a given degree > 0.
	
	## Details
	
	 Each element has degree+1 nodes per face and vnodes = (degree+1)^2 nodes per volume. num_local_elements is the number of local quadrants in the p4est. element_nodes is of dimension vnodes * num_local_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); so for degree == 2, this is the layout of nodes:
	
	         f_3  c_2           c_3      6---7---8      |       | f_0  3   4   5  f_1      |       |      0---1---2  c_0           c_1         f_2
	
	 element_nodes indexes into the set of local nodes, layed out as follows: local nodes = [<-----owned_count----->|<-----nonlocal_nodes----->]             = [<----------------num_local_nodes----------------->] nonlocal_nodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.
	
	 Whether nodes are hanging or not is decided based on the element faces. This information is encoded in face_code with one int8_t per element. If no faces are hanging, the value is zero, otherwise the face_code is interpreted by p4est_lnodes_decode.
	
	 Independent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree *touching* the node.
	
	 What is meant by *touching*? A quadrant is said to touch all faces/corners that are incident on it, and by extension all nodes that are contained in those faces/corners.
	
	         X +-----------+         o |           |         o |           | +-----+ o |     p     | |  q  | o |           | |     | o |           | +-----+ O +-----------+
	
	 In this example degree = 6.  There are 5 nodes that live on the face between q and p, and one at each corner of that face.  The face is incident on q, so q owns the nodes on the face (provided q is from a lower tree or has a lower index than p).  The lower corner is incident on q, so q owns it as well.  The upper corner is not incident on q, so q cannot own it.
	
	 global_owned_count contains the number of independent nodes owned by each process.
	
	 The sharers array contains items of type p4est_lnodes_rank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.
	
	 degree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces and corners) rather than the \$C^0\$ Lobatto nodes:
	
	 if degree == -1, then one node is assigned per face, and no nodes are assigned per volume or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 4, and the nodes are listed in face-order:
	
	         f_3  c_2           c_3      +---3---+      |       | f_0  0       1  f_1      |       |      +---2---+  c_0           c_1         f_2
	
	 if degree == -2, then one node is assigned per face and per corner and no nodes are assigned per volume.  In this case, vnodes == 8, and the nodes are listed in face-order, followed by corner-order:
	
	         f_3  c_2           c_3      6---3---7      |       | f_0  0       1  f_1      |       |      4---2---5  c_0           c_1         f_2
	
	## Reference
	
	[p4est_lnodes.h:147](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:147:1)
	""" p4est_lnodes_t
	export p4est_lnodes, p4est_lnodes_t
	𝐣𝐥.@ctypedef p4est_lnodes_t 𝐣𝐥.@cstruct p4est_lnodes {
		mpicomm::sc_MPI_Comm
		num_local_nodes::p4est_locidx_t
		owned_count::p4est_locidx_t
		global_offset::p4est_gloidx_t
		nonlocal_nodes::𝐣𝐥.Ptr{p4est_gloidx_t}
		sharers::𝐣𝐥.Ptr{sc_array_t}
		global_owned_count::𝐣𝐥.Ptr{p4est_locidx_t}
		(degree, vnodes)::𝐣𝐥.Cint
		num_local_elements::p4est_locidx_t
		face_code::𝐣𝐥.Ptr{p4est_lnodes_code_t}
		element_nodes::𝐣𝐥.Ptr{p4est_locidx_t}
	}
	
	𝐣𝐥.@doc """
	 The structure stored in the sharers array.
	
	## Details
	
	 shared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes.  The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p4est_lnodes_t.
	
	## Reference
	
	[p4est_lnodes.h:167](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:167:1)
	""" p4est_lnodes_rank_t
	𝐣𝐥.@doc """
	 The structure stored in the sharers array.
	
	## Details
	
	 shared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes.  The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p4est_lnodes_t.
	
	## Reference
	
	[p4est_lnodes.h:160](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:160:16)
	""" p4est_lnodes_rank
	export p4est_lnodes_rank, p4est_lnodes_rank_t
	𝐣𝐥.@ctypedef p4est_lnodes_rank_t 𝐣𝐥.@cstruct p4est_lnodes_rank {
		rank::𝐣𝐥.Cint
		shared_nodes::sc_array_t
		(shared_mine_offset, shared_mine_count)::p4est_locidx_t
		(owned_offset, owned_count)::p4est_locidx_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_new(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, degree::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_lnodes_t}
	```
	
	## Reference
	
	[p4est_lnodes.h:209](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:209:21)
	""" p4est_lnodes_new
	export p4est_lnodes_new
	𝐣𝐥.@cextern p4est_lnodes_new(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, degree::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_lnodes_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_destroy(lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_lnodes.h:213](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:213:21)
	""" p4est_lnodes_destroy
	export p4est_lnodes_destroy
	𝐣𝐥.@cextern p4est_lnodes_destroy(lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_support_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Expand the ghost layer to include the support of all nodes supported on the local partition.
	
	## Parameters
	
	  * `p4est`:        The forest from which the ghost layer was                              generated.
	  * `lnodes`:       The nodes to support.
	  * `ghost`:        The ghost layer to be expanded.
	
	## Reference
	
	[p4est_lnodes.h:223](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:223:21)
	""" p4est_ghost_support_lnodes
	export p4est_ghost_support_lnodes
	𝐣𝐥.@cextern p4est_ghost_support_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_ghost_expand_by_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Expand the ghost layer as in p4est_ghost_expand(), but use node support to define adjacency instead of geometric adjacency.
	
	## Parameters
	
	  * `p4est`:        The forest from which the ghost layer was                              generated.
	  * `lnodes`:       The nodes to support.
	  * `ghost`:        The ghost layer to be expanded.
	
	## Reference
	
	[p4est_lnodes.h:235](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:235:21)
	""" p4est_ghost_expand_by_lnodes
	export p4est_ghost_expand_by_lnodes
	𝐣𝐥.@cextern p4est_ghost_expand_by_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_partition_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, degree::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Partition using weights based on the number of nodes assigned to each element in lnodes
	
	## Parameters
	
	  * `p4est`:                    the forest to be repartitioned
	  * `ghost`:                    the ghost layer
	  * `degree`:                   the degree that would be passed to p4est_lnodes_new()
	  * `partition_for_coarsening`: whether the partition should allow                                         coarsening (i.e. group siblings who                                         might merge)
	
	## Reference
	
	[p4est_lnodes.h:249](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:249:21)
	""" p4est_partition_lnodes
	export p4est_partition_lnodes
	𝐣𝐥.@cextern p4est_partition_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, degree::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_partition_lnodes_detailed(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, nodes_per_volume::𝐣𝐥.Cint, nodes_per_face::𝐣𝐥.Cint, nodes_per_corner::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Partition using weights that are broken down by where they reside: in volumes, on faces, or on corners.
	
	## Reference
	
	[p4est_lnodes.h:256](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:256:21)
	""" p4est_partition_lnodes_detailed
	export p4est_partition_lnodes_detailed
	𝐣𝐥.@cextern p4est_partition_lnodes_detailed(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, nodes_per_volume::𝐣𝐥.Cint, nodes_per_face::𝐣𝐥.Cint, nodes_per_corner::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 p4est_lnodes_buffer_t handles the communication of data associated with nodes.
	
	## Details
	
	 *send_buffers* is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared_*_begin and a shared_*_end call.
	
	 *recv_buffers* is an array of arrays that is used in lnodes_share_all_*. *recv_buffers[j]* corresponds with lnodes->sharers[j]: it is the same length as *lnodes->sharers[j]->shared_nodes.*  At the completion of lnodes_share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).
	
	## Reference
	
	[p4est_lnodes.h:284](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:284:1)
	""" p4est_lnodes_buffer_t
	𝐣𝐥.@doc """
	 p4est_lnodes_buffer_t handles the communication of data associated with nodes.
	
	## Details
	
	 *send_buffers* is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared_*_begin and a shared_*_end call.
	
	 *recv_buffers* is an array of arrays that is used in lnodes_share_all_*. *recv_buffers[j]* corresponds with lnodes->sharers[j]: it is the same length as *lnodes->sharers[j]->shared_nodes.*  At the completion of lnodes_share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).
	
	## Reference
	
	[p4est_lnodes.h:278](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:278:16)
	""" p4est_lnodes_buffer
	export p4est_lnodes_buffer, p4est_lnodes_buffer_t
	𝐣𝐥.@ctypedef p4est_lnodes_buffer_t 𝐣𝐥.@cstruct p4est_lnodes_buffer {
		requests::𝐣𝐥.Ptr{sc_array_t}
		send_buffers::𝐣𝐥.Ptr{sc_array_t}
		recv_buffers::𝐣𝐥.Ptr{sc_array_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_share_owned_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}
	```
	
	 p4est_lnodes_share_owned_begin
	
	## Details
	
	 *node_data* is a user-defined array of arbitrary type, where each entry is associated with the *lnodes* local nodes entry of matching index. For every local nodes entry that is owned by a process other than the current one, the value in the *node_data* array of the owning process is written directly into the *node_data* array of the current process.  Values of *node_data* are not guaranteed to be sent or received until the *buffer* created by p4est_lnodes_share_owned_begin is passed to p4est_lnodes_share_owned_end.
	
	 To be memory neutral, the *buffer* created by p4est_lnodes_share_owned_begin must be destroying with p4est_lnodes_buffer_destroy (it is not destroyed by p4est_lnodes_share_owned_end).
	
	## Reference
	
	[p4est_lnodes.h:302](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:302:24)
	""" p4est_lnodes_share_owned_begin
	export p4est_lnodes_share_owned_begin
	𝐣𝐥.@cextern p4est_lnodes_share_owned_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_share_owned_end(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_lnodes.h:306](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:306:21)
	""" p4est_lnodes_share_owned_end
	export p4est_lnodes_share_owned_end
	𝐣𝐥.@cextern p4est_lnodes_share_owned_end(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_share_owned(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Cvoid
	```
	
	 Equivalent to calling p4est_lnodes_share_owned_end directly after p4est_lnodes_share_owned_begin.  Use if there is no local work that can be done to mask the communication cost.
	
	## Reference
	
	[p4est_lnodes.h:313](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:313:21)
	""" p4est_lnodes_share_owned
	export p4est_lnodes_share_owned
	𝐣𝐥.@cextern p4est_lnodes_share_owned(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_share_all_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}
	```
	
	 p4est_lnodes_share_all_begin
	
	## Details
	
	 *node_data* is a user_defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every process that shares an entry with the current one, the value in the *node_data* array of that process is written into a *buffer->recv_buffers* entry as described above.  The user can then perform some arbitrary work that requires the data from all processes that share a node (such as reduce, max, min, etc.).  When the work concludes, the *buffer* should be destroyed with p4est_lnodes_buffer_destroy.
	
	 Values of *node_data* are not guaranteed to be sent, and *buffer->recv_buffer* entries are not guaranteed to be received until the *buffer* created by p4est_lnodes_share_all_begin is passed to p4est_lnodes_share_all_end.
	
	## Reference
	
	[p4est_lnodes.h:332](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:332:24)
	""" p4est_lnodes_share_all_begin
	export p4est_lnodes_share_all_begin
	𝐣𝐥.@cextern p4est_lnodes_share_all_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_share_all_end(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_lnodes.h:335](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:335:21)
	""" p4est_lnodes_share_all_end
	export p4est_lnodes_share_all_end
	𝐣𝐥.@cextern p4est_lnodes_share_all_end(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_share_all(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}
	```
	
	 Equivalent to calling p4est_lnodes_share_all_end directly after p4est_lnodes_share_all_begin.  Use if there is no local work that can be done to mask the communication cost. 
	
	## Returns
	
	          A fully initialized buffer that contains the received data.                  After processing this data, the buffer must be freed with                  p4est_lnodes_buffer_destroy.
	
	## Reference
	
	[p4est_lnodes.h:345](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:345:24)
	""" p4est_lnodes_share_all
	export p4est_lnodes_share_all
	𝐣𝐥.@cextern p4est_lnodes_share_all(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lnodes_buffer_destroy(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_lnodes.h:348](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_lnodes.h:348:21)
	""" p4est_lnodes_buffer_destroy
	export p4est_lnodes_buffer_destroy
	𝐣𝐥.@cextern p4est_lnodes_buffer_destroy(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 A datatype to handle the linear id in 2D. 
	
	## Reference
	
	[p4est_extended.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:51:21)
	""" p4est_lid_t
	export p4est_lid_t
	𝐣𝐥.@ctypedef p4est_lid_t uint64_t
	
	𝐣𝐥.@doc """
	 Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p4est main structure.
	
	## Details
	
	 The balance_ranges and balance_notify* times are collected whenever an inspect structure is present in p4est.
	
	## Reference
	
	[p4est_extended.h:61](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:61:8)
	""" p4est_inspect
	export p4est_inspect
	𝐣𝐥.@cstruct p4est_inspect {
		use_balance_ranges::𝐣𝐥.Cint
		use_balance_ranges_notify::𝐣𝐥.Cint
		use_balance_verify::𝐣𝐥.Cint
		balance_max_ranges::𝐣𝐥.Cint
		balance_A_count_in::size_t
		balance_A_count_out::size_t
		balance_comm_sent::size_t
		balance_comm_nzpeers::size_t
		balance_B_count_in::size_t
		balance_B_count_out::size_t
		(balance_zero_sends::_[2], balance_zero_receives::_[2])::size_t
		balance_A::𝐣𝐥.Cdouble
		balance_comm::𝐣𝐥.Cdouble
		balance_B::𝐣𝐥.Cdouble
		balance_ranges::𝐣𝐥.Cdouble
		balance_notify::𝐣𝐥.Cdouble
		balance_notify_allgather::𝐣𝐥.Cdouble
		use_B::𝐣𝐥.Cint
	}
	
	𝐣𝐥.@doc """
	 Callback function prototype to replace one set of quadrants with another.
	
	## Details
	
	 This is used by extended routines when the quadrants of an existing, valid p4est are changed.  The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.
	
	## Parameters
	
	  * `num_outgoing`: The number of outgoing quadrants.
	  * `outgoing`:     The outgoing quadrants: after the callback, the                          user_data, if *p4est->data_size* is nonzero,                          will be destroyed.
	  * `num_incoming`: The number of incoming quadrants.
	  * `incoming`: The incoming quadrants: prior to the callback,                          the user_data, if *p4est->data_size* is nonzero,                          is allocated, and the p4est_init_t callback,                          if it has been provided, will be called.
	
	 If the mesh is being refined, num_outgoing will be 1 and num_incoming will be 4, and vice versa if the mesh is being coarsened.
	
	## Reference
	
	[p4est_extended.h:109](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:109:23)
	""" p4est_replace_t
	export p4est_replace_t
	𝐣𝐥.@ctypedef p4est_replace_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p4est_t}, p4est_topidx_t, 𝐣𝐥.Cint, 𝐣𝐥.Ptr{p4est_quadrant_t}[], 𝐣𝐥.Cint, 𝐣𝐥.Ptr{p4est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cint
	```
	
	 Compare the p4est_lid_t *a* and the p4est_lid_t *b.* 
	
	## Parameters
	
	  * `a`: A pointer to a p4est_lid_t.
	  * `b`: A pointer to a p4est_lid_t.
	
	## Returns
	
	        Returns -1 if a < b,                         1 if a > b and                         0 if a == b.
	
	## Reference
	
	[p4est_extended.h:123](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:123:21)
	""" p4est_lid_compare
	export p4est_lid_compare
	𝐣𝐥.@cextern p4est_lid_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cint
	```
	
	 Checks if the p4est_lid_t *a* and the p4est_lid_t *b* are equal. 
	
	## Parameters
	
	  * `a`: A pointer to a p4est_lid_t.
	  * `b`: A pointer to a p4est_lid_t.
	
	## Returns
	
	        Returns a true value if *a* and *b* are equal,                false otherwise
	
	## Reference
	
	[p4est_extended.h:132](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:132:21)
	""" p4est_lid_is_equal
	export p4est_lid_is_equal
	𝐣𝐥.@cextern p4est_lid_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_init(input::𝐣𝐥.Ptr{p4est_lid_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an unsigned 64 bit integer. *high* is just a  a placeholder to use the same interface in 3D. 
	
	## Parameters
	
	  * `input`:  A pointer to a p4est_lid_t that will be intialized.
	  * `high`:       The given high bits must be zero.
	  * `low`:        The given low bits to initialize *input.*
	
	## Reference
	
	[p4est_extended.h:141](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:141:21)
	""" p4est_lid_init
	export p4est_lid_init
	𝐣𝐥.@cextern p4est_lid_init(input::𝐣𝐥.Ptr{p4est_lid_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_set_zero(input::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to zero. 
	
	## Parameters
	
	  * `input`:     A pointer to a p4est_lid_t that will be intialized.
	
	## Reference
	
	[p4est_extended.h:147](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:147:21)
	""" p4est_lid_set_zero
	export p4est_lid_set_zero
	𝐣𝐥.@cextern p4est_lid_set_zero(input::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_set_one(input::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to one. 
	
	## Parameters
	
	  * `input`:     A pointer to a p4est_lid_t that will be intialized.
	
	## Reference
	
	[p4est_extended.h:152](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:152:21)
	""" p4est_lid_set_one
	export p4est_lid_set_one
	𝐣𝐥.@cextern p4est_lid_set_one(input::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_set_uint64(input::𝐣𝐥.Ptr{p4est_lid_t}, u::uint64_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to an unsigned 64 bit integer. 
	
	## Parameters
	
	  * `input`:     A pointer to a p4est_lid_t that will be intialized.
	
	## Reference
	
	[p4est_extended.h:157](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:157:21)
	""" p4est_lid_set_uint64
	export p4est_lid_set_uint64
	𝐣𝐥.@cextern p4est_lid_set_uint64(input::𝐣𝐥.Ptr{p4est_lid_t}, u::uint64_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Returns the bit_number-th bit of *input.* This function checks a bit of an existing, initialized value. 
	
	## Parameters
	
	  * `input`:      A pointer to a p4est_lid_t.
	  * `bit_number`: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= *bit_number* < 64.
	
	## Returns
	
	                    True if bit is set, false if not.
	
	## Reference
	
	[p4est_extended.h:167](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:167:21)
	""" p4est_lid_chk_bit
	export p4est_lid_chk_bit
	𝐣𝐥.@cextern p4est_lid_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_set_bit(input::𝐣𝐥.Ptr{p4est_lid_t}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Sets the exponent-th bit of *a* to one. This function modifies an existing, initialized value. 
	
	## Parameters
	
	  * `input`:      A pointer to a p4est_lid_t.
	  * `bit_number`: The bit (counted from the right hand side)                            that is set to one by logical or.                            Require 0 <= *bit_number* < 64.
	
	## Reference
	
	[p4est_extended.h:177](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:177:21)
	""" p4est_lid_set_bit
	export p4est_lid_set_bit
	𝐣𝐥.@cextern p4est_lid_set_bit(input::𝐣𝐥.Ptr{p4est_lid_t}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, output::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Copies an initialized p4est_lid_t to a p4est_lid_t. 
	
	## Parameters
	
	  * `input`:    A pointer to the p4est_lid_t that is copied.
	  * `output`:   A pointer to a p4est_lid_t.                          The low bits of *output* will                          be set to the low bits of                          *input* and high bits are ignored.
	
	## Reference
	
	[p4est_extended.h:186](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:186:21)
	""" p4est_lid_copy
	export p4est_lid_copy
	𝐣𝐥.@cextern p4est_lid_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, output::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Adds the uint128_t *b* to the uint128_t *a.* *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a p4est_lid_t.
	  * `b`:       A pointer to a p4est_lid_t.
	  * `result`:  A pointer to a p4est_lid_t.                      The sum *a* + *b* will be saved in *result.*
	
	## Reference
	
	[p4est_extended.h:197](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:197:21)
	""" p4est_lid_add
	export p4est_lid_add
	𝐣𝐥.@cextern p4est_lid_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Substracts the p4est_lid_t *b* from the p4est_lid_t *a.* This function assumes that the result is >= 0. *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a p4est_lid_t.
	  * `b`:       A pointer to a p4est_lid_t.
	  * `result`:  A pointer to a p4est_lid_t.                      The difference *a* - *b* will be saved in *result.*
	
	## Reference
	
	[p4est_extended.h:210](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:210:21)
	""" p4est_lid_sub
	export p4est_lid_sub
	𝐣𝐥.@cextern p4est_lid_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise negation of the uint128_t *a.* *a* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a p4est_lid_t.
	  * `result`:   A pointer to a p4est_lid_t.                      The bitwise negation of *a* will be saved in                      *result.*
	
	## Reference
	
	[p4est_extended.h:221](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:221:21)
	""" p4est_lid_bitwise_neg
	export p4est_lid_bitwise_neg
	𝐣𝐥.@cextern p4est_lid_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a p4est_lid_t.
	  * `b`:        A pointer to a p4est_lid_t.
	  * `result`:   A pointer to a p4est_lid_t.                      The bitwise or of *a* and *b* will be                      saved in *result.*
	
	## Reference
	
	[p4est_extended.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:233:21)
	""" p4est_lid_bitwise_or
	export p4est_lid_bitwise_or
	𝐣𝐥.@cextern p4est_lid_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a p4est_lid_t.
	  * `b`:       A pointer to a p4est_lid_t.
	  * `result`:  A pointer to a p4est_lid_t.                      The bitwise and of *a* and *b* will be saved.                      in *result.*
	
	## Reference
	
	[p4est_extended.h:246](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:246:21)
	""" p4est_lid_bitwise_and
	export p4est_lid_bitwise_and
	𝐣𝐥.@cextern p4est_lid_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit right shift of uint128_t *input* by shift_count bits. We shift in zeros from the left. If *shift_count* >= 64, *result* is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a p4est_lid_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a p4est_lid_t.                              The right shifted number will be saved                              in *result.*
	
	## Reference
	
	[p4est_extended.h:260](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:260:21)
	""" p4est_lid_shift_right
	export p4est_lid_shift_right
	𝐣𝐥.@cextern p4est_lid_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit left shift of uint128_t *input* by shift_count bits. We shift in zeros from the right. If *shift_count* >= 64, *result* is 0. All bits left from the 63th bit (counted zero based from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a p4est_lid_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a p4est_lid_t.                              The left shifted number will be saved                              in *result.*
	
	## Reference
	
	[p4est_extended.h:274](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:274:21)
	""" p4est_lid_shift_left
	export p4est_lid_shift_left
	𝐣𝐥.@cextern p4est_lid_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_add_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Adds the p4est_lid_t *b* to the p4est_lid_t *a.* The result is saved in *a.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a p4est_lid_t. *a*                      will be overwritten by *a* + *b.*
	  * `b`:       A pointer to a p4est_lid_t.
	
	## Reference
	
	[p4est_extended.h:284](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:284:21)
	""" p4est_lid_add_inplace
	export p4est_lid_add_inplace
	𝐣𝐥.@cextern p4est_lid_add_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_sub_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Substracts the uint128_t *b* from the uint128_t *a.* The result is saved in *a.* *a* == *b* is allowed. This function assumes that the result is >= 0. 
	
	## Parameters
	
	  * `a`:   A pointer to a p4est_lid_t.                      *a* will be overwritten by *a* - *b.*
	  * `b`:   A pointer to a p4est_lid_t.
	
	## Reference
	
	[p4est_extended.h:294](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:294:21)
	""" p4est_lid_sub_inplace
	export p4est_lid_sub_inplace
	𝐣𝐥.@cextern p4est_lid_sub_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_bitwise_or_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a p4est_lid_t.                      The bitwise or will be saved in *a.*
	  * `b`:   A pointer to a p4est_lid_t.
	
	## Reference
	
	[p4est_extended.h:303](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:303:21)
	""" p4est_lid_bitwise_or_inplace
	export p4est_lid_bitwise_or_inplace
	𝐣𝐥.@cextern p4est_lid_bitwise_or_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_lid_bitwise_and_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a p4est_lid_t.                      The bitwise and will be saved in *a.*
	  * `b`:   A pointer to a p4est_lid_t.
	
	## Reference
	
	[p4est_extended.h:312](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:312:21)
	""" p4est_lid_bitwise_and_inplace
	export p4est_lid_bitwise_and_inplace
	𝐣𝐥.@cextern p4est_lid_bitwise_and_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_quadrant_linear_id_ext128(quadrant::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Computes the linear position as p4est_lid_t of a quadrant in a uniform grid. The grid and quadrant levels need not coincide. If they do, this is the inverse of p4est_quadrant_set_morton. 
	
	## Parameters
	
	  * `quadrant`:  Quadrant whose linear index will be computed.                       If the quadrant is smaller than the grid (has a higher                       quadrant->level), the result is computed from its                       ancestor at the grid's level.                       If the quadrant has a smaller level than the grid (it                       is bigger than a grid cell), the grid cell sharing its                       lower left corner is used as reference.
	  * `level`:     The level of the regular grid compared to which the                       linear position is to be computed.
	  * `id`:     A pointer to an allocated or static p4est_lid_t.                       id will be the linear position of this quadrant on a                       uniform grid.
	
	NOTE: The user_data of *quadrant* is never modified.
	
	## Reference
	
	[p4est_extended.h:332](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:332:21)
	""" p4est_quadrant_linear_id_ext128
	export p4est_quadrant_linear_id_ext128
	𝐣𝐥.@cextern p4est_quadrant_linear_id_ext128(quadrant::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_quadrant_set_morton_ext128(quadrant::𝐣𝐥.Ptr{p4est_quadrant_t}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Set quadrant Morton indices based on linear position given as p4est_lid_t in uniform grid. This is the inverse operation of p4est_quadrant_linear_id. 
	
	## Parameters
	
	  * `quadrant`:  Quadrant whose Morton indices will be set.
	  * `level`:     Level of the grid and of the resulting quadrant.
	  * `id`:        Linear index of the quadrant on a uniform grid.
	
	NOTE: The user_data of *quadrant* is never modified.
	
	## Reference
	
	[p4est_extended.h:343](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:343:21)
	""" p4est_quadrant_set_morton_ext128
	export p4est_quadrant_set_morton_ext128
	𝐣𝐥.@cextern p4est_quadrant_set_morton_ext128(quadrant::𝐣𝐥.Ptr{p4est_quadrant_t}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_t}
	```
	
	 Create a new forest. This is a more general form of p4est_new. The forest created is either uniformly refined at a given level or created with the coarsest possible refinement that fits the exact partition that would have been created in the uniform mode. The latter, coarse refinement depends on the number of MPI processes! The initial level is currently limited to P4EST_OLD_QMAXLEVEL. Regardless, p4est_refine can go as deep as P4EST_QMAXLEVEL.
	
	## Parameters
	
	  * `mpicomm`:          A valid MPI communicator.
	  * `connectivity`:     This is the connectivity information that                              the forest is built with.  Note the forest                              does not take ownership of the memory.
	  * `min_quadrants`:    Minimum initial quadrants per processor.                              Makes the refinement pattern mpisize-specific.                              For maximum reproducibility, set this to 0.
	  * `min_level`:        The forest is refined at most to this level.                              Later coarsening and refinement is unaffected.                              May be negative or 0, then it has no effect.
	  * `fill_uniform`:     If true, fill the forest with a uniform mesh                              instead of the coarsest possible one.                              The latter is partition-specific, which                              is not a good idea wrt. reproducibility.
	  * `data_size`:        The size of data for each quadrant.
	  * `init_fn`:          Callback function to initialize the user_data                              which is internally allocated using data_size.
	  * `user_pointer`:     Assigned to the user_pointer member of the                              forest before init_fn is called the first time.
	
	## Returns
	
	                      Valid p4est object.
	
	## Reference
	
	[p4est_extended.h:377](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:377:21)
	""" p4est_new_ext
	export p4est_new_ext
	𝐣𝐥.@cextern p4est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_mesh_new_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, compute_tree_index::𝐣𝐥.Cint, compute_level_lists::𝐣𝐥.Cint, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_mesh_t}
	```
	
	 Create a new mesh. 
	
	## Parameters
	
	  * `p4est`:                A forest that is fully 2:1 balanced.
	  * `ghost`:                The ghost layer created from the                                  provided p4est.
	  * `compute_tree_index`:   Boolean to decide whether to allocate and                                  compute the quad_to_tree list.
	  * `compute_level_lists`:  Boolean to decide whether to compute the                                  level lists in quad_level.
	  * `btype`:                Currently ignored, only face neighbors                                  are stored.
	
	## Returns
	
	                          A fully allocated mesh structure.
	
	## Reference
	
	[p4est_extended.h:396](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:396:21)
	""" p4est_mesh_new_ext
	export p4est_mesh_new_ext
	𝐣𝐥.@cextern p4est_mesh_new_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, compute_tree_index::𝐣𝐥.Cint, compute_level_lists::𝐣𝐥.Cint, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_mesh_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_copy_ext(input::𝐣𝐥.Ptr{p4est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_t}
	```
	
	 Make a deep copy of a p4est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.
	
	## Parameters
	
	  * `copy_data`:  If true, data are copied.                         If false, data_size is set to 0.
	  * `duplicate_mpicomm`:  If true, MPI communicator is copied.
	
	## Returns
	
	  Returns a valid p4est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.
	
	## Reference
	
	[p4est_extended.h:416](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:416:21)
	""" p4est_copy_ext
	export p4est_copy_ext
	𝐣𝐥.@cextern p4est_copy_ext(input::𝐣𝐥.Ptr{p4est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_refine_ext(p4est::𝐣𝐥.Ptr{p4est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p4est_refine_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Refine a forest with a bounded refinement level and a replace option. 
	
	## Parameters
	
	  * `p4est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `maxlevel`:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p4est.h.
	  * `refine_fn`:  Callback function that must return true if a quadrant                        shall be refined.  If refine_recursive is true,                        refine_fn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether init_fn or                        replace_fn gets called.
	  * `init_fn`:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.
	
	## Reference
	
	[p4est_extended.h:440](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:440:21)
	""" p4est_refine_ext
	export p4est_refine_ext
	𝐣𝐥.@cextern p4est_refine_ext(p4est::𝐣𝐥.Ptr{p4est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p4est_refine_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_coarsen_ext(p4est::𝐣𝐥.Ptr{p4est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p4est_coarsen_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Coarsen a forest. 
	
	## Parameters
	
	  * `p4est`: The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `callback_orphans`: Boolean to enable calling coarsen_fn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsen_recursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.                        With coarsen_recursive false and callback_orphans true,                        it is guaranteed that every quadrant is passed exactly                        once into the coarsen_fn callback.
	  * `coarsen_fn`: Callback function that returns true if a                        family of quadrants shall be coarsened.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p4est_extended.h:467](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:467:21)
	""" p4est_coarsen_ext
	export p4est_coarsen_ext
	𝐣𝐥.@cextern p4est_coarsen_ext(p4est::𝐣𝐥.Ptr{p4est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p4est_coarsen_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_balance_ext(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 2:1 balance the size differences of neighboring elements in a forest. 
	
	## Parameters
	
	  * `p4est`:  The p4est to be worked on.
	  * `btype`:      Balance type (face or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p4est_extended.h:484](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:484:21)
	""" p4est_balance_ext
	export p4est_balance_ext
	𝐣𝐥.@cextern p4est_balance_ext(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_balance_subtree_ext(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, which_tree::p4est_topidx_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p4est_extended.h:489](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:489:21)
	""" p4est_balance_subtree_ext
	export p4est_balance_subtree_ext
	𝐣𝐥.@cextern p4est_balance_subtree_ext(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, which_tree::p4est_topidx_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_partition_ext(p4est::𝐣𝐥.Ptr{p4est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p4est_weight_t)::p4est_gloidx_t
	```
	
	 Repartition the forest.
	
	## Details
	
	 The forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).
	
	## Parameters
	
	  * `p4est`:      The forest that will be partitioned.
	  * `partition_for_coarsening`:     If true, the partition                            is modified to allow one level of coarsening.
	  * `weight_fn`:  A weighting function or NULL                            for uniform partitioning. A weighting function                            with constant weight 1 on each quadrant is                            equivalent to weight_fn == NULL but other constant                            weightings may result in different uniform                            partitionings.
	
	## Returns
	
	         The global number of shipped quadrants
	
	## Reference
	
	[p4est_extended.h:511](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:511:21)
	""" p4est_partition_ext
	export p4est_partition_ext
	𝐣𝐥.@cextern p4est_partition_ext(p4est::𝐣𝐥.Ptr{p4est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p4est_weight_t)::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_partition_for_coarsening(p4est::𝐣𝐥.Ptr{p4est_t}, num_quadrants_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	```
	
	 Correct partition to allow one level of coarsening.
	
	## Parameters
	
	  * `p4est`:                     forest whose partition is corrected
	  * `num_quadrants_in_proc`: partition that will be corrected
	
	## Returns
	
	                               absolute number of moved quadrants
	
	## Reference
	
	[p4est_extended.h:521](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:521:21)
	""" p4est_partition_for_coarsening
	export p4est_partition_for_coarsening
	𝐣𝐥.@cextern p4est_partition_for_coarsening(p4est::𝐣𝐥.Ptr{p4est_t}, num_quadrants_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_iterate_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p4est_iter_volume_t, iter_face::p4est_iter_face_t, iter_corner::p4est_iter_corner_t, remote::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 p4est_iterate_ext adds the option *remote:* if this is false, then it is the same as p4est_iterate; if this is true, then corner callbacks are also called on corners for hanging faces touched by local quadrants.
	
	## Reference
	
	[p4est_extended.h:529](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:529:21)
	""" p4est_iterate_ext
	export p4est_iterate_ext
	𝐣𝐥.@cextern p4est_iterate_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p4est_iter_volume_t, iter_face::p4est_iter_face_t, iter_corner::p4est_iter_corner_t, remote::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p4est::𝐣𝐥.Ptr{p4est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Save the complete connectivity/p4est data to disk.  This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p4est_load_ext for information on the autopartition parameter. 
	
	## Parameters
	
	  * `filename`:    Name of the file to write.
	  * `p4est`:       Valid forest structure.
	  * `save_data`:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.
	  * `save_partition`:   If false, save file as if 1 core was used.                              If true, save core count and partition.                         Advantage: Partition can be recovered on loading                              with same mpisize and autopartition false.                         Disadvantage: Makes the file depend on mpisize.                  Either way the file can be loaded with autopartition true.
	
	NOTE:            Aborts on file errors.
	
	## Reference
	
	[p4est_extended.h:554](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:554:21)
	""" p4est_save_ext
	export p4est_save_ext
	𝐣𝐥.@cextern p4est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p4est::𝐣𝐥.Ptr{p4est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}
	```
	
	 Load the complete connectivity/p4est structure from disk. It is possible to load the file with a different number of processors than has been used to write it.  The partition will then be uniform. 
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `mpicomm`:          A valid MPI communicator.
	  * `data_size`:        Size of data for each quadrant which can be                              zero.  Then user_data_pool is set to NULL.                              If data_size is zero, load_data is ignored.
	  * `load_data`:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.
	  * `autopartition`:    Ignore saved partition and make it uniform.
	  * `broadcasthead`:    Have only rank 0 read headers and bcast them.
	  * `user_pointer`:     Assign to the user_pointer member of the p4est                              before init_fn is called the first time.
	  * `connectivity`:    Connectivity must be destroyed separately.
	
	## Returns
	
	          Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument. 
	
	NOTE:            Aborts on file errors or invalid file contents.
	
	## Reference
	
	[p4est_extended.h:578](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:578:21)
	""" p4est_load_ext
	export p4est_load_ext
	𝐣𝐥.@cextern p4est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_source_ext(src::𝐣𝐥.Ptr{sc_io_source_t}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}
	```
	
	 The same as p4est_load_ext, but reading the connectivity/p4est from an open sc_io_source_t stream.
	
	## Reference
	
	[p4est_extended.h:587](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:587:21)
	""" p4est_source_ext
	export p4est_source_ext
	𝐣𝐥.@cextern p4est_source_ext(src::𝐣𝐥.Ptr{sc_io_source_t}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_get_plex_data_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_ghost_t}}, lnodes::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_lnodes_t}}, ctype::p4est_connect_type_t, overlap::𝐣𝐥.Cint, first_local_quad::𝐣𝐥.Ptr{p4est_locidx_t}, out_points_per_dim::𝐣𝐥.Ptr{sc_array_t}, out_cone_sizes::𝐣𝐥.Ptr{sc_array_t}, out_cones::𝐣𝐥.Ptr{sc_array_t}, out_cone_orientations::𝐣𝐥.Ptr{sc_array_t}, out_vertex_coords::𝐣𝐥.Ptr{sc_array_t}, out_children::𝐣𝐥.Ptr{sc_array_t}, out_parents::𝐣𝐥.Ptr{sc_array_t}, out_childids::𝐣𝐥.Ptr{sc_array_t}, out_leaves::𝐣𝐥.Ptr{sc_array_t}, out_remotes::𝐣𝐥.Ptr{sc_array_t}, custom_numbering::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Create the data necessary to create a PETsc DMPLEX representation of a forest, as well as the accompanying lnodes and ghost layer.  The forest must be at least face balanced (see p4est_balance()).  See test/test_plex2.c for example usage.
	
	## Details
	
	 All arrays should be initialized to hold sizeof (p4est_locidx_t), except for *out_remotes,* which should be initialized to hold (2 * sizeof (p4est_locidx_t)).
	
	## Parameters
	
	  * `p4est`:                 the forest
	  * `ghost`:                 the ghost layer
	  * `lnodes`:                the lnodes
	  * `ctype`:                 the type of adjacency for the overlap
	  * `overlap`:               the number of layers of overlap (zero                                      is acceptable)
	  * `first_local_quad`:      the local quadrants are assigned                                      contiguous plex indices, starting with                                      this index
	  * `out_points_per_dim`:    filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_cone_sizes`:        filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_cones`:             filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_cone_orientations`: filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_vertex_coords`:     filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_children`:          filled with argument for                                      DMPlexSetTree()
	  * `out_parents`:           filled with argument for                                      DMPlexSetTree()
	  * `out_childids`:          filled with argument for                                      DMPlexSetTree()
	  * `out_leaves`:            filled with argument for                                      PetscSFSetGraph()
	  * `out_remotes`:           filled with argument for                                      PetscSFSetGraph()
	  * `custom_numbering`:      Whether or use the default numbering                                      (0) of DMPlex child ids or the custom                                      (1).
	
	## Reference
	
	[p4est_extended.h:635](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_extended.h:635:21)
	""" p4est_get_plex_data_ext
	export p4est_get_plex_data_ext
	𝐣𝐥.@cextern p4est_get_plex_data_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_ghost_t}}, lnodes::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_lnodes_t}}, ctype::p4est_connect_type_t, overlap::𝐣𝐥.Cint, first_local_quad::𝐣𝐥.Ptr{p4est_locidx_t}, out_points_per_dim::𝐣𝐥.Ptr{sc_array_t}, out_cone_sizes::𝐣𝐥.Ptr{sc_array_t}, out_cones::𝐣𝐥.Ptr{sc_array_t}, out_cone_orientations::𝐣𝐥.Ptr{sc_array_t}, out_vertex_coords::𝐣𝐥.Ptr{sc_array_t}, out_children::𝐣𝐥.Ptr{sc_array_t}, out_parents::𝐣𝐥.Ptr{sc_array_t}, out_childids::𝐣𝐥.Ptr{sc_array_t}, out_leaves::𝐣𝐥.Ptr{sc_array_t}, out_remotes::𝐣𝐥.Ptr{sc_array_t}, custom_numbering::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:92:3)
	""" P8EST_CONNECT_FACE
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:95](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:95:3)
	""" P8EST_CONNECT_FULL
	𝐣𝐥.@doc """
	 Characterize a type of adjacency.
	
	## Details
	
	 Several functions involve relationships between neighboring trees and/or quadrants, and their behavior depends on how one defines adjacency: 1) entities are adjacent if they share a face, or 2) entities are adjacent if they share a face or corner, or 3) entities are adjacent if they share a face, corner or edge. p8est_connect_type_t is used to choose the desired behavior. This enum must fit into an int8_t.
	
	## Reference
	
	[p8est_connectivity.h:97](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:97:1)
	""" p8est_connect_type_t
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:94](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:94:3)
	""" P8EST_CONNECT_CORNER
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:93](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:93:3)
	""" P8EST_CONNECT_EDGE
	export P8EST_CONNECT_CORNER, P8EST_CONNECT_EDGE, P8EST_CONNECT_FACE, P8EST_CONNECT_FULL, p8est_connect_type_t
	𝐣𝐥.@ctypedef p8est_connect_type_t 𝐣𝐥.@cenum {
		P8EST_CONNECT_FACE = 𝐣𝐥.Cuint(31)
		P8EST_CONNECT_EDGE = 𝐣𝐥.Cuint(32)
		P8EST_CONNECT_CORNER = 𝐣𝐥.Cuint(33)
		P8EST_CONNECT_FULL = 𝐣𝐥.Cuint(33)
	}
	
	𝐣𝐥.@doc """
	 Invalid entry to close the list. 
	
	## Reference
	
	[p8est_connectivity.h:107](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:107:3)
	""" P8EST_CONN_ENCODE_LAST
	𝐣𝐥.@doc """
	 Typedef for serialization method. 
	
	## Reference
	
	[p8est_connectivity.h:109](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:109:1)
	""" p8est_connectivity_encode_t
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:106](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:106:3)
	""" P8EST_CONN_ENCODE_NONE
	export P8EST_CONN_ENCODE_LAST, P8EST_CONN_ENCODE_NONE, p8est_connectivity_encode_t
	𝐣𝐥.@ctypedef p8est_connectivity_encode_t 𝐣𝐥.@cenum {
		P8EST_CONN_ENCODE_NONE = 𝐣𝐥.Cuint(0)
		P8EST_CONN_ENCODE_LAST = 𝐣𝐥.Cuint(1)
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connect_type_int(btype::p8est_connect_type_t)::𝐣𝐥.Cint
	```
	
	 Convert the p8est_connect_type_t into a number. 
	
	## Parameters
	
	  * `btype`:    The balance type to convert.
	
	## Returns
	
	              Returns 1, 2 or 3.
	
	## Reference
	
	[p8est_connectivity.h:115](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:115:21)
	""" p8est_connect_type_int
	export p8est_connect_type_int
	𝐣𝐥.@cextern p8est_connect_type_int(btype::p8est_connect_type_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connect_type_string(btype::p8est_connect_type_t)::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	```
	
	 Convert the p8est_connect_type_t into a const string. 
	
	## Parameters
	
	  * `btype`:    The balance type to convert.
	
	## Returns
	
	              Returns a pointer to a constant string.
	
	## Reference
	
	[p8est_connectivity.h:121](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:121:21)
	""" p8est_connect_type_string
	export p8est_connect_type_string
	𝐣𝐥.@cextern p8est_connect_type_string(btype::p8est_connect_type_t)::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	
	𝐣𝐥.@doc """
	 This structure holds the 3D inter-tree connectivity information. Identification of arbitrary faces, edges and corners is possible.
	
	## Details
	
	 The arrays tree_to_* are stored in z ordering. For corners the order wrt. zyx is 000 001 010 011 100 101 110 111. For faces the order is -x +x -y +y -z +z. They are allocated [0][0]..[0][N-1]..[num_trees-1][0]..[num_trees-1][N-1]. where N is 6 for tree and face, 8 for corner, 12 for edge.
	
	 The values for tree_to_face are in 0..23 where ttf % 6 gives the face number and ttf / 6 the face orientation code. The orientation is determined as follows.  Let my_face and other_face be the two face numbers of the connecting trees in 0..5.  Then the first face corner of the lower of my_face and other_face connects to a face corner numbered 0..3 in the higher of my_face and other_face.  The face orientation is defined as this number.  If my_face == other_face, treating either of both faces as the lower one leads to the same result.
	
	 It is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].
	
	 The edges are only stored when they connect trees. In this case tree_to_edge indexes into *ett_offset.* Otherwise the tree_to_edge entry must be -1 and this edge is ignored. If num_edges == 0, tree_to_edge and edge_to_* arrays are set to NULL.
	
	 The arrays edge_to_* store a variable number of entries per edge. For edge e these are at position [ett_offset[e]]..[ett_offset[e+1]-1]. Their number for edge e is ett_offset[e+1] - ett_offset[e]. The entries encode all trees adjacent to edge e. The size of the edge_to_* arrays is num_ett = ett_offset[num_edges]. The edge_to_edge array holds values in 0..23, where the lower 12 indicate one edge orientation and the higher 12 the opposite edge orientation.
	
	 The corners are only stored when they connect trees. In this case tree_to_corner indexes into *ctt_offset.* Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.
	
	 The arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].
	
	 The *_to_attr arrays may have arbitrary contents defined by the user.
	
	## Reference
	
	[p8est_connectivity.h:172](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:172:16)
	""" p8est_connectivity
	𝐣𝐥.@doc """
	 This structure holds the 3D inter-tree connectivity information. Identification of arbitrary faces, edges and corners is possible.
	
	## Details
	
	 The arrays tree_to_* are stored in z ordering. For corners the order wrt. zyx is 000 001 010 011 100 101 110 111. For faces the order is -x +x -y +y -z +z. They are allocated [0][0]..[0][N-1]..[num_trees-1][0]..[num_trees-1][N-1]. where N is 6 for tree and face, 8 for corner, 12 for edge.
	
	 The values for tree_to_face are in 0..23 where ttf % 6 gives the face number and ttf / 6 the face orientation code. The orientation is determined as follows.  Let my_face and other_face be the two face numbers of the connecting trees in 0..5.  Then the first face corner of the lower of my_face and other_face connects to a face corner numbered 0..3 in the higher of my_face and other_face.  The face orientation is defined as this number.  If my_face == other_face, treating either of both faces as the lower one leads to the same result.
	
	 It is valid to specify num_vertices as 0. In this case vertices and tree_to_vertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[num_vertices-1][0]..[num_vertices-1][2].
	
	 The edges are only stored when they connect trees. In this case tree_to_edge indexes into *ett_offset.* Otherwise the tree_to_edge entry must be -1 and this edge is ignored. If num_edges == 0, tree_to_edge and edge_to_* arrays are set to NULL.
	
	 The arrays edge_to_* store a variable number of entries per edge. For edge e these are at position [ett_offset[e]]..[ett_offset[e+1]-1]. Their number for edge e is ett_offset[e+1] - ett_offset[e]. The entries encode all trees adjacent to edge e. The size of the edge_to_* arrays is num_ett = ett_offset[num_edges]. The edge_to_edge array holds values in 0..23, where the lower 12 indicate one edge orientation and the higher 12 the opposite edge orientation.
	
	 The corners are only stored when they connect trees. In this case tree_to_corner indexes into *ctt_offset.* Otherwise the tree_to_corner entry must be -1 and this corner is ignored. If num_corners == 0, tree_to_corner and corner_to_* arrays are set to NULL.
	
	 The arrays corner_to_* store a variable number of entries per corner. For corner c these are at position [ctt_offset[c]]..[ctt_offset[c+1]-1]. Their number for corner c is ctt_offset[c+1] - ctt_offset[c]. The entries encode all trees adjacent to corner c. The size of the corner_to_* arrays is num_ctt = ctt_offset[num_corners].
	
	 The *_to_attr arrays may have arbitrary contents defined by the user.
	
	## Reference
	
	[p8est_connectivity.h:211](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:211:1)
	""" p8est_connectivity_t
	export p8est_connectivity, p8est_connectivity_t
	𝐣𝐥.@ctypedef p8est_connectivity_t 𝐣𝐥.@cstruct p8est_connectivity {
		num_vertices::p4est_topidx_t
		num_trees::p4est_topidx_t
		num_edges::p4est_topidx_t
		num_corners::p4est_topidx_t
		vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}
		tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t}
		tree_attr_bytes::size_t
		tree_to_attr::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
		tree_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		tree_to_face::𝐣𝐥.Ptr{int8_t}
		tree_to_edge::𝐣𝐥.Ptr{p4est_topidx_t}
		ett_offset::𝐣𝐥.Ptr{p4est_topidx_t}
		edge_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		edge_to_edge::𝐣𝐥.Ptr{int8_t}
		tree_to_corner::𝐣𝐥.Ptr{p4est_topidx_t}
		ctt_offset::𝐣𝐥.Ptr{p4est_topidx_t}
		corner_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		corner_to_corner::𝐣𝐥.Ptr{int8_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_memory_used(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::size_t
	```
	
	 Calculate memory usage of a connectivity structure. 
	
	## Parameters
	
	  * `conn`:   Connectivity structure.
	
	## Returns
	
	            Memory used in bytes.
	
	## Reference
	
	[p8est_connectivity.h:217](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:217:21)
	""" p8est_connectivity_memory_used
	export p8est_connectivity_memory_used
	𝐣𝐥.@cextern p8est_connectivity_memory_used(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::size_t
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:225](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:225:1)
	""" p8est_edge_transform_t
	export p8est_edge_transform_t
	𝐣𝐥.@ctypedef p8est_edge_transform_t 𝐣𝐥.@cstruct {
		ntree::p4est_topidx_t
		(nedge, naxis::_[3], nflip, corners)::int8_t
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:232](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:232:1)
	""" p8est_edge_info_t
	export p8est_edge_info_t
	𝐣𝐥.@ctypedef p8est_edge_info_t 𝐣𝐥.@cstruct {
		iedge::int8_t
		edge_transforms::sc_array_t
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:239](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:239:1)
	""" p8est_corner_transform_t
	export p8est_corner_transform_t
	𝐣𝐥.@ctypedef p8est_corner_transform_t 𝐣𝐥.@cstruct {
		ntree::p4est_topidx_t
		ncorner::int8_t
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:246](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:246:1)
	""" p8est_corner_info_t
	export p8est_corner_info_t
	𝐣𝐥.@ctypedef p8est_corner_info_t 𝐣𝐥.@cstruct {
		icorner::p4est_topidx_t
		corner_transforms::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[6]
	```
	
	 Store the corner numbers 0..7 for each tree face. 
	
	## Reference
	
	[p8est_connectivity.h:249](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:249:21)
	""" p8est_face_corners
	export p8est_face_corners
	𝐣𝐥.@cextern p8est_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[6]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[6]
	```
	
	 Store the edge numbers 0..12 for each tree face. 
	
	## Reference
	
	[p8est_connectivity.h:252](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:252:21)
	""" p8est_face_edges
	export p8est_face_edges
	𝐣𝐥.@cextern p8est_face_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[6]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_dual::𝐣𝐥.Cconst(𝐣𝐥.Cint)[6]
	```
	
	 Store the face numbers in the face neighbor's system. 
	
	## Reference
	
	[p8est_connectivity.h:255](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:255:21)
	""" p8est_face_dual
	export p8est_face_dual
	𝐣𝐥.@cextern p8est_face_dual::𝐣𝐥.Cconst(𝐣𝐥.Cint)[6]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_permutations::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[8]
	```
	
	 Store only the 8 out of 24 possible permutations that occur. 
	
	## Reference
	
	[p8est_connectivity.h:260](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:260:21)
	""" p8est_face_permutations
	export p8est_face_permutations
	𝐣𝐥.@cextern p8est_face_permutations::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_permutation_sets::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[3]
	```
	
	 Store the 3 occurring sets of 4 permutations per face. 
	
	## Reference
	
	[p8est_connectivity.h:263](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:263:21)
	""" p8est_face_permutation_sets
	export p8est_face_permutation_sets
	𝐣𝐥.@cextern p8est_face_permutation_sets::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[3]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_permutation_refs::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[6]
	```
	
	 For each face combination store the permutation set. The order is [my_face][neighbor_face] 
	
	## Reference
	
	[p8est_connectivity.h:267](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:267:21)
	""" p8est_face_permutation_refs
	export p8est_face_permutation_refs
	𝐣𝐥.@cextern p8est_face_permutation_refs::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[6]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_edge_permutations::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[8]
	```
	
	 Store only the 8 out of 24 possible permutations that occur. 
	
	## Reference
	
	[p8est_connectivity.h:272](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:272:21)
	""" p8est_face_edge_permutations
	export p8est_face_edge_permutations
	𝐣𝐥.@cextern p8est_face_edge_permutations::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_edge_permutation_sets::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[3]
	```
	
	 Store the 3 occurring sets of 4 permutations per face. 
	
	## Reference
	
	[p8est_connectivity.h:275](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:275:21)
	""" p8est_face_edge_permutation_sets
	export p8est_face_edge_permutation_sets
	𝐣𝐥.@cextern p8est_face_edge_permutation_sets::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[3]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_edge_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[12]
	```
	
	 Store the face numbers 0..5 adjacent to each tree edge. 
	
	## Reference
	
	[p8est_connectivity.h:278](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:278:21)
	""" p8est_edge_faces
	export p8est_edge_faces
	𝐣𝐥.@cextern p8est_edge_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[12]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[12]
	```
	
	 Store the corner numbers 0..8 for each tree edge. 
	
	## Reference
	
	[p8est_connectivity.h:281](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:281:21)
	""" p8est_edge_corners
	export p8est_edge_corners
	𝐣𝐥.@cextern p8est_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[12]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_edge_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[12]
	```
	
	 Store the edge corner numbers 0..1 for the corners touching a tree edge    or -1 if combination is invalid 
	
	## Reference
	
	[p8est_connectivity.h:285](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:285:21)
	""" p8est_edge_edge_corners
	export p8est_edge_edge_corners
	𝐣𝐥.@cextern p8est_edge_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[12]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_edge_face_corners::((𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[6])[12]
	```
	
	 Store the face corner numbers 0..3 for the faces touching a tree edge.    Is -1 for invalid combinations of indices 
	
	## Reference
	
	[p8est_connectivity.h:289](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:289:21)
	""" p8est_edge_face_corners
	export p8est_edge_face_corners
	𝐣𝐥.@cextern p8est_edge_face_corners::((𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[6])[12]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_edge_face_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[12]
	```
	
	 Store the face edge numbers 0..3 for the faces touching a tree edge.    Is -1 for invalid combinations of indices 
	
	## Reference
	
	[p8est_connectivity.h:293](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:293:21)
	""" p8est_edge_face_edges
	export p8est_edge_face_edges
	𝐣𝐥.@cextern p8est_edge_face_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[12]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[3])[8]
	```
	
	 Store the face numbers 0..5 for each tree corner. 
	
	## Reference
	
	[p8est_connectivity.h:296](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:296:21)
	""" p8est_corner_faces
	export p8est_corner_faces
	𝐣𝐥.@cextern p8est_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[3])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_corner_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[3])[8]
	```
	
	 Store the edge numbers 0..11 for each tree corner. 
	
	## Reference
	
	[p8est_connectivity.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:299:21)
	""" p8est_corner_edges
	export p8est_corner_edges
	𝐣𝐥.@cextern p8est_corner_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[3])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_corner_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[8]
	```
	
	 Store the face corner numbers for the faces touching a tree corner.    Is -1 for invalid combinations. 
	
	## Reference
	
	[p8est_connectivity.h:303](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:303:21)
	""" p8est_corner_face_corners
	export p8est_corner_face_corners
	𝐣𝐥.@cextern p8est_corner_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_corner_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[12])[8]
	```
	
	 Store the edge corner numbers for the edges touching a tree corner.    Is -1 for invalid combinations. 
	
	## Reference
	
	[p8est_connectivity.h:307](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:307:21)
	""" p8est_corner_edge_corners
	export p8est_corner_edge_corners
	𝐣𝐥.@cextern p8est_corner_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[12])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_child_edge_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[12])[8]
	```
	
	 Store the faces for each child and edge, can be -1. 
	
	## Reference
	
	[p8est_connectivity.h:310](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:310:21)
	""" p8est_child_edge_faces
	export p8est_child_edge_faces
	𝐣𝐥.@cextern p8est_child_edge_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[12])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_child_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[8]
	```
	
	 Store the faces for each child and corner, can be -1. 
	
	## Reference
	
	[p8est_connectivity.h:313](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:313:21)
	""" p8est_child_corner_faces
	export p8est_child_corner_faces
	𝐣𝐥.@cextern p8est_child_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_child_corner_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[8]
	```
	
	 Store the edges for each child and corner, can be -1. 
	
	## Reference
	
	[p8est_connectivity.h:316](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:316:21)
	""" p8est_child_corner_edges
	export p8est_child_corner_edges
	𝐣𝐥.@cextern p8est_child_corner_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[8]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_corner_set(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, set::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a corner across one of the adjacent faces into a neighbor tree. It expects a face permutation index that has been precomputed. 
	
	## Parameters
	
	  * `c`:    A corner number in 0..7.
	  * `f`:    A face number that touches the corner *c.*
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `set`:  A value from *p8est_face_permutation_sets* that is                  obtained using *f,* *nf,* and a valid orientation:                  ref = p8est_face_permutation_refs[f][nf];                  set = p8est_face_permutation_sets[ref][orientation];
	
	## Returns
	
	          The corner number in 0..7 seen from the other face.
	
	## Reference
	
	[p8est_connectivity.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:329:21)
	""" p8est_connectivity_face_neighbor_corner_set
	export p8est_connectivity_face_neighbor_corner_set
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_corner_set(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, set::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_face_corner(fc::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a face corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. 
	
	## Parameters
	
	  * `fc`:   A face corner number in 0..3.
	  * `f`:    A face that the face corner *fc* is relative to.
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `o`:    The orientation between tree boundary faces *f* and nothing.
	
	## Returns
	
	          The face corner number relative to the neighbor's face.
	
	## Reference
	
	[p8est_connectivity.h:340](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:340:21)
	""" p8est_connectivity_face_neighbor_face_corner
	export p8est_connectivity_face_neighbor_face_corner
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_face_corner(fc::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_corner(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. 
	
	## Parameters
	
	  * `c`:    A corner number in 0..7.
	  * `f`:    A face number that touches the corner *c.*
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `o`:    The orientation between tree boundary faces *f* and nothing.
	
	## Returns
	
	          The number of the corner seen from the neighbor tree.
	
	## Reference
	
	[p8est_connectivity.h:351](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:351:21)
	""" p8est_connectivity_face_neighbor_corner
	export p8est_connectivity_face_neighbor_corner
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_corner(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_face_edge(fe::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a face-edge across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. 
	
	## Parameters
	
	  * `fe`:   A face edge number in 0..3.
	  * `f`:    A face number that touches the edge *e.*
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `o`:    The orientation between tree boundary faces *f* and nothing.
	
	## Returns
	
	          The face edge number seen from the neighbor tree.
	
	## Reference
	
	[p8est_connectivity.h:362](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:362:21)
	""" p8est_connectivity_face_neighbor_face_edge
	export p8est_connectivity_face_neighbor_face_edge
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_face_edge(fe::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_edge(e::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform an edge across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. 
	
	## Parameters
	
	  * `e`:    A edge number in 0..11.
	  * `f`:    A face 0..5 that touches the edge *e.*
	  * `nf`:   A neighbor face that is on the other side of nothing.
	  * `o`:    The orientation between tree boundary faces *f* and nothing.
	
	## Returns
	
	          The edge's number seen from the neighbor.
	
	## Reference
	
	[p8est_connectivity.h:373](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:373:21)
	""" p8est_connectivity_face_neighbor_edge
	export p8est_connectivity_face_neighbor_edge
	𝐣𝐥.@cextern p8est_connectivity_face_neighbor_edge(e::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_edge_neighbor_edge_corner(ec::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform an edge corner across one of the adjacent edges into a neighbor tree. 
	
	## Parameters
	
	  * `ec`:   An edge corner number in 0..1.
	  * `o`:    The orientation of a tree boundary edge connection.
	
	## Returns
	
	          The edge corner number seen from the other tree.
	
	## Reference
	
	[p8est_connectivity.h:381](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:381:21)
	""" p8est_connectivity_edge_neighbor_edge_corner
	export p8est_connectivity_edge_neighbor_edge_corner
	𝐣𝐥.@cextern p8est_connectivity_edge_neighbor_edge_corner(ec::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_edge_neighbor_corner(c::𝐣𝐥.Cint, e::𝐣𝐥.Cint, ne::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Transform a corner across one of the adjacent edges into a neighbor tree. This version expects the neighbor edge and orientation separately. 
	
	## Parameters
	
	  * `c`:    A corner number in 0..7.
	  * `e`:    An edge 0..11 that touches the corner *c.*
	  * `ne`:   A neighbor edge that is on the other side of *.*
	  * `o`:    The orientation between tree boundary edges *e* and *.*
	
	## Returns
	
	          Corner number seen from the neighbor.
	
	## Reference
	
	[p8est_connectivity.h:392](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:392:21)
	""" p8est_connectivity_edge_neighbor_corner
	export p8est_connectivity_edge_neighbor_corner
	𝐣𝐥.@cextern p8est_connectivity_edge_neighbor_corner(c::𝐣𝐥.Cint, e::𝐣𝐥.Cint, ne::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_edges::p4est_topidx_t, num_ett::p4est_topidx_t, num_corners::p4est_topidx_t, num_ctt::p4est_topidx_t)::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Allocate a connectivity structure. The attribute fields are initialized to NULL. 
	
	## Parameters
	
	  * `num_vertices`:   Number of total vertices (i.e. geometric points).
	  * `num_trees`:      Number of trees in the forest.
	  * `num_edges`:      Number of tree-connecting edges.
	  * `num_ett`:        Number of total trees in edge_to_tree array.
	  * `num_corners`:    Number of tree-connecting corners.
	  * `num_ctt`:        Number of total trees in corner_to_tree array.
	
	## Returns
	
	                    A connectivity structure with allocated arrays.
	
	## Reference
	
	[p8est_connectivity.h:405](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:405:23)
	""" p8est_connectivity_new
	export p8est_connectivity_new
	𝐣𝐥.@cextern p8est_connectivity_new(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_edges::p4est_topidx_t, num_ett::p4est_topidx_t, num_corners::p4est_topidx_t, num_ctt::p4est_topidx_t)::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_copy(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_edges::p4est_topidx_t, num_corners::p4est_topidx_t, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cdouble)}, ttv::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttf::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, tte::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, eoff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ett::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ete::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, ttc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, coff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)})::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Allocate a connectivity structure and populate from constants. The attribute fields are initialized to NULL. 
	
	## Parameters
	
	  * `num_vertices`:   Number of total vertices (i.e. geometric points).
	  * `num_trees`:      Number of trees in the forest.
	  * `num_edges`:      Number of tree-connecting edges.
	  * `num_corners`:    Number of tree-connecting corners.
	  * `eoff`:           Edge-to-tree offsets (num_edges + 1 values).                            This must always be non-NULL; in trivial cases                            it is just a pointer to a p4est_topix value of 0.
	  * `coff`:           Corner-to-tree offsets (num_corners + 1 values).                            This must always be non-NULL; in trivial cases                            it is just a pointer to a p4est_topix value of 0.
	
	## Returns
	
	                    The connectivity is checked for validity.
	
	## Reference
	
	[p8est_connectivity.h:426](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:426:23)
	""" p8est_connectivity_new_copy
	export p8est_connectivity_new_copy
	𝐣𝐥.@cextern p8est_connectivity_new_copy(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_edges::p4est_topidx_t, num_corners::p4est_topidx_t, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cdouble)}, ttv::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttf::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, tte::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, eoff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ett::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ete::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, ttc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, coff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)})::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_bcast(conn_in::𝐣𝐥.Ptr{p8est_connectivity_t}, root::𝐣𝐥.Cint, comm::sc_MPI_Comm)::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Broadcast a connectivity structure that exists only on one process to all.  On the other processors, it will be allocated using p8est_connectivity_new.  
	
	## Parameters
	
	  * `conn_in`: For the root process the connectivity to be broadcast,                      for the other processes it must be NULL.
	  * `root`:    The rank of the process that provides the connectivity.
	  * `comm`:    The MPI communicator.
	
	## Returns
	
	             For the root process this is a pointer to *conn_in.*                      Else, a pointer to a newly allocated connectivity                      structure with the same values as *conn_in* on the                      root process.
	
	## Reference
	
	[p8est_connectivity.h:457](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:457:23)
	""" p8est_connectivity_bcast
	export p8est_connectivity_bcast
	𝐣𝐥.@cextern p8est_connectivity_bcast(conn_in::𝐣𝐥.Ptr{p8est_connectivity_t}, root::𝐣𝐥.Cint, comm::sc_MPI_Comm)::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_destroy(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a connectivity structure.  Also destroy all attributes.
	
	## Reference
	
	[p8est_connectivity.h:463](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:463:21)
	""" p8est_connectivity_destroy
	export p8est_connectivity_destroy
	𝐣𝐥.@cextern p8est_connectivity_destroy(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_set_attr(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, bytes_per_tree::size_t)::𝐣𝐥.Cvoid
	```
	
	 Allocate or free the attribute fields in a connectivity. 
	
	## Parameters
	
	  * `conn`:         The conn->*_to_attr fields must either be NULL                              or previously be allocated by this function.
	  * `bytes_per_tree`:   If 0, tree_to_attr is freed (being NULL is ok).                              If positive, requested space is allocated.
	
	## Reference
	
	[p8est_connectivity.h:472](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:472:21)
	""" p8est_connectivity_set_attr
	export p8est_connectivity_set_attr
	𝐣𝐥.@cextern p8est_connectivity_set_attr(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, bytes_per_tree::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_is_valid(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 Examine a connectivity structure. 
	
	## Returns
	
	  Returns true if structure is valid, false otherwise.
	
	## Reference
	
	[p8est_connectivity.h:478](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:478:21)
	""" p8est_connectivity_is_valid
	export p8est_connectivity_is_valid
	𝐣𝐥.@cextern p8est_connectivity_is_valid(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_is_equal(conn1::𝐣𝐥.Ptr{p8est_connectivity_t}, conn2::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 Check two connectivity structures for equality. 
	
	## Returns
	
	          Returns true if structures are equal, false otherwise.
	
	## Reference
	
	[p8est_connectivity.h:484](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:484:21)
	""" p8est_connectivity_is_equal
	export p8est_connectivity_is_equal
	𝐣𝐥.@cextern p8est_connectivity_is_equal(conn1::𝐣𝐥.Ptr{p8est_connectivity_t}, conn2::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_sink(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	```
	
	 Write connectivity to a sink object. 
	
	## Parameters
	
	  * `conn`:     The connectivity to be written.
	  * `sink`: The connectivity is written into this sink.
	
	## Returns
	
	              0 on success, nonzero on error.
	
	## Reference
	
	[p8est_connectivity.h:493](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:493:21)
	""" p8est_connectivity_sink
	export p8est_connectivity_sink
	𝐣𝐥.@cextern p8est_connectivity_sink(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_deflate(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, code::p8est_connectivity_encode_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Allocate memory and store the connectivity information there. 
	
	## Parameters
	
	  * `conn`:     The connectivity structure to be exported to memory.
	  * `code`:     Encoding and compression method for serialization.
	
	## Returns
	
	              Newly created array that contains the information.
	
	## Reference
	
	[p8est_connectivity.h:501](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:501:21)
	""" p8est_connectivity_deflate
	export p8est_connectivity_deflate
	𝐣𝐥.@cextern p8est_connectivity_deflate(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, code::p8est_connectivity_encode_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 Save a connectivity structure to disk. 
	
	## Parameters
	
	  * `filename`:         Name of the file to write.
	  * `connectivity`:     Valid connectivity structure.
	
	## Returns
	
	                      Returns 0 on success, nonzero on file error.
	
	## Reference
	
	[p8est_connectivity.h:510](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:510:21)
	""" p8est_connectivity_save
	export p8est_connectivity_save
	𝐣𝐥.@cextern p8est_connectivity_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_source(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Read connectivity from a source object. 
	
	## Parameters
	
	  * `source`:       The connectivity is read from this source.
	
	## Returns
	
	              The newly created connectivity, or NULL on error.
	
	## Reference
	
	[p8est_connectivity.h:518](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:518:23)
	""" p8est_connectivity_source
	export p8est_connectivity_source
	𝐣𝐥.@cextern p8est_connectivity_source(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_inflate(buffer::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create new connectivity from a memory buffer. 
	
	## Parameters
	
	  * `buffer`:   The connectivity is created from this memory buffer.
	
	## Returns
	
	              The newly created connectivity, or NULL on error.
	
	## Reference
	
	[p8est_connectivity.h:524](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:524:23)
	""" p8est_connectivity_inflate
	export p8est_connectivity_inflate
	𝐣𝐥.@cextern p8est_connectivity_inflate(buffer::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, bytes::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Load a connectivity structure from disk. 
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `bytes`:           Size in bytes of connectivity on disk or NULL.
	
	## Returns
	
	              Returns valid connectivity, or NULL on file error.
	
	## Reference
	
	[p8est_connectivity.h:531](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:531:23)
	""" p8est_connectivity_load
	export p8est_connectivity_load
	𝐣𝐥.@cextern p8est_connectivity_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, bytes::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_unitcube()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure for the unit cube.
	
	## Reference
	
	[p8est_connectivity.h:536](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:536:23)
	""" p8est_connectivity_new_unitcube
	export p8est_connectivity_new_unitcube
	𝐣𝐥.@cextern p8est_connectivity_new_unitcube()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_periodic()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure for an all-periodic unit cube.
	
	## Reference
	
	[p8est_connectivity.h:540](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:540:23)
	""" p8est_connectivity_new_periodic
	export p8est_connectivity_new_periodic
	𝐣𝐥.@cextern p8est_connectivity_new_periodic()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_rotwrap()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure for a mostly periodic unit cube. The left and right faces are identified, and bottom and top rotated. Front and back are not identified.
	
	## Reference
	
	[p8est_connectivity.h:546](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:546:23)
	""" p8est_connectivity_new_rotwrap
	export p8est_connectivity_new_rotwrap
	𝐣𝐥.@cextern p8est_connectivity_new_rotwrap()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_twocubes()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure that contains two cubes.
	
	## Reference
	
	[p8est_connectivity.h:550](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:550:23)
	""" p8est_connectivity_new_twocubes
	export p8est_connectivity_new_twocubes
	𝐣𝐥.@cextern p8est_connectivity_new_twocubes()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_twotrees(l_face::𝐣𝐥.Cint, r_face::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure for two trees being rotated w.r.t. each other in a user-defined way. 
	
	## Parameters
	
	  * `l_face`:      index of left face
	  * `r_face`:      index of right face
	  * `orientation`: orientation of trees w.r.t. each other
	
	## Reference
	
	[p8est_connectivity.h:558](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:558:23)
	""" p8est_connectivity_new_twotrees
	export p8est_connectivity_new_twotrees
	𝐣𝐥.@cextern p8est_connectivity_new_twotrees(l_face::𝐣𝐥.Cint, r_face::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_twowrap()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure that contains two cubes where the two far ends are identified periodically.
	
	## Reference
	
	[p8est_connectivity.h:565](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:565:23)
	""" p8est_connectivity_new_twowrap
	export p8est_connectivity_new_twowrap
	𝐣𝐥.@cextern p8est_connectivity_new_twowrap()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_rotcubes()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure that contains a few cubes. These are rotated against each other to stress the topology routines.
	
	## Reference
	
	[p8est_connectivity.h:570](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:570:23)
	""" p8est_connectivity_new_rotcubes
	export p8est_connectivity_new_rotcubes
	𝐣𝐥.@cextern p8est_connectivity_new_rotcubes()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_brick(m::𝐣𝐥.Cint, n::𝐣𝐥.Cint, p::𝐣𝐥.Cint, periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint, periodic_c::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 An m by n by p array with periodicity in x, y, and z if periodic_a, periodic_b, and periodic_c are true, respectively.
	
	## Reference
	
	[p8est_connectivity.h:575](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:575:23)
	""" p8est_connectivity_new_brick
	export p8est_connectivity_new_brick
	𝐣𝐥.@cextern p8est_connectivity_new_brick(m::𝐣𝐥.Cint, n::𝐣𝐥.Cint, p::𝐣𝐥.Cint, periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint, periodic_c::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_shell()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure that builds a spherical shell. It is made up of six connected parts [-1,1]x[-1,1]x[1,2]. This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8est_connectivity_complete.
	
	## Reference
	
	[p8est_connectivity.h:585](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:585:23)
	""" p8est_connectivity_new_shell
	export p8est_connectivity_new_shell
	𝐣𝐥.@cextern p8est_connectivity_new_shell()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_sphere()::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure that builds a solid sphere. It is made up of two layers and a cube in the center. This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8est_connectivity_complete.
	
	## Reference
	
	[p8est_connectivity.h:592](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:592:23)
	""" p8est_connectivity_new_sphere
	export p8est_connectivity_new_sphere
	𝐣𝐥.@cextern p8est_connectivity_new_sphere()::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_torus(nSegments::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a connectivity structure that builds a revolution torus.
	
	## Details
	
	 This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8est_connectivity_complete.
	
	 This connectivity reuses ideas from disk2d connectivity. More precisely the torus is divided into segments arround the revolution axis, each segments is made of 5 trees (à la disk2d). The total number of trees if 5 times the number of segments.
	
	 This connectivity is meant to be used with p8est_geometry_new_torus
	
	## Parameters
	
	  * `nSegments`: number of trees along the great circle
	
	## Reference
	
	[p8est_connectivity.h:608](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:608:23)
	""" p8est_connectivity_new_torus
	export p8est_connectivity_new_torus
	𝐣𝐥.@cextern p8est_connectivity_new_torus(nSegments::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_new_byname(name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create connectivity structure from predefined catalogue. 
	
	## Parameters
	
	  * `name`:            Invokes connectivity_new_* function.              brick235        brick (2, 3, 5, 0, 0, 0)              periodic        periodic              rotcubes        rotcubes              rotwrap         rotwrap              shell           shell              sphere          sphere              twocubes        twocubes              twowrap         twowrap              unit            unitcube
	
	## Returns
	
	      An initialized connectivity if name is defined, NULL else.
	
	## Reference
	
	[p8est_connectivity.h:623](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:623:23)
	""" p8est_connectivity_new_byname
	export p8est_connectivity_new_byname
	𝐣𝐥.@cextern p8est_connectivity_new_byname(name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_refine(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, num_per_edge::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Uniformly refine a connectivity. This is useful if you would like to uniformly refine by something other than a power of 2.
	
	## Parameters
	
	  * `conn`:         A valid connectivity
	  * `num_per_edge`: The number of new trees in each direction.                      Must use no more than P8EST_OLD_QMAXLEVEL bits.
	
	## Returns
	
	 a refined connectivity.
	
	## Reference
	
	[p8est_connectivity.h:635](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:635:23)
	""" p8est_connectivity_refine
	export p8est_connectivity_refine
	𝐣𝐥.@cextern p8est_connectivity_refine(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, num_per_edge::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_expand_face_transform(iface::𝐣𝐥.Cint, nface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::𝐣𝐥.Cvoid
	```
	
	 Fill an array with the axis combination of a face neighbor transform. 
	
	## Parameters
	
	  * `iface`:       The number of the originating face.
	  * `nface`:       Encoded as nface = r * 6 + nf, where nf = 0..5 is                          the neigbbor's connecting face number and r = 0..3                          is the relative orientation to the neighbor's face.                          This encoding matches p8est_connectivity_t.
	  * `ftransform`:  This array holds 9 integers.              [0]..[2]    The coordinate axis sequence of the origin face,                          the first two referring to the tangentials and the                          third to the normal.  A permutation of (0, 1, 2).              [3]..[5]    The coordinate axis sequence of the target face.              [6]..[8]    Edge reversal flags for tangential axes (boolean);                          face code in [0, 3] for the normal coordinate q:                          0: q' = -q                          1: q' = q + 1                          2: q' = q - 1                          3: q' = 2 - q
	
	## Reference
	
	[p8est_connectivity.h:656](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:656:21)
	""" p8est_expand_face_transform
	export p8est_expand_face_transform
	𝐣𝐥.@cextern p8est_expand_face_transform(iface::𝐣𝐥.Cint, nface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_find_face_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, iface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::p4est_topidx_t
	```
	
	 Fill an array with the axis combination of a face neighbor transform. 
	
	## Parameters
	
	  * `itree`:       The number of the originating tree.
	  * `iface`:       The number of the originating tree's face.
	  * `ftransform`:  This array holds 9 integers.              [0]..[2]    The coordinate axis sequence of the origin face.              [3]..[5]    The coordinate axis sequence of the target face.              [6]..[8]    Edge reverse flag for axes t1, t2; face code for n.
	
	## Returns
	
	                  The face neighbor tree if it exists, -1 otherwise.
	
	## Reference
	
	[p8est_connectivity.h:668](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:668:21)
	""" p8est_find_face_transform
	export p8est_find_face_transform
	𝐣𝐥.@cextern p8est_find_face_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, iface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::p4est_topidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_find_edge_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, iedge::𝐣𝐥.Cint, ei::𝐣𝐥.Ptr{p8est_edge_info_t})::𝐣𝐥.Cvoid
	```
	
	 Fills an array with information about edge neighbors. 
	
	## Parameters
	
	  * `itree`:    The number of the originating tree.
	  * `iedge`:    The number of the originating edge.
	  * `ei`:   A p8est_edge_info_t structure with initialized array.
	
	## Reference
	
	[p8est_connectivity.h:678](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:678:21)
	""" p8est_find_edge_transform
	export p8est_find_edge_transform
	𝐣𝐥.@cextern p8est_find_edge_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, iedge::𝐣𝐥.Cint, ei::𝐣𝐥.Ptr{p8est_edge_info_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_find_corner_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, icorner::𝐣𝐥.Cint, ci::𝐣𝐥.Ptr{p8est_corner_info_t})::𝐣𝐥.Cvoid
	```
	
	 Fills an array with information about corner neighbors. 
	
	## Parameters
	
	  * `itree`:    The number of the originating tree.
	  * `icorner`:  The number of the originating corner.
	  * `ci`:   A p8est_corner_info_t structure with initialized array.
	
	## Reference
	
	[p8est_connectivity.h:689](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:689:21)
	""" p8est_find_corner_transform
	export p8est_find_corner_transform
	𝐣𝐥.@cextern p8est_find_corner_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, icorner::𝐣𝐥.Cint, ci::𝐣𝐥.Ptr{p8est_corner_info_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_complete(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Internally connect a connectivity based on tree_to_vertex information. Periodicity that is not inherent in the list of vertices will be lost. 
	
	## Parameters
	
	  * `conn`:     The connectivity needs to have proper vertices                          and tree_to_vertex fields.  The tree_to_tree                          and tree_to_face fields must be allocated                          and satisfy p8est_connectivity_is_valid (conn)                          but will be overwritten.  The edge and corner                          fields will be freed and allocated anew.
	
	## Reference
	
	[p8est_connectivity.h:704](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:704:21)
	""" p8est_connectivity_complete
	export p8est_connectivity_complete
	𝐣𝐥.@cextern p8est_connectivity_complete(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_reduce(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Removes corner and edge information of a connectivity  such that enough information is left to run p8est_connectivity_complete successfully.  The reduced connectivity still passes p8est_connectivity_is_valid. 
	
	## Parameters
	
	  * `conn`:     The connectivity to be reduced.
	
	## Reference
	
	[p8est_connectivity.h:711](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:711:21)
	""" p8est_connectivity_reduce
	export p8est_connectivity_reduce
	𝐣𝐥.@cextern p8est_connectivity_reduce(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_permute(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, perm::𝐣𝐥.Ptr{sc_array_t}, is_current_to_new::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 p8est_connectivity_permute Given a permutation *perm* of the trees in a connectivity *conn,* permute the trees of *conn* in place and update *conn* to match. 
	
	## Parameters
	
	  * `conn`:                The connectivity whose trees are                                     permuted.
	  * `perm`:                    A permutation array, whose elements are                                     size_t's.
	  * `is_current_to_new`:       if true, the jth entry of perm is the                                     new index for the entry whose current                                     index is j, otherwise the jth entry of                                     perm is the current index of the tree                                     whose index will be j after the                                     permutation.
	
	## Reference
	
	[p8est_connectivity.h:727](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:727:21)
	""" p8est_connectivity_permute
	export p8est_connectivity_permute
	𝐣𝐥.@cextern p8est_connectivity_permute(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, perm::𝐣𝐥.Ptr{sc_array_t}, is_current_to_new::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_join_faces(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, tree_left::p4est_topidx_t, tree_right::p4est_topidx_t, face_left::𝐣𝐥.Cint, face_right::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 p8est_connectivity_join_faces This function takes an existing valid connectivity *conn* and modifies it by joining two tree faces that are currently boundary faces. 
	
	## Parameters
	
	  * `conn`:        connectivity that will be altered.
	  * `tree_left`:   tree that will be on the left side of the joined                             faces.
	  * `tree_right`:  tree that will be on the right side of the                             joined faces.
	  * `face_left`:   face of *tree_left* that will be joined.
	  * `face_right`:  face of *tree_right* that will be joined.
	  * `orientation`: the orientation of *face_left* and                             *face_right* once joined (see the description                             of p8est_connectivity_t to understand                             orientation).
	
	## Reference
	
	[p8est_connectivity.h:776](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:776:21)
	""" p8est_connectivity_join_faces
	export p8est_connectivity_join_faces
	𝐣𝐥.@cextern p8est_connectivity_join_faces(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, tree_left::p4est_topidx_t, tree_right::p4est_topidx_t, face_left::𝐣𝐥.Cint, face_right::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_is_equivalent(conn1::𝐣𝐥.Ptr{p8est_connectivity_t}, conn2::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	```
	
	 p8est_connectivity_is_equivalent This function compares two connectivities for equivalence: it returns *true* if they are the same connectivity, or if they have the same topology.  The definition of topological sameness is strict: there is no attempt made to determine whether permutation and/or rotation of the trees makes the connectivities equivalent.
	
	## Parameters
	
	  * `conn1`:    a valid connectivity
	  * `conn2`:    a valid connectivity
	
	## Reference
	
	[p8est_connectivity.h:794](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:794:21)
	""" p8est_connectivity_is_equivalent
	export p8est_connectivity_is_equivalent
	𝐣𝐥.@cextern p8est_connectivity_is_equivalent(conn1::𝐣𝐥.Ptr{p8est_connectivity_t}, conn2::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_read_inp_stream(stream::𝐣𝐥.Ptr{FILE}, num_vertices::𝐣𝐥.Ptr{p4est_topidx_t}, num_trees::𝐣𝐥.Ptr{p4est_topidx_t}, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t})::𝐣𝐥.Cint
	```
	
	 Read an ABAQUS input file from a file stream.
	
	## Details
	
	 This utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.
	
	 A basic 2D mesh is given below.  The `*Node` section gives the vertex number and x, y, and z components for each vertex.  The `*Element` section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:
	
	   4                     3   +-------------------+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +-------------------+   1                   2
	
	 and in 3D they are given as:
	
	 8                     7  +---------------------+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+---------------------+6  |    |                |    |  +----|----------------+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +---------------------+       1                     2
	
	```
	 *Heading
	  box.inp
	 *Node
	     1,    5,   -5,    5
	     2,    5,    5,    5
	     3,    5,    0,    5
	     4,   -5,    5,    5
	     5,    0,    5,    5
	     6,   -5,   -5,    5
	     7,   -5,    0,    5
	     8,    0,   -5,    5
	     9,    0,    0,    5
	    10,    5,    5,   -5
	    11,    5,   -5,   -5
	    12,    5,    0,   -5
	    13,   -5,   -5,   -5
	    14,    0,   -5,   -5
	    15,   -5,    5,   -5
	    16,   -5,    0,   -5
	    17,    0,    5,   -5
	    18,    0,    0,   -5
	    19,   -5,   -5,    0
	    20,    5,   -5,    0
	    21,    0,   -5,    0
	    22,   -5,    5,    0
	    23,   -5,    0,    0
	    24,    5,    5,    0
	    25,    0,    5,    0
	    26,    5,    0,    0
	    27,    0,    0,    0
	 *Element, type=C3D8, ELSET=EB1
	     1,       6,      19,      23,       7,       8,      21,      27,       9
	     2,      19,      13,      16,      23,      21,      14,      18,      27
	     3,       7,      23,      22,       4,       9,      27,      25,       5
	     4,      23,      16,      15,      22,      27,      18,      17,      25
	     5,       8,      21,      27,       9,       1,      20,      26,       3
	     6,      21,      14,      18,      27,      20,      11,      12,      26
	     7,       9,      27,      25,       5,       3,      26,      24,       2
	     8,      27,      18,      17,      25,      26,      12,      10,      24
	```
	
	 This code can be called two ways.  The first, when `vertex==NULL` and `tree_to_vertex==NULL,` is used to count the number of trees and vertices in the connectivity to be generated by the `.inp` mesh in the *stream.*  The second, when `vertices!=NULL` and `tree_to_vertex!=NULL,` fill `vertices` and `tree_to_vertex.`  In this case `num_vertices` and `num_trees` need to be set to the maximum number of entries allocated in `vertices` and `tree_to_vertex.`
	
	## Parameters
	
	  * `stream`:         file stream to read the connectivity from
	  * `num_vertices`:   the number of vertices in the connectivity
	  * `num_trees`:      the number of trees in the connectivity
	  * `vertices`:       the list of `vertices` of the connectivity
	  * `tree_to_vertex`: the `tree_to_vertex` map of the connectivity
	
	## Returns
	
	 0 if successful and nonzero if not
	
	## Reference
	
	[p8est_connectivity.h:923](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:923:21)
	""" p8est_connectivity_read_inp_stream
	export p8est_connectivity_read_inp_stream
	𝐣𝐥.@cextern p8est_connectivity_read_inp_stream(stream::𝐣𝐥.Ptr{FILE}, num_vertices::𝐣𝐥.Ptr{p4est_topidx_t}, num_trees::𝐣𝐥.Ptr{p4est_topidx_t}, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_connectivity_read_inp(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p8est_connectivity_t}
	```
	
	 Create a p4est connectivity from an ABAQUS input file.
	
	## Details
	
	 This utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.
	
	 A basic 2D mesh is given below.  The `*Node` section gives the vertex number and x, y, and z components for each vertex.  The `*Element` section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:
	
	   4                     3   +-------------------+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +-------------------+   1                   2
	
	 and in 3D they are given as:
	
	 8                     7  +---------------------+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+---------------------+6  |    |                |    |  +----|----------------+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +---------------------+       1                     2
	
	```
	 *Heading
	  box.inp
	 *Node
	     1,    5,   -5,    5
	     2,    5,    5,    5
	     3,    5,    0,    5
	     4,   -5,    5,    5
	     5,    0,    5,    5
	     6,   -5,   -5,    5
	     7,   -5,    0,    5
	     8,    0,   -5,    5
	     9,    0,    0,    5
	    10,    5,    5,   -5
	    11,    5,   -5,   -5
	    12,    5,    0,   -5
	    13,   -5,   -5,   -5
	    14,    0,   -5,   -5
	    15,   -5,    5,   -5
	    16,   -5,    0,   -5
	    17,    0,    5,   -5
	    18,    0,    0,   -5
	    19,   -5,   -5,    0
	    20,    5,   -5,    0
	    21,    0,   -5,    0
	    22,   -5,    5,    0
	    23,   -5,    0,    0
	    24,    5,    5,    0
	    25,    0,    5,    0
	    26,    5,    0,    0
	    27,    0,    0,    0
	 *Element, type=C3D8, ELSET=EB1
	     1,       6,      19,      23,       7,       8,      21,      27,       9
	     2,      19,      13,      16,      23,      21,      14,      18,      27
	     3,       7,      23,      22,       4,       9,      27,      25,       5
	     4,      23,      16,      15,      22,      27,      18,      17,      25
	     5,       8,      21,      27,       9,       1,      20,      26,       3
	     6,      21,      14,      18,      27,      20,      11,      12,      26
	     7,       9,      27,      25,       5,       3,      26,      24,       2
	     8,      27,      18,      17,      25,      26,      12,      10,      24
	```
	
	 This function reads a mesh from *filename* and returns an associated p4est connectivity.
	
	## Parameters
	
	  * `filename`:         file to read the connectivity from
	
	## Returns
	
	 an allocated connectivity associated with the mesh in *filename* 
	
	## Reference
	
	[p8est_connectivity.h:1021](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:1021:23)
	""" p8est_connectivity_read_inp
	export p8est_connectivity_read_inp
	𝐣𝐥.@cextern p8est_connectivity_read_inp(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p8est_connectivity_t}
	
	𝐣𝐥.@doc """
	 This structure holds the 2D+1D inter-tree connectivity information. It is essentially a wrapper of the 2D p4est_connecitivity_t datatype, with some additional information about how the third dimension is embedded.
	
	## Reference
	
	[p6est.h:64](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:64:16)
	""" p6est_connectivity
	𝐣𝐥.@doc """
	 This structure holds the 2D+1D inter-tree connectivity information. It is essentially a wrapper of the 2D p4est_connecitivity_t datatype, with some additional information about how the third dimension is embedded.
	
	## Reference
	
	[p6est.h:77](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:77:1)
	""" p6est_connectivity_t
	export p6est_connectivity, p6est_connectivity_t
	𝐣𝐥.@ctypedef p6est_connectivity_t 𝐣𝐥.@cstruct p6est_connectivity {
		conn4::𝐣𝐥.Ptr{p4est_connectivity_t}
		top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}
		height::𝐣𝐥.Cdouble[3]
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_connectivity_new(conn4::𝐣𝐥.Ptr{p4est_connectivity_t}, top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, height::𝐣𝐥.Cdouble[3])::𝐣𝐥.Ptr{p6est_connectivity_t}
	```
	
	 Create a p6est_connectivity_t from a p4est_connectivity_t.  All fields are copied, so all inputs can be safey destroyed.
	
	## Parameters
	
	  * `conn4`:         the 2D connectivity
	  * `top_vertices`:  if NULL, then the sheet has a uniform vertical                          profile; otherwise, *top_vertices* gives teh                          vertices of the top of the sheet; should be the                          same size as *conn4->tree_to_vertex*
	  * `height`:        if *top_vertices* == NULL, then this gives the                          offset fro the bottom of the sheet to the top.
	
	## Returns
	
	 the 2D+1D connectivity information.
	
	## Reference
	
	[p6est.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:92:23)
	""" p6est_connectivity_new
	export p6est_connectivity_new
	𝐣𝐥.@cextern p6est_connectivity_new(conn4::𝐣𝐥.Ptr{p4est_connectivity_t}, top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, height::𝐣𝐥.Cdouble[3])::𝐣𝐥.Ptr{p6est_connectivity_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_connectivity_destroy(conn::𝐣𝐥.Ptr{p6est_connectivity_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a p6est_connectivity structure 
	
	## Reference
	
	[p6est.h:97](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:97:21)
	""" p6est_connectivity_destroy
	export p6est_connectivity_destroy
	𝐣𝐥.@cextern p6est_connectivity_destroy(conn::𝐣𝐥.Ptr{p6est_connectivity_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_tree_get_vertices(conn::𝐣𝐥.Ptr{p6est_connectivity_t}, which_tree::p4est_topidx_t, vertices::𝐣𝐥.Cdouble[24])::𝐣𝐥.Cvoid
	```
	
	 Get the vertices of the corners of a tree.
	
	## Parameters
	
	  * `conn`:         the 2D+1D connectivity structure
	  * `which_tree`:   a tree in the forest
	  * `vertices`:     the coordinates of the corners of the tree
	
	## Reference
	
	[p6est.h:105](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:105:21)
	""" p6est_tree_get_vertices
	export p6est_tree_get_vertices
	𝐣𝐥.@cextern p6est_tree_get_vertices(conn::𝐣𝐥.Ptr{p6est_connectivity_t}, which_tree::p4est_topidx_t, vertices::𝐣𝐥.Cdouble[24])::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, z::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid
	```
	
	 Transform a quadrant coordinate into the space spanned by tree vertices.
	
	## Parameters
	
	  * `connectivity`:     Connectivity must provide the vertices.
	  * `treeid`:           Identify the tree that contains x, y.
	  * `x,`: y             Quadrant coordinates relative to treeid.
	  * `vxy`:             Transformed coordinates in vertex space.
	
	## Reference
	
	[p6est.h:116](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:116:21)
	""" p6est_qcoord_to_vertex
	export p6est_qcoord_to_vertex
	𝐣𝐥.@cextern p6est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, z::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[p6est.h:132](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:132:9)
	""" p6est_quadrant_data
	𝐣𝐥.@doc """
	 A 1D quadrant datatype: this is used to encode a \"layer\" of a column in the 2D+1D AMR scheme.
	
	## Reference
	
	[p6est.h:161](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:161:1)
	""" p2est_quadrant_t
	𝐣𝐥.@doc """
	 A 1D quadrant datatype: this is used to encode a \"layer\" of a column in the 2D+1D AMR scheme.
	
	## Reference
	
	[p6est.h:126](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:126:16)
	""" p2est_quadrant
	export p2est_quadrant, p2est_quadrant_t, p6est_quadrant_data
	𝐣𝐥.@ctypedef p2est_quadrant_t 𝐣𝐥.@cstruct p2est_quadrant {
		z::p4est_qcoord_t
		(level, pad8)::int8_t
		pad16::int16_t
		p::𝐣𝐥.@cunion p6est_quadrant_data {
			user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
			user_long::𝐣𝐥.Clong
			user_int::𝐣𝐥.Cint
			which_tree::p4est_topidx_t
			piggy1::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				owner_rank::𝐣𝐥.Cint
			}
			piggy2::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				from_tree::p4est_topidx_t
			}
			piggy3::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				local_num::p4est_locidx_t
			}
		}
	}
	
	𝐣𝐥.@doc """
	 The p6est forest datatype 
	
	## Reference
	
	[p6est.h:189](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:189:1)
	""" p6est_t
	𝐣𝐥.@doc """
	 The p6est forest datatype 
	
	## Reference
	
	[p6est.h:164](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:164:16)
	""" p6est
	export p6est, p6est_t
	𝐣𝐥.@ctypedef p6est_t 𝐣𝐥.@cstruct p6est {
		mpicomm::sc_MPI_Comm
		(mpisize, mpirank)::𝐣𝐥.Cint
		mpicomm_owned::𝐣𝐥.Cint
		data_size::size_t
		user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}
		columns::𝐣𝐥.Ptr{p4est_t}
		layers::𝐣𝐥.Ptr{sc_array_t}
		user_data_pool::𝐣𝐥.Ptr{sc_mempool_t}
		layer_pool::𝐣𝐥.Ptr{sc_mempool_t}
		global_first_layer::𝐣𝐥.Ptr{p4est_gloidx_t}
		root_len::p4est_qcoord_t
	}
	
	𝐣𝐥.@doc """
	 Callback function prototype to initialize the layers's user data.
	
	## Parameters
	
	  * `p6est`:        the forest
	  * `which_tree`:   the tree in the forest
	  * `column`:       the column in the tree in the forest
	  * `layer`:        the layer in the column in the tree in the                         forest, whose *user_data* is to be initialized
	
	## Reference
	
	[p6est.h:199](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:199:23)
	""" p6est_init_t
	export p6est_init_t
	𝐣𝐥.@ctypedef p6est_init_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}, 𝐣𝐥.Ptr{p2est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to transfer information from outgoing layers to incoming layers.
	
	## Details
	
	 This is used by extended routines when the layers of an existing, valid p6est are changed.  The callback allows the user to make changes to newly initialized layers before the layers that they replace are destroyed.
	
	## Parameters
	
	  * `num_outcolumns`:  The number of columns that contain the outgoing                             layers: will be either 1 or 4.
	  * `num_outlayers`:   The number of outgoing layers: will be either 1                             (a single layer is being refined), 2 (two                             layers are being vertically coarsened), or 4                             (four layers are being horizontally coarsened).
	  * `outcolumns`:      The columns of the outgoing layers
	  * `outlayers`:       The outgoing layers: after the callback, the                             user_data, if *p6est->data_size* is nonzero,                             will be destroyed.
	  * `num_incolumns`:   The number of columns that contain the outgoing                             layers: will be either 1 or 4.
	  * `num_inlayers`:    The number of incoming layers: will be either 1                             (coarsening), 2 (vertical refinement), or 4                             (horizontal refinement)
	  * `incolumns`:       The columns of the incoming layers
	  * `inlayers`:    The incoming layers: prior to the callback,                             the user_data, if *p6est->data_size* is nonzero,                             is allocated, and the p6est_init_t callback,                             if it has been provided, will be called.
	
	## Reference
	
	[p6est.h:232](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:232:23)
	""" p6est_replace_t
	export p6est_replace_t
	𝐣𝐥.@ctypedef p6est_replace_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Ptr{p4est_quadrant_t}[], 𝐣𝐥.Ptr{p2est_quadrant_t}[], 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Ptr{p4est_quadrant_t}[], 𝐣𝐥.Ptr{p2est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide whether to horizontally refine a column, i.e., horizontally refine all of the layers in the column. 
	
	## Returns
	
	 nonzero if the layer shall be refined.
	
	## Reference
	
	[p6est.h:247](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:247:23)
	""" p6est_refine_column_t
	export p6est_refine_column_t
	𝐣𝐥.@ctypedef p6est_refine_column_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide whether to vertically refine a layer. 
	
	## Returns
	
	 nonzero if the layer shall be refined.
	
	## Reference
	
	[p6est.h:255](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:255:23)
	""" p6est_refine_layer_t
	export p6est_refine_layer_t
	𝐣𝐥.@ctypedef p6est_refine_layer_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}, 𝐣𝐥.Ptr{p2est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide for horizontal coarsening. 
	
	## Parameters
	
	  * `columns`:      Pointers to 4 sibling columns.
	
	## Returns
	
	 nonzero if the columns shall be replaced with their parent.
	
	## Reference
	
	[p6est.h:264](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:264:23)
	""" p6est_coarsen_column_t
	export p6est_coarsen_column_t
	𝐣𝐥.@ctypedef p6est_coarsen_column_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide for vertical coarsening. 
	
	## Parameters
	
	  * `layers`:      Pointers to 2 vertical sibling layers.
	
	## Returns
	
	 nonzero if the layers shall be replaced with their parent.
	
	## Reference
	
	[p6est.h:272](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:272:23)
	""" p6est_coarsen_layer_t
	export p6est_coarsen_layer_t
	𝐣𝐥.@ctypedef p6est_coarsen_layer_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}, 𝐣𝐥.Ptr{p2est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to calculate weights for partitioning. 
	
	## Returns
	
	 a 32bit integer >= 0 as the quadrant weight. 
	
	NOTE:    Global sum of weights must fit into a 64bit integer.
	
	## Reference
	
	[p6est.h:281](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:281:23)
	""" p6est_weight_t
	export p6est_weight_t
	𝐣𝐥.@ctypedef p6est_weight_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p6est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p4est_quadrant_t}, 𝐣𝐥.Ptr{p2est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P2EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[p6est.h:286](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:286:21)
	""" P2EST_DATA_UNINITIALIZED
	export P2EST_DATA_UNINITIALIZED
	𝐣𝐥.@cextern P2EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Create a new forest.
	
	## Details
	
	 The new forest consists of equi-partitioned root quadrants. When there are more processors than trees, some processors are empty.
	
	## Parameters
	
	  * `mpicomm`:       A valid MPI communicator.
	  * `connectivity`:  This is the connectivity information that                           the forest is built with.  Note the p6est                           does not take ownership of the memory.
	  * `data_size`:     This is the size of data for each quadrant which                           can be zero.  Then user_data_pool is set to NULL.
	  * `init_fn`:       Callback function to initialize the user_data                           which is already allocated automatically.
	  * `user_pointer`:  Assign to the user_pointer member of the p6est                           before init_fn is called the first time.
	
	## Returns
	
	 This returns a valid forest.
	
	NOTE: The connectivity structure must not be destroyed       during the lifetime of this forest.
	
	## Reference
	
	[p6est.h:313](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:313:21)
	""" p6est_new
	export p6est_new
	𝐣𝐥.@cextern p6est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_new_from_p4est(p4est::𝐣𝐥.Ptr{p4est_t}, top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, height::𝐣𝐥.Cdouble[3], min_zlevel::𝐣𝐥.Cint, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Create a new forest from an already created p4est that represents columns.
	
	## Parameters
	
	  * `p4est`:         A valid p4est.  A deep copy will be created, so                           this can be destroyed without affectin the new                           p6est object.
	  * `top_vertices`:  the same as in p6est_conectivity_new()
	  * `height`:        the same as in p6est_conectivity_new()
	  * `min_zlevel`:    the same as in p6est_new()
	  * `data_size`:     the same as in p6est_new()
	  * `init_fn`:       the same as in p6est_new()
	  * `user_pointer`:  the same as in p6est_new()
	
	## Returns
	
	 This returns a valid forest.  The user must destroy the connectivity for the new p6est independently.
	
	## Reference
	
	[p6est.h:334](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:334:21)
	""" p6est_new_from_p4est
	export p6est_new_from_p4est
	𝐣𝐥.@cextern p6est_new_from_p4est(p4est::𝐣𝐥.Ptr{p4est_t}, top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, height::𝐣𝐥.Cdouble[3], min_zlevel::𝐣𝐥.Cint, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_destroy(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a p6est.
	
	## Details
	
	NOTE: The connectivity structure is not destroyed with the p6est.
	
	## Reference
	
	[p6est.h:345](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:345:21)
	""" p6est_destroy
	export p6est_destroy
	𝐣𝐥.@cextern p6est_destroy(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_copy(input::𝐣𝐥.Ptr{p6est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Make a deep copy of a p6est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless.
	
	## Parameters
	
	  * `copy_data`:  If true, data are copied.                         If false, data_size is set to 0.
	
	## Returns
	
	  Returns a valid p6est that does not depend on the input.
	
	## Reference
	
	[p6est.h:356](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:356:21)
	""" p6est_copy
	export p6est_copy
	𝐣𝐥.@cextern p6est_copy(input::𝐣𝐥.Ptr{p6est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_reset_data(p6est::𝐣𝐥.Ptr{p6est_t}, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Reset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.
	
	## Parameters
	
	  * `data_size`:     This is the size of data for each quadrant which                           can be zero.  Then user_data_pool is set to NULL.
	  * `init_fn`:       Callback function to initialize the user_data                           which is already allocated automatically.
	  * `user_pointer`:  Assign to the user_pointer member of the p6est                           before init_fn is called the first time.
	
	## Reference
	
	[p6est.h:370](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:370:21)
	""" p6est_reset_data
	export p6est_reset_data
	𝐣𝐥.@cextern p6est_reset_data(p6est::𝐣𝐥.Ptr{p6est_t}, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_refine_columns(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p6est_refine_column_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Refine the columns of a sheet.
	
	## Parameters
	
	  * `p6est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `refine_fn`: Callback function that must return true if a column                       shall be refined into smaller columns.  If                       refine_recursive is true, refine_fn is called for                       every existing and newly created column.                       Otherwise, it is called for every existing column.                       It is possible that a refinement request made by the                       callback is ignored.  To catch this case, you can                       examine whether init_fn gets called, or use                       p6est_refine_columns_ext in p6est_extended.h and examine                       whether replace_fn gets called.
	  * `init_fn`:   Callback function to initialize the user_data of newly                       created layers within columns, which are already                       allocated.  This function pointer may be NULL.
	
	## Reference
	
	[p6est.h:392](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:392:21)
	""" p6est_refine_columns
	export p6est_refine_columns
	𝐣𝐥.@cextern p6est_refine_columns(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p6est_refine_column_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_refine_layers(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p6est_refine_layer_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Refine the layers within the columns of a sheet.
	
	## Parameters
	
	  * `p6est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `refine_fn`: Callback function that must return true if a layer                       shall be refined into smaller layers.  If                       refine_recursive is true, refine_fn is called for                       every existing and newly created layer.                       Otherwise, it is called for every existing layer.                       It is possible that a refinement request made by the                       callback is ignored.  To catch this case, you can                       examine whether init_fn gets called, or use                       p6est_refine_layers_ext in p6est_extended.h and examine                       whether replace_fn gets called.
	  * `init_fn`:   Callback function to initialize the user_data of newly                       created layers, which are already allocated.  This                       function pointer may be NULL.
	
	## Reference
	
	[p6est.h:415](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:415:21)
	""" p6est_refine_layers
	export p6est_refine_layers
	𝐣𝐥.@cextern p6est_refine_layers(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p6est_refine_layer_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_coarsen_columns(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_column_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Coarsen the columns of a sheet.
	
	## Parameters
	
	  * `p6est`:  The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `coarsen_fn`: Callback function that returns true if a                        family of columns shall be coarsened
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	
	## Reference
	
	[p6est.h:429](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:429:21)
	""" p6est_coarsen_columns
	export p6est_coarsen_columns
	𝐣𝐥.@cextern p6est_coarsen_columns(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_column_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_coarsen_layers(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_layer_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Coarsen the layers of a sheet.
	
	## Parameters
	
	  * `p6est`:  The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `coarsen_fn`: Callback function that returns true if a                        family of layers shall be coarsened
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	
	## Reference
	
	[p6est.h:443](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:443:21)
	""" p6est_coarsen_layers
	export p6est_coarsen_layers
	𝐣𝐥.@cextern p6est_coarsen_layers(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_layer_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_balance(p6est::𝐣𝐥.Ptr{p6est_t}, btype::p8est_connect_type_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Balance a forest.
	
	## Parameters
	
	  * `p6est`:     The p6est to be worked on.
	  * `btype`:     Balance type (face, corner or default, full).
	  * `init_fn`:   Callback function to initialize the user_data                       which is already allocated automatically.
	
	## Reference
	
	[p6est.h:455](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:455:21)
	""" p6est_balance
	export p6est_balance
	𝐣𝐥.@cextern p6est_balance(p6est::𝐣𝐥.Ptr{p6est_t}, btype::p8est_connect_type_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[p6est.h:462](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:462:3)
	""" P6EST_COMM_GHOST
	𝐣𝐥.@doc """
	## Reference
	
	[p6est.h:465](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:465:1)
	""" p6est_comm_tag_t
	𝐣𝐥.@doc """
	## Reference
	
	[p6est.h:461](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:461:3)
	""" P6EST_COMM_PARTITION
	𝐣𝐥.@doc """
	## Reference
	
	[p6est.h:463](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:463:3)
	""" P6EST_COMM_BALANCE
	export P6EST_COMM_BALANCE, P6EST_COMM_GHOST, P6EST_COMM_PARTITION, p6est_comm_tag_t
	𝐣𝐥.@ctypedef p6est_comm_tag_t 𝐣𝐥.@cenum {
		P6EST_COMM_PARTITION = 𝐣𝐥.Cuint(1)
		P6EST_COMM_GHOST = 𝐣𝐥.Cuint(2)
		P6EST_COMM_BALANCE = 𝐣𝐥.Cuint(3)
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, weight_fn::p6est_weight_t)::p4est_gloidx_t
	```
	
	 Equally partition the forest.
	
	## Details
	
	 The forest will be partitioned between processors where they each have an approximately equal number of quadrants.
	
	 Note that *p6est->layers* and *p6est->global_first_layers* may change during this call.  Address pointers referencing these objects from before *p6est_partition* is called become invalid.
	
	## Parameters
	
	  * `p6est`:      The forest that will be partitioned.
	  * `weight_fn`:  A weighting function or NULL                            for uniform partitioning.
	
	## Reference
	
	[p6est.h:480](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:480:21)
	""" p6est_partition
	export p6est_partition
	𝐣𝐥.@cextern p6est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, weight_fn::p6est_weight_t)::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_partition_correct(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p6est.h:482](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:482:21)
	""" p6est_partition_correct
	export p6est_partition_correct
	𝐣𝐥.@cextern p6est_partition_correct(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_partition_to_p4est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t}, num_columns_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p6est.h:485](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:485:21)
	""" p6est_partition_to_p4est_partition
	export p6est_partition_to_p4est_partition
	𝐣𝐥.@cextern p6est_partition_to_p4est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t}, num_columns_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p4est_partition_to_p6est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, num_columns_in_proc::𝐣𝐥.Ptr{p4est_locidx_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p6est.h:490](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:490:21)
	""" p4est_partition_to_p6est_partition
	export p4est_partition_to_p6est_partition
	𝐣𝐥.@cextern p4est_partition_to_p6est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, num_columns_in_proc::𝐣𝐥.Ptr{p4est_locidx_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_partition_for_coarsening(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	```
	
	## Reference
	
	[p6est.h:496](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:496:21)
	""" p6est_partition_for_coarsening
	export p6est_partition_for_coarsening
	𝐣𝐥.@cextern p6est_partition_for_coarsening(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_partition_given(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	```
	
	## Reference
	
	[p6est.h:499](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:499:21)
	""" p6est_partition_given
	export p6est_partition_given
	𝐣𝐥.@cextern p6est_partition_given(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_checksum(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cuint
	```
	
	 Compute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize. 
	
	## Returns
	
	  Returns the checksum on processor 0 only. 0 on other processors.
	
	## Reference
	
	[p6est.h:507](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:507:21)
	""" p6est_checksum
	export p6est_checksum
	𝐣𝐥.@cextern p6est_checksum(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p6est::𝐣𝐥.Ptr{p6est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Save the complete connectivity/p6est data to disk.  This is a collective
	
	## Details
	
	 operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations. 
	
	## Parameters
	
	  * `filename`:    Name of the file to write.
	  * `p6est`:       Valid forest structure.
	  * `save_data`:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.
	
	NOTE:            Aborts on file errors.
	
	## Reference
	
	[p6est.h:520](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:520:21)
	""" p6est_save
	export p6est_save
	𝐣𝐥.@cextern p6est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p6est::𝐣𝐥.Ptr{p6est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p6est_connectivity_t}})::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Load the complete connectivity/p6est structure from disk.
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `mpicomm`:          A valid MPI communicator.
	  * `data_size`:        Size of data for each quadrant which can be                              zero.  Then user_data_pool is set to NULL.                              If data_size is zero, load_data is ignored.
	  * `load_data`:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.
	  * `user_pointer`:     Assign to the user_pointer member of the p6est                              before init_fn is called the first time.
	  * `connectivity`:    Connectivity must be destroyed separately.
	
	## Returns
	
	          Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument. 
	
	NOTE:            Aborts on file errors or invalid file contents.
	
	## Reference
	
	[p6est.h:541](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:541:21)
	""" p6est_load
	export p6est_load
	𝐣𝐥.@cextern p6est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p6est_connectivity_t}})::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_compress_columns(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p6est.h:624](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:624:21)
	""" p6est_compress_columns
	export p6est_compress_columns
	𝐣𝐥.@cextern p6est_compress_columns(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_update_offsets(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p6est.h:625](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est.h:625:21)
	""" p6est_update_offsets
	export p6est_update_offsets
	𝐣𝐥.@cextern p6est_update_offsets(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, min_zlevel::𝐣𝐥.Cint, num_zroot::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Create a new forest. This is a more general form of p6est_new(). See the documentation of p6est_new() for basic usage.
	
	## Parameters
	
	  * `min_quadrants`:    Minimum initial quadrants per processor.                              Makes the refinement pattern mpisize-specific.
	  * `min_level`:        The forest is horizontally refined at least to                              this level.  May be negative or 0, then it has                              no effect.
	  * `min_zlevel`:       The forest is vertically refined at least to                              this level.  May be negative or 0, then it has                              no effect.
	  * `num_zroot`:        The number of \"root\" vertical layers                              (used when non-power-of-2 layers are desired)
	  * `fill_uniform`:     If true, fill the forest with a uniform mesh                              instead of the coarsest possible one.                              The latter is partition-specific so that                              is usually not a good idea.
	
	## Reference
	
	[p6est_extended.h:66](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:66:21)
	""" p6est_new_ext
	export p6est_new_ext
	𝐣𝐥.@cextern p6est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, min_zlevel::𝐣𝐥.Cint, num_zroot::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_copy_ext(input::𝐣𝐥.Ptr{p6est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Make a deep copy of a p6est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL.
	
	## Parameters
	
	  * `copy_data`:  If true, data are copied.                         If false, data_size is set to 0.
	  * `duplicate_mpicomm`:  If true, MPI communicator is copied.
	
	## Returns
	
	  Returns a valid p6est that does not depend on the input.
	
	## Reference
	
	[p6est_extended.h:85](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:85:21)
	""" p6est_copy_ext
	export p6est_copy_ext
	𝐣𝐥.@cextern p6est_copy_ext(input::𝐣𝐥.Ptr{p6est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p6est::𝐣𝐥.Ptr{p6est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Save the complete connectivity/p6est data to disk.
	
	## Details
	
	 This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations.  See p6est_load_ext() for information on the autopartition parameter.
	
	## Parameters
	
	  * `filename`:    Name of the file to write.
	  * `p6est`:       Valid forest structure.
	  * `save_data`:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.
	  * `save_partition`:   If false, save file as if 1 core was used.                              If true, save core count and partition.                         Advantage: Partition can be recovered on loading                              with same mpisize and autopartition false.                         Disadvantage: Makes the file depend on mpisize.                  Either way the file can be loaded with autopartition true.
	
	NOTE:            Aborts on file errors.
	
	## Reference
	
	[p6est_extended.h:107](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:107:21)
	""" p6est_save_ext
	export p6est_save_ext
	𝐣𝐥.@cextern p6est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p6est::𝐣𝐥.Ptr{p6est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p6est_connectivity_t}})::𝐣𝐥.Ptr{p6est_t}
	```
	
	 Load the complete connectivity/p6est structure from disk.
	
	## Details
	
	 It is possible to load the file with a different number of processors than has been used to write it.  The partition will then be uniform.
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `mpicomm`:          A valid MPI communicator.
	  * `data_size`:        Size of data for each quadrant which can be                              zero.  Then user_data_pool is set to NULL.                              If data_size is zero, load_data is ignored.
	  * `load_data`:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.
	  * `autopartition`:    Ignore saved partition and make it uniform.
	  * `broadcasthead`:    Have only rank 0 read headers and bcast them.
	  * `user_pointer`:     Assign to the user_pointer member of the p6est                              before init_fn is called the first time.
	  * `connectivity`:    Connectivity must be destroyed separately.
	
	## Returns
	
	          Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument. 
	
	NOTE:            Aborts on file errors or invalid file contents.
	
	## Reference
	
	[p6est_extended.h:133](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:133:21)
	""" p6est_load_ext
	export p6est_load_ext
	𝐣𝐥.@cextern p6est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p6est_connectivity_t}})::𝐣𝐥.Ptr{p6est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_refine_columns_ext(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p6est_refine_column_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Horizontally refine a forest with a bounded refinement level and a replace option.
	
	## Parameters
	
	  * `p6est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `maxlevel`:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p4est.h.
	  * `refine_fn`:  Callback function that must return true if a quadrant                        shall be refined.  If refine_recursive is true,                        refine_fn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether init_fn or                        replace_fn gets called.
	  * `init_fn`:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.
	
	## Reference
	
	[p6est_extended.h:161](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:161:21)
	""" p6est_refine_columns_ext
	export p6est_refine_columns_ext
	𝐣𝐥.@cextern p6est_refine_columns_ext(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p6est_refine_column_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_refine_layers_ext(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p6est_refine_layer_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Vertically refine a forest with a bounded refinement level and a replace option.
	
	## Parameters
	
	  * `p6est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `maxlevel`:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p4est.h.
	  * `refine_fn`:  Callback function that must return true if a quadrant                        shall be refined.  If refine_recursive is true,                        refine_fn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether init_fn or                        replace_fn gets called.
	  * `init_fn`:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.
	
	## Reference
	
	[p6est_extended.h:190](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:190:21)
	""" p6est_refine_layers_ext
	export p6est_refine_layers_ext
	𝐣𝐥.@cextern p6est_refine_layers_ext(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p6est_refine_layer_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_coarsen_columns_ext(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_column_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Horizontally coarsen a forest. 
	
	## Parameters
	
	  * `p6est`: The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `callback_orphans`: Boolean to enable calling coarsen_fn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsen_recursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.
	  * `coarsen_fn`: Callback function that returns true if a                        family of quadrants shall be coarsened.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p6est_extended.h:215](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:215:21)
	""" p6est_coarsen_columns_ext
	export p6est_coarsen_columns_ext
	𝐣𝐥.@cextern p6est_coarsen_columns_ext(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_column_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_coarsen_layers_ext(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_layer_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Vertically coarsen a forest. 
	
	## Parameters
	
	  * `p6est`: The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `callback_orphans`: Boolean to enable calling coarsen_fn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsen_recursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.
	  * `coarsen_fn`: Callback function that returns true if a                        family of quadrants shall be coarsened.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p6est_extended.h:241](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:241:21)
	""" p6est_coarsen_layers_ext
	export p6est_coarsen_layers_ext
	𝐣𝐥.@cextern p6est_coarsen_layers_ext(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_layer_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_partition_ext(p6est::𝐣𝐥.Ptr{p6est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p6est_weight_t)::p4est_gloidx_t
	```
	
	 Repartition the forest.
	
	## Details
	
	 The forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).
	
	## Parameters
	
	  * `p6est`:      The forest that will be partitioned.
	  * `partition_for_coarsening`:     If true, the partition                            is modified to allow one level of coarsening.
	  * `weight_fn`:  A weighting function or NULL                            for uniform partitioning.
	
	## Returns
	
	         The global number of shipped quadrants
	
	## Reference
	
	[p6est_extended.h:261](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:261:21)
	""" p6est_partition_ext
	export p6est_partition_ext
	𝐣𝐥.@cextern p6est_partition_ext(p6est::𝐣𝐥.Ptr{p6est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p6est_weight_t)::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p6est_balance_ext(p6est::𝐣𝐥.Ptr{p6est_t}, btype::p8est_connect_type_t, max_diff::𝐣𝐥.Cint, min_diff::𝐣𝐥.Cint, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 2:1 balance the size differences of neighboring elements in a forest. 
	
	## Parameters
	
	  * `p6est`:  The p6est to be worked on.
	  * `btype`:      Balance type (face or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.
	  * `max_diff`:   The maximum difference between the horizontal                        refinement level and the vertical refinement level
	  * `min_diff`:   The minimum difference between the horizontal                        refinement level and the vertical refinement level
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p6est_extended.h:280](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p6est_extended.h:280:21)
	""" p6est_balance_ext
	export p6est_balance_ext
	𝐣𝐥.@cextern p6est_balance_ext(p6est::𝐣𝐥.Ptr{p6est_t}, btype::p8est_connect_type_t, max_diff::𝐣𝐥.Cint, min_diff::𝐣𝐥.Cint, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 The 3D quadrant (i.e., octant) datatype 
	
	## Reference
	
	[p8est.h:107](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:107:1)
	""" p8est_quadrant_t
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:75](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:75:9)
	""" p8est_quadrant_data
	𝐣𝐥.@doc """
	 The 3D quadrant (i.e., octant) datatype 
	
	## Reference
	
	[p8est.h:67](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:67:16)
	""" p8est_quadrant
	export p8est_quadrant, p8est_quadrant_data, p8est_quadrant_t
	𝐣𝐥.@ctypedef p8est_quadrant_t 𝐣𝐥.@cstruct p8est_quadrant {
		(x, y, z)::p4est_qcoord_t
		(level, pad8)::int8_t
		pad16::int16_t
		p::𝐣𝐥.@cunion p8est_quadrant_data {
			user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
			user_long::𝐣𝐥.Clong
			user_int::𝐣𝐥.Cint
			which_tree::p4est_topidx_t
			piggy1::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				owner_rank::𝐣𝐥.Cint
			}
			piggy2::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				from_tree::p4est_topidx_t
			}
			piggy3::𝐣𝐥.@cstruct {
				which_tree::p4est_topidx_t
				local_num::p4est_locidx_t
			}
		}
	}
	
	𝐣𝐥.@doc """
	 The p8est tree datatype 
	
	## Reference
	
	[p8est.h:122](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:122:1)
	""" p8est_tree_t
	𝐣𝐥.@doc """
	 The p8est tree datatype 
	
	## Reference
	
	[p8est.h:110](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:110:16)
	""" p8est_tree
	export p8est_tree, p8est_tree_t
	𝐣𝐥.@ctypedef p8est_tree_t 𝐣𝐥.@cstruct p8est_tree {
		quadrants::sc_array_t
		(first_desc, last_desc)::p8est_quadrant_t
		quadrants_offset::p4est_locidx_t
		quadrants_per_level::p4est_locidx_t[31]
		maxlevel::int8_t
	}
	
	𝐣𝐥.@doc """
	 Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p8est main structure. Declared in p8est_extended.h.  Used to profile important algorithms.
	
	## Reference
	
	[p8est.h:128](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:128:30)
	""" p8est_inspect_t
	export p8est_inspect_t
	𝐣𝐥.@ctypedef p8est_inspect_t 𝐣𝐥.@cstruct p8est_inspect
	
	𝐣𝐥.@doc """
	 The p8est forest datatype 
	
	## Reference
	
	[p8est.h:131](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:131:16)
	""" p8est
	𝐣𝐥.@doc """
	 The p8est forest datatype 
	
	## Reference
	
	[p8est.h:169](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:169:1)
	""" p8est_t
	export p8est, p8est_t
	𝐣𝐥.@ctypedef p8est_t 𝐣𝐥.@cstruct p8est {
		mpicomm::sc_MPI_Comm
		(mpisize, mpirank)::𝐣𝐥.Cint
		mpicomm_owned::𝐣𝐥.Cint
		data_size::size_t
		user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		revision::𝐣𝐥.Clong
		first_local_tree::p4est_topidx_t
		last_local_tree::p4est_topidx_t
		local_num_quadrants::p4est_locidx_t
		global_num_quadrants::p4est_gloidx_t
		global_first_quadrant::𝐣𝐥.Ptr{p4est_gloidx_t}
		global_first_position::𝐣𝐥.Ptr{p8est_quadrant_t}
		connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}
		trees::𝐣𝐥.Ptr{sc_array_t}
		user_data_pool::𝐣𝐥.Ptr{sc_mempool_t}
		quadrant_pool::𝐣𝐥.Ptr{sc_mempool_t}
		inspect::𝐣𝐥.Ptr{p8est_inspect_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_memory_used(p8est::𝐣𝐥.Ptr{p8est_t})::size_t
	```
	
	 Calculate local memory usage of a forest structure. Not collective.  The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use p8est_connectivity_memory_usage (p8est->connectivity). 
	
	## Parameters
	
	  * `p8est`:    Valid forest structure.
	
	## Returns
	
	              Memory used in bytes.
	
	## Reference
	
	[p8est.h:178](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:178:21)
	""" p8est_memory_used
	export p8est_memory_used
	𝐣𝐥.@cextern p8est_memory_used(p8est::𝐣𝐥.Ptr{p8est_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_revision(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Clong
	```
	
	 Return the revision counter of the forest. Not collective, even though the revision value is the same on all ranks. A newly created forest starts with a revision counter of zero. Every refine, coarsen, partition, and balance that actually changes the mesh increases the counter by one.  Operations with no effect keep the old value. 
	
	## Parameters
	
	  * `p8est`:    The forest must be valid.
	
	## Returns
	
	              Non-negative number.
	
	## Reference
	
	[p8est.h:188](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:188:21)
	""" p8est_revision
	export p8est_revision
	𝐣𝐥.@cextern p8est_revision(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Clong
	
	𝐣𝐥.@doc """
	 Callback function prototype to initialize the quadrant's user data. 
	
	## Parameters
	
	  * `p8est`:         the forest
	  * `which_tree`:    the tree containing *quadrant*
	  * `quadrant`:  the quadrant to be initialized: if data_size > 0,                           the data to be initialized is at                           *quadrant->p.user_data;* otherwise, the                           non-pointer user data (such as                           *quadrant->p.user_int)* can be initialized
	
	## Reference
	
	[p8est.h:199](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:199:23)
	""" p8est_init_t
	export p8est_init_t
	𝐣𝐥.@ctypedef p8est_init_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p8est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide for refinement. 
	
	## Parameters
	
	  * `p8est`:       the forest
	  * `which_tree`:  the tree containing *quadrant*
	  * `quadrant`:    the quadrant that may be refined
	
	## Returns
	
	 nonzero if the quadrant shall be refined.
	
	## Reference
	
	[p8est.h:209](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:209:23)
	""" p8est_refine_t
	export p8est_refine_t
	𝐣𝐥.@ctypedef p8est_refine_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p8est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to decide for coarsening. 
	
	## Parameters
	
	  * `p8est`:       the forest
	  * `which_tree`:  the tree containing *quadrant*
	  * `quadrants`:   Pointers to 8 siblings in Morton ordering.
	
	## Returns
	
	 nonzero if the quadrants shall be replaced with their parent.
	
	## Reference
	
	[p8est.h:219](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:219:23)
	""" p8est_coarsen_t
	export p8est_coarsen_t
	𝐣𝐥.@ctypedef p8est_coarsen_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p8est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Callback function prototype to calculate weights for partitioning. 
	
	## Parameters
	
	  * `p8est`:       the forest
	  * `which_tree`:  the tree containing *quadrant*
	
	## Returns
	
	 a 32bit integer >= 0 as the quadrant weight. 
	
	NOTE:    Global sum of weights must fit into a 64bit integer.
	
	## Reference
	
	[p8est.h:229](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:229:23)
	""" p8est_weight_t
	export p8est_weight_t
	𝐣𝐥.@ctypedef p8est_weight_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_t}, p4est_topidx_t, 𝐣𝐥.Ptr{p8est_quadrant_t}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern P8EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[p8est.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:233:21)
	""" P8EST_DATA_UNINITIALIZED
	export P8EST_DATA_UNINITIALIZED
	𝐣𝐥.@cextern P8EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, z::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid
	```
	
	 Transform a quadrant coordinate into the space spanned by tree vertices. 
	
	## Parameters
	
	  * `connectivity`:     Connectivity must provide the vertices.
	  * `treeid`:           Identify the tree that contains x, y, z.
	  * `x,`: y, z          Quadrant coordinates relative to treeid.
	  * `vxyz`:            Transformed coordinates in vertex space.
	
	## Reference
	
	[p8est.h:245](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:245:21)
	""" p8est_qcoord_to_vertex
	export p8est_qcoord_to_vertex
	𝐣𝐥.@cextern p8est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, z::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_t}
	```
	
	 Create a new forest with an initial coarse mesh. The new forest consists of equi-partitioned root quadrants. When there are more processors than trees, some processors are empty.
	
	## Parameters
	
	  * `mpicomm`:       A valid MPI communicator.
	  * `connectivity`:  This is the connectivity information that                           the forest is built with.  Note the p8est                           does not take ownership of the memory.
	  * `data_size`:     This is the size of data for each quadrant which                           can be zero.  Then user_data_pool is set to NULL.
	  * `init_fn`:       Callback function to initialize the user_data                           which is already allocated automatically.
	  * `user_pointer`:  Assign to the user_pointer member of the p8est                           before init_fn is called the first time.
	
	## Returns
	
	 This returns a valid forest.
	
	NOTE: The connectivity structure must not be destroyed       during the lifetime of this forest.
	
	## Reference
	
	[p8est.h:272](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:272:21)
	""" p8est_new
	export p8est_new
	𝐣𝐥.@cextern p8est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_destroy(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a p8est.
	
	## Details
	
	NOTE: The connectivity structure is not destroyed with the p8est.
	
	## Reference
	
	[p8est.h:281](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:281:21)
	""" p8est_destroy
	export p8est_destroy
	𝐣𝐥.@cextern p8est_destroy(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_copy(input::𝐣𝐥.Ptr{p8est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_t}
	```
	
	 Make a deep copy of a p8est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.
	
	## Parameters
	
	  * `copy_data`:  If true, data are copied.                         If false, data_size is set to 0.
	
	## Returns
	
	  Returns a valid p8est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.
	
	## Reference
	
	[p8est.h:296](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:296:21)
	""" p8est_copy
	export p8est_copy
	𝐣𝐥.@cextern p8est_copy(input::𝐣𝐥.Ptr{p8est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_reset_data(p8est::𝐣𝐥.Ptr{p8est_t}, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Reset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.
	
	## Parameters
	
	  * `data_size`:     This is the size of data for each quadrant which                           can be zero.  Then user_data_pool is set to NULL.
	  * `init_fn`:       Callback function to initialize the user_data                           which is already allocated automatically.                           May be NULL.
	  * `user_pointer`:  Assign to the user_pointer member of the p8est                           before init_fn is called the first time.
	
	## Reference
	
	[p8est.h:311](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:311:21)
	""" p8est_reset_data
	export p8est_reset_data
	𝐣𝐥.@cextern p8est_reset_data(p8est::𝐣𝐥.Ptr{p8est_t}, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_refine(p8est::𝐣𝐥.Ptr{p8est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p8est_refine_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Refine a forest. 
	
	## Parameters
	
	  * `p8est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `refine_fn`: Callback function that must return true if a quadrant                       shall be refined.  If refine_recursive is true,                       refine_fn is called for every existing and newly                       created quadrant.  Otherwise, it is called for every                       existing quadrant.  It is possible that a refinement                       request made by the callback is ignored.  To catch                       this case, you can examine whether init_fn gets                       called, or use p8est_refine_ext in p8est_extended.h                       and examine whether replace_fn gets called.
	  * `init_fn`:   Callback function to initialize the user_data of newly                       created quadrants, which is already allocated.  This                       function pointer may be NULL.
	
	## Reference
	
	[p8est.h:331](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:331:21)
	""" p8est_refine
	export p8est_refine
	𝐣𝐥.@cextern p8est_refine(p8est::𝐣𝐥.Ptr{p8est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p8est_refine_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_coarsen(p8est::𝐣𝐥.Ptr{p8est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p8est_coarsen_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid
	```
	
	 Coarsen a forest. 
	
	## Parameters
	
	  * `p8est`:  The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `coarsen_fn`: Callback function that returns true if a                        family of quadrants shall be coarsened
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	
	## Reference
	
	[p8est.h:344](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:344:21)
	""" p8est_coarsen
	export p8est_coarsen
	𝐣𝐥.@cextern p8est_coarsen(p8est::𝐣𝐥.Ptr{p8est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p8est_coarsen_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_balance(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid
	```
	
	 2:1 balance the size differences of neighboring elements in a forest. 
	
	## Parameters
	
	  * `p8est`:  The p8est to be worked on.
	  * `btype`:      Balance type (face, edge, or corner/full).  Examples:                        Finite volume or discontinuous Galerkin methods only                        require face balance.  Continuous finite element                        methods usually require edge balance.  Corner balance                        is almost never required mathematically; it just                        produces a smoother mesh grading.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	
	## Reference
	
	[p8est.h:360](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:360:21)
	""" p8est_balance
	export p8est_balance
	𝐣𝐥.@cextern p8est_balance(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_partition(p8est::𝐣𝐥.Ptr{p8est_t}, allow_for_coarsening::𝐣𝐥.Cint, weight_fn::p8est_weight_t)::𝐣𝐥.Cvoid
	```
	
	 Equally partition the forest. The partition can be by element count or by a user-defined weight.
	
	## Details
	
	 The forest will be partitioned between processors such that they have an approximately equal number of quadrants (or sum of weights).
	
	 On one process, the function noops and does not call the weight callback. Otherwise, the weight callback is called once per quadrant in order.
	
	## Parameters
	
	  * `p8est`:      The forest that will be partitioned.
	  * `allow_for_coarsening`: Slightly modify partition such that                            quadrant families are not split between ranks.
	  * `weight_fn`:  A weighting function or NULL                            for uniform partitioning.                            When running with mpisize == 1, never called.                            Otherwise, called in order for all quadrants                            if not NULL. A weighting function with constant                            weight 1 on each quadrant is equivalent                            to weight_fn == NULL but other constant weightings                            may result in different uniform partitionings.
	
	## Reference
	
	[p8est.h:385](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:385:21)
	""" p8est_partition
	export p8est_partition
	𝐣𝐥.@cextern p8est_partition(p8est::𝐣𝐥.Ptr{p8est_t}, allow_for_coarsening::𝐣𝐥.Cint, weight_fn::p8est_weight_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_checksum(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cuint
	```
	
	 Compute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize. 
	
	## Returns
	
	  Returns the checksum on processor 0 only. 0 on other processors.
	
	## Reference
	
	[p8est.h:393](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:393:21)
	""" p8est_checksum
	export p8est_checksum
	𝐣𝐥.@cextern p8est_checksum(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_checksum_partition(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cuint
	```
	
	 Compute a partition-dependent checksum for a forest. 
	
	## Returns
	
	  Returns the checksum on processor 0 only. 0 on other processors.
	
	## Reference
	
	[p8est.h:398](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:398:21)
	""" p8est_checksum_partition
	export p8est_checksum_partition
	𝐣𝐥.@cextern p8est_checksum_partition(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p8est::𝐣𝐥.Ptr{p8est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Save the complete connectivity/p8est data to disk.
	
	## Details
	
	 This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations.
	
	 By default, we write the current processor count and partition into the file header.  This makes the file depend on mpisize.  For changing this see p8est_save_ext() in p8est_extended.h.
	
	 The revision counter is not saved to the file, since that would make files different that come from different revisions but store the same mesh.
	
	## Parameters
	
	  * `filename`:    Name of the file to write.
	  * `p8est`:       Valid forest structure.
	  * `save_data`:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.
	
	NOTE:            Aborts on file errors. 
	
	NOTE:            If p4est is not configured to use MPI-IO, some processes                  return from this function before the file is complete, in                  which case immediate read-access to the file may require a                  call to sc_MPI_Barrier.
	
	## Reference
	
	[p8est.h:423](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:423:21)
	""" p8est_save
	export p8est_save
	𝐣𝐥.@cextern p8est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p8est::𝐣𝐥.Ptr{p8est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}
	```
	
	 Load the complete connectivity/p8est structure from disk.
	
	## Details
	
	 This is a collective operation that all MPI processes need to call.  All processes read from the same file, so the filename given needs to be identical over all parallel invocations.
	
	 By default, a file can only be loaded with the same number of processors that it was stored with.  The defaults can be changed with p8est_load_ext() in p8est_extended.h.
	
	 The revision counter of the loaded p4est is set to zero.
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `mpicomm`:          A valid MPI communicator.
	  * `data_size`:        Size of data for each quadrant which can be                              zero.  Then user_data_pool is set to NULL.                              If data_size is zero, load_data is ignored.
	  * `load_data`:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.
	  * `user_pointer`:     Assign to the user_pointer member of the p8est                              before init_fn is called the first time.
	  * `connectivity`:    Connectivity must be destroyed separately.
	
	## Returns
	
	          Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument. 
	
	NOTE:            Aborts on file errors or invalid file contents.
	
	## Reference
	
	[p8est.h:454](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:454:21)
	""" p8est_load
	export p8est_load
	𝐣𝐥.@cextern p8est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	 quadrants that neighbor the local domain 
	
	## Reference
	
	[p8est_ghost.h:78](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:78:1)
	""" p8est_ghost_t
	export p8est_ghost_t
	𝐣𝐥.@ctypedef p8est_ghost_t 𝐣𝐥.@cstruct {
		mpisize::𝐣𝐥.Cint
		num_trees::p4est_topidx_t
		btype::p8est_connect_type_t
		ghosts::sc_array_t
		tree_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		proc_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		mirrors::sc_array_t
		mirror_tree_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_mirrors::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_fronts::𝐣𝐥.Ptr{p4est_locidx_t}
		mirror_proc_front_offsets::𝐣𝐥.Ptr{p4est_locidx_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_is_valid(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cint
	```
	
	 Examine if a ghost structure is valid as desribed above. Test if within a ghost-structure the arrays ghosts and mirrors are in p8est_quadrant_compare_piggy order. Test if local_num in piggy3 data member of the quadrants in ghosts and mirrors are in ascending order (ascending within each rank for ghost).
	
	## Details
	
	 Test if the p4est_locidx_t arrays are in ascending order (for mirror_proc_mirrors ascending within each rank) 
	
	## Parameters
	
	  * `p8est`:    the forest.
	  * `ghost`:    Ghost layer structure.
	
	## Returns
	
	 true if *ghost* is valid
	
	## Reference
	
	[p8est_ghost.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:92:21)
	""" p8est_ghost_is_valid
	export p8est_ghost_is_valid
	𝐣𝐥.@cextern p8est_ghost_is_valid(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_memory_used(ghost::𝐣𝐥.Ptr{p8est_ghost_t})::size_t
	```
	
	 Calculate the memory usage of the ghost layer. 
	
	## Parameters
	
	  * `ghost`:    Ghost layer structure.
	
	## Returns
	
	              Memory used in bytes.
	
	## Reference
	
	[p8est_ghost.h:99](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:99:21)
	""" p8est_ghost_memory_used
	export p8est_ghost_memory_used
	𝐣𝐥.@cextern p8est_ghost_memory_used(ghost::𝐣𝐥.Ptr{p8est_ghost_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_quadrant_find_owner(p8est::𝐣𝐥.Ptr{p8est_t}, treeid::p4est_topidx_t, face::𝐣𝐥.Cint, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::𝐣𝐥.Cint
	```
	
	 Gets the processor id of a quadrant's owner. The quadrant can lie outside of a tree across faces (and only faces).
	
	## Parameters
	
	  * `p8est`:  The forest in which to search for a quadrant.
	  * `treeid`: The tree to which the quadrant belongs.
	  * `face`:   Supply a face direction if known, or -1 otherwise.
	  * `q`:      The quadrant that is being searched for.
	
	## Returns
	
	 Processor id of the owner                or -1 if the quadrant lies outside of the mesh.
	
	WARNING: Does not work for tree edge or corner neighbors.
	
	## Reference
	
	[p8est_ghost.h:114](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:114:21)
	""" p8est_quadrant_find_owner
	export p8est_quadrant_find_owner
	𝐣𝐥.@cextern p8est_quadrant_find_owner(p8est::𝐣𝐥.Ptr{p8est_t}, treeid::p4est_topidx_t, face::𝐣𝐥.Cint, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_new(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_ghost_t}
	```
	
	 Builds the ghost layer.
	
	## Details
	
	 This will gather the quadrants from each neighboring proc to build one layer of face, edge and corner based ghost elements around the ones they own.
	
	## Parameters
	
	  * `p8est`:            The forest for which the ghost layer will be                              generated.
	  * `btype`:            Which ghosts to include (across face, edge,                              or corner/full).
	
	## Returns
	
	                      A fully initialized ghost layer.
	
	## Reference
	
	[p8est_ghost.h:130](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:130:21)
	""" p8est_ghost_new
	export p8est_ghost_new
	𝐣𝐥.@cextern p8est_ghost_new(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_ghost_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_destroy(ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Frees all memory used for the ghost layer. 
	
	## Reference
	
	[p8est_ghost.h:134](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:134:21)
	""" p8est_ghost_destroy
	export p8est_ghost_destroy
	𝐣𝐥.@cextern p8est_ghost_destroy(ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_bsearch(ghost::𝐣𝐥.Ptr{p8est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::ssize_t
	```
	
	 Conduct binary search for exact match on a range of the ghost layer. 
	
	## Parameters
	
	  * `ghost`:            The ghost layer.
	  * `which_proc`:       The owner of the searched quadrant.  Can be -1.
	  * `which_tree`:       The tree of the searched quadrant.  Can be -1.
	  * `q`:                Valid quadrant is searched in the ghost layer.
	
	## Returns
	
	                      Offset in the ghost layer, or -1 if not found.
	
	## Reference
	
	[p8est_ghost.h:143](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:143:21)
	""" p8est_ghost_bsearch
	export p8est_ghost_bsearch
	𝐣𝐥.@cextern p8est_ghost_bsearch(ghost::𝐣𝐥.Ptr{p8est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::ssize_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_tree_contains(ghost::𝐣𝐥.Ptr{p8est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::ssize_t
	```
	
	 Conduct binary search for ancestor on range of the ghost layer. 
	
	## Parameters
	
	  * `ghost`:            The ghost layer.
	  * `which_proc`:       The owner of the searched quadrant.  Can be -1.
	  * `which_tree`:       The tree of the searched quadrant.  Can be -1.
	  * `q`:                Valid quadrant's ancestor is searched.
	
	## Returns
	
	                      Offset in the ghost layer, or -1 if not found.
	
	## Reference
	
	[p8est_ghost.h:155](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:155:21)
	""" p8est_ghost_tree_contains
	export p8est_ghost_tree_contains
	𝐣𝐥.@cextern p8est_ghost_tree_contains(ghost::𝐣𝐥.Ptr{p8est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::ssize_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_face_quadrant_exists(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, face::𝐣𝐥.Ptr{𝐣𝐥.Cint}, hang::𝐣𝐥.Ptr{𝐣𝐥.Cint}, owner_rank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::p4est_locidx_t
	```
	
	 Checks if quadrant exists in the local forest or the ghost layer.
	
	## Details
	
	 For quadrants across tree boundaries it checks if the quadrant exists across any face, but not across edges or corners.
	
	## Parameters
	
	  * `p8est`:        The forest in which to search for *q.*
	  * `ghost`:        The ghost layer in which to search for *q.*
	  * `treeid`:       The tree to which *q* belongs.
	  * `q`:            The quadrant that is being searched for.
	  * `face`:      On input, face id across which *q* was created.                           On output, the neighbor's face number augmented                           by orientation, so face is in 0..23.
	  * `hang`:      If not NULL, signals that q is bigger than                           the quadrant it came from.  The child id                           of that originating quadrant is passed into hang.                           On output, hang holds the hanging face number                           of *q* that is in contact with its originator.
	  * `owner_rank`:   Filled with the rank of the owner if it is found                           and undefined otherwise.
	
	## Returns
	
	      Returns the local number of *q* if the quadrant exists              in the local forest or in the ghost_layer.  Otherwise,              returns -2 for a domain boundary and -1 if not found.
	
	## Reference
	
	[p8est_ghost.h:184](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:184:21)
	""" p8est_face_quadrant_exists
	export p8est_face_quadrant_exists
	𝐣𝐥.@cextern p8est_face_quadrant_exists(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, face::𝐣𝐥.Ptr{𝐣𝐥.Cint}, hang::𝐣𝐥.Ptr{𝐣𝐥.Cint}, owner_rank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::p4est_locidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_quadrant_exists(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, exists_arr::𝐣𝐥.Ptr{sc_array_t}, rproc_arr::𝐣𝐥.Ptr{sc_array_t}, rquad_arr::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	```
	
	 Checks if quadrant exists in the local forest or the ghost layer.
	
	## Details
	
	 For quadrants across tree corners it checks if the quadrant exists in any of the corner neighbors, thus it can execute multiple queries.
	
	## Parameters
	
	  * `p8est`:        The forest in which to search for *q*
	  * `ghost`:        The ghost layer in which to search for *q*
	  * `treeid`:       The tree to which *q* belongs (can be extended).
	  * `q`:            The quadrant that is being searched for.
	  * `exists_arr`: Must exist and be of of elem_size = sizeof (int)                           for inter-tree corner cases.  Is resized by this                           function to one entry for each corner search                           and set to true/false depending on its existence                           in the local forest or ghost_layer.
	  * `rproc_arr`: If not NULL is filled with one rank per query.
	  * `rquad_arr`: If not NULL is filled with one quadrant per query.                           Its piggy3 member is defined as well.
	
	## Returns
	
	 true if the quadrant exists in the local forest or in the                  ghost_layer, and false if doesn't exist in either.
	
	## Reference
	
	[p8est_ghost.h:212](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:212:21)
	""" p8est_quadrant_exists
	export p8est_quadrant_exists
	𝐣𝐥.@cextern p8est_quadrant_exists(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, exists_arr::𝐣𝐥.Ptr{sc_array_t}, rproc_arr::𝐣𝐥.Ptr{sc_array_t}, rquad_arr::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_is_balanced(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t)::𝐣𝐥.Cint
	```
	
	 Check a forest to see if it is balanced.
	
	## Details
	
	 This function builds the ghost layer and discards it when done.
	
	## Parameters
	
	  * `p8est`:    The p8est to be tested.
	  * `btype`:    Balance type (face, edge, corner or default, full).
	
	## Returns
	
	 Returns true if balanced, false otherwise.
	
	## Reference
	
	[p8est_ghost.h:228](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:228:21)
	""" p8est_is_balanced
	export p8est_is_balanced
	𝐣𝐥.@cextern p8est_is_balanced(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_checksum(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cuint
	```
	
	 Compute the parallel checksum of a ghost layer. 
	
	## Parameters
	
	  * `p8est`:   The MPI information of this p8est will be used.
	  * `ghost`:   A ghost layer obtained from the p8est.
	
	## Returns
	
	             Parallel checksum on rank 0, 0 otherwise.
	
	## Reference
	
	[p8est_ghost.h:236](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:236:21)
	""" p8est_ghost_checksum
	export p8est_ghost_checksum
	𝐣𝐥.@cextern p8est_ghost_checksum(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_data(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Transfer data for local quadrants that are ghosts to other processors. Send the data stored in the quadrant's user_data.  This is either the pointer variable itself if `p8est->data_size` is 0, or the content of the referenced memory field if p8est->data_size is positive. 
	
	## Parameters
	
	  * `p8est`:            The forest used for reference.
	  * `ghost`:            The ghost layer used for reference.
	  * `ghost_data`:   Pre-allocated contiguous data for all ghost                              quadrants in sequence.  If p8est->data_size is                              0, must at least hold sizeof (void *) bytes for                              each, otherwise p8est->data_size each.
	
	## Reference
	
	[p8est_ghost.h:250](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:250:21)
	""" p8est_ghost_exchange_data
	export p8est_ghost_exchange_data
	𝐣𝐥.@cextern p8est_ghost_exchange_data(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 Transient storage for asynchronous ghost exchange. 
	
	## Reference
	
	[p8est_ghost.h:255](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:255:16)
	""" p8est_ghost_exchange
	𝐣𝐥.@doc """
	 Transient storage for asynchronous ghost exchange. 
	
	## Reference
	
	[p8est_ghost.h:268](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:268:1)
	""" p8est_ghost_exchange_t
	export p8est_ghost_exchange, p8est_ghost_exchange_t
	𝐣𝐥.@ctypedef p8est_ghost_exchange_t 𝐣𝐥.@cstruct p8est_ghost_exchange {
		is_custom::𝐣𝐥.Cint
		is_levels::𝐣𝐥.Cint
		p4est::𝐣𝐥.Ptr{p8est_t}
		ghost::𝐣𝐥.Ptr{p8est_ghost_t}
		(minlevel, maxlevel)::𝐣𝐥.Cint
		data_size::size_t
		ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		(qactive::𝐣𝐥.Ptr{_}, qbuffer::𝐣𝐥.Ptr{_})::𝐣𝐥.Cint
		(requests, sbuffers)::sc_array_t
		(rrequests, rbuffers)::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_data_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}
	```
	
	 Begin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8est_ghost_exchange_data. The return type is always non-NULL and must be passed to p8est_ghost_exchange_data_end to complete the exchange. The ghost data must not be accessed before completion. 
	
	## Parameters
	
	  * `ghost_data`:  Must stay alive into the completion call.
	
	## Returns
	
	          Transient storage for messages in progress.
	
	## Reference
	
	[p8est_ghost.h:278](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:278:25)
	""" p8est_ghost_exchange_data_begin
	export p8est_ghost_exchange_data_begin
	𝐣𝐥.@cextern p8est_ghost_exchange_data_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_data_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid
	```
	
	 Complete an asynchronous ghost data exchange. This function waits for all pending MPI communications. 
	
	## Parameters
	
	  * `exc`: Created ONLY by p8est_ghost_exchange_data_begin.                      It is deallocated before this function returns.
	
	## Reference
	
	[p8est_ghost.h:286](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:286:21)
	""" p8est_ghost_exchange_data_end
	export p8est_ghost_exchange_data_end
	𝐣𝐥.@cextern p8est_ghost_exchange_data_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_custom(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Transfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. 
	
	## Parameters
	
	  * `p8est`:            The forest used for reference.
	  * `ghost`:            The ghost layer used for reference.
	  * `data_size`:        The data size to transfer per quadrant.
	  * `mirror_data`:      One data pointer per mirror quadrant.
	  * `ghost_data`:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least `data_size` for each ghost.
	
	## Reference
	
	[p8est_ghost.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:299:21)
	""" p8est_ghost_exchange_custom
	export p8est_ghost_exchange_custom
	𝐣𝐥.@cextern p8est_ghost_exchange_custom(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}
	```
	
	 Begin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8est_ghost_exchange_custom. The return type is always non-NULL and must be passed to p8est_ghost_exchange_custom_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. 
	
	## Parameters
	
	  * `mirror_data`: Not required to stay alive any longer.
	  * `ghost_data`:  Must stay alive into the completion call.
	
	## Returns
	
	          Transient storage for messages in progress.
	
	## Reference
	
	[p8est_ghost.h:316](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:316:25)
	""" p8est_ghost_exchange_custom_begin
	export p8est_ghost_exchange_custom_begin
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid
	```
	
	 Complete an asynchronous ghost data exchange. This function waits for all pending MPI communications. 
	
	## Parameters
	
	  * `Data`: created ONLY by p8est_ghost_exchange_custom_begin.                  It is deallocated before this function returns.
	
	## Reference
	
	[p8est_ghost.h:325](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:325:21)
	""" p8est_ghost_exchange_custom_end
	export p8est_ghost_exchange_custom_end
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Transfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. This function restricts the transfer to a range of refinement levels. The memory for quadrants outside the level range is not dereferenced. 
	
	## Parameters
	
	  * `p8est`:            The forest used for reference.
	  * `ghost`:            The ghost layer used for reference.
	  * `minlevel`:         Level of the largest quads to be exchanged.                              Use <= 0 for no restriction.
	  * `maxlevel`:         Level of the smallest quads to be exchanged.                              Use >= P8EST_QMAXLEVEL for no restriction.
	  * `data_size`:        The data size to transfer per quadrant.
	  * `mirror_data`:      One data pointer per mirror quadrant as input.
	  * `ghost_data`:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least `data_size` for each ghost.
	
	## Reference
	
	[p8est_ghost.h:344](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:344:21)
	""" p8est_ghost_exchange_custom_levels
	export p8est_ghost_exchange_custom_levels
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}
	```
	
	 Begin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8est_ghost_exchange_custom_levels. The return type is always non-NULL and must be passed to p8est_ghost_exchange_custom_levels_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. 
	
	## Parameters
	
	  * `mirror_data`: Not required to stay alive any longer.
	  * `ghost_data`:  Must stay alive into the completion call.
	
	## Returns
	
	          Transient storage for messages in progress.
	
	## Reference
	
	[p8est_ghost.h:363](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:363:25)
	""" p8est_ghost_exchange_custom_levels_begin
	export p8est_ghost_exchange_custom_levels_begin
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid
	```
	
	 Complete an asynchronous ghost data exchange. This function waits for all pending MPI communications. 
	
	## Parameters
	
	  * `exc`: created ONLY by p8est_ghost_exchange_custom_levels_begin.                  It is deallocated before this function returns.
	
	## Reference
	
	[p8est_ghost.h:372](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:372:21)
	""" p8est_ghost_exchange_custom_levels_end
	export p8est_ghost_exchange_custom_levels_end
	𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_expand(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Expand the size of the ghost layer and mirrors by one additional layer of adjacency. 
	
	## Parameters
	
	  * `p8est`:            The forest from which the ghost layer was                              generated.
	  * `ghost`:        The ghost layer to be expanded.
	
	## Reference
	
	[p8est_ghost.h:381](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_ghost.h:381:21)
	""" p8est_ghost_expand
	export p8est_ghost_expand
	𝐣𝐥.@cextern p8est_ghost_expand(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 This structure contains complete mesh information on a 2:1 balanced forest. It stores the locally relevant neighborhood, that is, all locally owned quadrants and one layer of adjacent ghost quadrants and their owners.
	
	## Details
	
	 For each local quadrant, its tree number is stored in quad_to_tree. The quad_to_tree array is NULL by default and can be enabled using p8est_mesh_new_ext. For each ghost quadrant, its owner rank is stored in ghost_to_proc. For each level, an array of local quadrant numbers is stored in quad_level. The quad_level array is NULL by default and can be enabled using p8est_mesh_new_ext.
	
	 The quad_to_quad list stores one value for each local quadrant's face. This value is in 0..local_num_quadrants-1 for local quadrants, or in local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
	
	 The quad_to_face list has equally many entries that are either: 1. A value of v = 0..23 indicates one same-size neighbor.    This value is decoded as v = r * 6 + nf, where nf = 0..5 is the    neighbor's connecting face number and r = 0..3 is the relative    orientation of the neighbor's face; see p8est_connectivity.h. 2. A value of v = 24..119 indicates a double-size neighbor.    This value is decoded as v = 24 + h * 24 + r * 6 + nf, where    r and nf are as above and h = 0..3 is the number of the subface.    h designates the subface of the large neighbor that the quadrant    touches (this is the same as the large neighbor's face corner). 3. A value of v = -24..-1 indicates four half-size neighbors.    In this case the corresponding quad_to_quad index points into the    quad_to_half array that stores four quadrant numbers per index,    and the orientation of the smaller faces follows from 24 + v.    The entries of quad_to_half encode between local and ghost quadrant    in the same way as the quad_to_quad values described above.    The small neighbors in quad_to_half are stored in the sequence    of the face corners of this, i.e., the large quadrant.
	
	 A quadrant on the boundary of the forest sees itself and its face number.
	
	 The quad_to_edge list stores edge neighbors that are not face neighbors. On the inside of a tree, there are one or two of those depending on size. Between trees, there can be any number of same- or different-sized neighbors. For same-tree same-size neighbors, we record their number in quad_to_edge by the same convention as described for quad_to_quad above.  In this case, the neighbor's matching edge number is always diagonally opposite, that is, edge number ^ 3.
	
	 For half- and double-size and all inter-tree edge neighbors, the quad_to_edge value is in    local_num_quadrants + local_num_ghosts + [0 .. local_num_edges - 1]. After subtracting the number of local and ghost quadrants, it indexes into edge_offset, which encodes a group of edge neighbors. Each member of a group may be one same/double-size quadrant or two half-size quadrants; this is determined by the value of the edge_edge field as follows. 1. A value of e = 0..23 indicates one same-size neighbor.    This value is encoded as e = r * 12 + ne, where ne = 0..11 is the    neighbor's connecting edge number and r = 0..1 indicates an edge flip. 2. A value of e = 24..71 indicates a double-size neighbor.    This value is decoded as e = 24 + h * 24 + r * 12 + ne, where    r and ne are as above and h = 0..1 is the number of the subedge.    h designates the subedge of the large neighbor that the quadrant    touches (this is the same as the large neighbor's edge corner). 3. A value of e = -24..-1 indicates two half-size neighbors.    They are represented by two consecutive entries of the edge_quad and    edge_edge arrays with identical values for edge_edge.    The orientation of the smaller edges follows from 24 + e.    The small neighbors in edge_quad are stored in the sequence    of the edge corners of this, i.e., the large quadrant.
	
	 Edges with no diagonal neighbor at all are assigned the value -3.  This only happens on the domain boundary, which is necessarily a tree boundary. Edge neighbors for face-hanging nodes are assigned the value -1.
	
	 The quad_to_corner list stores corner neighbors that are not face or edge neighbors.  On the inside of a tree, there is precisely one such neighbor per corner.  In this case, its index is encoded as described above for quad_to_quad.  The neighbor's matching corner number is always diagonally opposite, that is, corner number ^ 7.
	
	 On the inside of an inter-tree face, we have precisely one corner neighbor. If a corner is across an inter-tree edge or corner, then the number of corner neighbors may be any non-negative number.  In all three cases, the quad_to_corner value is in    local_num_quadrants + local_num_ghosts + [0 .. local_num_corners - 1]. After subtracting the number of local and ghost quadrants, it indexes into corner_offset, which encodes a group of corner neighbors. Each group contains the quadrant numbers encoded as usual for quad_to_quad in corner_quad, and the corner number from the neighbor as corner_corner.
	
	 Corners with no diagonal neighbor at all are assigned the value -3.  This only happens on the domain boundary, which is necessarily a tree boundary. Corner-neighbors for face- and edge-hanging nodes are assigned the value -1.
	
	 TODO: In case of an inter-tree neighbor relation in a brick-like       situation (one same-size neighbor, diagonally opposite edge/corner),       use the same encoding as for edges/corners within a tree.
	
	## Reference
	
	[p8est_mesh.h:168](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:168:1)
	""" p8est_mesh_t
	export p8est_mesh_t
	𝐣𝐥.@ctypedef p8est_mesh_t 𝐣𝐥.@cstruct {
		local_num_quadrants::p4est_locidx_t
		ghost_num_quadrants::p4est_locidx_t
		quad_to_tree::𝐣𝐥.Ptr{p4est_topidx_t}
		ghost_to_proc::𝐣𝐥.Ptr{𝐣𝐥.Cint}
		quad_to_quad::𝐣𝐥.Ptr{p4est_locidx_t}
		quad_to_face::𝐣𝐥.Ptr{int8_t}
		quad_to_half::𝐣𝐥.Ptr{sc_array_t}
		quad_level::𝐣𝐥.Ptr{sc_array_t}
		local_num_edges::p4est_locidx_t
		quad_to_edge::𝐣𝐥.Ptr{p4est_locidx_t}
		edge_offset::𝐣𝐥.Ptr{sc_array_t}
		edge_quad::𝐣𝐥.Ptr{sc_array_t}
		edge_edge::𝐣𝐥.Ptr{sc_array_t}
		local_num_corners::p4est_locidx_t
		quad_to_corner::𝐣𝐥.Ptr{p4est_locidx_t}
		corner_offset::𝐣𝐥.Ptr{sc_array_t}
		corner_quad::𝐣𝐥.Ptr{sc_array_t}
		corner_corner::𝐣𝐥.Ptr{sc_array_t}
	}
	
	𝐣𝐥.@doc """
	 This structure can be used as the status of a face neighbor iterator. It always contains the face and subface of the neighbor to be processed.
	
	## Reference
	
	[p8est_mesh.h:192](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:192:1)
	""" p8est_mesh_face_neighbor_t
	export p8est_mesh_face_neighbor_t
	𝐣𝐥.@ctypedef p8est_mesh_face_neighbor_t 𝐣𝐥.@cstruct {
		p4est::𝐣𝐥.Ptr{p8est_t}
		ghost::𝐣𝐥.Ptr{p8est_ghost_t}
		mesh::𝐣𝐥.Ptr{p8est_mesh_t}
		which_tree::p4est_topidx_t
		quadrant_id::p4est_locidx_t
		quadrant_code::p4est_locidx_t
		face::𝐣𝐥.Cint
		subface::𝐣𝐥.Cint
		current_qtq::p4est_locidx_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_memory_used(mesh::𝐣𝐥.Ptr{p8est_mesh_t})::size_t
	```
	
	 Calculate the memory usage of the mesh structure. 
	
	## Parameters
	
	  * `mesh`:     Mesh structure.
	
	## Returns
	
	              Memory used in bytes.
	
	## Reference
	
	[p8est_mesh.h:198](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:198:21)
	""" p8est_mesh_memory_used
	export p8est_mesh_memory_used
	𝐣𝐥.@cextern p8est_mesh_memory_used(mesh::𝐣𝐥.Ptr{p8est_mesh_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_new(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_mesh_t}
	```
	
	 Create a p8est_mesh structure. This function does not populate the quad_to_tree and quad_level fields. To populate them, use p8est_mesh_new_ext. 
	
	## Parameters
	
	  * `p8est`:    A forest that is fully 2:1 balanced.
	  * `ghost`:    The ghost layer created from the provided p4est.
	  * `btype`:    Determines the highest codimension of neighbors.
	
	## Returns
	
	              A fully allocated mesh structure.
	
	## Reference
	
	[p8est_mesh.h:208](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:208:21)
	""" p8est_mesh_new
	export p8est_mesh_new
	𝐣𝐥.@cextern p8est_mesh_new(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_mesh_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_destroy(mesh::𝐣𝐥.Ptr{p8est_mesh_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a p8est_mesh structure. 
	
	## Parameters
	
	  * `mesh`:     Mesh structure previously created by p8est_mesh_new.
	
	## Reference
	
	[p8est_mesh.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:214:21)
	""" p8est_mesh_destroy
	export p8est_mesh_destroy
	𝐣𝐥.@cextern p8est_mesh_destroy(mesh::𝐣𝐥.Ptr{p8est_mesh_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_get_quadrant(p4est::𝐣𝐥.Ptr{p8est_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, qid::p4est_locidx_t)::𝐣𝐥.Ptr{p8est_quadrant_t}
	```
	
	 Access a process-local quadrant inside a forest. Needs a mesh with populated quad_to_tree array. This is a special case of p8est_mesh_quadrant_cumulative.
	
	## Parameters
	
	  * `p4est`:  The forest.
	  * `mesh`:   The mesh.
	  * `qid`:    Process-local id of the quadrant (cumulative over trees).
	
	## Returns
	
	            A pointer to the requested quadrant.
	
	## Reference
	
	[p8est_mesh.h:225](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:225:21)
	""" p8est_mesh_get_quadrant
	export p8est_mesh_get_quadrant
	𝐣𝐥.@cextern p8est_mesh_get_quadrant(p4est::𝐣𝐥.Ptr{p8est_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, qid::p4est_locidx_t)::𝐣𝐥.Ptr{p8est_quadrant_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_get_neighbors(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, curr_quad_id::p4est_locidx_t, direction::p4est_locidx_t, neighboring_quads::𝐣𝐥.Ptr{sc_array_t}, neighboring_encs::𝐣𝐥.Ptr{sc_array_t}, neighboring_qids::𝐣𝐥.Ptr{sc_array_t})::p4est_locidx_t
	```
	
	 Lookup neighboring quads of quadrant in a specific direction 
	
	## Parameters
	
	  * `p4est`:              Forest to be worked with.
	  * `ghost`:              Ghost quadrants.
	  * `mesh`:               Mesh structure.
	  * `curr_quad_id`:       Process-local ID of current quad.
	  * `direction`:          Direction in which to look for adjacent                                 quadrants is encoded as follows:                                   0 ..  5 neighbor(-s) across f_i,                                   6 .. 17 neighbor(-s) across e_{i-6}                                  18 .. 25 neighbor(-s) across c_{i-18}
	  * `neighboring_quads`:  Array containing neighboring quad(-s)                                 Needs to be empty, contains                                 p4est_quadrant_t*. May be NULL, then neighboring_qids must not be NULL.
	  * `neighboring_encs`:   Array containing encodings for neighboring                                 quads as described below                                 Needs to be empty, contains int. CAUTION: Note, that the encodings differ from the encodings saved in the          mesh.          Positive values are for local quadrants, negative values indicate          ghost quadrants.          Faces:     1 ..  24 => same size neighbor                                 (r * 6 + nf) + 1; nf = 0 .. 5 face index;                                 r = 0 .. 3 relative orientation                    25 .. 120 => double size neighbor                                 25 + h * 24 + r * 6 + nf; h = 0 .. 3 number                                 of the subface; r, nf as above                   121 .. 144 => half size neighbors                                 121 + r * 6 + nf; r, nf as above          Edges:     1 ..  24 => same size neighbor                                 r * 12 + ne + 1; ne = 0 .. 11 edge index;                                 r = 0 .. 1 relative orientation                    25 ..  72 => double size neighbor                                 25 + h * 24 + r * 12 + ne; h = 0 .. 1 number                                 of the subedge; r, ne as above                    73 ..  96 => half size neighbors                                 73 + r * 12 + ne; r, ne as above          Corners:   1 ..   8 => nc + 1; nc = 0 .. 7 corner index
	  * `neighboring_qids`:   Array containing quadrant ids for neighboring                                 quadrants. May be NULL, then no neighboring                                 qids are collected.                                 If non-NULL the array needs to be empty and                                 will contain int.
	
	## Reference
	
	[p8est_mesh.h:273](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:273:21)
	""" p8est_mesh_get_neighbors
	export p8est_mesh_get_neighbors
	𝐣𝐥.@cextern p8est_mesh_get_neighbors(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, curr_quad_id::p4est_locidx_t, direction::p4est_locidx_t, neighboring_quads::𝐣𝐥.Ptr{sc_array_t}, neighboring_encs::𝐣𝐥.Ptr{sc_array_t}, neighboring_qids::𝐣𝐥.Ptr{sc_array_t})::p4est_locidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_quadrant_cumulative(p8est::𝐣𝐥.Ptr{p8est_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, cumulative_id::p4est_locidx_t, which_tree::𝐣𝐥.Ptr{p4est_topidx_t}, quadrant_id::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Ptr{p8est_quadrant_t}
	```
	
	 Find a quadrant based on its cumulative number in the local forest. If the quad_to_tree field of the mesh structure exists, this is O(1). Otherwise, we perform a binary search over the processor-local trees.
	
	## Parameters
	
	  * `p8est`:           Forest to be worked with.
	  * `mesh`:            A mesh derived from the forest.
	  * `cumulative_id`:   Cumulative index over all trees of quadrant.                              Must refer to a local (non-ghost) quadrant.
	  * `which_tree`:   If not NULL, the input value can be -1                              or an initial guess for the quadrant's tree                              and output is the tree of returned quadrant.
	  * `quadrant_id`:     If not NULL, the number of quadrant in tree.
	
	## Returns
	
	                      The identified quadrant.
	
	## Reference
	
	[p8est_mesh.h:296](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:296:21)
	""" p8est_mesh_quadrant_cumulative
	export p8est_mesh_quadrant_cumulative
	𝐣𝐥.@cextern p8est_mesh_quadrant_cumulative(p8est::𝐣𝐥.Ptr{p8est_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, cumulative_id::p4est_locidx_t, which_tree::𝐣𝐥.Ptr{p4est_topidx_t}, quadrant_id::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Ptr{p8est_quadrant_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_init2(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, which_tree::p4est_topidx_t, quadrant_id::p4est_locidx_t)::𝐣𝐥.Cvoid
	```
	
	 Initialize a mesh neighbor iterator by quadrant index. 
	
	## Parameters
	
	  * `mfn`:         A p8est_mesh_face_neighbor_t to be initialized.
	  * `which_tree`:  Tree of quadrant whose neighbors are looped over.
	  * `quadrant_id`: Index relative to which_tree of quadrant.
	
	## Reference
	
	[p8est_mesh.h:310](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:310:21)
	""" p8est_mesh_face_neighbor_init2
	export p8est_mesh_face_neighbor_init2
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_init2(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, which_tree::p4est_topidx_t, quadrant_id::p4est_locidx_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_init(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, which_tree::p4est_topidx_t, quadrant::𝐣𝐥.Ptr{p8est_quadrant_t})::𝐣𝐥.Cvoid
	```
	
	 Initialize a mesh neighbor iterator by quadrant pointer. 
	
	## Parameters
	
	  * `mfn`:         A p8est_mesh_face_neighbor_t to be initialized.
	  * `which_tree`:  Tree of quadrant whose neighbors are looped over.
	  * `quadrant`:    Pointer to quadrant contained in which_tree.
	
	## Reference
	
	[p8est_mesh.h:323](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:323:21)
	""" p8est_mesh_face_neighbor_init
	export p8est_mesh_face_neighbor_init
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_init(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, which_tree::p4est_topidx_t, quadrant::𝐣𝐥.Ptr{p8est_quadrant_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_next(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, ntree::𝐣𝐥.Ptr{p4est_topidx_t}, nquad::𝐣𝐥.Ptr{p4est_locidx_t}, nface::𝐣𝐥.Ptr{𝐣𝐥.Cint}, nrank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Ptr{p8est_quadrant_t}
	```
	
	 Move the iterator forward to loop around neighbors of the quadrant. 
	
	## Parameters
	
	  * `mfn`:      Internal status of the iterator.
	  * `ntree`:    If not NULL, the tree number of the neighbor.
	  * `nquad`:    If not NULL, the quadrant number within tree.                          For ghosts instead the number in ghost layer.
	  * `nface`:    If not NULL, neighbor's face as in p8est_mesh_t.
	  * `nrank`:    If not NULL, the owner process of the neighbor.
	
	## Returns
	
	                  Either a real quadrant or one from the ghost layer.                          Returns NULL when the iterator is done.
	
	## Reference
	
	[p8est_mesh.h:341](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:341:21)
	""" p8est_mesh_face_neighbor_next
	export p8est_mesh_face_neighbor_next
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_next(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, ntree::𝐣𝐥.Ptr{p4est_topidx_t}, nquad::𝐣𝐥.Ptr{p4est_locidx_t}, nface::𝐣𝐥.Ptr{𝐣𝐥.Cint}, nrank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Ptr{p8est_quadrant_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_data(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Get the user data for the current face neighbor. 
	
	## Parameters
	
	  * `mfn`:           Internal status of the iterator.
	  * `ghost_data`:    Data for the ghost quadrants that has been                               synchronized with p4est_ghost_exchange_data.
	
	## Returns
	
	                       A pointer to the user data for the current                               neighbor.
	
	## Reference
	
	[p8est_mesh.h:354](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_mesh.h:354:21)
	""" p8est_mesh_face_neighbor_data
	export p8est_mesh_face_neighbor_data
	𝐣𝐥.@cextern p8est_mesh_face_neighbor_data(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p8est_iter_volume_t callback function.
	
	## Details
	
	 *treeid* gives the index in *p4est->trees* of the tree to which    *quad* belongs. *quadid* gives the index of *quad* within *tree's* quadrants array.
	
	## Reference
	
	[p8est_iterate.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:56:1)
	""" p8est_iter_volume_info_t
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p8est_iter_volume_t callback function.
	
	## Details
	
	 *treeid* gives the index in *p4est->trees* of the tree to which    *quad* belongs. *quadid* gives the index of *quad* within *tree's* quadrants array.
	
	## Reference
	
	[p8est_iterate.h:47](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:47:16)
	""" p8est_iter_volume_info
	export p8est_iter_volume_info, p8est_iter_volume_info_t
	𝐣𝐥.@ctypedef p8est_iter_volume_info_t 𝐣𝐥.@cstruct p8est_iter_volume_info {
		p4est::𝐣𝐥.Ptr{p8est_t}
		ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}
		quad::𝐣𝐥.Ptr{p8est_quadrant_t}
		quadid::p4est_locidx_t
		treeid::p4est_topidx_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p8est_iterate() will execute at every quadrant local to the current process. 
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p8est_iterate()
	
	## Reference
	
	[p8est_iterate.h:63](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:63:23)
	""" p8est_iter_volume_t
	export p8est_iter_volume_t
	𝐣𝐥.@ctypedef p8est_iter_volume_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_iter_volume_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Information about one side of a face in the forest.  If a *quad* is local (*is_ghost* is false), then its *quadid* indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.
	
	## Reference
	
	[p8est_iterate.h:73](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:73:16)
	""" p8est_iter_face_side
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_iterate.h:80](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:80:9)
	""" p8est_iter_face_side_data
	𝐣𝐥.@doc """
	 Information about one side of a face in the forest.  If a *quad* is local (*is_ghost* is false), then its *quadid* indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.
	
	## Reference
	
	[p8est_iterate.h:101](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:101:1)
	""" p8est_iter_face_side_t
	export p8est_iter_face_side, p8est_iter_face_side_data, p8est_iter_face_side_t
	𝐣𝐥.@ctypedef p8est_iter_face_side_t 𝐣𝐥.@cstruct p8est_iter_face_side {
		treeid::p4est_topidx_t
		face::int8_t
		is_hanging::int8_t
		is::𝐣𝐥.@cunion p8est_iter_face_side_data {
			full::𝐣𝐥.@cstruct {
				is_ghost::int8_t
				quad::𝐣𝐥.Ptr{p8est_quadrant_t}
				quadid::p4est_locidx_t
			}
			hanging::𝐣𝐥.@cstruct {
				is_ghost::int8_t[4]
				quad::𝐣𝐥.Ptr{p8est_quadrant_t}[4]
				quadid::p4est_locidx_t[4]
			}
		}
	}
	
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p8est_iter_face_t callback.
	
	## Details
	
	 The orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside of the forest, then there is only one side.  If tree_boundary is false, the face is on the interior of a tree.  When tree_boundary false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P8EST_CONNECT_FACE.
	
	## Reference
	
	[p8est_iterate.h:125](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:125:1)
	""" p8est_iter_face_info_t
	𝐣𝐥.@doc """
	 The information that is available to the user-defined p8est_iter_face_t callback.
	
	## Details
	
	 The orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside of the forest, then there is only one side.  If tree_boundary is false, the face is on the interior of a tree.  When tree_boundary false, sides[0] contains the lowest z-order quadrant that touches the face. When tree_boundary is true, its value is P8EST_CONNECT_FACE.
	
	## Reference
	
	[p8est_iterate.h:114](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:114:16)
	""" p8est_iter_face_info
	export p8est_iter_face_info, p8est_iter_face_info_t
	𝐣𝐥.@ctypedef p8est_iter_face_info_t 𝐣𝐥.@cstruct p8est_iter_face_info {
		p4est::𝐣𝐥.Ptr{p8est_t}
		ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}
		orientation::int8_t
		tree_boundary::int8_t
		sides::sc_array_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p8est_iterate() will execute wherever two quadrants share a face: the face can be a 2:1 hanging face, it does not have to be conformal.
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p8est_iterate()
	
	NOTE: the forest must be face balanced for p8est_iterate() to execute a callback function on faces (see p8est_balance()).
	
	## Reference
	
	[p8est_iterate.h:137](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:137:23)
	""" p8est_iter_face_t
	export p8est_iter_face_t
	𝐣𝐥.@ctypedef p8est_iter_face_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_iter_face_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_iterate.h:166](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:166:9)
	""" p8est_iter_edge_side_data
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_iterate.h:189](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:189:1)
	""" p8est_iter_edge_side_t
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_iterate.h:155](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:155:16)
	""" p8est_iter_edge_side
	export p8est_iter_edge_side, p8est_iter_edge_side_data, p8est_iter_edge_side_t
	𝐣𝐥.@ctypedef p8est_iter_edge_side_t 𝐣𝐥.@cstruct p8est_iter_edge_side {
		treeid::p4est_topidx_t
		edge::int8_t
		orientation::int8_t
		is_hanging::int8_t
		is::𝐣𝐥.@cunion p8est_iter_edge_side_data {
			full::𝐣𝐥.@cstruct {
				is_ghost::int8_t
				quad::𝐣𝐥.Ptr{p8est_quadrant_t}
				quadid::p4est_locidx_t
			}
			hanging::𝐣𝐥.@cstruct {
				is_ghost::int8_t[2]
				quad::𝐣𝐥.Ptr{p8est_quadrant_t}[2]
				quadid::p4est_locidx_t[2]
			}
		}
		faces::int8_t[2]
	}
	
	𝐣𝐥.@doc """
	 The information about all sides of an edge in the forest. If tree_boundary is false, the edge is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the edge. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE depending on the location of the edge relative to the tree.
	
	## Reference
	
	[p8est_iterate.h:198](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:198:16)
	""" p8est_iter_edge_info
	𝐣𝐥.@doc """
	 The information about all sides of an edge in the forest. If tree_boundary is false, the edge is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the edge. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE depending on the location of the edge relative to the tree.
	
	## Reference
	
	[p8est_iterate.h:206](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:206:1)
	""" p8est_iter_edge_info_t
	export p8est_iter_edge_info, p8est_iter_edge_info_t
	𝐣𝐥.@ctypedef p8est_iter_edge_info_t 𝐣𝐥.@cstruct p8est_iter_edge_info {
		p4est::𝐣𝐥.Ptr{p8est_t}
		ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}
		tree_boundary::int8_t
		sides::sc_array_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p8est_iterate will execute wherever the edge is an edge of all quadrants that touch it i.e. the callback will not execute on an edge the sits on a hanging face.
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p8est_iterate()
	
	NOTE: the forest must be edge balanced for p8est_iterate() to execute a callback function on edges.
	
	## Reference
	
	[p8est_iterate.h:218](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:218:23)
	""" p8est_iter_edge_t
	export p8est_iter_edge_t
	𝐣𝐥.@ctypedef p8est_iter_edge_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_iter_edge_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_iterate.h:241](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:241:1)
	""" p8est_iter_corner_side_t
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_iterate.h:230](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:230:16)
	""" p8est_iter_corner_side
	export p8est_iter_corner_side, p8est_iter_corner_side_t
	𝐣𝐥.@ctypedef p8est_iter_corner_side_t 𝐣𝐥.@cstruct p8est_iter_corner_side {
		treeid::p4est_topidx_t
		corner::int8_t
		is_ghost::int8_t
		quad::𝐣𝐥.Ptr{p8est_quadrant_t}
		quadid::p4est_locidx_t
		faces::int8_t[3]
		edges::int8_t[3]
	}
	
	𝐣𝐥.@doc """
	 The information that is availalbe to the user-defined p8est_iter_corner_t callback.
	
	## Details
	
	 If tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE/CORNER depending on the location of the corner relative to the tree.
	
	## Reference
	
	[p8est_iterate.h:252](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:252:16)
	""" p8est_iter_corner_info
	𝐣𝐥.@doc """
	 The information that is availalbe to the user-defined p8est_iter_corner_t callback.
	
	## Details
	
	 If tree_boundary is false, the corner is on the interior of a tree. When tree_boundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When tree_boundary is true, its value is P8EST_CONNECT_FACE/EDGE/CORNER depending on the location of the corner relative to the tree.
	
	## Reference
	
	[p8est_iterate.h:260](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:260:1)
	""" p8est_iter_corner_info_t
	export p8est_iter_corner_info, p8est_iter_corner_info_t
	𝐣𝐥.@ctypedef p8est_iter_corner_info_t 𝐣𝐥.@cstruct p8est_iter_corner_info {
		p4est::𝐣𝐥.Ptr{p8est_t}
		ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}
		tree_boundary::int8_t
		sides::sc_array_t
	}
	
	𝐣𝐥.@doc """
	 The prototype for a function that p8est_iterate will execute wherever the corner is a corner for all quadrants that touch it
	
	## Details
	
	 i.e. the callback will not execute on a corner that sits on a hanging face or edge.
	
	## Parameters
	
	  * `info`:          information about a quadrant provided to the user
	  * `user_data`: the user context passed to p8est_iterate()
	
	NOTE: the forest does not need to be corner balanced for p8est_iterate() to execute a callback function at corners, only face and edge balanced.
	
	## Reference
	
	[p8est_iterate.h:274](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:274:23)
	""" p8est_iter_corner_t
	export p8est_iter_corner_t
	𝐣𝐥.@ctypedef p8est_iter_corner_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_iter_corner_info_t}, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_iterate(p4est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p8est_iter_volume_t, iter_face::p8est_iter_face_t, iter_edge::p8est_iter_edge_t, iter_corner::p8est_iter_corner_t)::𝐣𝐥.Cvoid
	```
	
	 Execute the user-supplied callback functions at every volume, face, edge and corner in the local forest.
	
	## Details
	
	 The ghost_layer may be NULL. The *user_data* pointer is not touched by p8est_iterate, but is passed to each of the callbacks. Any of the callback functions may be NULL.  The callback functions are interspersed with each other, i.e. some face callbacks will occur between volume callbacks, and some edge callbacks will occur between face callbacks, etc.:
	
	 1) volume callbacks occur in the sorted Morton-index order. 2) a face callback is not executed until after the volume callbacks have    been executed for the quadrants that share it. 3) an edge callback is not executed until the face callbacks have been    executed for all faces that touch the edge. 4) a corner callback is not executed until the edge callbacks have been    executed for all edges that touch the corner. 5) it is not always the case that every face callback for a given quadrant    is executed before any of the edge or corner callbacks, and it is not    always the case that every edge callback for a given quadrant is executed    before any of the corner callbacks. 6) callbacks are not executed at faces, edges or corners that only involve    ghost quadrants, i.e. that are not adjacent in the local section of the    forest.
	
	## Parameters
	
	  * `p4est`:          the forest
	  * `ghost_layer`:    optional: when not given, callbacks at the                           boundaries of the local partition cannot provide                           quadrant data about ghost quadrants: missing                           (p8est_quadrant_t *) pointers are set to NULL,                           missing indices are set to -1.
	  * `user_data`:  optional context to supply to each callback
	  * `iter_volume`:    callback function for every quadrant's interior
	  * `iter_face`:      callback function for every face between                           quadrants
	  * `iter_edge`:      callback function for every edge between                           quadrants
	  * `iter_corner`:    callback function for every corner between                           quadrants
	
	## Reference
	
	[p8est_iterate.h:316](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_iterate.h:316:21)
	""" p8est_iterate
	export p8est_iterate
	𝐣𝐥.@cextern p8est_iterate(p4est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p8est_iter_volume_t, iter_face::p8est_iter_face_t, iter_edge::p8est_iter_edge_t, iter_corner::p8est_iter_corner_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_lnodes.h:33](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:33:21)
	""" p8est_lnodes_code_t
	export p8est_lnodes_code_t
	𝐣𝐥.@ctypedef p8est_lnodes_code_t int16_t
	
	𝐣𝐥.@doc """
	 Store a parallel numbering of Lobatto points of a given degree > 0.
	
	## Details
	
	 Each element has degree+1 nodes per edge and vnodes = (degree+1)^3 nodes per volume. element_nodes is of dimension vnodes * num_local_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); element_nodes indexes into the set of local nodes, layed out as follows: local nodes = [<-----owned_count----->|<-----nonlocal_nodes----->]             = [<----------------num_local_nodes----------------->] nonlocal_nodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.
	
	 Whether nodes are hanging or not is decided based on the element faces and edges. This information is encoded in face_code with one int16_t per element. If no faces or edges are hanging, the value is zero, otherwise the face_code is interpreted by p8est_lnodes_decode.
	
	 Independent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree *touching* the node.
	
	 What is meant by *touching*? A quadrant is said to touch all faces/edges/corners that are incident on it, and by extension all nodes that are contained in those faces/edges/corners.
	
	            X      +-----------+             x     |\\           \\            x      | \\           \\             . x   |  \\           \\            x   X  |   +-----------+ +-----+     . .   |   |           | |\\     \\   X   o  +   |           | | +-----+   o .    \\  |     p     | + |  q  |      o    \\ |           |  \\|     |     o      \\|           |   +-----+      O      +-----------+
	
	 In this example degree = 3.  There are 4 nodes that live on the face between q and p, two on each edge and one at each corner of that face. The face is incident on q, so q owns the nodes marked '.' on the face (provided q is from a lower tree or has a lower index than p). The bottom and front edges are incident on q, so q owns its nodes marked 'o' as well. The front lower corner is incident on q, so q owns its node 'O' as well.  The other edges and corners are not incident on q, so q cannot own their nodes, marked 'x' and 'X'.
	
	 global_owned_count contains the number of independent nodes owned by each process.
	
	 The sharers array contains items of type p8est_lnodes_rank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.
	
	 degree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces, edge  and corners) rather than the \$C^0\$ Lobatto nodes:
	
	 if degree == -1, then one node is assigned per face, and no nodes are assigned per volume, per edge,  or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 6, and the nodes are listed in face-order.
	
	 if degree == -2, then one node is assigned per face and per edge and no nodes are assigned per volume or per corner.  In this case, vnodes == 18, and the nodes are listed in face-order, followed by edge-order.
	
	 if degree == -3, then one node is assigned per face, per edge and per corner and no nodes are assigned per volume.  In this case, vnodes == 26, and the nodes are listed in face-order, followed by edge-order, followed by corner-order.
	
	## Reference
	
	[p8est_lnodes.h:112](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:112:16)
	""" p8est_lnodes
	𝐣𝐥.@doc """
	 Store a parallel numbering of Lobatto points of a given degree > 0.
	
	## Details
	
	 Each element has degree+1 nodes per edge and vnodes = (degree+1)^3 nodes per volume. element_nodes is of dimension vnodes * num_local_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); element_nodes indexes into the set of local nodes, layed out as follows: local nodes = [<-----owned_count----->|<-----nonlocal_nodes----->]             = [<----------------num_local_nodes----------------->] nonlocal_nodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.
	
	 Whether nodes are hanging or not is decided based on the element faces and edges. This information is encoded in face_code with one int16_t per element. If no faces or edges are hanging, the value is zero, otherwise the face_code is interpreted by p8est_lnodes_decode.
	
	 Independent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree *touching* the node.
	
	 What is meant by *touching*? A quadrant is said to touch all faces/edges/corners that are incident on it, and by extension all nodes that are contained in those faces/edges/corners.
	
	            X      +-----------+             x     |\\           \\            x      | \\           \\             . x   |  \\           \\            x   X  |   +-----------+ +-----+     . .   |   |           | |\\     \\   X   o  +   |           | | +-----+   o .    \\  |     p     | + |  q  |      o    \\ |           |  \\|     |     o      \\|           |   +-----+      O      +-----------+
	
	 In this example degree = 3.  There are 4 nodes that live on the face between q and p, two on each edge and one at each corner of that face. The face is incident on q, so q owns the nodes marked '.' on the face (provided q is from a lower tree or has a lower index than p). The bottom and front edges are incident on q, so q owns its nodes marked 'o' as well. The front lower corner is incident on q, so q owns its node 'O' as well.  The other edges and corners are not incident on q, so q cannot own their nodes, marked 'x' and 'X'.
	
	 global_owned_count contains the number of independent nodes owned by each process.
	
	 The sharers array contains items of type p8est_lnodes_rank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.
	
	 degree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces, edge  and corners) rather than the \$C^0\$ Lobatto nodes:
	
	 if degree == -1, then one node is assigned per face, and no nodes are assigned per volume, per edge,  or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 6, and the nodes are listed in face-order.
	
	 if degree == -2, then one node is assigned per face and per edge and no nodes are assigned per volume or per corner.  In this case, vnodes == 18, and the nodes are listed in face-order, followed by edge-order.
	
	 if degree == -3, then one node is assigned per face, per edge and per corner and no nodes are assigned per volume.  In this case, vnodes == 26, and the nodes are listed in face-order, followed by edge-order, followed by corner-order.
	
	## Reference
	
	[p8est_lnodes.h:127](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:127:1)
	""" p8est_lnodes_t
	export p8est_lnodes, p8est_lnodes_t
	𝐣𝐥.@ctypedef p8est_lnodes_t 𝐣𝐥.@cstruct p8est_lnodes {
		mpicomm::sc_MPI_Comm
		num_local_nodes::p4est_locidx_t
		owned_count::p4est_locidx_t
		global_offset::p4est_gloidx_t
		nonlocal_nodes::𝐣𝐥.Ptr{p4est_gloidx_t}
		sharers::𝐣𝐥.Ptr{sc_array_t}
		global_owned_count::𝐣𝐥.Ptr{p4est_locidx_t}
		(degree, vnodes)::𝐣𝐥.Cint
		num_local_elements::p4est_locidx_t
		face_code::𝐣𝐥.Ptr{p8est_lnodes_code_t}
		element_nodes::𝐣𝐥.Ptr{p4est_locidx_t}
	}
	
	𝐣𝐥.@doc """
	 The structure stored in the sharers array.
	
	## Details
	
	 shared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes.  The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p8est_lnodes_t.
	
	## Reference
	
	[p8est_lnodes.h:140](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:140:16)
	""" p8est_lnodes_rank
	𝐣𝐥.@doc """
	 The structure stored in the sharers array.
	
	## Details
	
	 shared_nodes is a sorted array of p4est_locidx_t that indexes into local nodes.  The shared_nodes array has a contiguous (or empty) section of nodes owned by the current rank. shared_mine_offset and shared_mine_count identify this section by indexing the shared_nodes array, not the local nodes array. owned_offset and owned_count define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p8est_lnodes_t.
	
	## Reference
	
	[p8est_lnodes.h:147](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:147:1)
	""" p8est_lnodes_rank_t
	export p8est_lnodes_rank, p8est_lnodes_rank_t
	𝐣𝐥.@ctypedef p8est_lnodes_rank_t 𝐣𝐥.@cstruct p8est_lnodes_rank {
		rank::𝐣𝐥.Cint
		shared_nodes::sc_array_t
		(shared_mine_offset, shared_mine_count)::p4est_locidx_t
		(owned_offset, owned_count)::p4est_locidx_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_new(p8est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, degree::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_lnodes_t}
	```
	
	## Reference
	
	[p8est_lnodes.h:248](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:248:21)
	""" p8est_lnodes_new
	export p8est_lnodes_new
	𝐣𝐥.@cextern p8est_lnodes_new(p8est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, degree::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_lnodes_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_destroy(lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p8est_lnodes.h:252](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:252:21)
	""" p8est_lnodes_destroy
	export p8est_lnodes_destroy
	𝐣𝐥.@cextern p8est_lnodes_destroy(lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_partition_lnodes(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, degree::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Partition using weights based on the number of nodes assigned to each element in lnodes
	
	## Parameters
	
	  * `p8est`:                    the forest to be repartitioned
	  * `ghost`:                    the ghost layer
	  * `degree`:                   the degree that would be passed to p8est_lnodes_new()
	  * `partition_for_coarsening`: whether the partition should allow                                         coarsening (i.e. group siblings who                                         might merge)
	
	## Reference
	
	[p8est_lnodes.h:264](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:264:21)
	""" p8est_partition_lnodes
	export p8est_partition_lnodes
	𝐣𝐥.@cextern p8est_partition_lnodes(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, degree::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_partition_lnodes_detailed(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, nodes_per_volume::𝐣𝐥.Cint, nodes_per_face::𝐣𝐥.Cint, nodes_per_edge::𝐣𝐥.Cint, nodes_per_corner::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Partition using weights that are broken down by where they reside: in volumes, on faces, on edges, or on corners.
	
	## Reference
	
	[p8est_lnodes.h:271](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:271:21)
	""" p8est_partition_lnodes_detailed
	export p8est_partition_lnodes_detailed
	𝐣𝐥.@cextern p8est_partition_lnodes_detailed(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, nodes_per_volume::𝐣𝐥.Cint, nodes_per_face::𝐣𝐥.Cint, nodes_per_edge::𝐣𝐥.Cint, nodes_per_corner::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_support_lnodes(p8est::𝐣𝐥.Ptr{p8est_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Expand the ghost layer to include the support of all nodes supported on the local partition.
	
	## Parameters
	
	  * `p8est`:        The forest from which the ghost layer was                              generated.
	  * `lnodes`:       The nodes to support.
	  * `ghost`:        The ghost layer to be expanded.
	
	## Reference
	
	[p8est_lnodes.h:288](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:288:21)
	""" p8est_ghost_support_lnodes
	export p8est_ghost_support_lnodes
	𝐣𝐥.@cextern p8est_ghost_support_lnodes(p8est::𝐣𝐥.Ptr{p8est_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_ghost_expand_by_lnodes(p4est::𝐣𝐥.Ptr{p8est_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	```
	
	 Expand the ghost layer as in p8est_ghost_expand(), but use node support to define adjacency instead of geometric adjacency.
	
	## Parameters
	
	  * `p8est`:        The forest from which the ghost layer was                              generated.
	  * `lnodes`:       The nodes to support.
	  * `ghost`:        The ghost layer to be expanded.
	
	## Reference
	
	[p8est_lnodes.h:300](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:300:21)
	""" p8est_ghost_expand_by_lnodes
	export p8est_ghost_expand_by_lnodes
	𝐣𝐥.@cextern p8est_ghost_expand_by_lnodes(p4est::𝐣𝐥.Ptr{p8est_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 p8est_lnodes_buffer_t handles the communication of data associated with nodes.
	
	## Details
	
	 *send_buffers* is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared_*_begin and a shared_*_end call.
	
	 *recv_buffers* is an array of arrays that is used in lnodes_share_all_*. *recv_buffers[j]* corresponds with lnodes->sharers[j]: it is the same length as *lnodes->sharers[j]->shared_nodes.*  At the completion of lnodes_share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).
	
	## Reference
	
	[p8est_lnodes.h:324](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:324:1)
	""" p8est_lnodes_buffer_t
	𝐣𝐥.@doc """
	 p8est_lnodes_buffer_t handles the communication of data associated with nodes.
	
	## Details
	
	 *send_buffers* is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared_*_begin and a shared_*_end call.
	
	 *recv_buffers* is an array of arrays that is used in lnodes_share_all_*. *recv_buffers[j]* corresponds with lnodes->sharers[j]: it is the same length as *lnodes->sharers[j]->shared_nodes.*  At the completion of lnodes_share_all or lnodes_share_all_end, recv_buffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).
	
	## Reference
	
	[p8est_lnodes.h:318](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:318:16)
	""" p8est_lnodes_buffer
	export p8est_lnodes_buffer, p8est_lnodes_buffer_t
	𝐣𝐥.@ctypedef p8est_lnodes_buffer_t 𝐣𝐥.@cstruct p8est_lnodes_buffer {
		requests::𝐣𝐥.Ptr{sc_array_t}
		send_buffers::𝐣𝐥.Ptr{sc_array_t}
		recv_buffers::𝐣𝐥.Ptr{sc_array_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_share_owned_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}
	```
	
	 p8est_lnodes_share_owned_begin
	
	## Details
	
	 *node_data* is a user-defined array of arbitrary type, where each entry is associated with the *lnodes* local nodes entry of matching index. For every local nodes entry that is owned by a process other than the current one, the value in the *node_data* array of the owning process is written directly into the *node_data* array of the current process.  Values of *node_data* are not guaranteed to be sent or received until the *buffer* created by p8est_lnodes_share_owned_begin is passed to p8est_lnodes_share_owned_end.
	
	 To be memory neutral, the *buffer* created by p8est_lnodes_share_owned_begin must be destroying with p8est_lnodes_buffer_destroy (it is not destroyed by p8est_lnodes_share_owned_end).
	
	## Reference
	
	[p8est_lnodes.h:342](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:342:24)
	""" p8est_lnodes_share_owned_begin
	export p8est_lnodes_share_owned_begin
	𝐣𝐥.@cextern p8est_lnodes_share_owned_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_share_owned_end(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p8est_lnodes.h:346](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:346:21)
	""" p8est_lnodes_share_owned_end
	export p8est_lnodes_share_owned_end
	𝐣𝐥.@cextern p8est_lnodes_share_owned_end(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_share_owned(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Cvoid
	```
	
	 Equivalent to calling p8est_lnodes_share_owned_end directly after p8est_lnodes_share_owned_begin.  Use if there is no local work that can be done to mask the communication cost.
	
	## Reference
	
	[p8est_lnodes.h:353](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:353:21)
	""" p8est_lnodes_share_owned
	export p8est_lnodes_share_owned
	𝐣𝐥.@cextern p8est_lnodes_share_owned(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_share_all_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}
	```
	
	 p8est_lnodes_share_all_begin
	
	## Details
	
	 *node_data* is a user_defined array of arbitrary type, where each entry is associated with the *lnodes* local nodes entry of matching index. For every process that shares an entry with the current one, the value in the *node_data* array of that process is written into a *buffer->recv_buffers* entry as described above.  The user can then perform some arbitrary work that requires the data from all processes that share a node (such as reduce, max, min, etc.).  When the work concludes, the *buffer* should be destroyed with p8est_lnodes_buffer_destroy.
	
	 Values of *node_data* are not guaranteed to be send, and *buffer->recv_buffer* entries are not guaranteed to be received until the *buffer* created by p8est_lnodes_share_all_begin is passed to p8est_lnodes_share_all_end.
	
	## Reference
	
	[p8est_lnodes.h:372](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:372:24)
	""" p8est_lnodes_share_all_begin
	export p8est_lnodes_share_all_begin
	𝐣𝐥.@cextern p8est_lnodes_share_all_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_share_all_end(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p8est_lnodes.h:375](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:375:21)
	""" p8est_lnodes_share_all_end
	export p8est_lnodes_share_all_end
	𝐣𝐥.@cextern p8est_lnodes_share_all_end(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_share_all(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}
	```
	
	 Equivalend to calling p8est_lnodes_share_all_end directly after p8est_lnodes_share_all_begin.  Use if there is no local work that can be done to mask the communication cost. 
	
	## Returns
	
	          A fully initialized buffer that contains the received data.                  After processing this data, the buffer must be freed with                  p8est_lnodes_buffer_destroy.
	
	## Reference
	
	[p8est_lnodes.h:385](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:385:24)
	""" p8est_lnodes_share_all
	export p8est_lnodes_share_all
	𝐣𝐥.@cextern p8est_lnodes_share_all(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lnodes_buffer_destroy(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p8est_lnodes.h:388](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_lnodes.h:388:21)
	""" p8est_lnodes_buffer_destroy
	export p8est_lnodes_buffer_destroy
	𝐣𝐥.@cextern p8est_lnodes_buffer_destroy(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 An unsigned 128 bit integer represented as two uint64_t. 
	
	## Reference
	
	[sc_uint128.h:49](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:49:1)
	""" sc_uint128_t
	𝐣𝐥.@doc """
	 An unsigned 128 bit integer represented as two uint64_t. 
	
	## Reference
	
	[sc_uint128.h:44](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:44:16)
	""" sc_uint128
	export sc_uint128, sc_uint128_t
	𝐣𝐥.@ctypedef sc_uint128_t 𝐣𝐥.@cstruct sc_uint128 {
		high_bits::uint64_t
		low_bits::uint64_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	 Compare the sc_uint128_t *a* and the sc_uint128_t *b.* 
	
	## Parameters
	
	  * `a`: A pointer to a sc_uint128_t.
	  * `b`: A pointer to a sc_uint128_t.
	
	## Returns
	
	        Returns -1 if a < b,                         1 if a > b and                         0 if a == b.
	
	## Reference
	
	[sc_uint128.h:58](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:58:21)
	""" sc_uint128_compare
	export sc_uint128_compare
	𝐣𝐥.@cextern sc_uint128_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cint
	```
	
	 Checks if the sc_uint128_t *a* and the sc_uint128_t *b* are equal. 
	
	## Parameters
	
	  * `a`: A pointer to a sc_uint128_t.
	  * `b`: A pointer to a sc_uint128_t.
	
	## Returns
	
	        Returns a true value if *a* and *b* are equal,                false otherwise.
	
	## Reference
	
	[sc_uint128.h:66](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:66:21)
	""" sc_uint128_is_equal
	export sc_uint128_is_equal
	𝐣𝐥.@cextern sc_uint128_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_init(a::𝐣𝐥.Ptr{sc_uint128_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an unsigned 128 bit integer to a given value. 
	
	## Parameters
	
	  * `a`:        A pointer to the sc_uint128_t that will be                          initialized.
	  * `high`:     The given high bits to initialize *a.*
	  * `low`:      The given low bits to initialize *a.*
	
	## Reference
	
	[sc_uint128.h:75](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:75:21)
	""" sc_uint128_init
	export sc_uint128_init
	𝐣𝐥.@cextern sc_uint128_init(a::𝐣𝐥.Ptr{sc_uint128_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Returns the bit_number-th bit of *input.* This function checks a bit of an existing, initialized value. 
	
	## Parameters
	
	  * `input`:      A pointer to a sc_uint128_t.
	  * `bit_number`: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= *bit_number* < 128.
	
	## Returns
	
	                    True if the checked bit is set, false if not.
	
	## Reference
	
	[sc_uint128.h:86](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:86:21)
	""" sc_uint128_chk_bit
	export sc_uint128_chk_bit
	𝐣𝐥.@cextern sc_uint128_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_set_bit(a::𝐣𝐥.Ptr{sc_uint128_t}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Sets the exponent-th bit of *a* to one and keep all other bits. This function modifies an existing, initialized value. 
	
	## Parameters
	
	  * `a`:        A pointer to a sc_uint128_t.
	  * `exponent`:      The bit (0-based from the rightmost bit)                          that is set to one by logical or.                          0 <= *exponent* < 128.
	
	## Reference
	
	[sc_uint128.h:96](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:96:21)
	""" sc_uint128_set_bit
	export sc_uint128_set_bit
	𝐣𝐥.@cextern sc_uint128_set_bit(a::𝐣𝐥.Ptr{sc_uint128_t}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, output::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Copies an initialized sc_uint128_t to a sc_uint128_t. 
	
	## Parameters
	
	  * `input`:    A pointer to the sc_uint128 that is copied.
	  * `output`:   A pointer to a sc_uint128_t.                          The high and low bits of *output* will                          be set to the high and low bits of                          *input,* respectively.
	
	## Reference
	
	[sc_uint128.h:105](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:105:21)
	""" sc_uint128_copy
	export sc_uint128_copy
	𝐣𝐥.@cextern sc_uint128_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, output::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Adds the uint128_t *b* to the uint128_t *a.* *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a sc_uint128_t.
	  * `b`:       A pointer to a sc_uint128_t.
	  * `result`:  A pointer to a sc_uint128_t.                      The sum *a* + *b* will be saved in *result.*
	
	## Reference
	
	[sc_uint128.h:116](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:116:21)
	""" sc_uint128_add
	export sc_uint128_add
	𝐣𝐥.@cextern sc_uint128_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Subtracts the uint128_t *b* from the uint128_t *a.* This function assumes that the result is >= 0. *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a sc_uint128_t.
	  * `b`:       A pointer to a sc_uint128_t.
	  * `result`:  A pointer to a sc_uint128_t.                      The difference *a* - *b* will be saved in *result.*
	
	## Reference
	
	[sc_uint128.h:129](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:129:21)
	""" sc_uint128_sub
	export sc_uint128_sub
	𝐣𝐥.@cextern sc_uint128_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise negation of the uint128_t *a.* *a* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a sc_uint128_t.
	  * `result`:   A pointer to a sc_uint128_t.                      The bitwise negation of *a* will be saved in                      *result.*
	
	## Reference
	
	[sc_uint128.h:140](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:140:21)
	""" sc_uint128_bitwise_neg
	export sc_uint128_bitwise_neg
	𝐣𝐥.@cextern sc_uint128_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a sc_uint128_t.
	  * `b`:        A pointer to a sc_uint128_t.
	  * `result`:   A pointer to a sc_uint128_t.                      The bitwise or of *a* and *b* will be                      saved in *result.*
	
	## Reference
	
	[sc_uint128.h:152](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:152:21)
	""" sc_uint128_bitwise_or
	export sc_uint128_bitwise_or
	𝐣𝐥.@cextern sc_uint128_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a sc_uint128_t.
	  * `b`:       A pointer to a sc_uint128_t.
	  * `result`:  A pointer to a sc_uint128_t.                      The bitwise and of *a* and *b* will be saved.                      in *result.*
	
	## Reference
	
	[sc_uint128.h:165](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:165:21)
	""" sc_uint128_bitwise_and
	export sc_uint128_bitwise_and
	𝐣𝐥.@cextern sc_uint128_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit right shift of uint128_t *input* by shift_count bits. We shift in zeros from the left. If *shift_count* >= 128, *result* is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a sc_uint128_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a sc_uint128_t.                              The right shifted number will be saved                              in *result.*
	
	## Reference
	
	[sc_uint128.h:179](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:179:21)
	""" sc_uint128_shift_right
	export sc_uint128_shift_right
	𝐣𝐥.@cextern sc_uint128_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit left shift of uint128_t *input* by shift_count bits. We shift in zeros from the right. If *shift_count* >= 128, *result* is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a sc_uint128_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a sc_uint128_t.                              The left shifted number will be saved                              in *result.*
	
	## Reference
	
	[sc_uint128.h:193](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:193:21)
	""" sc_uint128_shift_left
	export sc_uint128_shift_left
	𝐣𝐥.@cextern sc_uint128_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_add_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Adds the uint128 *b* to the uint128_t *a.* The result is saved in *a.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t. *a*                      will be overwritten by *a* + *b.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:203](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:203:21)
	""" sc_uint128_add_inplace
	export sc_uint128_add_inplace
	𝐣𝐥.@cextern sc_uint128_add_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_sub_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Subtracts the uint128_t *b* from the uint128_t *a.* The result is saved in *a.* *a* == *b* is allowed. This function assumes that the result is >= 0. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t.                      *a* will be overwritten by *a* - *b.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:213](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:213:21)
	""" sc_uint128_sub_inplace
	export sc_uint128_sub_inplace
	𝐣𝐥.@cextern sc_uint128_sub_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_or_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t.                      The bitwise or will be saved in *a.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:222](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:222:21)
	""" sc_uint128_bitwise_or_inplace
	export sc_uint128_bitwise_or_inplace
	𝐣𝐥.@cextern sc_uint128_bitwise_or_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_and_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t.                      The bitwise and will be saved in *a.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:231](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_uint128.h:231:21)
	""" sc_uint128_bitwise_and_inplace
	export sc_uint128_bitwise_and_inplace
	𝐣𝐥.@cextern sc_uint128_bitwise_and_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 A datatype to handle the linear id in 3D. We use the implementation of unsigned 128 bit integer in libsc, i.e., a struct with the members high_bits and low_bits (both uint64_t).
	
	## Reference
	
	[p8est_extended.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:56:22)
	""" p8est_lid_t
	export p8est_lid_t
	𝐣𝐥.@ctypedef p8est_lid_t sc_uint128_t
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_extended.h:66](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:66:8)
	""" p8est_inspect
	export p8est_inspect
	𝐣𝐥.@cstruct p8est_inspect {
		use_balance_ranges::𝐣𝐥.Cint
		use_balance_ranges_notify::𝐣𝐥.Cint
		use_balance_verify::𝐣𝐥.Cint
		balance_max_ranges::𝐣𝐥.Cint
		balance_A_count_in::size_t
		balance_A_count_out::size_t
		balance_comm_sent::size_t
		balance_comm_nzpeers::size_t
		balance_B_count_in::size_t
		balance_B_count_out::size_t
		(balance_zero_sends::_[2], balance_zero_receives::_[2])::size_t
		balance_A::𝐣𝐥.Cdouble
		balance_comm::𝐣𝐥.Cdouble
		balance_B::𝐣𝐥.Cdouble
		balance_ranges::𝐣𝐥.Cdouble
		balance_notify::𝐣𝐥.Cdouble
		balance_notify_allgather::𝐣𝐥.Cdouble
		use_B::𝐣𝐥.Cint
	}
	
	𝐣𝐥.@doc """
	 Callback function prototype to replace one set of quadrants with another.
	
	## Details
	
	 This is used by extended routines when the quadrants of an existing, valid p8est are changed.  The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.
	
	## Parameters
	
	  * `num_outgoing`: The number of outgoing quadrants.
	  * `outgoing`:     The outgoing quadrants: after the callback, the                          user_data, if *p8est->data_size* is nonzero,                          will be destroyed.
	  * `num_incoming`: The number of incoming quadrants.
	  * `incoming`: The incoming quadrants: prior to the callback,                          the user_data, if *p8est->data_size* is nonzero,                          is allocated, and the p8est_init_t callback,                          if it has been provided, will be called.
	
	 If the mesh is being refined, num_outgoing will be 1 and num_incoming will be 8, and vice versa if the mesh is being coarsened.
	
	## Reference
	
	[p8est_extended.h:114](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:114:23)
	""" p8est_replace_t
	export p8est_replace_t
	𝐣𝐥.@ctypedef p8est_replace_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{p8est_t}, p4est_topidx_t, 𝐣𝐥.Cint, 𝐣𝐥.Ptr{p8est_quadrant_t}[], 𝐣𝐥.Cint, 𝐣𝐥.Ptr{p8est_quadrant_t}[]}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cint
	```
	
	 Compare the p8est_lid_t *a* and the p8est_lid_t *b.* 
	
	## Parameters
	
	  * `a`: A pointer to a p8est_lid_t.
	  * `b`: A pointer to a p8est_lid_t.
	
	## Returns
	
	        Returns -1 if a < b,                         1 if a > b and                         0 if a == b.
	
	## Reference
	
	[p8est_extended.h:128](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:128:21)
	""" p8est_lid_compare
	export p8est_lid_compare
	𝐣𝐥.@cextern p8est_lid_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cint
	```
	
	 Checks if the p8est_lid_t *a* and the p8est_lid_t *b* are equal. 
	
	## Parameters
	
	  * `a`: A pointer to a p8est_lid_t.
	  * `b`: A pointer to a p8est_lid_t.
	
	## Returns
	
	        Returns a true value if *a* and *b* are equal,                false otherwise
	
	## Reference
	
	[p8est_extended.h:137](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:137:21)
	""" p8est_lid_is_equal
	export p8est_lid_is_equal
	𝐣𝐥.@cextern p8est_lid_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_init(input::𝐣𝐥.Ptr{p8est_lid_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to a given value. 
	
	## Parameters
	
	  * `a`:        A pointer to the p8est_lid_t that will be                          initialized.
	  * `high`:     The given high bits to intialize *a.*
	  * `low`:      The given low bits to initialize *a.*
	
	## Reference
	
	[p8est_extended.h:146](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:146:21)
	""" p8est_lid_init
	export p8est_lid_init
	𝐣𝐥.@cextern p8est_lid_init(input::𝐣𝐥.Ptr{p8est_lid_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_set_zero(input::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to zero. 
	
	## Parameters
	
	  * `input`:     A pointer to a p4est_lid_t that will be intialized.
	
	## Reference
	
	[p8est_extended.h:152](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:152:21)
	""" p8est_lid_set_zero
	export p8est_lid_set_zero
	𝐣𝐥.@cextern p8est_lid_set_zero(input::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_set_one(input::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to one. 
	
	## Parameters
	
	  * `input`:     A pointer to a p4est_lid_t that will be intialized.
	
	## Reference
	
	[p8est_extended.h:157](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:157:21)
	""" p8est_lid_set_one
	export p8est_lid_set_one
	𝐣𝐥.@cextern p8est_lid_set_one(input::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_set_uint64(input::𝐣𝐥.Ptr{p8est_lid_t}, u::uint64_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes a linear index to an unsigned 64 bit integer. 
	
	## Parameters
	
	  * `input`:     A pointer to a p4est_lid_t that will be intialized.
	
	## Reference
	
	[p8est_extended.h:162](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:162:21)
	""" p8est_lid_set_uint64
	export p8est_lid_set_uint64
	𝐣𝐥.@cextern p8est_lid_set_uint64(input::𝐣𝐥.Ptr{p8est_lid_t}, u::uint64_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Returns the bit_number-th bit of *input.* This function checks a bit of an existing, initialized value. 
	
	## Parameters
	
	  * `input`:      A pointer to a p8est_lid_t.
	  * `bit_number`: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= *bit_number* < 128.
	
	## Returns
	
	                    True if bit is set, false if not.
	
	## Reference
	
	[p8est_extended.h:172](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:172:21)
	""" p8est_lid_chk_bit
	export p8est_lid_chk_bit
	𝐣𝐥.@cextern p8est_lid_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_set_bit(input::𝐣𝐥.Ptr{p8est_lid_t}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Sets the exponent-th bit of *input* to one. This function modifies an existing, initialized value. 
	
	## Parameters
	
	  * `input`:      A pointer to a p8est_lid_t.
	  * `bit_number`: The bit (counted from the right hand side)                            that is set to one by logical or.                            Require 0 <= *bit_number* < 128.
	
	## Reference
	
	[p8est_extended.h:182](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:182:21)
	""" p8est_lid_set_bit
	export p8est_lid_set_bit
	𝐣𝐥.@cextern p8est_lid_set_bit(input::𝐣𝐥.Ptr{p8est_lid_t}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, output::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Copies an initialized p8est_lid_t to a p8est_lid_t. 
	
	## Parameters
	
	  * `input`:    A pointer to the sc_uint128 that is copied.
	  * `output`:   A pointer to a p8est_lid_t.                          The high and low bits of *output* will                          be set to the high and low bits of                          *input,* respectively.
	
	## Reference
	
	[p8est_extended.h:191](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:191:21)
	""" p8est_lid_copy
	export p8est_lid_copy
	𝐣𝐥.@cextern p8est_lid_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, output::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Adds the uint128_t *b* to the uint128_t *a.* *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a p8est_lid_t.
	  * `b`:       A pointer to a p8est_lid_t.
	  * `result`:  A pointer to a p8est_lid_t.                      The sum *a* + *b* will be saved in *result.*
	
	## Reference
	
	[p8est_extended.h:202](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:202:21)
	""" p8est_lid_add
	export p8est_lid_add
	𝐣𝐥.@cextern p8est_lid_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Substracts the p8est_lid_t *b* from the p8est_lid_t *a.* This function assumes that the result is >= 0. *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a p8est_lid_t.
	  * `b`:       A pointer to a p8est_lid_t.
	  * `result`:  A pointer to a p8est_lid_t.                      The difference *a* - *b* will be saved in *result.*
	
	## Reference
	
	[p8est_extended.h:215](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:215:21)
	""" p8est_lid_sub
	export p8est_lid_sub
	𝐣𝐥.@cextern p8est_lid_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise negation of the uint128_t *a.* *a* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a p8est_lid_t.
	  * `result`:   A pointer to a p8est_lid_t.                      The bitwise negation of *a* will be saved in                      *result.*
	
	## Reference
	
	[p8est_extended.h:226](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:226:21)
	""" p8est_lid_bitwise_neg
	export p8est_lid_bitwise_neg
	𝐣𝐥.@cextern p8est_lid_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a p8est_lid_t.
	  * `b`:        A pointer to a p8est_lid_t.
	  * `result`:   A pointer to a p8est_lid_t.                      The bitwise or of *a* and *b* will be                      saved in *result.*
	
	## Reference
	
	[p8est_extended.h:238](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:238:21)
	""" p8est_lid_bitwise_or
	export p8est_lid_bitwise_or
	𝐣𝐥.@cextern p8est_lid_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a p8est_lid_t.
	  * `b`:       A pointer to a p8est_lid_t.
	  * `result`:  A pointer to a p8est_lid_t.                      The bitwise and of *a* and *b* will be saved.                      in *result.*
	
	## Reference
	
	[p8est_extended.h:251](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:251:21)
	""" p8est_lid_bitwise_and
	export p8est_lid_bitwise_and
	𝐣𝐥.@cextern p8est_lid_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit right shift of uint128_t *input* by shift_count bits. We shift in zeros from the left. If *shift_count* >= 128, *result* is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a p8est_lid_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a p8est_lid_t.                              The right shifted number will be saved                              in *result.*
	
	## Reference
	
	[p8est_extended.h:265](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:265:21)
	""" p8est_lid_shift_right
	export p8est_lid_shift_right
	𝐣𝐥.@cextern p8est_lid_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit left shift of uint128_t *input* by shift_count bits. We shift in zeros from the right. If *shift_count* >= 128, *result* is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a p8est_lid_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a p8est_lid_t.                              The left shifted number will be saved                              in *result.*
	
	## Reference
	
	[p8est_extended.h:279](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:279:21)
	""" p8est_lid_shift_left
	export p8est_lid_shift_left
	𝐣𝐥.@cextern p8est_lid_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_add_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Adds the p8est_lid_t *b* to the p8est_lid_t *a.* The result is saved in *a.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a p8est_lid_t. *a*                      will be overwritten by *a* + *b.*
	  * `b`:       A pointer to a p8est_lid_t.
	
	## Reference
	
	[p8est_extended.h:289](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:289:21)
	""" p8est_lid_add_inplace
	export p8est_lid_add_inplace
	𝐣𝐥.@cextern p8est_lid_add_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_sub_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Substracts the uint128_t *b* from the uint128_t *a.* The result is saved in *a.* *a* == *b* is allowed. This function assumes that the result is >= 0. 
	
	## Parameters
	
	  * `a`:   A pointer to a p8est_lid_t.                      *a* will be overwritten by *a* - *b.*
	  * `b`:   A pointer to a p8est_lid_t.
	
	## Reference
	
	[p8est_extended.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:299:21)
	""" p8est_lid_sub_inplace
	export p8est_lid_sub_inplace
	𝐣𝐥.@cextern p8est_lid_sub_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_bitwise_or_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a p8est_lid_t.                      The bitwise or will be saved in *a.*
	  * `b`:   A pointer to a p8est_lid_t.
	
	## Reference
	
	[p8est_extended.h:308](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:308:21)
	""" p8est_lid_bitwise_or_inplace
	export p8est_lid_bitwise_or_inplace
	𝐣𝐥.@cextern p8est_lid_bitwise_or_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_lid_bitwise_and_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a p8est_lid_t.                      The bitwise and will be saved in *a.*
	  * `b`:   A pointer to a p8est_lid_t.
	
	## Reference
	
	[p8est_extended.h:317](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:317:21)
	""" p8est_lid_bitwise_and_inplace
	export p8est_lid_bitwise_and_inplace
	𝐣𝐥.@cextern p8est_lid_bitwise_and_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_quadrant_linear_id_ext128(quadrant::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	```
	
	 Computes the linear position as p8est_lid_t of a quadrant in a uniform grid. The grid and quadrant levels need not coincide. If they do, this is the inverse of p4est_quadrant_set_morton. 
	
	## Parameters
	
	  * `quadrant`:  Quadrant whose linear index will be computed.                       If the quadrant is smaller than the grid (has a higher                       quadrant->level), the result is computed from its                       ancestor at the grid's level.                       If the quadrant has a smaller level than the grid (it                       is bigger than a grid cell), the grid cell sharing its                       lower left corner is used as reference.
	  * `level`:     The level of the regular grid compared to which the                       linear position is to be computed.
	  * `id`:     A pointer to an allocated or static p8est_lid_t.                       id will be the linear position of this quadrant on a                       uniform grid.
	
	NOTE: The user_data of *quadrant* is never modified.
	
	## Reference
	
	[p8est_extended.h:336](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:336:21)
	""" p8est_quadrant_linear_id_ext128
	export p8est_quadrant_linear_id_ext128
	𝐣𝐥.@cextern p8est_quadrant_linear_id_ext128(quadrant::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_quadrant_set_morton_ext128(quadrant::𝐣𝐥.Ptr{p8est_quadrant_t}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	```
	
	 Set quadrant Morton indices based on linear position given as p8est_lid_t in uniform grid. This is the inverse operation of p4est_quadrant_linear_id. 
	
	## Parameters
	
	  * `quadrant`:  Quadrant whose Morton indices will be set.
	  * `level`:     Level of the grid and of the resulting quadrant.
	  * `id`:        Linear index of the quadrant on a uniform grid.
	
	NOTE: The user_data of *quadrant* is never modified.
	
	## Reference
	
	[p8est_extended.h:347](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:347:21)
	""" p8est_quadrant_set_morton_ext128
	export p8est_quadrant_set_morton_ext128
	𝐣𝐥.@cextern p8est_quadrant_set_morton_ext128(quadrant::𝐣𝐥.Ptr{p8est_quadrant_t}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_t}
	```
	
	 Create a new forest. This is a more general form of p8est_new. The forest created is either uniformly refined at a given level or created with the coarsest possible refinement that fits the exact partition that would have been created in the uniform mode. The latter, coarse refinement depends on the number of MPI processes! The initial level is currently limited to P8EST_OLD_QMAXLEVEL. Regardless, p8est_refine can go as deep as P8EST_QMAXLEVEL.
	
	## Parameters
	
	  * `mpicomm`:          A valid MPI communicator.
	  * `connectivity`:     This is the connectivity information that                              the forest is built with.  Note the forest                              does not take ownership of the memory.
	  * `min_quadrants`:    Minimum initial quadrants per processor.                              Makes the refinement pattern mpisize-specific.                              For maximum reproducibility, set this to 0.
	  * `min_level`:        The forest is refined at most to this level.                              Later coarsening and refinement is unaffected.                              May be negative or 0, then it has no effect.
	  * `fill_uniform`:     If true, fill the forest with a uniform mesh                              instead of the coarsest possible one.                              The latter is partition-specific, which                              is not a good idea wrt. reproducibility.
	  * `data_size`:        The size of data for each quadrant.
	  * `init_fn`:          Callback function to initialize the user_data                              which is internally allocated using data_size.
	  * `user_pointer`:     Assigned to the user_pointer member of the                              forest before init_fn is called the first time.
	
	## Returns
	
	                      Valid p8est object.
	
	## Reference
	
	[p8est_extended.h:381](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:381:21)
	""" p8est_new_ext
	export p8est_new_ext
	𝐣𝐥.@cextern p8est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_mesh_new_ext(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, compute_tree_index::𝐣𝐥.Cint, compute_level_lists::𝐣𝐥.Cint, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_mesh_t}
	```
	
	 Create a new mesh. 
	
	## Parameters
	
	  * `p8est`:                A forest that is fully 2:1 balanced.
	  * `ghost`:                The ghost layer created from the                                  provided p4est.
	  * `compute_tree_index`:   Boolean to decide whether to allocate and                                  compute the quad_to_tree list.
	  * `compute_level_lists`:  Boolean to decide whether to compute the                                  level lists in quad_level.
	  * `btype`:                Currently ignored, only face neighbors                                  are stored.
	
	## Returns
	
	                          A fully allocated mesh structure.
	
	## Reference
	
	[p8est_extended.h:400](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:400:21)
	""" p8est_mesh_new_ext
	export p8est_mesh_new_ext
	𝐣𝐥.@cextern p8est_mesh_new_ext(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, compute_tree_index::𝐣𝐥.Cint, compute_level_lists::𝐣𝐥.Cint, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_mesh_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_copy_ext(input::𝐣𝐥.Ptr{p8est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_t}
	```
	
	 Make a deep copy of a p8est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.
	
	## Parameters
	
	  * `copy_data`:  If true, data are copied.                         If false, data_size is set to 0.
	  * `duplicate_mpicomm`:  If true, MPI communicator is copied.
	
	## Returns
	
	  Returns a valid p8est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.
	
	## Reference
	
	[p8est_extended.h:420](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:420:21)
	""" p8est_copy_ext
	export p8est_copy_ext
	𝐣𝐥.@cextern p8est_copy_ext(input::𝐣𝐥.Ptr{p8est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_refine_ext(p8est::𝐣𝐥.Ptr{p8est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p8est_refine_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Refine a forest with a bounded refinement level and a replace option. 
	
	## Parameters
	
	  * `p8est`: The forest is changed in place.
	  * `refine_recursive`: Boolean to decide on recursive refinement.
	  * `maxlevel`:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p8est.h.
	  * `refine_fn`:  Callback function that must return true if a quadrant                        shall be refined.  If refine_recursive is true,                        refine_fn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether init_fn or                        replace_fn gets called.
	  * `init_fn`:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.
	
	## Reference
	
	[p8est_extended.h:444](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:444:21)
	""" p8est_refine_ext
	export p8est_refine_ext
	𝐣𝐥.@cextern p8est_refine_ext(p8est::𝐣𝐥.Ptr{p8est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p8est_refine_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_coarsen_ext(p8est::𝐣𝐥.Ptr{p8est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p8est_coarsen_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 Coarsen a forest. 
	
	## Parameters
	
	  * `p8est`: The forest is changed in place.
	  * `coarsen_recursive`: Boolean to decide on recursive coarsening.
	  * `callback_orphans`: Boolean to enable calling coarsen_fn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsen_recursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.                        With coarsen_recursive false and callback_orphans true,                        it is guaranteed that every quadrant is passed exactly                        once into the coarsen_fn callback.
	  * `coarsen_fn`: Callback function that returns true if a                        family of quadrants shall be coarsened.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p8est_extended.h:471](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:471:21)
	""" p8est_coarsen_ext
	export p8est_coarsen_ext
	𝐣𝐥.@cextern p8est_coarsen_ext(p8est::𝐣𝐥.Ptr{p8est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p8est_coarsen_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_balance_ext(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	```
	
	 2:1 balance the size differences of neighboring elements in a forest. 
	
	## Parameters
	
	  * `p8est`:  The p8est to be worked on.
	  * `btype`:      Balance type (face, edge, or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.
	  * `init_fn`:    Callback function to initialize the user_data                        which is already allocated automatically.
	  * `replace_fn`: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.
	
	## Reference
	
	[p8est_extended.h:488](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:488:21)
	""" p8est_balance_ext
	export p8est_balance_ext
	𝐣𝐥.@cextern p8est_balance_ext(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_balance_subtree_ext(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, which_tree::p4est_topidx_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[p8est_extended.h:493](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:493:21)
	""" p8est_balance_subtree_ext
	export p8est_balance_subtree_ext
	𝐣𝐥.@cextern p8est_balance_subtree_ext(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, which_tree::p4est_topidx_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_partition_ext(p8est::𝐣𝐥.Ptr{p8est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p8est_weight_t)::p4est_gloidx_t
	```
	
	 Repartition the forest.
	
	## Details
	
	 The forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).
	
	## Parameters
	
	  * `p8est`:      The forest that will be partitioned.
	  * `partition_for_coarsening`:     If true, the partition                            is modified to allow one level of coarsening.
	  * `weight_fn`:  A weighting function or NULL                            for uniform partitioning. A weighting function                            with constant weight 1 on each quadrant is                            equivalent to weight_fn == NULL but other constant                            weightings may result in different uniform                            partitionings.
	
	## Returns
	
	         The global number of shipped quadrants
	
	## Reference
	
	[p8est_extended.h:515](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:515:21)
	""" p8est_partition_ext
	export p8est_partition_ext
	𝐣𝐥.@cextern p8est_partition_ext(p8est::𝐣𝐥.Ptr{p8est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p8est_weight_t)::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_partition_for_coarsening(p8est::𝐣𝐥.Ptr{p8est_t}, num_quadrants_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	```
	
	 Correct partition to allow one level of coarsening.
	
	## Parameters
	
	  * `p8est`:                     forest whose partition is corrected
	  * `num_quadrants_in_proc`: partition that will be corrected
	
	## Returns
	
	                               absolute number of moved quadrants
	
	## Reference
	
	[p8est_extended.h:525](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:525:21)
	""" p8est_partition_for_coarsening
	export p8est_partition_for_coarsening
	𝐣𝐥.@cextern p8est_partition_for_coarsening(p8est::𝐣𝐥.Ptr{p8est_t}, num_quadrants_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_iterate_ext(p8est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p8est_iter_volume_t, iter_face::p8est_iter_face_t, iter_edge::p8est_iter_edge_t, iter_corner::p8est_iter_corner_t, remote::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 p8est_iterate_ext adds the option *remote:* if this is false, then it is the same as p8est_iterate; if this is true, then corner/edge callbacks are also called on corners/edges for hanging faces/edges touched by local quadrants.
	
	## Reference
	
	[p8est_extended.h:534](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:534:21)
	""" p8est_iterate_ext
	export p8est_iterate_ext
	𝐣𝐥.@cextern p8est_iterate_ext(p8est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p8est_iter_volume_t, iter_face::p8est_iter_face_t, iter_edge::p8est_iter_edge_t, iter_corner::p8est_iter_corner_t, remote::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p8est::𝐣𝐥.Ptr{p8est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Save the complete connectivity/p8est data to disk.  This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p8est_load_ext for information on the autopartition parameter. 
	
	## Parameters
	
	  * `filename`:    Name of the file to write.
	  * `p8est`:       Valid forest structure.
	  * `save_data`:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.
	  * `save_partition`:   If false, save file as if 1 core was used.                              If true, save core count and partition.                         Advantage: Partition can be recovered on loading                              with same mpisize and autopartition false.                         Disadvantage: Makes the file depend on mpisize.                  Either way the file can be loaded with autopartition true.
	
	NOTE:            Aborts on file errors.
	
	## Reference
	
	[p8est_extended.h:560](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:560:21)
	""" p8est_save_ext
	export p8est_save_ext
	𝐣𝐥.@cextern p8est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p8est::𝐣𝐥.Ptr{p8est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}
	```
	
	 Load the complete connectivity/p4est structure from disk. It is possible to load the file with a different number of processors than has been used to write it.  The partition will then be uniform. 
	
	## Parameters
	
	  * `filename`:         Name of the file to read.
	  * `mpicomm`:          A valid MPI communicator.
	  * `data_size`:        Size of data for each quadrant which can be                              zero.  Then user_data_pool is set to NULL.                              If data_size is zero, load_data is ignored.
	  * `load_data`:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.
	  * `autopartition`:    Ignore saved partition and make it uniform.
	  * `broadcasthead`:    Have only rank 0 read headers and bcast them.
	  * `user_pointer`:     Assign to the user_pointer member of the p4est                              before init_fn is called the first time.
	  * `connectivity`:    Connectivity must be destroyed separately.
	
	## Returns
	
	          Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument. 
	
	NOTE:            Aborts on file errors or invalid file contents.
	
	## Reference
	
	[p8est_extended.h:584](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:584:21)
	""" p8est_load_ext
	export p8est_load_ext
	𝐣𝐥.@cextern p8est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_source_ext(src::𝐣𝐥.Ptr{sc_io_source_t}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}
	```
	
	 The same as p8est_load_ext, but reading the connectivity/p8est from an open sc_io_source_t stream.
	
	## Reference
	
	[p8est_extended.h:593](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:593:21)
	""" p8est_source_ext
	export p8est_source_ext
	𝐣𝐥.@cextern p8est_source_ext(src::𝐣𝐥.Ptr{sc_io_source_t}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern p8est_get_plex_data_ext(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_ghost_t}}, lnodes::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_lnodes_t}}, ctype::p8est_connect_type_t, overlap::𝐣𝐥.Cint, first_local_quad::𝐣𝐥.Ptr{p4est_locidx_t}, out_points_per_dim::𝐣𝐥.Ptr{sc_array_t}, out_cone_sizes::𝐣𝐥.Ptr{sc_array_t}, out_cones::𝐣𝐥.Ptr{sc_array_t}, out_cone_orientations::𝐣𝐥.Ptr{sc_array_t}, out_vertex_coords::𝐣𝐥.Ptr{sc_array_t}, out_children::𝐣𝐥.Ptr{sc_array_t}, out_parents::𝐣𝐥.Ptr{sc_array_t}, out_childids::𝐣𝐥.Ptr{sc_array_t}, out_leaves::𝐣𝐥.Ptr{sc_array_t}, out_remotes::𝐣𝐥.Ptr{sc_array_t}, custom_numbering::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Create the data necessary to create a PETsc DMPLEX representation of a forest, as well as the accompanying lnodes and ghost layer.  The forest must be at least face balanced (see p4est_balance()).  See test/test_plex2.c for example usage.
	
	## Details
	
	 All arrays should be initialized to hold sizeof (p4est_locidx_t), except for *out_remotes,* which should be initialized to hold (2 * sizeof (p4est_locidx_t)).
	
	## Parameters
	
	  * `p8est`:                 the forest
	  * `ghost`:                 the ghost layer
	  * `lnodes`:                the lnodes
	  * `ctype`:                 the type of adjacency for the overlap
	  * `overlap`:               the number of layers of overlap (zero                                      is acceptable)
	  * `first_local_quad`:      the local quadrants are assigned                                      contiguous plex indices, starting with                                      this index
	  * `out_points_per_dim`:    filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_cone_sizes`:        filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_cones`:             filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_cone_orientations`: filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_vertex_coords`:     filled with argument for                                      DMPlexCreateFromDAG()
	  * `out_children`:          filled with argument for                                      DMPlexSetTree()
	  * `out_parents`:           filled with argument for                                      DMPlexSetTree()
	  * `out_childids`:          filled with argument for                                      DMPlexSetTree()
	  * `out_leaves`:            filled with argument for                                      PetscSFSetGraph()
	  * `out_remotes`:           filled with argument for                                      PetscSFSetGraph()
	  * `custom_numbering`:      Whether or use the default numbering                                      (0) of DMPlex child ids or the custom                                      (1).
	
	## Reference
	
	[p8est_extended.h:641](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_extended.h:641:21)
	""" p8est_get_plex_data_ext
	export p8est_get_plex_data_ext
	𝐣𝐥.@cextern p8est_get_plex_data_ext(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_ghost_t}}, lnodes::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_lnodes_t}}, ctype::p8est_connect_type_t, overlap::𝐣𝐥.Cint, first_local_quad::𝐣𝐥.Ptr{p4est_locidx_t}, out_points_per_dim::𝐣𝐥.Ptr{sc_array_t}, out_cone_sizes::𝐣𝐥.Ptr{sc_array_t}, out_cones::𝐣𝐥.Ptr{sc_array_t}, out_cone_orientations::𝐣𝐥.Ptr{sc_array_t}, out_vertex_coords::𝐣𝐥.Ptr{sc_array_t}, out_children::𝐣𝐥.Ptr{sc_array_t}, out_parents::𝐣𝐥.Ptr{sc_array_t}, out_childids::𝐣𝐥.Ptr{sc_array_t}, out_leaves::𝐣𝐥.Ptr{sc_array_t}, out_remotes::𝐣𝐥.Ptr{sc_array_t}, custom_numbering::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:2](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:2:9)
	""" :(@_CONFIG_SC_CONFIG_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:2](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:2:9)
	""" _CONFIG_SC_CONFIG_H
	export @_CONFIG_SC_CONFIG_H
	macro _CONFIG_SC_CONFIG_H() return quote 1 end end
	const _CONFIG_SC_CONFIG_H = (@_CONFIG_SC_CONFIG_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:13](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:13:9)
	""" SC_CC
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:13](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:13:9)
	""" :(@SC_CC)
	export @SC_CC, SC_CC
	macro SC_CC() return quote "cc" end end
	const SC_CC = (@SC_CC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:18](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:18:9)
	""" SC_CFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:18](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:18:9)
	""" :(@SC_CFLAGS)
	export @SC_CFLAGS, SC_CFLAGS
	macro SC_CFLAGS() return quote "-g -O2" end end
	const SC_CFLAGS = (@SC_CFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:23](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:23:9)
	""" :(@SC_CPP)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:23](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:23:9)
	""" SC_CPP
	export @SC_CPP, SC_CPP
	macro SC_CPP() return quote "cc -E" end end
	const SC_CPP = (@SC_CPP)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:28](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:28:9)
	""" SC_CPPFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:28](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:28:9)
	""" :(@SC_CPPFLAGS)
	export @SC_CPPFLAGS, SC_CPPFLAGS
	macro SC_CPPFLAGS() return quote "-I/workspace/destdir/include" end end
	const SC_CPPFLAGS = (@SC_CPPFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:33](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:33:9)
	""" :(@SC_CXX)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:33](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:33:9)
	""" SC_CXX
	export @SC_CXX, SC_CXX
	macro SC_CXX() return quote "c++" end end
	const SC_CXX = (@SC_CXX)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:38](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:38:9)
	""" :(@SC_CXXFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:38](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:38:9)
	""" SC_CXXFLAGS
	export @SC_CXXFLAGS, SC_CXXFLAGS
	macro SC_CXXFLAGS() return quote "-g -O2" end end
	const SC_CXXFLAGS = (@SC_CXXFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:53](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:53:9)
	""" :(@SC_ENABLE_MEMALIGN)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:53](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:53:9)
	""" SC_ENABLE_MEMALIGN
	export @SC_ENABLE_MEMALIGN, SC_ENABLE_MEMALIGN
	macro SC_ENABLE_MEMALIGN() return quote 1 end end
	const SC_ENABLE_MEMALIGN = (@SC_ENABLE_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:85](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:85:9)
	""" :(@SC_ENABLE_USE_REALLOC)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:85](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:85:9)
	""" SC_ENABLE_USE_REALLOC
	export @SC_ENABLE_USE_REALLOC, SC_ENABLE_USE_REALLOC
	macro SC_ENABLE_USE_REALLOC() return quote 1 end end
	const SC_ENABLE_USE_REALLOC = (@SC_ENABLE_USE_REALLOC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:90](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:90:9)
	""" :(@SC_ENABLE_V4L2)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:90](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:90:9)
	""" SC_ENABLE_V4L2
	export @SC_ENABLE_V4L2, SC_ENABLE_V4L2
	macro SC_ENABLE_V4L2() return quote 1 end end
	const SC_ENABLE_V4L2 = (@SC_ENABLE_V4L2)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:95](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:95:9)
	""" :(@SC_F77)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:95](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:95:9)
	""" SC_F77
	export @SC_F77, SC_F77
	macro SC_F77() return quote "gfortran" end end
	const SC_F77 = (@SC_F77)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:118](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:118:9)
	""" SC_FC
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:118](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:118:9)
	""" :(@SC_FC)
	export @SC_FC, SC_FC
	macro SC_FC() return quote "gfortran" end end
	const SC_FC = (@SC_FC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:123](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:123:9)
	""" SC_FCFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:123](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:123:9)
	""" :(@SC_FCFLAGS)
	export @SC_FCFLAGS, SC_FCFLAGS
	macro SC_FCFLAGS() return quote "-g -O2" end end
	const SC_FCFLAGS = (@SC_FCFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:149](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:149:9)
	""" :(@SC_FFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:149](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:149:9)
	""" SC_FFLAGS
	export @SC_FFLAGS, SC_FFLAGS
	macro SC_FFLAGS() return quote "-g -O2" end end
	const SC_FFLAGS = (@SC_FFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:157](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:157:9)
	""" :(@SC_HAVE_BACKTRACE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:157](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:157:9)
	""" SC_HAVE_BACKTRACE
	export @SC_HAVE_BACKTRACE, SC_HAVE_BACKTRACE
	macro SC_HAVE_BACKTRACE() return quote 1 end end
	const SC_HAVE_BACKTRACE = (@SC_HAVE_BACKTRACE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:162](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:162:9)
	""" :(@SC_HAVE_BACKTRACE_SYMBOLS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:162](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:162:9)
	""" SC_HAVE_BACKTRACE_SYMBOLS
	export @SC_HAVE_BACKTRACE_SYMBOLS, SC_HAVE_BACKTRACE_SYMBOLS
	macro SC_HAVE_BACKTRACE_SYMBOLS() return quote 1 end end
	const SC_HAVE_BACKTRACE_SYMBOLS = (@SC_HAVE_BACKTRACE_SYMBOLS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:167](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:167:9)
	""" SC_HAVE_DLFCN_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:167](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:167:9)
	""" :(@SC_HAVE_DLFCN_H)
	export @SC_HAVE_DLFCN_H, SC_HAVE_DLFCN_H
	macro SC_HAVE_DLFCN_H() return quote 1 end end
	const SC_HAVE_DLFCN_H = (@SC_HAVE_DLFCN_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:172](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:172:9)
	""" SC_HAVE_EXECINFO_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:172](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:172:9)
	""" :(@SC_HAVE_EXECINFO_H)
	export @SC_HAVE_EXECINFO_H, SC_HAVE_EXECINFO_H
	macro SC_HAVE_EXECINFO_H() return quote 1 end end
	const SC_HAVE_EXECINFO_H = (@SC_HAVE_EXECINFO_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:177](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:177:9)
	""" SC_HAVE_FCNTL_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:177](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:177:9)
	""" :(@SC_HAVE_FCNTL_H)
	export @SC_HAVE_FCNTL_H, SC_HAVE_FCNTL_H
	macro SC_HAVE_FCNTL_H() return quote 1 end end
	const SC_HAVE_FCNTL_H = (@SC_HAVE_FCNTL_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:182](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:182:9)
	""" :(@SC_HAVE_FSYNC)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:182](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:182:9)
	""" SC_HAVE_FSYNC
	export @SC_HAVE_FSYNC, SC_HAVE_FSYNC
	macro SC_HAVE_FSYNC() return quote 1 end end
	const SC_HAVE_FSYNC = (@SC_HAVE_FSYNC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:187](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:187:9)
	""" :(@SC_HAVE_INTTYPES_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:187](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:187:9)
	""" SC_HAVE_INTTYPES_H
	export @SC_HAVE_INTTYPES_H, SC_HAVE_INTTYPES_H
	macro SC_HAVE_INTTYPES_H() return quote 1 end end
	const SC_HAVE_INTTYPES_H = (@SC_HAVE_INTTYPES_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:192](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:192:9)
	""" SC_HAVE_LINUX_VIDEODEV2_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:192](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:192:9)
	""" :(@SC_HAVE_LINUX_VIDEODEV2_H)
	export @SC_HAVE_LINUX_VIDEODEV2_H, SC_HAVE_LINUX_VIDEODEV2_H
	macro SC_HAVE_LINUX_VIDEODEV2_H() return quote 1 end end
	const SC_HAVE_LINUX_VIDEODEV2_H = (@SC_HAVE_LINUX_VIDEODEV2_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:215](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:215:9)
	""" SC_HAVE_MEMORY_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:215](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:215:9)
	""" :(@SC_HAVE_MEMORY_H)
	export @SC_HAVE_MEMORY_H, SC_HAVE_MEMORY_H
	macro SC_HAVE_MEMORY_H() return quote 1 end end
	const SC_HAVE_MEMORY_H = (@SC_HAVE_MEMORY_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:223](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:223:9)
	""" :(@SC_HAVE_POSIX_MEMALIGN)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:223](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:223:9)
	""" SC_HAVE_POSIX_MEMALIGN
	export @SC_HAVE_POSIX_MEMALIGN, SC_HAVE_POSIX_MEMALIGN
	macro SC_HAVE_POSIX_MEMALIGN() return quote 1 end end
	const SC_HAVE_POSIX_MEMALIGN = (@SC_HAVE_POSIX_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:228](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:228:9)
	""" :(@SC_HAVE_QSORT_R)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:228](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:228:9)
	""" SC_HAVE_QSORT_R
	export @SC_HAVE_QSORT_R, SC_HAVE_QSORT_R
	macro SC_HAVE_QSORT_R() return quote 1 end end
	const SC_HAVE_QSORT_R = (@SC_HAVE_QSORT_R)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:233:9)
	""" :(@SC_HAVE_SIGNAL_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:233](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:233:9)
	""" SC_HAVE_SIGNAL_H
	export @SC_HAVE_SIGNAL_H, SC_HAVE_SIGNAL_H
	macro SC_HAVE_SIGNAL_H() return quote 1 end end
	const SC_HAVE_SIGNAL_H = (@SC_HAVE_SIGNAL_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:238](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:238:9)
	""" SC_HAVE_STDINT_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:238](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:238:9)
	""" :(@SC_HAVE_STDINT_H)
	export @SC_HAVE_STDINT_H, SC_HAVE_STDINT_H
	macro SC_HAVE_STDINT_H() return quote 1 end end
	const SC_HAVE_STDINT_H = (@SC_HAVE_STDINT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:243](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:243:9)
	""" SC_HAVE_STDLIB_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:243](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:243:9)
	""" :(@SC_HAVE_STDLIB_H)
	export @SC_HAVE_STDLIB_H, SC_HAVE_STDLIB_H
	macro SC_HAVE_STDLIB_H() return quote 1 end end
	const SC_HAVE_STDLIB_H = (@SC_HAVE_STDLIB_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:248](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:248:9)
	""" :(@SC_HAVE_STRINGS_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:248](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:248:9)
	""" SC_HAVE_STRINGS_H
	export @SC_HAVE_STRINGS_H, SC_HAVE_STRINGS_H
	macro SC_HAVE_STRINGS_H() return quote 1 end end
	const SC_HAVE_STRINGS_H = (@SC_HAVE_STRINGS_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:253](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:253:9)
	""" :(@SC_HAVE_STRING_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:253](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:253:9)
	""" SC_HAVE_STRING_H
	export @SC_HAVE_STRING_H, SC_HAVE_STRING_H
	macro SC_HAVE_STRING_H() return quote 1 end end
	const SC_HAVE_STRING_H = (@SC_HAVE_STRING_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:258](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:258:9)
	""" :(@SC_HAVE_STRTOL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:258](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:258:9)
	""" SC_HAVE_STRTOL
	export @SC_HAVE_STRTOL, SC_HAVE_STRTOL
	macro SC_HAVE_STRTOL() return quote 1 end end
	const SC_HAVE_STRTOL = (@SC_HAVE_STRTOL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:263](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:263:9)
	""" :(@SC_HAVE_STRTOLL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:263](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:263:9)
	""" SC_HAVE_STRTOLL
	export @SC_HAVE_STRTOLL, SC_HAVE_STRTOLL
	macro SC_HAVE_STRTOLL() return quote 1 end end
	const SC_HAVE_STRTOLL = (@SC_HAVE_STRTOLL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:268](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:268:9)
	""" SC_HAVE_SYS_IOCTL_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:268](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:268:9)
	""" :(@SC_HAVE_SYS_IOCTL_H)
	export @SC_HAVE_SYS_IOCTL_H, SC_HAVE_SYS_IOCTL_H
	macro SC_HAVE_SYS_IOCTL_H() return quote 1 end end
	const SC_HAVE_SYS_IOCTL_H = (@SC_HAVE_SYS_IOCTL_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:273](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:273:9)
	""" SC_HAVE_SYS_SELECT_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:273](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:273:9)
	""" :(@SC_HAVE_SYS_SELECT_H)
	export @SC_HAVE_SYS_SELECT_H, SC_HAVE_SYS_SELECT_H
	macro SC_HAVE_SYS_SELECT_H() return quote 1 end end
	const SC_HAVE_SYS_SELECT_H = (@SC_HAVE_SYS_SELECT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:278](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:278:9)
	""" SC_HAVE_SYS_STAT_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:278](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:278:9)
	""" :(@SC_HAVE_SYS_STAT_H)
	export @SC_HAVE_SYS_STAT_H, SC_HAVE_SYS_STAT_H
	macro SC_HAVE_SYS_STAT_H() return quote 1 end end
	const SC_HAVE_SYS_STAT_H = (@SC_HAVE_SYS_STAT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:283](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:283:9)
	""" :(@SC_HAVE_SYS_TIME_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:283](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:283:9)
	""" SC_HAVE_SYS_TIME_H
	export @SC_HAVE_SYS_TIME_H, SC_HAVE_SYS_TIME_H
	macro SC_HAVE_SYS_TIME_H() return quote 1 end end
	const SC_HAVE_SYS_TIME_H = (@SC_HAVE_SYS_TIME_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:288](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:288:9)
	""" :(@SC_HAVE_SYS_TYPES_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:288](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:288:9)
	""" SC_HAVE_SYS_TYPES_H
	export @SC_HAVE_SYS_TYPES_H, SC_HAVE_SYS_TYPES_H
	macro SC_HAVE_SYS_TYPES_H() return quote 1 end end
	const SC_HAVE_SYS_TYPES_H = (@SC_HAVE_SYS_TYPES_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:293](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:293:9)
	""" :(@SC_HAVE_TIME_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:293](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:293:9)
	""" SC_HAVE_TIME_H
	export @SC_HAVE_TIME_H, SC_HAVE_TIME_H
	macro SC_HAVE_TIME_H() return quote 1 end end
	const SC_HAVE_TIME_H = (@SC_HAVE_TIME_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:298](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:298:9)
	""" :(@SC_HAVE_UNISTD_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:298](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:298:9)
	""" SC_HAVE_UNISTD_H
	export @SC_HAVE_UNISTD_H, SC_HAVE_UNISTD_H
	macro SC_HAVE_UNISTD_H() return quote 1 end end
	const SC_HAVE_UNISTD_H = (@SC_HAVE_UNISTD_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:303](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:303:9)
	""" SC_HAVE_ZLIB
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:303](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:303:9)
	""" :(@SC_HAVE_ZLIB)
	export @SC_HAVE_ZLIB, SC_HAVE_ZLIB
	macro SC_HAVE_ZLIB() return quote 1 end end
	const SC_HAVE_ZLIB = (@SC_HAVE_ZLIB)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:311](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:311:9)
	""" :(@SC_LDFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:311](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:311:9)
	""" SC_LDFLAGS
	export @SC_LDFLAGS, SC_LDFLAGS
	macro SC_LDFLAGS() return quote "-L/workspace/destdir/lib" end end
	const SC_LDFLAGS = (@SC_LDFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:316](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:316:9)
	""" :(@SC_LIBS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:316](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:316:9)
	""" SC_LIBS
	export @SC_LIBS, SC_LIBS
	macro SC_LIBS() return quote "  -lz -lm   " end end
	const SC_LIBS = (@SC_LIBS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:324](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:324:9)
	""" :(@SC_LT_OBJDIR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:324](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:324:9)
	""" SC_LT_OBJDIR
	export @SC_LT_OBJDIR, SC_LT_OBJDIR
	macro SC_LT_OBJDIR() return quote ".libs/" end end
	const SC_LT_OBJDIR = (@SC_LT_OBJDIR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:329:9)
	""" SC_MEMALIGN
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:329:9)
	""" :(@SC_MEMALIGN)
	export @SC_MEMALIGN, SC_MEMALIGN
	macro SC_MEMALIGN() return quote 1 end end
	const SC_MEMALIGN = (@SC_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:334](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:334:9)
	""" :(@SC_MEMALIGN_BYTES)
	export @SC_MEMALIGN_BYTES
	macro SC_MEMALIGN_BYTES() return quote ((@SC_SIZEOF_VOID_P)) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:351](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:351:9)
	""" :(@SC_PACKAGE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:351](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:351:9)
	""" SC_PACKAGE
	export @SC_PACKAGE, SC_PACKAGE
	macro SC_PACKAGE() return quote "libsc" end end
	const SC_PACKAGE = (@SC_PACKAGE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:356](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:356:9)
	""" :(@SC_PACKAGE_BUGREPORT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:356](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:356:9)
	""" SC_PACKAGE_BUGREPORT
	export @SC_PACKAGE_BUGREPORT, SC_PACKAGE_BUGREPORT
	macro SC_PACKAGE_BUGREPORT() return quote "p4est@ins.uni-bonn.de" end end
	const SC_PACKAGE_BUGREPORT = (@SC_PACKAGE_BUGREPORT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:361](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:361:9)
	""" SC_PACKAGE_NAME
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:361](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:361:9)
	""" :(@SC_PACKAGE_NAME)
	export @SC_PACKAGE_NAME, SC_PACKAGE_NAME
	macro SC_PACKAGE_NAME() return quote "libsc" end end
	const SC_PACKAGE_NAME = (@SC_PACKAGE_NAME)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:366](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:366:9)
	""" SC_PACKAGE_STRING
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:366](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:366:9)
	""" :(@SC_PACKAGE_STRING)
	export @SC_PACKAGE_STRING, SC_PACKAGE_STRING
	macro SC_PACKAGE_STRING() return quote "libsc 2.3.1" end end
	const SC_PACKAGE_STRING = (@SC_PACKAGE_STRING)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:371](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:371:9)
	""" SC_PACKAGE_TARNAME
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:371](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:371:9)
	""" :(@SC_PACKAGE_TARNAME)
	export @SC_PACKAGE_TARNAME, SC_PACKAGE_TARNAME
	macro SC_PACKAGE_TARNAME() return quote "libsc" end end
	const SC_PACKAGE_TARNAME = (@SC_PACKAGE_TARNAME)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:376](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:376:9)
	""" SC_PACKAGE_URL
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:376](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:376:9)
	""" :(@SC_PACKAGE_URL)
	export @SC_PACKAGE_URL, SC_PACKAGE_URL
	macro SC_PACKAGE_URL() return quote "" end end
	const SC_PACKAGE_URL = (@SC_PACKAGE_URL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:381](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:381:9)
	""" SC_PACKAGE_VERSION
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:381](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:381:9)
	""" :(@SC_PACKAGE_VERSION)
	export @SC_PACKAGE_VERSION, SC_PACKAGE_VERSION
	macro SC_PACKAGE_VERSION() return quote "2.3.1" end end
	const SC_PACKAGE_VERSION = (@SC_PACKAGE_VERSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:398](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:398:9)
	""" :(@SC_SIZEOF_INT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:398](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:398:9)
	""" SC_SIZEOF_INT
	export @SC_SIZEOF_INT, SC_SIZEOF_INT
	macro SC_SIZEOF_INT() return quote 4 end end
	const SC_SIZEOF_INT = (@SC_SIZEOF_INT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:403](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:403:9)
	""" :(@SC_SIZEOF_LONG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:403](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:403:9)
	""" SC_SIZEOF_LONG
	export @SC_SIZEOF_LONG, SC_SIZEOF_LONG
	macro SC_SIZEOF_LONG() return quote 8 end end
	const SC_SIZEOF_LONG = (@SC_SIZEOF_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:408](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:408:9)
	""" :(@SC_SIZEOF_LONG_LONG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:408](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:408:9)
	""" SC_SIZEOF_LONG_LONG
	export @SC_SIZEOF_LONG_LONG, SC_SIZEOF_LONG_LONG
	macro SC_SIZEOF_LONG_LONG() return quote 8 end end
	const SC_SIZEOF_LONG_LONG = (@SC_SIZEOF_LONG_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:413](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:413:9)
	""" :(@SC_SIZEOF_UNSIGNED_LONG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:413](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:413:9)
	""" SC_SIZEOF_UNSIGNED_LONG
	export @SC_SIZEOF_UNSIGNED_LONG, SC_SIZEOF_UNSIGNED_LONG
	macro SC_SIZEOF_UNSIGNED_LONG() return quote 8 end end
	const SC_SIZEOF_UNSIGNED_LONG = (@SC_SIZEOF_UNSIGNED_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:418](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:418:9)
	""" SC_SIZEOF_UNSIGNED_LONG_LONG
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:418](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:418:9)
	""" :(@SC_SIZEOF_UNSIGNED_LONG_LONG)
	export @SC_SIZEOF_UNSIGNED_LONG_LONG, SC_SIZEOF_UNSIGNED_LONG_LONG
	macro SC_SIZEOF_UNSIGNED_LONG_LONG() return quote 8 end end
	const SC_SIZEOF_UNSIGNED_LONG_LONG = (@SC_SIZEOF_UNSIGNED_LONG_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:423](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:423:9)
	""" :(@SC_SIZEOF_VOID_P)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:423](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:423:9)
	""" SC_SIZEOF_VOID_P
	export @SC_SIZEOF_VOID_P, SC_SIZEOF_VOID_P
	macro SC_SIZEOF_VOID_P() return quote 8 end end
	const SC_SIZEOF_VOID_P = (@SC_SIZEOF_VOID_P)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:428](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:428:9)
	""" SC_STDC_HEADERS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:428](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:428:9)
	""" :(@SC_STDC_HEADERS)
	export @SC_STDC_HEADERS, SC_STDC_HEADERS
	macro SC_STDC_HEADERS() return quote 1 end end
	const SC_STDC_HEADERS = (@SC_STDC_HEADERS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:433](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:433:9)
	""" :(@SC_USE_REALLOC)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:433](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:433:9)
	""" SC_USE_REALLOC
	export @SC_USE_REALLOC, SC_USE_REALLOC
	macro SC_USE_REALLOC() return quote 1 end end
	const SC_USE_REALLOC = (@SC_USE_REALLOC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:438](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:438:9)
	""" SC_VERSION
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:438](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:438:9)
	""" :(@SC_VERSION)
	export @SC_VERSION, SC_VERSION
	macro SC_VERSION() return quote "2.3.1" end end
	const SC_VERSION = (@SC_VERSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:443](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:443:9)
	""" :(@SC_VERSION_MAJOR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:443](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:443:9)
	""" SC_VERSION_MAJOR
	export @SC_VERSION_MAJOR, SC_VERSION_MAJOR
	macro SC_VERSION_MAJOR() return quote 2 end end
	const SC_VERSION_MAJOR = (@SC_VERSION_MAJOR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:448](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:448:9)
	""" :(@SC_VERSION_MINOR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:448](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:448:9)
	""" SC_VERSION_MINOR
	export @SC_VERSION_MINOR, SC_VERSION_MINOR
	macro SC_VERSION_MINOR() return quote 3 end end
	const SC_VERSION_MINOR = (@SC_VERSION_MINOR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:453](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:453:9)
	""" :(@SC_VERSION_POINT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:453](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_config.h:453:9)
	""" SC_VERSION_POINT
	export @SC_VERSION_POINT, SC_VERSION_POINT
	macro SC_VERSION_POINT() return quote 1 end end
	const SC_VERSION_POINT = (@SC_VERSION_POINT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:203](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:203:9)
	""" sc_MPI_SUCCESS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:203](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:203:9)
	""" :(@sc_MPI_SUCCESS)
	export @sc_MPI_SUCCESS, sc_MPI_SUCCESS
	macro sc_MPI_SUCCESS() return quote 0 end end
	const sc_MPI_SUCCESS = (@sc_MPI_SUCCESS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:211](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:211:9)
	""" :(@sc_MPI_IDENT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:211](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:211:9)
	""" sc_MPI_IDENT
	export @sc_MPI_IDENT, sc_MPI_IDENT
	macro sc_MPI_IDENT() return quote (1) end end
	const sc_MPI_IDENT = (@sc_MPI_IDENT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:212](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:212:9)
	""" sc_MPI_CONGRUENT
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:212](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:212:9)
	""" :(@sc_MPI_CONGRUENT)
	export @sc_MPI_CONGRUENT, sc_MPI_CONGRUENT
	macro sc_MPI_CONGRUENT() return quote (2) end end
	const sc_MPI_CONGRUENT = (@sc_MPI_CONGRUENT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:213](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:213:9)
	""" :(@sc_MPI_SIMILAR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:213](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:213:9)
	""" sc_MPI_SIMILAR
	export @sc_MPI_SIMILAR, sc_MPI_SIMILAR
	macro sc_MPI_SIMILAR() return quote (3) end end
	const sc_MPI_SIMILAR = (@sc_MPI_SIMILAR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:214:9)
	""" sc_MPI_UNEQUAL
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:214:9)
	""" :(@sc_MPI_UNEQUAL)
	export @sc_MPI_UNEQUAL, sc_MPI_UNEQUAL
	macro sc_MPI_UNEQUAL() return quote (-1) end end
	const sc_MPI_UNEQUAL = (@sc_MPI_UNEQUAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:216](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:216:9)
	""" :(@sc_MPI_ANY_SOURCE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:216](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:216:9)
	""" sc_MPI_ANY_SOURCE
	export @sc_MPI_ANY_SOURCE, sc_MPI_ANY_SOURCE
	macro sc_MPI_ANY_SOURCE() return quote (-2) end end
	const sc_MPI_ANY_SOURCE = (@sc_MPI_ANY_SOURCE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:217](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:217:9)
	""" sc_MPI_ANY_TAG
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:217](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:217:9)
	""" :(@sc_MPI_ANY_TAG)
	export @sc_MPI_ANY_TAG, sc_MPI_ANY_TAG
	macro sc_MPI_ANY_TAG() return quote (-1) end end
	const sc_MPI_ANY_TAG = (@sc_MPI_ANY_TAG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:256](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:256:9)
	""" :(@sc_MPI_UNDEFINED)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:256](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:256:9)
	""" sc_MPI_UNDEFINED
	export @sc_MPI_UNDEFINED, sc_MPI_UNDEFINED
	macro sc_MPI_UNDEFINED() return quote (-32766) end end
	const sc_MPI_UNDEFINED = (@sc_MPI_UNDEFINED)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:258](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:258:9)
	""" sc_MPI_ERR_GROUP
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:258](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:258:9)
	""" :(@sc_MPI_ERR_GROUP)
	export @sc_MPI_ERR_GROUP, sc_MPI_ERR_GROUP
	macro sc_MPI_ERR_GROUP() return quote (-123456) end end
	const sc_MPI_ERR_GROUP = (@sc_MPI_ERR_GROUP)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:382](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:382:9)
	""" sc_MPI_THREAD_SINGLE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:382](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:382:9)
	""" :(@sc_MPI_THREAD_SINGLE)
	export @sc_MPI_THREAD_SINGLE, sc_MPI_THREAD_SINGLE
	macro sc_MPI_THREAD_SINGLE() return quote 0 end end
	const sc_MPI_THREAD_SINGLE = (@sc_MPI_THREAD_SINGLE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:383](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:383:9)
	""" sc_MPI_THREAD_FUNNELED
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:383](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:383:9)
	""" :(@sc_MPI_THREAD_FUNNELED)
	export @sc_MPI_THREAD_FUNNELED, sc_MPI_THREAD_FUNNELED
	macro sc_MPI_THREAD_FUNNELED() return quote 1 end end
	const sc_MPI_THREAD_FUNNELED = (@sc_MPI_THREAD_FUNNELED)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:384](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:384:9)
	""" sc_MPI_THREAD_SERIALIZED
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:384](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:384:9)
	""" :(@sc_MPI_THREAD_SERIALIZED)
	export @sc_MPI_THREAD_SERIALIZED, sc_MPI_THREAD_SERIALIZED
	macro sc_MPI_THREAD_SERIALIZED() return quote 2 end end
	const sc_MPI_THREAD_SERIALIZED = (@sc_MPI_THREAD_SERIALIZED)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:385](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:385:9)
	""" sc_MPI_THREAD_MULTIPLE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:385](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc_mpi.h:385:9)
	""" :(@sc_MPI_THREAD_MULTIPLE)
	export @sc_MPI_THREAD_MULTIPLE, sc_MPI_THREAD_MULTIPLE
	macro sc_MPI_THREAD_MULTIPLE() return quote 3 end end
	const sc_MPI_THREAD_MULTIPLE = (@sc_MPI_THREAD_MULTIPLE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:154](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:154:9)
	""" :(@SC_EPS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:154](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:154:9)
	""" SC_EPS
	export @SC_EPS, SC_EPS
	macro SC_EPS() return quote 2.220446049250313e-16 end end
	const SC_EPS = (@SC_EPS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:302](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:302:9)
	""" :(@SC_LC_GLOBAL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:302](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:302:9)
	""" SC_LC_GLOBAL
	export @SC_LC_GLOBAL, SC_LC_GLOBAL
	macro SC_LC_GLOBAL() return quote 1 end end
	const SC_LC_GLOBAL = (@SC_LC_GLOBAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:303](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:303:9)
	""" SC_LC_NORMAL
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:303](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:303:9)
	""" :(@SC_LC_NORMAL)
	export @SC_LC_NORMAL, SC_LC_NORMAL
	macro SC_LC_NORMAL() return quote 2 end end
	const SC_LC_NORMAL = (@SC_LC_NORMAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:319](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:319:9)
	""" :(@SC_LP_DEFAULT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:319](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:319:9)
	""" SC_LP_DEFAULT
	export @SC_LP_DEFAULT, SC_LP_DEFAULT
	macro SC_LP_DEFAULT() return quote (-1) end end
	const SC_LP_DEFAULT = (@SC_LP_DEFAULT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:320](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:320:9)
	""" SC_LP_ALWAYS
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:320](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:320:9)
	""" :(@SC_LP_ALWAYS)
	export @SC_LP_ALWAYS, SC_LP_ALWAYS
	macro SC_LP_ALWAYS() return quote 0 end end
	const SC_LP_ALWAYS = (@SC_LP_ALWAYS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:321](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:321:9)
	""" :(@SC_LP_TRACE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:321](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:321:9)
	""" SC_LP_TRACE
	export @SC_LP_TRACE, SC_LP_TRACE
	macro SC_LP_TRACE() return quote 1 end end
	const SC_LP_TRACE = (@SC_LP_TRACE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:322](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:322:9)
	""" :(@SC_LP_DEBUG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:322](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:322:9)
	""" SC_LP_DEBUG
	export @SC_LP_DEBUG, SC_LP_DEBUG
	macro SC_LP_DEBUG() return quote 2 end end
	const SC_LP_DEBUG = (@SC_LP_DEBUG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:323](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:323:9)
	""" :(@SC_LP_VERBOSE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:323](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:323:9)
	""" SC_LP_VERBOSE
	export @SC_LP_VERBOSE, SC_LP_VERBOSE
	macro SC_LP_VERBOSE() return quote 3 end end
	const SC_LP_VERBOSE = (@SC_LP_VERBOSE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:324](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:324:9)
	""" :(@SC_LP_INFO)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:324](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:324:9)
	""" SC_LP_INFO
	export @SC_LP_INFO, SC_LP_INFO
	macro SC_LP_INFO() return quote 4 end end
	const SC_LP_INFO = (@SC_LP_INFO)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:325](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:325:9)
	""" :(@SC_LP_STATISTICS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:325](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:325:9)
	""" SC_LP_STATISTICS
	export @SC_LP_STATISTICS, SC_LP_STATISTICS
	macro SC_LP_STATISTICS() return quote 5 end end
	const SC_LP_STATISTICS = (@SC_LP_STATISTICS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:326](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:326:9)
	""" SC_LP_PRODUCTION
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:326](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:326:9)
	""" :(@SC_LP_PRODUCTION)
	export @SC_LP_PRODUCTION, SC_LP_PRODUCTION
	macro SC_LP_PRODUCTION() return quote 6 end end
	const SC_LP_PRODUCTION = (@SC_LP_PRODUCTION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:327](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:327:9)
	""" :(@SC_LP_ESSENTIAL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:327](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:327:9)
	""" SC_LP_ESSENTIAL
	export @SC_LP_ESSENTIAL, SC_LP_ESSENTIAL
	macro SC_LP_ESSENTIAL() return quote 7 end end
	const SC_LP_ESSENTIAL = (@SC_LP_ESSENTIAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:328](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:328:9)
	""" SC_LP_ERROR
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:328](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:328:9)
	""" :(@SC_LP_ERROR)
	export @SC_LP_ERROR, SC_LP_ERROR
	macro SC_LP_ERROR() return quote 8 end end
	const SC_LP_ERROR = (@SC_LP_ERROR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:329:9)
	""" SC_LP_SILENT
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:329:9)
	""" :(@SC_LP_SILENT)
	export @SC_LP_SILENT, SC_LP_SILENT
	macro SC_LP_SILENT() return quote 9 end end
	const SC_LP_SILENT = (@SC_LP_SILENT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:341](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/sc.h:341:9)
	""" :(@SC_LP_THRESHOLD)
	export @SC_LP_THRESHOLD
	macro SC_LP_THRESHOLD() return quote (@SC_LP_INFO) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:2](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:2:9)
	""" _CONFIG_P_EST_CONFIG_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:2](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:2:9)
	""" :(@_CONFIG_P_EST_CONFIG_H)
	export @_CONFIG_P_EST_CONFIG_H
	macro _CONFIG_P_EST_CONFIG_H() return quote 1 end end
	const _CONFIG_P_EST_CONFIG_H = (@_CONFIG_P_EST_CONFIG_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:10](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:10:9)
	""" P4EST_BUILD_2D
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:10](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:10:9)
	""" :(@P4EST_BUILD_2D)
	export @P4EST_BUILD_2D, P4EST_BUILD_2D
	macro P4EST_BUILD_2D() return quote 1 end end
	const P4EST_BUILD_2D = (@P4EST_BUILD_2D)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:15](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:15:9)
	""" P4EST_BUILD_3D
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:15](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:15:9)
	""" :(@P4EST_BUILD_3D)
	export @P4EST_BUILD_3D, P4EST_BUILD_3D
	macro P4EST_BUILD_3D() return quote 1 end end
	const P4EST_BUILD_3D = (@P4EST_BUILD_3D)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:20](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:20:9)
	""" :(@P4EST_BUILD_P6EST)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:20](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:20:9)
	""" P4EST_BUILD_P6EST
	export @P4EST_BUILD_P6EST, P4EST_BUILD_P6EST
	macro P4EST_BUILD_P6EST() return quote 1 end end
	const P4EST_BUILD_P6EST = (@P4EST_BUILD_P6EST)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:25](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:25:9)
	""" :(@P4EST_CC)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:25](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:25:9)
	""" P4EST_CC
	export @P4EST_CC, P4EST_CC
	macro P4EST_CC() return quote "cc" end end
	const P4EST_CC = (@P4EST_CC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:30](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:30:9)
	""" :(@P4EST_CFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:30](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:30:9)
	""" P4EST_CFLAGS
	export @P4EST_CFLAGS, P4EST_CFLAGS
	macro P4EST_CFLAGS() return quote "-g -O2" end end
	const P4EST_CFLAGS = (@P4EST_CFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:35](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:35:9)
	""" P4EST_CPP
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:35](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:35:9)
	""" :(@P4EST_CPP)
	export @P4EST_CPP, P4EST_CPP
	macro P4EST_CPP() return quote "cc -E" end end
	const P4EST_CPP = (@P4EST_CPP)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:40](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:40:9)
	""" P4EST_CPPFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:40](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:40:9)
	""" :(@P4EST_CPPFLAGS)
	export @P4EST_CPPFLAGS, P4EST_CPPFLAGS
	macro P4EST_CPPFLAGS() return quote "-I/workspace/destdir/include" end end
	const P4EST_CPPFLAGS = (@P4EST_CPPFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:51:9)
	""" P4EST_ENABLE_BUILD_2D
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:51:9)
	""" :(@P4EST_ENABLE_BUILD_2D)
	export @P4EST_ENABLE_BUILD_2D, P4EST_ENABLE_BUILD_2D
	macro P4EST_ENABLE_BUILD_2D() return quote 1 end end
	const P4EST_ENABLE_BUILD_2D = (@P4EST_ENABLE_BUILD_2D)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:56:9)
	""" :(@P4EST_ENABLE_BUILD_3D)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:56:9)
	""" P4EST_ENABLE_BUILD_3D
	export @P4EST_ENABLE_BUILD_3D, P4EST_ENABLE_BUILD_3D
	macro P4EST_ENABLE_BUILD_3D() return quote 1 end end
	const P4EST_ENABLE_BUILD_3D = (@P4EST_ENABLE_BUILD_3D)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:61](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:61:9)
	""" P4EST_ENABLE_BUILD_P6EST
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:61](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:61:9)
	""" :(@P4EST_ENABLE_BUILD_P6EST)
	export @P4EST_ENABLE_BUILD_P6EST, P4EST_ENABLE_BUILD_P6EST
	macro P4EST_ENABLE_BUILD_P6EST() return quote 1 end end
	const P4EST_ENABLE_BUILD_P6EST = (@P4EST_ENABLE_BUILD_P6EST)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:70](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:70:9)
	""" :(@P4EST_ENABLE_MEMALIGN)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:70](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:70:9)
	""" P4EST_ENABLE_MEMALIGN
	export @P4EST_ENABLE_MEMALIGN, P4EST_ENABLE_MEMALIGN
	macro P4EST_ENABLE_MEMALIGN() return quote 1 end end
	const P4EST_ENABLE_MEMALIGN = (@P4EST_ENABLE_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:105](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:105:9)
	""" :(@P4EST_ENABLE_VTK_BINARY)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:105](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:105:9)
	""" P4EST_ENABLE_VTK_BINARY
	export @P4EST_ENABLE_VTK_BINARY, P4EST_ENABLE_VTK_BINARY
	macro P4EST_ENABLE_VTK_BINARY() return quote 1 end end
	const P4EST_ENABLE_VTK_BINARY = (@P4EST_ENABLE_VTK_BINARY)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:110](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:110:9)
	""" P4EST_ENABLE_VTK_COMPRESSION
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:110](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:110:9)
	""" :(@P4EST_ENABLE_VTK_COMPRESSION)
	export @P4EST_ENABLE_VTK_COMPRESSION, P4EST_ENABLE_VTK_COMPRESSION
	macro P4EST_ENABLE_VTK_COMPRESSION() return quote 1 end end
	const P4EST_ENABLE_VTK_COMPRESSION = (@P4EST_ENABLE_VTK_COMPRESSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:160](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:160:9)
	""" P4EST_HAVE_ARPA_INET_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:160](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:160:9)
	""" :(@P4EST_HAVE_ARPA_INET_H)
	export @P4EST_HAVE_ARPA_INET_H, P4EST_HAVE_ARPA_INET_H
	macro P4EST_HAVE_ARPA_INET_H() return quote 1 end end
	const P4EST_HAVE_ARPA_INET_H = (@P4EST_HAVE_ARPA_INET_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:165](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:165:9)
	""" :(@P4EST_HAVE_DLFCN_H)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:165](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:165:9)
	""" P4EST_HAVE_DLFCN_H
	export @P4EST_HAVE_DLFCN_H, P4EST_HAVE_DLFCN_H
	macro P4EST_HAVE_DLFCN_H() return quote 1 end end
	const P4EST_HAVE_DLFCN_H = (@P4EST_HAVE_DLFCN_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:170](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:170:9)
	""" :(@P4EST_HAVE_INTTYPES_H)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:170](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:170:9)
	""" P4EST_HAVE_INTTYPES_H
	export @P4EST_HAVE_INTTYPES_H, P4EST_HAVE_INTTYPES_H
	macro P4EST_HAVE_INTTYPES_H() return quote 1 end end
	const P4EST_HAVE_INTTYPES_H = (@P4EST_HAVE_INTTYPES_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:181](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:181:9)
	""" P4EST_HAVE_MEMORY_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:181](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:181:9)
	""" :(@P4EST_HAVE_MEMORY_H)
	export @P4EST_HAVE_MEMORY_H, P4EST_HAVE_MEMORY_H
	macro P4EST_HAVE_MEMORY_H() return quote 1 end end
	const P4EST_HAVE_MEMORY_H = (@P4EST_HAVE_MEMORY_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:186](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:186:9)
	""" P4EST_HAVE_NETINET_IN_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:186](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:186:9)
	""" :(@P4EST_HAVE_NETINET_IN_H)
	export @P4EST_HAVE_NETINET_IN_H, P4EST_HAVE_NETINET_IN_H
	macro P4EST_HAVE_NETINET_IN_H() return quote 1 end end
	const P4EST_HAVE_NETINET_IN_H = (@P4EST_HAVE_NETINET_IN_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:194](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:194:9)
	""" P4EST_HAVE_POSIX_MEMALIGN
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:194](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:194:9)
	""" :(@P4EST_HAVE_POSIX_MEMALIGN)
	export @P4EST_HAVE_POSIX_MEMALIGN, P4EST_HAVE_POSIX_MEMALIGN
	macro P4EST_HAVE_POSIX_MEMALIGN() return quote 1 end end
	const P4EST_HAVE_POSIX_MEMALIGN = (@P4EST_HAVE_POSIX_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:199](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:199:9)
	""" P4EST_HAVE_STDINT_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:199](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:199:9)
	""" :(@P4EST_HAVE_STDINT_H)
	export @P4EST_HAVE_STDINT_H, P4EST_HAVE_STDINT_H
	macro P4EST_HAVE_STDINT_H() return quote 1 end end
	const P4EST_HAVE_STDINT_H = (@P4EST_HAVE_STDINT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:204](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:204:9)
	""" P4EST_HAVE_STDLIB_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:204](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:204:9)
	""" :(@P4EST_HAVE_STDLIB_H)
	export @P4EST_HAVE_STDLIB_H, P4EST_HAVE_STDLIB_H
	macro P4EST_HAVE_STDLIB_H() return quote 1 end end
	const P4EST_HAVE_STDLIB_H = (@P4EST_HAVE_STDLIB_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:209](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:209:9)
	""" P4EST_HAVE_STRINGS_H
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:209](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:209:9)
	""" :(@P4EST_HAVE_STRINGS_H)
	export @P4EST_HAVE_STRINGS_H, P4EST_HAVE_STRINGS_H
	macro P4EST_HAVE_STRINGS_H() return quote 1 end end
	const P4EST_HAVE_STRINGS_H = (@P4EST_HAVE_STRINGS_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:214:9)
	""" :(@P4EST_HAVE_STRING_H)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:214](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:214:9)
	""" P4EST_HAVE_STRING_H
	export @P4EST_HAVE_STRING_H, P4EST_HAVE_STRING_H
	macro P4EST_HAVE_STRING_H() return quote 1 end end
	const P4EST_HAVE_STRING_H = (@P4EST_HAVE_STRING_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:219](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:219:9)
	""" :(@P4EST_HAVE_SYS_STAT_H)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:219](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:219:9)
	""" P4EST_HAVE_SYS_STAT_H
	export @P4EST_HAVE_SYS_STAT_H, P4EST_HAVE_SYS_STAT_H
	macro P4EST_HAVE_SYS_STAT_H() return quote 1 end end
	const P4EST_HAVE_SYS_STAT_H = (@P4EST_HAVE_SYS_STAT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:224](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:224:9)
	""" :(@P4EST_HAVE_SYS_TYPES_H)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:224](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:224:9)
	""" P4EST_HAVE_SYS_TYPES_H
	export @P4EST_HAVE_SYS_TYPES_H, P4EST_HAVE_SYS_TYPES_H
	macro P4EST_HAVE_SYS_TYPES_H() return quote 1 end end
	const P4EST_HAVE_SYS_TYPES_H = (@P4EST_HAVE_SYS_TYPES_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:229](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:229:9)
	""" :(@P4EST_HAVE_UNISTD_H)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:229](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:229:9)
	""" P4EST_HAVE_UNISTD_H
	export @P4EST_HAVE_UNISTD_H, P4EST_HAVE_UNISTD_H
	macro P4EST_HAVE_UNISTD_H() return quote 1 end end
	const P4EST_HAVE_UNISTD_H = (@P4EST_HAVE_UNISTD_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:234](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:234:9)
	""" :(@P4EST_HAVE_ZLIB)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:234](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:234:9)
	""" P4EST_HAVE_ZLIB
	export @P4EST_HAVE_ZLIB, P4EST_HAVE_ZLIB
	macro P4EST_HAVE_ZLIB() return quote 1 end end
	const P4EST_HAVE_ZLIB = (@P4EST_HAVE_ZLIB)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:239](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:239:9)
	""" :(@P4EST_LDFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:239](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:239:9)
	""" P4EST_LDFLAGS
	export @P4EST_LDFLAGS, P4EST_LDFLAGS
	macro P4EST_LDFLAGS() return quote "-L/workspace/destdir/lib" end end
	const P4EST_LDFLAGS = (@P4EST_LDFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:244](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:244:9)
	""" P4EST_LIBS
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:244](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:244:9)
	""" :(@P4EST_LIBS)
	export @P4EST_LIBS, P4EST_LIBS
	macro P4EST_LIBS() return quote "  -lz -lm   " end end
	const P4EST_LIBS = (@P4EST_LIBS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:249](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:249:9)
	""" P4EST_LT_OBJDIR
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:249](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:249:9)
	""" :(@P4EST_LT_OBJDIR)
	export @P4EST_LT_OBJDIR, P4EST_LT_OBJDIR
	macro P4EST_LT_OBJDIR() return quote ".libs/" end end
	const P4EST_LT_OBJDIR = (@P4EST_LT_OBJDIR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:254](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:254:9)
	""" :(@P4EST_MEMALIGN)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:254](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:254:9)
	""" P4EST_MEMALIGN
	export @P4EST_MEMALIGN, P4EST_MEMALIGN
	macro P4EST_MEMALIGN() return quote 1 end end
	const P4EST_MEMALIGN = (@P4EST_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:259](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:259:9)
	""" :(@P4EST_MEMALIGN_BYTES)
	export @P4EST_MEMALIGN_BYTES
	macro P4EST_MEMALIGN_BYTES() return quote ((@P4EST_SIZEOF_VOID_P)) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:279](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:279:9)
	""" P4EST_PACKAGE
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:279](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:279:9)
	""" :(@P4EST_PACKAGE)
	export @P4EST_PACKAGE, P4EST_PACKAGE
	macro P4EST_PACKAGE() return quote "p4est" end end
	const P4EST_PACKAGE = (@P4EST_PACKAGE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:284](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:284:9)
	""" :(@P4EST_PACKAGE_BUGREPORT)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:284](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:284:9)
	""" P4EST_PACKAGE_BUGREPORT
	export @P4EST_PACKAGE_BUGREPORT, P4EST_PACKAGE_BUGREPORT
	macro P4EST_PACKAGE_BUGREPORT() return quote "p4est@ins.uni-bonn.de" end end
	const P4EST_PACKAGE_BUGREPORT = (@P4EST_PACKAGE_BUGREPORT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:289](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:289:9)
	""" :(@P4EST_PACKAGE_NAME)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:289](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:289:9)
	""" P4EST_PACKAGE_NAME
	export @P4EST_PACKAGE_NAME, P4EST_PACKAGE_NAME
	macro P4EST_PACKAGE_NAME() return quote "p4est" end end
	const P4EST_PACKAGE_NAME = (@P4EST_PACKAGE_NAME)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:294](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:294:9)
	""" :(@P4EST_PACKAGE_STRING)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:294](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:294:9)
	""" P4EST_PACKAGE_STRING
	export @P4EST_PACKAGE_STRING, P4EST_PACKAGE_STRING
	macro P4EST_PACKAGE_STRING() return quote "p4est 2.3.1" end end
	const P4EST_PACKAGE_STRING = (@P4EST_PACKAGE_STRING)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:299:9)
	""" :(@P4EST_PACKAGE_TARNAME)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:299](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:299:9)
	""" P4EST_PACKAGE_TARNAME
	export @P4EST_PACKAGE_TARNAME, P4EST_PACKAGE_TARNAME
	macro P4EST_PACKAGE_TARNAME() return quote "p4est" end end
	const P4EST_PACKAGE_TARNAME = (@P4EST_PACKAGE_TARNAME)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:304](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:304:9)
	""" P4EST_PACKAGE_URL
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:304](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:304:9)
	""" :(@P4EST_PACKAGE_URL)
	export @P4EST_PACKAGE_URL, P4EST_PACKAGE_URL
	macro P4EST_PACKAGE_URL() return quote "" end end
	const P4EST_PACKAGE_URL = (@P4EST_PACKAGE_URL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:309](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:309:9)
	""" P4EST_PACKAGE_VERSION
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:309](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:309:9)
	""" :(@P4EST_PACKAGE_VERSION)
	export @P4EST_PACKAGE_VERSION, P4EST_PACKAGE_VERSION
	macro P4EST_PACKAGE_VERSION() return quote "2.3.1" end end
	const P4EST_PACKAGE_VERSION = (@P4EST_PACKAGE_VERSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:329:9)
	""" P4EST_SIZEOF_VOID_P
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:329](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:329:9)
	""" :(@P4EST_SIZEOF_VOID_P)
	export @P4EST_SIZEOF_VOID_P, P4EST_SIZEOF_VOID_P
	macro P4EST_SIZEOF_VOID_P() return quote 8 end end
	const P4EST_SIZEOF_VOID_P = (@P4EST_SIZEOF_VOID_P)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:334](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:334:9)
	""" :(@P4EST_STDC_HEADERS)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:334](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:334:9)
	""" P4EST_STDC_HEADERS
	export @P4EST_STDC_HEADERS, P4EST_STDC_HEADERS
	macro P4EST_STDC_HEADERS() return quote 1 end end
	const P4EST_STDC_HEADERS = (@P4EST_STDC_HEADERS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:339](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:339:9)
	""" :(@P4EST_VERSION)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:339](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:339:9)
	""" P4EST_VERSION
	export @P4EST_VERSION, P4EST_VERSION
	macro P4EST_VERSION() return quote "2.3.1" end end
	const P4EST_VERSION = (@P4EST_VERSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:344](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:344:9)
	""" :(@P4EST_VERSION_MAJOR)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:344](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:344:9)
	""" P4EST_VERSION_MAJOR
	export @P4EST_VERSION_MAJOR, P4EST_VERSION_MAJOR
	macro P4EST_VERSION_MAJOR() return quote 2 end end
	const P4EST_VERSION_MAJOR = (@P4EST_VERSION_MAJOR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:349](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:349:9)
	""" :(@P4EST_VERSION_MINOR)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:349](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:349:9)
	""" P4EST_VERSION_MINOR
	export @P4EST_VERSION_MINOR, P4EST_VERSION_MINOR
	macro P4EST_VERSION_MINOR() return quote 3 end end
	const P4EST_VERSION_MINOR = (@P4EST_VERSION_MINOR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:354](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:354:9)
	""" :(@P4EST_VERSION_POINT)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:354](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:354:9)
	""" P4EST_VERSION_POINT
	export @P4EST_VERSION_POINT, P4EST_VERSION_POINT
	macro P4EST_VERSION_POINT() return quote 1 end end
	const P4EST_VERSION_POINT = (@P4EST_VERSION_POINT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:359](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:359:9)
	""" :(@P4EST_VTK_BINARY)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:359](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:359:9)
	""" P4EST_VTK_BINARY
	export @P4EST_VTK_BINARY, P4EST_VTK_BINARY
	macro P4EST_VTK_BINARY() return quote 1 end end
	const P4EST_VTK_BINARY = (@P4EST_VTK_BINARY)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:364](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:364:9)
	""" :(@P4EST_VTK_COMPRESSION)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_config.h:364](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_config.h:364:9)
	""" P4EST_VTK_COMPRESSION
	export @P4EST_VTK_COMPRESSION, P4EST_VTK_COMPRESSION
	macro P4EST_VTK_COMPRESSION() return quote 1 end end
	const P4EST_VTK_COMPRESSION = (@P4EST_VTK_COMPRESSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:49](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:49:9)
	""" :(@_p4est_const)
	export @_p4est_const
	macro _p4est_const() return quote (@_sc_const) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:79](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:79:9)
	""" :(@p4est_qcoord_compare)
	export @p4est_qcoord_compare
	macro p4est_qcoord_compare() return quote (@sc_int32_compare) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:80](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:80:9)
	""" :(@P4EST_QCOORD_BITS)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:80](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:80:9)
	""" P4EST_QCOORD_BITS
	export @P4EST_QCOORD_BITS, P4EST_QCOORD_BITS
	macro P4EST_QCOORD_BITS() return quote 32 end end
	const P4EST_QCOORD_BITS = (@P4EST_QCOORD_BITS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:81](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:81:9)
	""" :(@P4EST_MPI_QCOORD)
	export @P4EST_MPI_QCOORD
	macro P4EST_MPI_QCOORD() return quote (@sc_MPI_INT) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:82](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:82:9)
	""" :(@P4EST_VTK_QCOORD)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:82](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:82:9)
	""" P4EST_VTK_QCOORD
	export @P4EST_VTK_QCOORD, P4EST_VTK_QCOORD
	macro P4EST_VTK_QCOORD() return quote "Int32" end end
	const P4EST_VTK_QCOORD = (@P4EST_VTK_QCOORD)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:84](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:84:9)
	""" :(@P4EST_QCOORD_MIN)
	export @P4EST_QCOORD_MIN
	macro P4EST_QCOORD_MIN() return quote (@INT32_MIN) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:85](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:85:9)
	""" :(@P4EST_QCOORD_MAX)
	export @P4EST_QCOORD_MAX
	macro P4EST_QCOORD_MAX() return quote (@INT32_MAX) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:91](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:91:9)
	""" :(@p4est_topidx_compare)
	export @p4est_topidx_compare
	macro p4est_topidx_compare() return quote (@sc_int32_compare) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:92:9)
	""" :(@P4EST_TOPIDX_BITS)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:92](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:92:9)
	""" P4EST_TOPIDX_BITS
	export @P4EST_TOPIDX_BITS, P4EST_TOPIDX_BITS
	macro P4EST_TOPIDX_BITS() return quote 32 end end
	const P4EST_TOPIDX_BITS = (@P4EST_TOPIDX_BITS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:93](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:93:9)
	""" :(@P4EST_MPI_TOPIDX)
	export @P4EST_MPI_TOPIDX
	macro P4EST_MPI_TOPIDX() return quote (@sc_MPI_INT) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:94](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:94:9)
	""" P4EST_VTK_TOPIDX
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:94](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:94:9)
	""" :(@P4EST_VTK_TOPIDX)
	export @P4EST_VTK_TOPIDX, P4EST_VTK_TOPIDX
	macro P4EST_VTK_TOPIDX() return quote "Int32" end end
	const P4EST_VTK_TOPIDX = (@P4EST_VTK_TOPIDX)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:96](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:96:9)
	""" :(@P4EST_TOPIDX_MIN)
	export @P4EST_TOPIDX_MIN
	macro P4EST_TOPIDX_MIN() return quote (@INT32_MIN) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:97](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:97:9)
	""" :(@P4EST_TOPIDX_MAX)
	export @P4EST_TOPIDX_MAX
	macro P4EST_TOPIDX_MAX() return quote (@INT32_MAX) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:98](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:98:9)
	""" P4EST_TOPIDX_FITS_32
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:98](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:98:9)
	""" :(@P4EST_TOPIDX_FITS_32)
	export @P4EST_TOPIDX_FITS_32, P4EST_TOPIDX_FITS_32
	macro P4EST_TOPIDX_FITS_32() return quote 1 end end
	const P4EST_TOPIDX_FITS_32 = (@P4EST_TOPIDX_FITS_32)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:104](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:104:9)
	""" :(@p4est_locidx_compare)
	export @p4est_locidx_compare
	macro p4est_locidx_compare() return quote (@sc_int32_compare) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:105](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:105:9)
	""" :(@P4EST_LOCIDX_BITS)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:105](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:105:9)
	""" P4EST_LOCIDX_BITS
	export @P4EST_LOCIDX_BITS, P4EST_LOCIDX_BITS
	macro P4EST_LOCIDX_BITS() return quote 32 end end
	const P4EST_LOCIDX_BITS = (@P4EST_LOCIDX_BITS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:106](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:106:9)
	""" :(@P4EST_MPI_LOCIDX)
	export @P4EST_MPI_LOCIDX
	macro P4EST_MPI_LOCIDX() return quote (@sc_MPI_INT) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:107](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:107:9)
	""" :(@P4EST_VTK_LOCIDX)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:107](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:107:9)
	""" P4EST_VTK_LOCIDX
	export @P4EST_VTK_LOCIDX, P4EST_VTK_LOCIDX
	macro P4EST_VTK_LOCIDX() return quote "Int32" end end
	const P4EST_VTK_LOCIDX = (@P4EST_VTK_LOCIDX)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:109](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:109:9)
	""" :(@P4EST_LOCIDX_MIN)
	export @P4EST_LOCIDX_MIN
	macro P4EST_LOCIDX_MIN() return quote (@INT32_MIN) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:110](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:110:9)
	""" :(@P4EST_LOCIDX_MAX)
	export @P4EST_LOCIDX_MAX
	macro P4EST_LOCIDX_MAX() return quote (@INT32_MAX) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:116](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:116:9)
	""" :(@p4est_gloidx_compare)
	export @p4est_gloidx_compare
	macro p4est_gloidx_compare() return quote (@sc_int64_compare) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:117](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:117:9)
	""" P4EST_GLOIDX_BITS
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:117](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:117:9)
	""" :(@P4EST_GLOIDX_BITS)
	export @P4EST_GLOIDX_BITS, P4EST_GLOIDX_BITS
	macro P4EST_GLOIDX_BITS() return quote 64 end end
	const P4EST_GLOIDX_BITS = (@P4EST_GLOIDX_BITS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:118](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:118:9)
	""" :(@P4EST_MPI_GLOIDX)
	export @P4EST_MPI_GLOIDX
	macro P4EST_MPI_GLOIDX() return quote (@sc_MPI_LONG_LONG_INT) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:119](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:119:9)
	""" P4EST_VTK_GLOIDX
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:119](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:119:9)
	""" :(@P4EST_VTK_GLOIDX)
	export @P4EST_VTK_GLOIDX, P4EST_VTK_GLOIDX
	macro P4EST_VTK_GLOIDX() return quote "Int64" end end
	const P4EST_VTK_GLOIDX = (@P4EST_VTK_GLOIDX)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:121](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:121:9)
	""" :(@P4EST_GLOIDX_MIN)
	export @P4EST_GLOIDX_MIN
	macro P4EST_GLOIDX_MIN() return quote (@INT64_MIN) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:122](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:122:9)
	""" :(@P4EST_GLOIDX_MAX)
	export @P4EST_GLOIDX_MAX
	macro P4EST_GLOIDX_MAX() return quote (@INT64_MAX) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:268](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:268:9)
	""" :(@P4EST_GLOBAL_NOTICE)
	export @P4EST_GLOBAL_NOTICE
	macro P4EST_GLOBAL_NOTICE() return quote (@P4EST_GLOBAL_STATISTICS) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:269](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:269:9)
	""" :(@P4EST_GLOBAL_NOTICEF)
	export @P4EST_GLOBAL_NOTICEF
	macro P4EST_GLOBAL_NOTICEF() return quote (@P4EST_GLOBAL_STATISTICSF) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:314](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:314:9)
	""" :(@P4EST_NOTICE)
	export @P4EST_NOTICE
	macro P4EST_NOTICE() return quote (@P4EST_STATISTICS) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_base.h:315](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_base.h:315:9)
	""" :(@P4EST_NOTICEF)
	export @P4EST_NOTICEF
	macro P4EST_NOTICEF() return quote (@P4EST_STATISTICSF) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:45](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:45:9)
	""" P4EST_DIM
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:45](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:45:9)
	""" :(@P4EST_DIM)
	export @P4EST_DIM, P4EST_DIM
	macro P4EST_DIM() return quote 2 end end
	const P4EST_DIM = (@P4EST_DIM)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:51:9)
	""" :(@P4EST_CHILDREN)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:51:9)
	""" P4EST_CHILDREN
	export @P4EST_CHILDREN, P4EST_CHILDREN
	macro P4EST_CHILDREN() return quote 4 end end
	const P4EST_CHILDREN = (@P4EST_CHILDREN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:55](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:55:9)
	""" P4EST_INSUL
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:55](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:55:9)
	""" :(@P4EST_INSUL)
	export @P4EST_INSUL, P4EST_INSUL
	macro P4EST_INSUL() return quote 9 end end
	const P4EST_INSUL = (@P4EST_INSUL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:67](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:67:9)
	""" :(@P4EST_FTRANSFORM)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:67](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:67:9)
	""" P4EST_FTRANSFORM
	export @P4EST_FTRANSFORM, P4EST_FTRANSFORM
	macro P4EST_FTRANSFORM() return quote 9 end end
	const P4EST_FTRANSFORM = (@P4EST_FTRANSFORM)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:70](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:70:9)
	""" :(@P4EST_STRING)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:70](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:70:9)
	""" P4EST_STRING
	export @P4EST_STRING, P4EST_STRING
	macro P4EST_STRING() return quote "p4est" end end
	const P4EST_STRING = (@P4EST_STRING)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:76](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:76:9)
	""" :(@P4EST_ONDISK_FORMAT)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est_connectivity.h:76](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est_connectivity.h:76:9)
	""" P4EST_ONDISK_FORMAT
	export @P4EST_ONDISK_FORMAT, P4EST_ONDISK_FORMAT
	macro P4EST_ONDISK_FORMAT() return quote 0x02000009 end end
	const P4EST_ONDISK_FORMAT = (@P4EST_ONDISK_FORMAT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:50](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:50:9)
	""" :(@P4EST_OLD_MAXLEVEL)
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:50](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:50:9)
	""" P4EST_OLD_MAXLEVEL
	export @P4EST_OLD_MAXLEVEL, P4EST_OLD_MAXLEVEL
	macro P4EST_OLD_MAXLEVEL() return quote 30 end end
	const P4EST_OLD_MAXLEVEL = (@P4EST_OLD_MAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:51:9)
	""" P4EST_MAXLEVEL
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:51:9)
	""" :(@P4EST_MAXLEVEL)
	export @P4EST_MAXLEVEL, P4EST_MAXLEVEL
	macro P4EST_MAXLEVEL() return quote 30 end end
	const P4EST_MAXLEVEL = (@P4EST_MAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:54](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:54:9)
	""" P4EST_OLD_QMAXLEVEL
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:54](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:54:9)
	""" :(@P4EST_OLD_QMAXLEVEL)
	export @P4EST_OLD_QMAXLEVEL, P4EST_OLD_QMAXLEVEL
	macro P4EST_OLD_QMAXLEVEL() return quote 29 end end
	const P4EST_OLD_QMAXLEVEL = (@P4EST_OLD_QMAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:55](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:55:9)
	""" P4EST_QMAXLEVEL
	𝐣𝐥.@doc """
	## Reference
	
	[p4est.h:55](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p4est.h:55:9)
	""" :(@P4EST_QMAXLEVEL)
	export @P4EST_QMAXLEVEL, P4EST_QMAXLEVEL
	macro P4EST_QMAXLEVEL() return quote 29 end end
	const P4EST_QMAXLEVEL = (@P4EST_QMAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:41](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:41:9)
	""" P8EST_DIM
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:41](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:41:9)
	""" :(@P8EST_DIM)
	export @P8EST_DIM, P8EST_DIM
	macro P8EST_DIM() return quote 3 end end
	const P8EST_DIM = (@P8EST_DIM)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:50](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:50:9)
	""" :(@P8EST_CHILDREN)
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:50](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:50:9)
	""" P8EST_CHILDREN
	export @P8EST_CHILDREN, P8EST_CHILDREN
	macro P8EST_CHILDREN() return quote 8 end end
	const P8EST_CHILDREN = (@P8EST_CHILDREN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:54](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:54:9)
	""" P8EST_EDGES
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:54](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:54:9)
	""" :(@P8EST_EDGES)
	export @P8EST_EDGES, P8EST_EDGES
	macro P8EST_EDGES() return quote 12 end end
	const P8EST_EDGES = (@P8EST_EDGES)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:56:9)
	""" P8EST_INSUL
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:56](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:56:9)
	""" :(@P8EST_INSUL)
	export @P8EST_INSUL, P8EST_INSUL
	macro P8EST_INSUL() return quote 27 end end
	const P8EST_INSUL = (@P8EST_INSUL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:68](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:68:9)
	""" P8EST_FTRANSFORM
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:68](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:68:9)
	""" :(@P8EST_FTRANSFORM)
	export @P8EST_FTRANSFORM, P8EST_FTRANSFORM
	macro P8EST_FTRANSFORM() return quote 9 end end
	const P8EST_FTRANSFORM = (@P8EST_FTRANSFORM)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:71](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:71:9)
	""" :(@P8EST_STRING)
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:71](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:71:9)
	""" P8EST_STRING
	export @P8EST_STRING, P8EST_STRING
	macro P8EST_STRING() return quote "p8est" end end
	const P8EST_STRING = (@P8EST_STRING)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:77](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:77:9)
	""" :(@P8EST_ONDISK_FORMAT)
	𝐣𝐥.@doc """
	## Reference
	
	[p8est_connectivity.h:77](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est_connectivity.h:77:9)
	""" P8EST_ONDISK_FORMAT
	export @P8EST_ONDISK_FORMAT, P8EST_ONDISK_FORMAT
	macro P8EST_ONDISK_FORMAT() return quote 0x03000009 end end
	const P8EST_ONDISK_FORMAT = (@P8EST_ONDISK_FORMAT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:46](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:46:9)
	""" P8EST_OLD_MAXLEVEL
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:46](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:46:9)
	""" :(@P8EST_OLD_MAXLEVEL)
	export @P8EST_OLD_MAXLEVEL, P8EST_OLD_MAXLEVEL
	macro P8EST_OLD_MAXLEVEL() return quote 19 end end
	const P8EST_OLD_MAXLEVEL = (@P8EST_OLD_MAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:47](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:47:9)
	""" :(@P8EST_MAXLEVEL)
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:47](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:47:9)
	""" P8EST_MAXLEVEL
	export @P8EST_MAXLEVEL, P8EST_MAXLEVEL
	macro P8EST_MAXLEVEL() return quote 30 end end
	const P8EST_MAXLEVEL = (@P8EST_MAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:50](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:50:9)
	""" P8EST_OLD_QMAXLEVEL
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:50](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:50:9)
	""" :(@P8EST_OLD_QMAXLEVEL)
	export @P8EST_OLD_QMAXLEVEL, P8EST_OLD_QMAXLEVEL
	macro P8EST_OLD_QMAXLEVEL() return quote 18 end end
	const P8EST_OLD_QMAXLEVEL = (@P8EST_OLD_QMAXLEVEL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:51:9)
	""" P8EST_QMAXLEVEL
	𝐣𝐥.@doc """
	## Reference
	
	[p8est.h:51](~/.julia/artifacts/d93837ed7e8410d90c6d1ada8c9009d8ad906db2/include/p8est.h:51:9)
	""" :(@P8EST_QMAXLEVEL)
	export @P8EST_QMAXLEVEL, P8EST_QMAXLEVEL
	macro P8EST_QMAXLEVEL() return quote 29 end end
	const P8EST_QMAXLEVEL = (@P8EST_QMAXLEVEL)
end
