# This file is automatically generated.  Do not edit.
using CBinding: 𝐣𝐥

𝐣𝐥.@cbindings "/home/mschlott/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/lib/libsc.so" begin
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:58](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:58:3)
	""" SC_TAG_AG_RECURSIVE_B
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:56](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:56:3)
	""" SC_TAG_AG_ALLTOALL
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:73](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:73:3)
	""" SC_TAG_PSORT_LO
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:60](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:60:3)
	""" SC_TAG_NOTIFY_CENSUS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:64](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:64:3)
	""" SC_TAG_NOTIFY_WRAPPER
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:71](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:71:3)
	""" SC_TAG_NOTIFY_NARY
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:68](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:68:3)
	""" SC_TAG_NOTIFY_SUPER_TRUE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:59](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:59:3)
	""" SC_TAG_AG_RECURSIVE_C
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:55](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:55:3)
	""" SC_TAG_FIRST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:69](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:69:3)
	""" SC_TAG_NOTIFY_SUPER_EXTRA
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:74](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:74:3)
	""" SC_TAG_PSORT_HI
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:70](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:70:3)
	""" SC_TAG_NOTIFY_RECURSIVE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:63](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:63:3)
	""" SC_TAG_NOTIFY_NBXV
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:57](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:57:3)
	""" SC_TAG_AG_RECURSIVE_A
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:75](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:75:3)
	""" SC_TAG_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:66](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:66:3)
	""" SC_TAG_NOTIFY_RANGES
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:61](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:61:3)
	""" SC_TAG_NOTIFY_CENSUSV
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:77](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:77:1)
	""" sc_tag_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:67](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:67:3)
	""" SC_TAG_NOTIFY_PAYLOAD
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:72](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:72:3)
	""" SC_TAG_REDUCE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:62](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:62:3)
	""" SC_TAG_NOTIFY_NBX
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:65](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:65:3)
	""" SC_TAG_NOTIFY_WRAPPERV
	export SC_TAG_AG_ALLTOALL, SC_TAG_AG_RECURSIVE_A, SC_TAG_AG_RECURSIVE_B, SC_TAG_AG_RECURSIVE_C, SC_TAG_FIRST, SC_TAG_LAST, SC_TAG_NOTIFY_CENSUS, SC_TAG_NOTIFY_CENSUSV, SC_TAG_NOTIFY_NARY, SC_TAG_NOTIFY_NBX, SC_TAG_NOTIFY_NBXV, SC_TAG_NOTIFY_PAYLOAD, SC_TAG_NOTIFY_RANGES, SC_TAG_NOTIFY_RECURSIVE, SC_TAG_NOTIFY_SUPER_EXTRA, SC_TAG_NOTIFY_SUPER_TRUE, SC_TAG_NOTIFY_WRAPPER, SC_TAG_NOTIFY_WRAPPERV, SC_TAG_PSORT_HI, SC_TAG_PSORT_LO, SC_TAG_REDUCE, sc_tag_t
	𝐣𝐥.@ctypedef sc_tag_t 𝐣𝐥.@cenum {
		SC_TAG_FIRST = 𝐣𝐥.Cuint(214)
		SC_TAG_AG_ALLTOALL = 𝐣𝐥.Cuint(214)
		SC_TAG_AG_RECURSIVE_A = 𝐣𝐥.Cuint(215)
		SC_TAG_AG_RECURSIVE_B = 𝐣𝐥.Cuint(216)
		SC_TAG_AG_RECURSIVE_C = 𝐣𝐥.Cuint(217)
		SC_TAG_NOTIFY_CENSUS = 𝐣𝐥.Cuint(218)
		SC_TAG_NOTIFY_CENSUSV = 𝐣𝐥.Cuint(219)
		SC_TAG_NOTIFY_NBX = 𝐣𝐥.Cuint(220)
		SC_TAG_NOTIFY_NBXV = 𝐣𝐥.Cuint(221)
		SC_TAG_NOTIFY_WRAPPER = 𝐣𝐥.Cuint(222)
		SC_TAG_NOTIFY_WRAPPERV = 𝐣𝐥.Cuint(223)
		SC_TAG_NOTIFY_RANGES = 𝐣𝐥.Cuint(224)
		SC_TAG_NOTIFY_PAYLOAD = 𝐣𝐥.Cuint(225)
		SC_TAG_NOTIFY_SUPER_TRUE = 𝐣𝐥.Cuint(226)
		SC_TAG_NOTIFY_SUPER_EXTRA = 𝐣𝐥.Cuint(227)
		SC_TAG_NOTIFY_RECURSIVE = 𝐣𝐥.Cuint(228)
		SC_TAG_NOTIFY_NARY = 𝐣𝐥.Cuint(260)
		SC_TAG_REDUCE = 𝐣𝐥.Cuint(292)
		SC_TAG_PSORT_LO = 𝐣𝐥.Cuint(293)
		SC_TAG_PSORT_HI = 𝐣𝐥.Cuint(294)
		SC_TAG_LAST = 𝐣𝐥.Cuint(295)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:262](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:262:21)
	""" sc_MPI_Comm
	export sc_MPI_Comm
	𝐣𝐥.@ctypedef sc_MPI_Comm 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:263](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:263:21)
	""" sc_MPI_Group
	export sc_MPI_Group
	𝐣𝐥.@ctypedef sc_MPI_Group 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:264](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:264:21)
	""" sc_MPI_Datatype
	export sc_MPI_Datatype
	𝐣𝐥.@ctypedef sc_MPI_Datatype 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:265](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:265:21)
	""" sc_MPI_Op
	export sc_MPI_Op
	𝐣𝐥.@ctypedef sc_MPI_Op 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:266](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:266:21)
	""" sc_MPI_Request
	export sc_MPI_Request
	𝐣𝐥.@ctypedef sc_MPI_Request 𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	## References
	
	[sc_mpi.h:267](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:267:16)
	
	[sc_mpi.h:275](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:275:1)
	""" sc_MPI_Status
	export sc_MPI_Status
	𝐣𝐥.@ctypedef sc_MPI_Status 𝐣𝐥.@cstruct sc_MPI_Status {
		count::𝐣𝐥.Cint
		cancelled::𝐣𝐥.Cint
		MPI_SOURCE::𝐣𝐥.Cint
		MPI_TAG::𝐣𝐥.Cint
		MPI_ERROR::𝐣𝐥.Cint
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Init(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:279](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:279:21)
	""" sc_MPI_Init
	export sc_MPI_Init
	𝐣𝐥.@cextern sc_MPI_Init(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Finalize()::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:282](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:282:21)
	""" sc_MPI_Finalize
	export sc_MPI_Finalize
	𝐣𝐥.@cextern sc_MPI_Finalize()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Abort(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:283](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:283:21)
	""" sc_MPI_Abort
	export sc_MPI_Abort
	𝐣𝐥.@cextern sc_MPI_Abort(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_dup(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:286](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:286:21)
	""" sc_MPI_Comm_dup
	export sc_MPI_Comm_dup
	𝐣𝐥.@cextern sc_MPI_Comm_dup(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_create(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:287](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:287:21)
	""" sc_MPI_Comm_create
	export sc_MPI_Comm_create
	𝐣𝐥.@cextern sc_MPI_Comm_create(var"?1?"::sc_MPI_Comm, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_split(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:289](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:289:21)
	""" sc_MPI_Comm_split
	export sc_MPI_Comm_split
	𝐣𝐥.@cextern sc_MPI_Comm_split(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Cint, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_free(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:290](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:290:21)
	""" sc_MPI_Comm_free
	export sc_MPI_Comm_free
	𝐣𝐥.@cextern sc_MPI_Comm_free(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_size(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:291](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:291:21)
	""" sc_MPI_Comm_size
	export sc_MPI_Comm_size
	𝐣𝐥.@cextern sc_MPI_Comm_size(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_rank(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:292](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:292:21)
	""" sc_MPI_Comm_rank
	export sc_MPI_Comm_rank
	𝐣𝐥.@cextern sc_MPI_Comm_rank(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_compare(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::sc_MPI_Comm, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:293](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:293:21)
	""" sc_MPI_Comm_compare
	export sc_MPI_Comm_compare
	𝐣𝐥.@cextern sc_MPI_Comm_compare(var"?1?"::sc_MPI_Comm, var"?2?"::sc_MPI_Comm, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Comm_group(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:294](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:294:21)
	""" sc_MPI_Comm_group
	export sc_MPI_Comm_group
	𝐣𝐥.@cextern sc_MPI_Comm_group(var"?1?"::sc_MPI_Comm, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_free(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:296](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:296:21)
	""" sc_MPI_Group_free
	export sc_MPI_Group_free
	𝐣𝐥.@cextern sc_MPI_Group_free(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_size(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:297](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:297:21)
	""" sc_MPI_Group_size
	export sc_MPI_Group_size
	𝐣𝐥.@cextern sc_MPI_Group_size(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_rank(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:298](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:298:21)
	""" sc_MPI_Group_rank
	export sc_MPI_Group_rank
	𝐣𝐥.@cextern sc_MPI_Group_rank(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_translate_ranks(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::sc_MPI_Group, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:299](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:299:21)
	""" sc_MPI_Group_translate_ranks
	export sc_MPI_Group_translate_ranks
	𝐣𝐥.@cextern sc_MPI_Group_translate_ranks(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::sc_MPI_Group, var"?5?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_compare(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:301](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:301:21)
	""" sc_MPI_Group_compare
	export sc_MPI_Group_compare
	𝐣𝐥.@cextern sc_MPI_Group_compare(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_union(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:302](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:302:21)
	""" sc_MPI_Group_union
	export sc_MPI_Group_union
	𝐣𝐥.@cextern sc_MPI_Group_union(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_intersection(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:304](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:304:21)
	""" sc_MPI_Group_intersection
	export sc_MPI_Group_intersection
	𝐣𝐥.@cextern sc_MPI_Group_intersection(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_difference(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:306](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:306:21)
	""" sc_MPI_Group_difference
	export sc_MPI_Group_difference
	𝐣𝐥.@cextern sc_MPI_Group_difference(var"?1?"::sc_MPI_Group, var"?2?"::sc_MPI_Group, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_incl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:308](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:308:21)
	""" sc_MPI_Group_incl
	export sc_MPI_Group_incl
	𝐣𝐥.@cextern sc_MPI_Group_incl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_excl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:310](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:310:21)
	""" sc_MPI_Group_excl
	export sc_MPI_Group_excl
	𝐣𝐥.@cextern sc_MPI_Group_excl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_range_incl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:312](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:312:21)
	""" sc_MPI_Group_range_incl
	export sc_MPI_Group_range_incl
	𝐣𝐥.@cextern sc_MPI_Group_range_incl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Group_range_excl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:314](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:314:21)
	""" sc_MPI_Group_range_excl
	export sc_MPI_Group_range_excl
	𝐣𝐥.@cextern sc_MPI_Group_range_excl(var"?1?"::sc_MPI_Group, var"?2?"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var"?4?"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Barrier(var\"?1?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:317](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:317:21)
	""" sc_MPI_Barrier
	export sc_MPI_Barrier
	𝐣𝐥.@cextern sc_MPI_Barrier(var"?1?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Bcast(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:318](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:318:21)
	""" sc_MPI_Bcast
	export sc_MPI_Bcast
	𝐣𝐥.@cextern sc_MPI_Bcast(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Gather(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::𝐣𝐥.Cint, var\"?8?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:320](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:320:21)
	""" sc_MPI_Gather
	export sc_MPI_Gather
	𝐣𝐥.@cextern sc_MPI_Gather(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Datatype, var"?7?"::𝐣𝐥.Cint, var"?8?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Gatherv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?6?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?7?\"::sc_MPI_Datatype, var\"?8?\"::𝐣𝐥.Cint, var\"?9?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:322](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:322:21)
	""" sc_MPI_Gatherv
	export sc_MPI_Gatherv
	𝐣𝐥.@cextern sc_MPI_Gatherv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?6?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?7?"::sc_MPI_Datatype, var"?8?"::𝐣𝐥.Cint, var"?9?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Allgather(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:325](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:325:21)
	""" sc_MPI_Allgather
	export sc_MPI_Allgather
	𝐣𝐥.@cextern sc_MPI_Allgather(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Datatype, var"?7?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Allgatherv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?6?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?7?\"::sc_MPI_Datatype, var\"?8?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:327](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:327:21)
	""" sc_MPI_Allgatherv
	export sc_MPI_Allgatherv
	𝐣𝐥.@cextern sc_MPI_Allgatherv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?6?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?7?"::sc_MPI_Datatype, var"?8?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Alltoall(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:330](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:330:21)
	""" sc_MPI_Alltoall
	export sc_MPI_Alltoall
	𝐣𝐥.@cextern sc_MPI_Alltoall(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Datatype, var"?7?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Reduce(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::𝐣𝐥.Cint, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:332](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:332:21)
	""" sc_MPI_Reduce
	export sc_MPI_Reduce
	𝐣𝐥.@cextern sc_MPI_Reduce(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::𝐣𝐥.Cint, var"?7?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Reduce_scatter_block(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:334](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:334:21)
	""" sc_MPI_Reduce_scatter_block
	export sc_MPI_Reduce_scatter_block
	𝐣𝐥.@cextern sc_MPI_Reduce_scatter_block(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Allreduce(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:337](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:337:21)
	""" sc_MPI_Allreduce
	export sc_MPI_Allreduce
	𝐣𝐥.@cextern sc_MPI_Allreduce(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Scan(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:339](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:339:21)
	""" sc_MPI_Scan
	export sc_MPI_Scan
	𝐣𝐥.@cextern sc_MPI_Scan(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Exscan(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:341](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:341:21)
	""" sc_MPI_Exscan
	export sc_MPI_Exscan
	𝐣𝐥.@cextern sc_MPI_Exscan(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?3?"::𝐣𝐥.Cint, var"?4?"::sc_MPI_Datatype, var"?5?"::sc_MPI_Op, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Wtime()::𝐣𝐥.Cdouble
	```
	
	## Reference
	
	[sc_mpi.h:344](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:344:21)
	""" sc_MPI_Wtime
	export sc_MPI_Wtime
	𝐣𝐥.@cextern sc_MPI_Wtime()::𝐣𝐥.Cdouble
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Recv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:348](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:348:21)
	""" sc_MPI_Recv
	export sc_MPI_Recv
	𝐣𝐥.@cextern sc_MPI_Recv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm, var"?7?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Irecv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:350](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:350:21)
	""" sc_MPI_Irecv
	export sc_MPI_Irecv
	𝐣𝐥.@cextern sc_MPI_Irecv(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm, var"?7?"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Send(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:352](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:352:21)
	""" sc_MPI_Send
	export sc_MPI_Send
	𝐣𝐥.@cextern sc_MPI_Send(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Isend(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:354](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:354:21)
	""" sc_MPI_Isend
	export sc_MPI_Isend
	𝐣𝐥.@cextern sc_MPI_Isend(var"?1?"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Datatype, var"?4?"::𝐣𝐥.Cint, var"?5?"::𝐣𝐥.Cint, var"?6?"::sc_MPI_Comm, var"?7?"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Probe(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Comm, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:356](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:356:21)
	""" sc_MPI_Probe
	export sc_MPI_Probe
	𝐣𝐥.@cextern sc_MPI_Probe(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Comm, var"?4?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Iprobe(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Comm, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?5?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:357](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:357:21)
	""" sc_MPI_Iprobe
	export sc_MPI_Iprobe
	𝐣𝐥.@cextern sc_MPI_Iprobe(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Cint, var"?3?"::sc_MPI_Comm, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?5?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Get_count(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Status}, var\"?2?\"::sc_MPI_Datatype, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:359](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:359:21)
	""" sc_MPI_Get_count
	export sc_MPI_Get_count
	𝐣𝐥.@cextern sc_MPI_Get_count(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Status}, var"?2?"::sc_MPI_Datatype, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Wait(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:364](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:364:21)
	""" sc_MPI_Wait
	export sc_MPI_Wait
	𝐣𝐥.@cextern sc_MPI_Wait(var"?1?"::𝐣𝐥.Ptr{sc_MPI_Request}, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Waitsome(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?5?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:365](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:365:21)
	""" sc_MPI_Waitsome
	export sc_MPI_Waitsome
	𝐣𝐥.@cextern sc_MPI_Waitsome(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Request}, var"?3?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?4?"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var"?5?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Waitall(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:367](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:367:21)
	""" sc_MPI_Waitall
	export sc_MPI_Waitall
	𝐣𝐥.@cextern sc_MPI_Waitall(var"?1?"::𝐣𝐥.Cint, var"?2?"::𝐣𝐥.Ptr{sc_MPI_Request}, var"?3?"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_MPI_Init_thread(argc::𝐣𝐥.Ptr{𝐣𝐥.Cint}, argv::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}}, required::𝐣𝐥.Cint, provided::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc_mpi.h:387](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:387:21)
	""" sc_MPI_Init_thread
	export sc_MPI_Init_thread
	𝐣𝐥.@cextern sc_MPI_Init_thread(argc::𝐣𝐥.Ptr{𝐣𝐥.Cint}, argv::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}}, required::𝐣𝐥.Cint, provided::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_sizeof(t::sc_MPI_Datatype)::size_t
	```
	
	 Return the size of MPI data types. 
	
	## Parameters
	
	  * `t`:    MPI data type.
	
	## Returns
	
	          Returns the size in bytes.
	
	## Reference
	
	[sc_mpi.h:396](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:396:21)
	""" sc_mpi_sizeof
	export sc_mpi_sizeof
	𝐣𝐥.@cextern sc_mpi_sizeof(t::sc_MPI_Datatype)::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_comm_attach_node_comms(comm::sc_MPI_Comm, processes_per_node::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Compute ``sc_intranode_comm'' and ``sc_internode_comm'' communicators and attach them to the current communicator.  This split takes *processes_per_node* passed by the user at face value: there is no hardware checking to see if this is the true affinity.
	
	## Parameters
	
	  * `comm`:                 MPI communicator
	  * `processes_per_node`:   the size of the intranode                                      communicators. if < 1,                                      sc will try to determine the correct                                      shared memory communicators.
	
	## Reference
	
	[sc_mpi.h:409](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:409:21)
	""" sc_mpi_comm_attach_node_comms
	export sc_mpi_comm_attach_node_comms
	𝐣𝐥.@cextern sc_mpi_comm_attach_node_comms(comm::sc_MPI_Comm, processes_per_node::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_comm_detach_node_comms(comm::sc_MPI_Comm)::𝐣𝐥.Cvoid
	```
	
	 Destroy ``sc_intranode_comm'' and ``sc_internode_comm'' communicators that are stored as attributes to communicator ``comm''. This routine enforces a call to the destroy callback for these attributes.
	
	## Parameters
	
	  * `comm`:                 MPI communicator
	
	## Reference
	
	[sc_mpi.h:418](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:418:21)
	""" sc_mpi_comm_detach_node_comms
	export sc_mpi_comm_detach_node_comms
	𝐣𝐥.@cextern sc_mpi_comm_detach_node_comms(comm::sc_MPI_Comm)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mpi_comm_get_node_comms(comm::sc_MPI_Comm, intranode::𝐣𝐥.Ptr{sc_MPI_Comm}, internode::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cvoid
	```
	
	 Get the communicators computed in sc_mpi_comm_attach_node_comms() if they exist; return sc_MPI_COMM_NULL otherwise.
	
	## Parameters
	
	  * `comm`:            Super communicator
	  * `intranode`:      intranode communicator
	  * `internode`:      internode communicator
	
	## Reference
	
	[sc_mpi.h:427](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:427:21)
	""" sc_mpi_comm_get_node_comms
	export sc_mpi_comm_get_node_comms
	𝐣𝐥.@cextern sc_mpi_comm_get_node_comms(comm::sc_MPI_Comm, intranode::𝐣𝐥.Ptr{sc_MPI_Comm}, internode::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log2_lookup_table::𝐣𝐥.Cconst(𝐣𝐥.Cint)[256]
	```
	
	 Lookup table to provide fast base-2 logarithm of integers. 
	
	## Reference
	
	[sc.h:137](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:137:21)
	""" sc_log2_lookup_table
	export sc_log2_lookup_table
	𝐣𝐥.@cextern sc_log2_lookup_table::𝐣𝐥.Cconst(𝐣𝐥.Cint)[256]
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_id::𝐣𝐥.Cint
	```
	
	 libsc allows for multiple packages to use their own log priorities etc. This is the package id for core sc functions, which is meant to be read only. It starts out with a value of -1, which is fine by itself. It is set to a non-negative value by the (optional) sc_init. 
	
	## Reference
	
	[sc.h:144](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:144:21)
	""" sc_package_id
	export sc_package_id
	𝐣𝐥.@cextern sc_package_id::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_trace_file::𝐣𝐥.Ptr{FILE}
	```
	
	 Optional trace file for logging (see sc_init). Initialized to NULL. 
	
	## Reference
	
	[sc.h:148](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:148:21)
	""" sc_trace_file
	export sc_trace_file
	𝐣𝐥.@cextern sc_trace_file::𝐣𝐥.Ptr{FILE}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_trace_prio::𝐣𝐥.Cint
	```
	
	 Optional minimum log priority for messages that go into the trace file. 
	
	## Reference
	
	[sc.h:151](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:151:21)
	""" sc_trace_prio
	export sc_trace_prio
	𝐣𝐥.@cextern sc_trace_prio::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_ABORTF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:177](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:177:21)
	""" SC_ABORTF
	export SC_ABORTF
	𝐣𝐥.@cextern SC_ABORTF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_CHECK_ABORTF(success::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:180](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:180:21)
	""" SC_CHECK_ABORTF
	export SC_CHECK_ABORTF
	𝐣𝐥.@cextern SC_CHECK_ABORTF(success::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GEN_LOGF(package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:351](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:351:21)
	""" SC_GEN_LOGF
	export SC_GEN_LOGF
	𝐣𝐥.@cextern SC_GEN_LOGF(package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:354](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:354:21)
	""" SC_GLOBAL_LOGF
	export SC_GLOBAL_LOGF
	𝐣𝐥.@cextern SC_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:356](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:356:21)
	""" SC_LOGF
	export SC_LOGF
	𝐣𝐥.@cextern SC_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:378](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:378:21)
	""" SC_GLOBAL_TRACEF
	export SC_GLOBAL_TRACEF
	𝐣𝐥.@cextern SC_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:380](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:380:21)
	""" SC_GLOBAL_LDEBUGF
	export SC_GLOBAL_LDEBUGF
	𝐣𝐥.@cextern SC_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:382](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:382:21)
	""" SC_GLOBAL_VERBOSEF
	export SC_GLOBAL_VERBOSEF
	𝐣𝐥.@cextern SC_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:384](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:384:21)
	""" SC_GLOBAL_INFOF
	export SC_GLOBAL_INFOF
	𝐣𝐥.@cextern SC_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:386](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:386:21)
	""" SC_GLOBAL_STATISTICSF
	export SC_GLOBAL_STATISTICSF
	𝐣𝐥.@cextern SC_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:388](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:388:21)
	""" SC_GLOBAL_PRODUCTIONF
	export SC_GLOBAL_PRODUCTIONF
	𝐣𝐥.@cextern SC_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:390](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:390:21)
	""" SC_GLOBAL_ESSENTIALF
	export SC_GLOBAL_ESSENTIALF
	𝐣𝐥.@cextern SC_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:392](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:392:21)
	""" SC_GLOBAL_LERRORF
	export SC_GLOBAL_LERRORF
	𝐣𝐥.@cextern SC_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:422](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:422:21)
	""" SC_TRACEF
	export SC_TRACEF
	𝐣𝐥.@cextern SC_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:424](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:424:21)
	""" SC_LDEBUGF
	export SC_LDEBUGF
	𝐣𝐥.@cextern SC_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:426](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:426:21)
	""" SC_VERBOSEF
	export SC_VERBOSEF
	𝐣𝐥.@cextern SC_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:428](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:428:21)
	""" SC_INFOF
	export SC_INFOF
	𝐣𝐥.@cextern SC_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:430](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:430:21)
	""" SC_STATISTICSF
	export SC_STATISTICSF
	𝐣𝐥.@cextern SC_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:432](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:432:21)
	""" SC_PRODUCTIONF
	export SC_PRODUCTIONF
	𝐣𝐥.@cextern SC_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:434](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:434:21)
	""" SC_ESSENTIALF
	export SC_ESSENTIALF
	𝐣𝐥.@cextern SC_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern SC_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:436](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:436:21)
	""" SC_LERRORF
	export SC_LERRORF
	𝐣𝐥.@cextern SC_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:467](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:467:23)
	""" sc_handler_t
	export sc_handler_t
	𝐣𝐥.@ctypedef sc_handler_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:468](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:468:23)
	""" sc_log_handler_t
	export sc_log_handler_t
	𝐣𝐥.@ctypedef sc_log_handler_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{FILE}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Cint, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:472](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:472:23)
	""" sc_abort_handler_t
	export sc_abort_handler_t
	𝐣𝐥.@ctypedef sc_abort_handler_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cvoid, 𝐣𝐥.Tuple{}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_malloc(package::𝐣𝐥.Cint, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[sc.h:476](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:476:21)
	""" sc_malloc
	export sc_malloc
	𝐣𝐥.@cextern sc_malloc(package::𝐣𝐥.Cint, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_calloc(package::𝐣𝐥.Cint, nmemb::size_t, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[sc.h:477](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:477:21)
	""" sc_calloc
	export sc_calloc
	𝐣𝐥.@cextern sc_calloc(package::𝐣𝐥.Cint, nmemb::size_t, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_realloc(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	## Reference
	
	[sc.h:478](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:478:21)
	""" sc_realloc
	export sc_realloc
	𝐣𝐥.@cextern sc_realloc(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_strdup(package::𝐣𝐥.Cint, s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
	```
	
	## Reference
	
	[sc.h:479](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:479:21)
	""" sc_strdup
	export sc_strdup
	𝐣𝐥.@cextern sc_strdup(package::𝐣𝐥.Cint, s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_free(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:480](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:480:21)
	""" sc_free
	export sc_free
	𝐣𝐥.@cextern sc_free(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_memory_status(package::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:481](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:481:21)
	""" sc_memory_status
	export sc_memory_status
	𝐣𝐥.@cextern sc_memory_status(package::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_memory_check(package::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:482](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:482:21)
	""" sc_memory_check
	export sc_memory_check
	𝐣𝐥.@cextern sc_memory_check(package::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:486](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:486:21)
	""" sc_int_compare
	export sc_int_compare
	𝐣𝐥.@cextern sc_int_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int8_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:487](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:487:21)
	""" sc_int8_compare
	export sc_int8_compare
	𝐣𝐥.@cextern sc_int8_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int16_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:488](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:488:21)
	""" sc_int16_compare
	export sc_int16_compare
	𝐣𝐥.@cextern sc_int16_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int32_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:489](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:489:21)
	""" sc_int32_compare
	export sc_int32_compare
	𝐣𝐥.@cextern sc_int32_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_int64_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:490](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:490:21)
	""" sc_int64_compare
	export sc_int64_compare
	𝐣𝐥.@cextern sc_int64_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_double_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	## Reference
	
	[sc.h:491](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:491:21)
	""" sc_double_compare
	export sc_double_compare
	𝐣𝐥.@cextern sc_double_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_atoi(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	```
	
	 Safe version of the standard library atoi (3) function. 
	
	## Parameters
	
	  * `nptr`:     NUL-terminated string.
	
	## Returns
	
	              Converted integer value.  0 if no valid number.                      INT_MAX on overflow, INT_MIN on underflow.
	
	## Reference
	
	[sc.h:498](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:498:21)
	""" sc_atoi
	export sc_atoi
	𝐣𝐥.@cextern sc_atoi(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_atol(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Clong
	```
	
	 Safe version of the standard library atol (3) function. 
	
	## Parameters
	
	  * `nptr`:     NUL-terminated string.
	
	## Returns
	
	              Converted long value.  0 if no valid number.                      LONG_MAX on overflow, LONG_MIN on underflow.
	
	## Reference
	
	[sc.h:505](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:505:21)
	""" sc_atol
	export sc_atol
	𝐣𝐥.@cextern sc_atol(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Clong
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_set_log_defaults(log_stream::𝐣𝐥.Ptr{FILE}, log_handler::sc_log_handler_t, log_thresold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Controls the default SC log behavior. 
	
	## Parameters
	
	  * `log_stream`:    Set stream to use by sc_logf (or NULL for stdout).
	  * `log_handler`:   Set default SC log handler (NULL selects builtin).
	  * `log_threshold`: Set default SC log threshold (or SC_LP_DEFAULT).                           May be SC_LP_ALWAYS or SC_LP_SILENT.
	
	## Reference
	
	[sc.h:513](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:513:21)
	""" sc_set_log_defaults
	export sc_set_log_defaults
	𝐣𝐥.@cextern sc_set_log_defaults(log_stream::𝐣𝐥.Ptr{FILE}, log_handler::sc_log_handler_t, log_thresold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_set_abort_handler(abort_handler::sc_abort_handler_t)::𝐣𝐥.Cvoid
	```
	
	 Controls the default SC abort behavior. 
	
	## Parameters
	
	  * `abort_handler`: Set default SC above handler (NULL selects                           builtin).  ***This function should not return!***
	
	## Reference
	
	[sc.h:521](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:521:21)
	""" sc_set_abort_handler
	export sc_set_abort_handler
	𝐣𝐥.@cextern sc_set_abort_handler(abort_handler::sc_abort_handler_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 The central log function to be called by all packages. Dispatches the log calls by package and filters by category and priority. 
	
	## Parameters
	
	  * `package`:   Must be a registered package id or -1.
	  * `category`:  Must be SC_LC_NORMAL or SC_LC_GLOBAL.
	  * `priority`:  Must be > SC_LP_ALWAYS and < SC_LP_SILENT.
	
	## Reference
	
	[sc.h:529](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:529:21)
	""" sc_log
	export sc_log
	𝐣𝐥.@cextern sc_log(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_logf(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:532](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:532:21)
	""" sc_logf
	export sc_logf
	𝐣𝐥.@cextern sc_logf(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_logv(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	```
	
	## Reference
	
	[sc.h:536](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:536:21)
	""" sc_logv
	export sc_logv
	𝐣𝐥.@cextern sc_logv(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_push_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Add spaces to the start of a package's default log format. 
	
	## Reference
	
	[sc.h:541](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:541:21)
	""" sc_log_indent_push_count
	export sc_log_indent_push_count
	𝐣𝐥.@cextern sc_log_indent_push_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_pop_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Remove spaces from the start of a package's default log format. 
	
	## Reference
	
	[sc.h:544](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:544:21)
	""" sc_log_indent_pop_count
	export sc_log_indent_pop_count
	𝐣𝐥.@cextern sc_log_indent_pop_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_push()::𝐣𝐥.Cvoid
	```
	
	 Add one space to the start of sc's default log format. 
	
	## Reference
	
	[sc.h:547](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:547:21)
	""" sc_log_indent_push
	export sc_log_indent_push
	𝐣𝐥.@cextern sc_log_indent_push()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_log_indent_pop()::𝐣𝐥.Cvoid
	```
	
	 Remove one space from the start of a sc's default log format. 
	
	## Reference
	
	[sc.h:550](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:550:21)
	""" sc_log_indent_pop
	export sc_log_indent_pop
	𝐣𝐥.@cextern sc_log_indent_pop()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort()::𝐣𝐥.Cvoid
	```
	
	 Print a stack trace, call the abort handler and then call abort (). 
	
	## Reference
	
	[sc.h:553](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:553:21)
	""" sc_abort
	export sc_abort
	𝐣𝐥.@cextern sc_abort()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_verbose(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Print a message to stderr and then call sc_abort (). 
	
	## Reference
	
	[sc.h:557](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:557:21)
	""" sc_abort_verbose
	export sc_abort_verbose
	𝐣𝐥.@cextern sc_abort_verbose(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_verbosef(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	 Print a message to stderr and then call sc_abort (). 
	
	## Reference
	
	[sc.h:562](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:562:21)
	""" sc_abort_verbosef
	export sc_abort_verbosef
	𝐣𝐥.@cextern sc_abort_verbosef(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_verbosev(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	```
	
	 Print a message to stderr and then call sc_abort (). 
	
	## Reference
	
	[sc.h:568](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:568:21)
	""" sc_abort_verbosev
	export sc_abort_verbosev
	𝐣𝐥.@cextern sc_abort_verbosev(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_abort_collective(msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Collective abort where only root prints a message 
	
	## Reference
	
	[sc.h:573](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:573:21)
	""" sc_abort_collective
	export sc_abort_collective
	𝐣𝐥.@cextern sc_abort_collective(msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_register(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint, name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, full::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	```
	
	 Register a software package with SC. This function must only be called before additional threads are created. The logging parameters are as in sc_set_log_defaults. 
	
	## Returns
	
	                   Returns a unique package id.
	
	## Reference
	
	[sc.h:581](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:581:21)
	""" sc_package_register
	export sc_package_register
	𝐣𝐥.@cextern sc_package_register(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint, name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, full::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_is_registered(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Query whether an identifier matches a registered package. 
	
	## Parameters
	
	  * `package_id`:       Only a non-negative id can be registered.
	
	## Returns
	
	                      True if and only if the package id is                              non-negative and package is registered.
	
	## Reference
	
	[sc.h:590](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:590:21)
	""" sc_package_is_registered
	export sc_package_is_registered
	𝐣𝐥.@cextern sc_package_is_registered(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_lock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Acquire a pthread mutex lock. If configured without --enable-pthread, this function does nothing. This function must be followed with a matching sc_package_unlock. 
	
	## Parameters
	
	  * `package_id`:       Either -1 for an undefined package or                              an id returned from sc_package_register.                              Depending on the value, the appropriate mutex                              is chosen.  Thus, we may overlap locking calls                              with distinct package_id.
	
	## Reference
	
	[sc.h:601](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:601:21)
	""" sc_package_lock
	export sc_package_lock
	𝐣𝐥.@cextern sc_package_lock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_unlock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Release a pthread mutex lock. If configured without --enable-pthread, this function does nothing. This function must be follow a matching sc_package_lock. 
	
	## Parameters
	
	  * `package_id`:       Either -1 for an undefined package or                              an id returned from sc_package_register.                              Depending on the value, the appropriate mutex                              is chosen.  Thus, we may overlap locking calls                              with distinct package_id.
	
	## Reference
	
	[sc.h:612](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:612:21)
	""" sc_package_unlock
	export sc_package_unlock
	𝐣𝐥.@cextern sc_package_unlock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_set_verbosity(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Set the logging verbosity of a registered package. This can be called at any point in the program, any number of times. It can only lower the verbosity at and below the value of SC_LP_THRESHOLD. 
	
	## Parameters
	
	  * `package_id`:       Must be a registered package identifier.
	
	## Reference
	
	[sc.h:619](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:619:21)
	""" sc_package_set_verbosity
	export sc_package_set_verbosity
	𝐣𝐥.@cextern sc_package_set_verbosity(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_set_abort_alloc_mismatch(package_id::𝐣𝐥.Cint, set_abort::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Set the unregister behavior of sc_package_unregister().
	
	## Parameters
	
	  * `package_id`:    Must be -1 for the default package or                          the identifier of a registered package.
	  * `set_abort`:     True if sc_package_unregister() should abort if the                          number of allocs does not match the number of                          frees; false otherwise.
	
	## Reference
	
	[sc.h:630](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:630:21)
	""" sc_package_set_abort_alloc_mismatch
	export sc_package_set_abort_alloc_mismatch
	𝐣𝐥.@cextern sc_package_set_abort_alloc_mismatch(package_id::𝐣𝐥.Cint, set_abort::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_unregister(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Unregister a software package with SC. This function must only be called after additional threads are finished.
	
	## Reference
	
	[sc.h:636](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:636:21)
	""" sc_package_unregister
	export sc_package_unregister
	𝐣𝐥.@cextern sc_package_unregister(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_package_print_summary(log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Print a summary of all packages registered with SC. Uses the SC_LC_GLOBAL log category which by default only prints on rank 0. 
	
	## Parameters
	
	  * `log_priority`:     Priority passed to sc log functions.
	
	## Reference
	
	[sc.h:642](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:642:21)
	""" sc_package_print_summary
	export sc_package_print_summary
	𝐣𝐥.@cextern sc_package_print_summary(log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_init(mpicomm::sc_MPI_Comm, catch_signals::𝐣𝐥.Cint, print_backtrace::𝐣𝐥.Cint, log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Sets the global program identifier (e.g. the MPI rank) and some flags. This function is optional. This function must only be called before additional threads are created. If this function is not called or called with log_handler == NULL, the default SC log handler will be used. If this function is not called or called with log_threshold == SC_LP_DEFAULT, the default SC log threshold will be used. The default SC log settings can be changed with sc_set_log_defaults (). 
	
	## Parameters
	
	  * `mpicomm`:          MPI communicator, can be sc_MPI_COMM_NULL.                              If sc_MPI_COMM_NULL, the identifier is set to -1.                              Otherwise, sc_MPI_Init must have been called.                              Effectively, we just query size and rank.
	  * `catch_signals`:    If true, signals INT and SEGV are caught.
	  * `print_backtrace`:  If true, sc_abort prints a backtrace.
	
	## Reference
	
	[sc.h:659](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:659:21)
	""" sc_init
	export sc_init
	𝐣𝐥.@cextern sc_init(mpicomm::sc_MPI_Comm, catch_signals::𝐣𝐥.Cint, print_backtrace::𝐣𝐥.Cint, log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_finalize()::𝐣𝐥.Cvoid
	```
	
	 Unregisters all packages, runs the memory check, removes the signal handlers and resets sc_identifier and sc_root_*. This function is optional. This function does not require sc_init to be called first.
	
	## Reference
	
	[sc.h:668](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:668:21)
	""" sc_finalize
	export sc_finalize
	𝐣𝐥.@cextern sc_finalize()::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_is_root()::𝐣𝐥.Cint
	```
	
	 Identify the root process. Only meaningful between sc_init and sc_finalize and with a communicator that is not sc_MPI_COMM_NULL (otherwise always true).
	
	## Returns
	
	          Return true for the root process and false otherwise.
	
	## Reference
	
	[sc.h:676](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:676:21)
	""" sc_is_root
	export sc_is_root
	𝐣𝐥.@cextern sc_is_root()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_strcopy(dest::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, src::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Provide a string copy function. 
	
	## Parameters
	
	  * `dest`:    Buffer of length at least *size.*                      On output, not touched if NULL or *size* == 0.
	  * `size`:     Allocation length of *dest.*
	  * `src`:      Null-terminated string.
	
	## Returns
	
	              Equivalent to sc_snprintf (dest, size, \"%s\", src).
	
	## Reference
	
	[sc.h:686](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:686:21)
	""" sc_strcopy
	export sc_strcopy
	𝐣𝐥.@cextern sc_strcopy(dest::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, src::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_snprintf(str::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, format::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid
	```
	
	 Wrap the system snprintf function, allowing for truncation. The snprintf function may truncate the string written to the specified length. In some cases, compilers warn when this may occur. Here this is permitted behavior and we avoid the warning. 
	
	## Parameters
	
	  * `str`:     Buffer of length at least *size.*                      On output, not touched if NULL or *size* == 0.                      Otherwise, \"\" on snprintf error or the proper result.
	  * `size`:     Allocation length of *str.*
	  * `format`:   Format string as in man (3) snprintf.
	
	## Reference
	
	[sc.h:698](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:698:21)
	""" sc_snprintf
	export sc_snprintf
	𝐣𝐥.@cextern sc_snprintf(str::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, format::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var"?vararg?"...)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	```
	
	 Return the full version of libsc.
	
	## Returns
	
	          Return the version of libsc using the format                  `VERSION_MAJOR.VERSION_MINOR.VERSION_POINT`,                  where `VERSION_POINT` can contain dots and                  characters, e.g. to indicate the additional                  number of commits and a git commit hash.
	
	## Reference
	
	[sc.h:710](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:710:21)
	""" sc_version
	export sc_version
	𝐣𝐥.@cextern sc_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_version_major()::𝐣𝐥.Cint
	```
	
	 Return the major version of libsc.
	
	## Returns
	
	          Return the major version of libsc.
	
	## Reference
	
	[sc.h:716](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:716:21)
	""" sc_version_major
	export sc_version_major
	𝐣𝐥.@cextern sc_version_major()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_version_minor()::𝐣𝐥.Cint
	```
	
	 Return the minor version of libsc.
	
	## Returns
	
	          Return the minor version of libsc.
	
	## Reference
	
	[sc.h:722](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:722:21)
	""" sc_version_minor
	export sc_version_minor
	𝐣𝐥.@cextern sc_version_minor()::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	 Function to compute a hash value of an object. 
	
	## Parameters
	
	  * `v`:   The object to hash.
	  * `u`:   Arbitrary user data.
	
	## Returns
	
	 Returns an unsigned integer.
	
	## Reference
	
	[sc_containers.h:75](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:75:24)
	""" sc_hash_function_t
	export sc_hash_function_t
	𝐣𝐥.@ctypedef sc_hash_function_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cuint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Function to check equality of two objects. 
	
	## Parameters
	
	  * `u`:   Arbitrary user data.
	
	## Returns
	
	 Returns false if *v1 is unequal *v2 and true otherwise.
	
	## Reference
	
	[sc_containers.h:81](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:81:23)
	""" sc_equal_function_t
	export sc_equal_function_t
	𝐣𝐥.@ctypedef sc_equal_function_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 Function to call on every data item of a hash table. 
	
	## Parameters
	
	  * `v`:   The address of the pointer to the current object.
	  * `u`:   Arbitrary user data.
	
	## Returns
	
	 Return true if the traversal should continue, false to stop.
	
	## Reference
	
	[sc_containers.h:89](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:89:23)
	""" sc_hash_foreach_t
	export sc_hash_foreach_t
	𝐣𝐥.@ctypedef sc_hash_foreach_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	 The sc_array object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index.  Their address may change. The number of elements (== elem_count) of the array can be changed by  sc_array_resize and sc_array_rewind. Elements can be sorted with sc_array_sort. If the array is sorted, it can be searched with sc_array_bsearch. A priority queue is implemented with pqueue_add and pqueue_pop (untested).
	
	## Reference
	
	[sc_containers.h:99](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:99:16)
	""" sc_array
	𝐣𝐥.@doc """
	 The sc_array object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index.  Their address may change. The number of elements (== elem_count) of the array can be changed by  sc_array_resize and sc_array_rewind. Elements can be sorted with sc_array_sort. If the array is sorted, it can be searched with sc_array_bsearch. A priority queue is implemented with pqueue_add and pqueue_pop (untested).
	
	## Reference
	
	[sc_containers.h:113](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:113:1)
	""" sc_array_t
	export sc_array, sc_array_t
	𝐣𝐥.@ctypedef sc_array_t 𝐣𝐥.@cstruct sc_array {
		elem_size::size_t
		elem_count::size_t
		byte_alloc::ssize_t
		array::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_memory_used(array::𝐣𝐥.Ptr{sc_array_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	```
	
	 Calculate the memory used by an array. 
	
	## Parameters
	
	  * `array`:       The array.
	  * `is_dynamic`:  True if created with sc_array_new,                         false if initialized with sc_array_init
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:127](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:127:21)
	""" sc_array_memory_used
	export sc_array_memory_used
	𝐣𝐥.@cextern sc_array_memory_used(array::𝐣𝐥.Ptr{sc_array_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new array structure with 0 elements. 
	
	## Parameters
	
	  * `elem_size`:    Size of one array element in bytes.
	
	## Returns
	
	                  Return an allocated array of zero length.
	
	## Reference
	
	[sc_containers.h:133](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:133:21)
	""" sc_array_new
	export sc_array_new
	𝐣𝐥.@cextern sc_array_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new_count(elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new array structure with a given length (number of elements). 
	
	## Parameters
	
	  * `elem_size`:    Size of one array element in bytes.
	  * `elem_count`:   Initial number of array elements.
	
	## Returns
	
	                  Return an allocated array                          with allocated but uninitialized elements.
	
	## Reference
	
	[sc_containers.h:141](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:141:21)
	""" sc_array_new_count
	export sc_array_new_count
	𝐣𝐥.@cextern sc_array_new_count(elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new_view(array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new view of an existing sc_array_t. 
	
	## Parameters
	
	  * `array`:    The array must not be resized while view is alive.
	  * `offset`:   The offset of the viewed section in element units.                      This offset cannot be changed until the view is reset.
	  * `length`:   The length of the viewed section in element units.                      The view cannot be resized to exceed this length.
	
	## Reference
	
	[sc_containers.h:153](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:153:21)
	""" sc_array_new_view
	export sc_array_new_view
	𝐣𝐥.@cextern sc_array_new_view(array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_new_data(base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	```
	
	 Creates a new view of an existing plain C array. 
	
	## Parameters
	
	  * `base`:         The data must not be moved while view is alive.
	  * `elem_size`:    Size of one array element in bytes.
	  * `elem_count`:   The length of the view in element units.                          The view cannot be resized to exceed this length.
	
	## Reference
	
	[sc_containers.h:162](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:162:21)
	""" sc_array_new_data
	export sc_array_new_data
	𝐣𝐥.@cextern sc_array_new_data(base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_destroy(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Destroys an array structure. 
	
	## Parameters
	
	  * `array`:    The array to be destroyed.
	
	## Reference
	
	[sc_containers.h:168](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:168:21)
	""" sc_array_destroy
	export sc_array_destroy
	𝐣𝐥.@cextern sc_array_destroy(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_destroy_null(parray::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_array_t}})::𝐣𝐥.Cvoid
	```
	
	 Destroys an array structure and sets the pointer to NULL. 
	
	## Parameters
	
	  * `parray`:       Pointer to address of array to be destroyed.                              On output, *parray is NULL.
	
	## Reference
	
	[sc_containers.h:174](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:174:21)
	""" sc_array_destroy_null
	export sc_array_destroy_null
	𝐣𝐥.@cextern sc_array_destroy_null(parray::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_array_t}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) array structure. 
	
	## Parameters
	
	  * `array`:       Array structure to be initialized.
	  * `elem_size`:        Size of one array element in bytes.
	
	## Reference
	
	[sc_containers.h:180](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:180:21)
	""" sc_array_init
	export sc_array_init
	𝐣𝐥.@cextern sc_array_init(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_size(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) array structure and allocates a given number of elements. Deprecated: use sc_array_init_count. 
	
	## Parameters
	
	  * `array`:       Array structure to be initialized.
	  * `elem_size`:        Size of one array element in bytes.
	  * `elem_count`:       Number of initial array elements.
	
	## Reference
	
	[sc_containers.h:189](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:189:21)
	""" sc_array_init_size
	export sc_array_init_size
	𝐣𝐥.@cextern sc_array_init_size(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_count(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) array structure and allocates a given number of elements. This function supersedes sc_array_init_size. 
	
	## Parameters
	
	  * `array`:       Array structure to be initialized.
	  * `elem_size`:        Size of one array element in bytes.
	  * `elem_count`:       Number of initial array elements.
	
	## Reference
	
	[sc_containers.h:199](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:199:21)
	""" sc_array_init_count
	export sc_array_init_count
	𝐣𝐥.@cextern sc_array_init_count(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_view(view::𝐣𝐥.Ptr{sc_array_t}, array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) view from existing sc_array_t. The array view returned does not require sc_array_reset (doesn't hurt though). 
	
	## Parameters
	
	  * `view`:  Array structure to be initialized.
	  * `array`:     The array must not be resized while view is alive.
	  * `offset`:    The offset of the viewed section in element units.                       This offset cannot be changed until the view is reset.
	  * `length`:    The length of the view in element units.                       The view cannot be resized to exceed this length.                       It is not necessary to call sc_array_reset later.
	
	## Reference
	
	[sc_containers.h:212](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:212:21)
	""" sc_array_init_view
	export sc_array_init_view
	𝐣𝐥.@cextern sc_array_init_view(view::𝐣𝐥.Ptr{sc_array_t}, array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_init_data(view::𝐣𝐥.Ptr{sc_array_t}, base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an already allocated (or static) view from given plain C data. The array view returned does not require sc_array_reset (doesn't hurt though). 
	
	## Parameters
	
	  * `view`:     Array structure to be initialized.
	  * `base`:         The data must not be moved while view is alive.
	  * `elem_size`:    Size of one array element in bytes.
	  * `elem_count`:   The length of the view in element units.                          The view cannot be resized to exceed this length.                          It is not necessary to call sc_array_reset later.
	
	## Reference
	
	[sc_containers.h:224](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:224:21)
	""" sc_array_init_data
	export sc_array_init_data
	𝐣𝐥.@cextern sc_array_init_data(view::𝐣𝐥.Ptr{sc_array_t}, base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_memset(array::𝐣𝐥.Ptr{sc_array_t}, c::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Run memset on the array storage. We pass the character to memset unchanged.  Thus, care must be taken when setting values below -1 or above 127, just as with standard memset (3). 
	
	## Parameters
	
	  * `array`:    This array's storage will be overwritten.
	  * `c`:            Character to overwrite every byte with.
	
	## Reference
	
	[sc_containers.h:233](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:233:21)
	""" sc_array_memset
	export sc_array_memset
	𝐣𝐥.@cextern sc_array_memset(array::𝐣𝐥.Ptr{sc_array_t}, c::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_reset(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Sets the array count to zero and frees all elements. This function turns a view into a newly initialized array. 
	
	## Parameters
	
	  * `array`:       Array structure to be reset.
	
	NOTE: Calling sc_array_init, then any array operations,       then sc_array_reset is memory neutral.       As an exception, the two functions sc_array_init_view and       sc_array_init_data do not require a subsequent call to sc_array_reset.       Regardless, it is legal to call sc_array_reset anyway.
	
	## Reference
	
	[sc_containers.h:244](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:244:21)
	""" sc_array_reset
	export sc_array_reset
	𝐣𝐥.@cextern sc_array_reset(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_truncate(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Sets the array count to zero, but does not free elements. Not allowed for views. 
	
	## Parameters
	
	  * `array`:       Array structure to be truncated.
	
	NOTE: This is intended to allow an sc_array to be used as a reusable buffer, where the \"high water mark\" of the buffer is preserved, so that O(log (max n)) reallocs occur over the life of the buffer.
	
	## Reference
	
	[sc_containers.h:253](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:253:21)
	""" sc_array_truncate
	export sc_array_truncate
	𝐣𝐥.@cextern sc_array_truncate(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_rewind(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Shorten an array without reallocating it. 
	
	## Parameters
	
	  * `array`:    The element count of this array is modified.
	  * `new_count`:    Must be less or equal than the **array's** count.                          If it is less, the number of elements in the                          array is reduced without reallocating memory.                          The exception is a **new_count** of zero                          specified for an array that is not a view:                          In this case sc_array_reset is equivalent.
	
	## Reference
	
	[sc_containers.h:264](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:264:21)
	""" sc_array_rewind
	export sc_array_rewind
	𝐣𝐥.@cextern sc_array_rewind(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_resize(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Sets the element count to new_count. If the array is not a view, reallocation takes place occasionally. If the array is a view, new_count must not be greater than the element count of the view when it was created.  The original offset of the view cannot be changed. 
	
	## Parameters
	
	  * `array`:    The element count and address is modified.
	  * `new_count`:    New element count of the array.                          If it is zero and the array is not a view,                          the effect equals sc_array_reset.
	
	## Reference
	
	[sc_containers.h:276](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:276:21)
	""" sc_array_resize
	export sc_array_resize
	𝐣𝐥.@cextern sc_array_resize(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_copy(dest::𝐣𝐥.Ptr{sc_array_t}, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Copy the contents of one array into another. Both arrays must have equal element sizes. The source array may be a view. We use memcpy (3):  If the two arrays overlap, results are undefined. 
	
	## Parameters
	
	  * `dest`:     Array (not a view) will be resized and get new data.
	  * `src`:      Array used as source of new data, will not be changed.
	
	## Reference
	
	[sc_containers.h:285](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:285:21)
	""" sc_array_copy
	export sc_array_copy
	𝐣𝐥.@cextern sc_array_copy(dest::𝐣𝐥.Ptr{sc_array_t}, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_copy_into(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Copy the contents of one array into some portion of another. Both arrays must have equal element sizes. Either array may be a view.  The destination array must be large enough. We use memcpy (3):  If the two arrays overlap, results are undefined. 
	
	## Parameters
	
	  * `dest`:     Array will be written into.  Its element count must                      be at least **dest_offset** + **src->elem_count.**
	  * `dest_offset`:  First index in **dest** array to be overwritten.                      As every index, it refers to elements, not bytes.
	  * `src`:      Array used as source of new data, will not be changed.
	
	## Reference
	
	[sc_containers.h:297](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:297:21)
	""" sc_array_copy_into
	export sc_array_copy_into
	𝐣𝐥.@cextern sc_array_copy_into(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_move_part(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t}, src_offset::size_t, count::size_t)::𝐣𝐥.Cvoid
	```
	
	 Copy part of one array into another using memmove (3). Both arrays must have equal element sizes. Either array may be a view.  The destination array must be large enough. We use memmove (3):  The two arrays may overlap. 
	
	## Parameters
	
	  * `dest`:     Array will be written into.  Its element count must                      be at least **dest_offset** + **count.**
	  * `dest_offset`:  First index in **dest** array to be overwritten.                      As every index, it refers to elements, not bytes.
	  * `src`:      Array will be read from.  Its element count must                      be at least **src_offset** + **count.**
	  * `src_offset`:   First index in **src** array to be used.                      As every index, it refers to elements, not bytes.
	  * `count`:    Number of entries copied.
	
	## Reference
	
	[sc_containers.h:314](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:314:21)
	""" sc_array_move_part
	export sc_array_move_part
	𝐣𝐥.@cextern sc_array_move_part(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t}, src_offset::size_t, count::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_sort(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	```
	
	 Sorts the array in ascending order wrt. the comparison function. 
	
	## Parameters
	
	  * `array`:    The array to sort.
	  * `compar`:   The comparison function to be used.
	
	## Reference
	
	[sc_containers.h:322](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:322:21)
	""" sc_array_sort
	export sc_array_sort
	𝐣𝐥.@cextern sc_array_sort(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_is_sorted(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cint
	```
	
	 Check whether the array is sorted wrt. the comparison function. 
	
	## Parameters
	
	  * `array`:    The array to check.
	  * `compar`:   The comparison function to be used.
	
	## Returns
	
	              True if array is sorted, false otherwise.
	
	## Reference
	
	[sc_containers.h:331](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:331:21)
	""" sc_array_is_sorted
	export sc_array_is_sorted
	𝐣𝐥.@cextern sc_array_is_sorted(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_is_equal(array::𝐣𝐥.Ptr{sc_array_t}, other::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	```
	
	 Check whether two arrays have equal size, count, and content. Either array may be a view.  Both arrays will not be changed. 
	
	## Parameters
	
	  * `array`:   One array to be compared.
	  * `other`:   A second array to be compared.
	
	## Returns
	
	              True if array and other are equal, false otherwise.
	
	## Reference
	
	[sc_containers.h:341](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:341:21)
	""" sc_array_is_equal
	export sc_array_is_equal
	𝐣𝐥.@cextern sc_array_is_equal(array::𝐣𝐥.Ptr{sc_array_t}, other::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_uniq(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	```
	
	 Removed duplicate entries from a sorted array. This function is not allowed for views. 
	
	## Parameters
	
	  * `array`:  The array size will be reduced as necessary.
	  * `compar`:     The comparison function to be used.
	
	## Reference
	
	[sc_containers.h:349](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:349:21)
	""" sc_array_uniq
	export sc_array_uniq
	𝐣𝐥.@cextern sc_array_uniq(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_bsearch(array::𝐣𝐥.Ptr{sc_array_t}, key::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::ssize_t
	```
	
	 Performs a binary search on an array. The array must be sorted. 
	
	## Parameters
	
	  * `array`:   A sorted array to search in.
	  * `key`:     An element to be searched for.
	  * `compar`:  The comparison function to be used.
	
	## Returns
	
	 Returns the index into array for the item found, or -1.
	
	## Reference
	
	[sc_containers.h:359](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:359:21)
	""" sc_array_bsearch
	export sc_array_bsearch
	𝐣𝐥.@cextern sc_array_bsearch(array::𝐣𝐥.Ptr{sc_array_t}, key::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::ssize_t
	
	𝐣𝐥.@doc """
	 Function to determine the enumerable type of an object in an array. 
	
	## Parameters
	
	  * `array`:   Array containing the object.
	  * `index`:   The location of the object.
	  * `data`:    Arbitrary user data.
	
	## Reference
	
	[sc_containers.h:369](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:369:23)
	""" sc_array_type_t
	export sc_array_type_t
	𝐣𝐥.@ctypedef sc_array_type_t 𝐣𝐥.Ptr{𝐣𝐥.Cfunction{size_t, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{sc_array_t}, size_t, 𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, 𝐣𝐥.CDECL}}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_split(array::𝐣𝐥.Ptr{sc_array_t}, offsets::𝐣𝐥.Ptr{sc_array_t}, num_types::size_t, type_fn::sc_array_type_t, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	```
	
	 Compute the offsets of groups of enumerable types in an array. 
	
	## Parameters
	
	  * `array`:         Array that is sorted in ascending order by type.                           If k indexes *array,* then                           0 <= *type_fn* (*array,* k, *data)* <                           *num_types.*
	  * `offsets`:   An initialized array of type size_t that is                           resized to *num_types* + 1 entries.  The indices                           j of *array* that contain objects of type k are                           *offsets[k]* <= j < *offsets[k* + 1].                           If there are no objects of type k, then                           *offsets[k]* = *offset[k* + 1].
	  * `num_types`:     The number of possible types of objects in                           *array.*
	  * `type_fn`:       Returns the type of an object in the array.
	  * `data`:          Arbitrary user data passed to *type_fn.*
	
	## Reference
	
	[sc_containers.h:388](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:388:21)
	""" sc_array_split
	export sc_array_split
	𝐣𝐥.@cextern sc_array_split(array::𝐣𝐥.Ptr{sc_array_t}, offsets::𝐣𝐥.Ptr{sc_array_t}, num_types::size_t, type_fn::sc_array_type_t, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_is_permutation(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	```
	
	 Determine whether *array* is an array of size_t's whose entries include every integer 0 <= i < array->elem_count. 
	
	## Parameters
	
	  * `array`:         An array.
	
	## Returns
	
	                   Returns 1 if array contains size_t elements whose                           entries include every integer                           0 <= i < *array->elem_count,* 0 otherwise.
	
	## Reference
	
	[sc_containers.h:399](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:399:21)
	""" sc_array_is_permutation
	export sc_array_is_permutation
	𝐣𝐥.@cextern sc_array_is_permutation(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_permute(array::𝐣𝐥.Ptr{sc_array_t}, newindices::𝐣𝐥.Ptr{sc_array_t}, keepperm::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Given permutation *newindices,* permute *array* in place.  The data that on input is contained in *array[i]* will be contained in *array[newindices[i]]* on output.  The entries of newindices will be altered unless *keepperm* is true. 
	
	## Parameters
	
	  * `array`:      An array.
	  * `newindices`: Permutation array (see sc_array_is_permutation).
	  * `keepperm`:   If true, *newindices* will be unchanged by the                            algorithm; if false, *newindices* will be the                            identity permutation on output, but the                            algorithm will only use O(1) space.
	
	## Reference
	
	[sc_containers.h:412](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:412:21)
	""" sc_array_permute
	export sc_array_permute
	𝐣𝐥.@cextern sc_array_permute(array::𝐣𝐥.Ptr{sc_array_t}, newindices::𝐣𝐥.Ptr{sc_array_t}, keepperm::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_checksum(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cuint
	```
	
	 Computes the adler32 checksum of array data (see zlib documentation). This is a faster checksum than crc32, and it works with zeros as data.
	
	## Reference
	
	[sc_containers.h:418](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:418:21)
	""" sc_array_checksum
	export sc_array_checksum
	𝐣𝐥.@cextern sc_array_checksum(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_pqueue_add(array::𝐣𝐥.Ptr{sc_array_t}, temp::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	```
	
	 Adds an element to a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. The priority queue is implemented as a heap in ascending order. A heap is a binary tree where the children are not less than their parent. Assumes that elements [0]..[elem_count-2] form a valid heap. Then propagates [elem_count-1] upward by swapping if necessary. 
	
	## Parameters
	
	  * `temp`:    Pointer to unused allocated memory of elem_size.
	  * `compar`:  The comparison function to be used.
	
	## Returns
	
	 Returns the number of swap operations. 
	
	NOTE:  If the return value is zero for all elements in an array,        the array is sorted linearly and unchanged.
	
	## Reference
	
	[sc_containers.h:433](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:433:21)
	""" sc_array_pqueue_add
	export sc_array_pqueue_add
	𝐣𝐥.@cextern sc_array_pqueue_add(array::𝐣𝐥.Ptr{sc_array_t}, temp::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_array_pqueue_pop(array::𝐣𝐥.Ptr{sc_array_t}, result::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	```
	
	 Pops the smallest element from a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. This function assumes that the array forms a valid heap in ascending order. 
	
	## Parameters
	
	  * `result`:  Pointer to unused allocated memory of elem_size.
	  * `compar`:  The comparison function to be used.
	
	## Returns
	
	 Returns the number of swap operations. 
	
	NOTE: This function resizes the array to elem_count-1.
	
	## Reference
	
	[sc_containers.h:447](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:447:21)
	""" sc_array_pqueue_pop
	export sc_array_pqueue_pop
	𝐣𝐥.@cextern sc_array_pqueue_pop(array::𝐣𝐥.Ptr{sc_array_t}, result::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t
	
	𝐣𝐥.@doc """
	 A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See sc_mempool_t for that purpose.
	
	## Reference
	
	[sc_containers.h:613](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:613:1)
	""" sc_mstamp_t
	𝐣𝐥.@doc """
	 A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See sc_mempool_t for that purpose.
	
	## Reference
	
	[sc_containers.h:604](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:604:16)
	""" sc_mstamp
	export sc_mstamp, sc_mstamp_t
	𝐣𝐥.@ctypedef sc_mstamp_t 𝐣𝐥.@cstruct sc_mstamp {
		elem_size::size_t
		per_stamp::size_t
		stamp_size::size_t
		cur_snext::size_t
		current::𝐣𝐥.Ptr{𝐣𝐥.Cchar}
		remember::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_init(mst::𝐣𝐥.Ptr{sc_mstamp_t}, stamp_unit::size_t, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initialize a memory stamp container. We provide allocation of fixed-size memory items without allocating new memory in every request. Instead we block the allocations in what we call a stamp of multiple items. Even if no allocations are done, the container's internal memory must be freed eventually by sc_mstamp_reset.
	
	## Parameters
	
	  * `mst`:          Legal pointer to a stamp structure.
	  * `stamp_unit`:       Size of each memory block that we allocate.                              If it is larger than the element size,                              we may place more than one element in it.                              Passing 0 is legal and forces                              stamps that hold one item each.
	  * `elem_size`:        Size of each item.                              Passing 0 is legal.  In that case,                              sc_mstamp_alloc returns NULL.
	
	## Reference
	
	[sc_containers.h:632](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:632:21)
	""" sc_mstamp_init
	export sc_mstamp_init
	𝐣𝐥.@cextern sc_mstamp_init(mst::𝐣𝐥.Ptr{sc_mstamp_t}, stamp_unit::size_t, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_reset(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	```
	
	 Free all memory in a stamp structure and all items previously returned. 
	
	## Parameters
	
	  * `Properly`: initialized stamp container.                              On output, the structure is undefined.
	
	## Reference
	
	[sc_containers.h:639](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:639:21)
	""" sc_mstamp_reset
	export sc_mstamp_reset
	𝐣𝐥.@cextern sc_mstamp_reset(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_truncate(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	```
	
	 Free all memory in a stamp structure and initialize it anew. Equivalent to calling sc_mstamp_reset followed by                       sc_mstamp_init with the same                            stamp_unit and elem_size.
	
	## Parameters
	
	  * `Properly`: initialized stamp container.                              On output, its elements have been freed                              and it is ready for further use.
	
	## Reference
	
	[sc_containers.h:650](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:650:21)
	""" sc_mstamp_truncate
	export sc_mstamp_truncate
	𝐣𝐥.@cextern sc_mstamp_truncate(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_alloc(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Return a new item. The memory returned will stay legal until container is destroyed or truncated. 
	
	## Parameters
	
	  * `Properly`: initialized stamp container.
	
	## Returns
	
	                      Pointer to an item ready to use.                              Legal until sc_stamp_destroy or                              sc_stamp_truncate is called on mst.
	
	## Reference
	
	[sc_containers.h:660](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:660:21)
	""" sc_mstamp_alloc
	export sc_mstamp_alloc
	𝐣𝐥.@cextern sc_mstamp_alloc(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mstamp_memory_used(mst::𝐣𝐥.Ptr{sc_mstamp_t})::size_t
	```
	
	 Return memory size in bytes of all data allocated in the container. 
	
	## Parameters
	
	  * `Properly`: initialized stamp container.
	
	## Returns
	
	                      Total container memory size in bytes.
	
	## Reference
	
	[sc_containers.h:666](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:666:21)
	""" sc_mstamp_memory_used
	export sc_mstamp_memory_used
	𝐣𝐥.@cextern sc_mstamp_memory_used(mst::𝐣𝐥.Ptr{sc_mstamp_t})::size_t
	
	𝐣𝐥.@doc """
	 The sc_mempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool)    and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.
	
	## Reference
	
	[sc_containers.h:677](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:677:16)
	""" sc_mempool
	𝐣𝐥.@doc """
	 The sc_mempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool)    and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.
	
	## Reference
	
	[sc_containers.h:692](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:692:1)
	""" sc_mempool_t
	export sc_mempool, sc_mempool_t
	𝐣𝐥.@ctypedef sc_mempool_t 𝐣𝐥.@cstruct sc_mempool {
		elem_size::size_t
		elem_count::size_t
		zero_and_persist::𝐣𝐥.Cint
		mstamp::sc_mstamp_t
		freed::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_memory_used(mempool::𝐣𝐥.Ptr{sc_mempool_t})::size_t
	```
	
	 Calculate the memory used by a memory pool. 
	
	## Parameters
	
	  * `array`:       The memory pool.
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:698](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:698:21)
	""" sc_mempool_memory_used
	export sc_mempool_memory_used
	𝐣𝐥.@cextern sc_mempool_memory_used(mempool::𝐣𝐥.Ptr{sc_mempool_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	```
	
	 Creates a new mempool structure with the zero_and_persist option off. The contents of any elements returned by sc_mempool_alloc are undefined. 
	
	## Parameters
	
	  * `elem_size`:  Size of one element in bytes.
	
	## Returns
	
	 Returns an allocated and initialized memory pool.
	
	## Reference
	
	[sc_containers.h:705](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:705:21)
	""" sc_mempool_new
	export sc_mempool_new
	𝐣𝐥.@cextern sc_mempool_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_new_zero_and_persist(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	```
	
	 Creates a new mempool structure with the zero_and_persist option on. The memory of newly created elements is zero'd out, and the contents of an element are not touched between freeing and re-returning it. 
	
	## Parameters
	
	  * `elem_size`:  Size of one element in bytes.
	
	## Returns
	
	 Returns an allocated and initialized memory pool.
	
	## Reference
	
	[sc_containers.h:713](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:713:21)
	""" sc_mempool_new_zero_and_persist
	export sc_mempool_new_zero_and_persist
	𝐣𝐥.@cextern sc_mempool_new_zero_and_persist(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_init(mempool::𝐣𝐥.Ptr{sc_mempool_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Same as sc_mempool_new, but for an already allocated sc_mempool_t pointer. 
	
	## Reference
	
	[sc_containers.h:716](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:716:21)
	""" sc_mempool_init
	export sc_mempool_init
	𝐣𝐥.@cextern sc_mempool_init(mempool::𝐣𝐥.Ptr{sc_mempool_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_destroy(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a mempool structure. All elements that are still in use are invalidated. 
	
	## Parameters
	
	  * `mempool`:      Its memory is freed.
	
	## Reference
	
	[sc_containers.h:723](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:723:21)
	""" sc_mempool_destroy
	export sc_mempool_destroy
	𝐣𝐥.@cextern sc_mempool_destroy(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_destroy_null(pmempool::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_mempool_t}})::𝐣𝐥.Cvoid
	```
	
	 Destroy a mempool structure. All elements that are still in use are invalidated. 
	
	## Parameters
	
	  * `pmempool`:     Address of pointer to memory pool.                              Its memory is freed, pointer is NULLed.
	
	## Reference
	
	[sc_containers.h:730](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:730:21)
	""" sc_mempool_destroy_null
	export sc_mempool_destroy_null
	𝐣𝐥.@cextern sc_mempool_destroy_null(pmempool::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_mempool_t}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_reset(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Same as sc_mempool_destroy, but does not free the pointer 
	
	## Reference
	
	[sc_containers.h:733](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:733:21)
	""" sc_mempool_reset
	export sc_mempool_reset
	𝐣𝐥.@cextern sc_mempool_reset(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_mempool_truncate(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Invalidates all previously returned pointers, resets count to 0.
	
	## Reference
	
	[sc_containers.h:737](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:737:21)
	""" sc_mempool_truncate
	export sc_mempool_truncate
	𝐣𝐥.@cextern sc_mempool_truncate(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 The sc_link structure is one link of a linked list.
	
	## Reference
	
	[sc_containers.h:799](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:799:16)
	""" sc_link
	𝐣𝐥.@doc """
	 The sc_link structure is one link of a linked list.
	
	## Reference
	
	[sc_containers.h:804](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:804:1)
	""" sc_link_t
	export sc_link, sc_link_t
	𝐣𝐥.@ctypedef sc_link_t 𝐣𝐥.@cstruct sc_link {
		data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		next::𝐣𝐥.Ptr{𝐣𝐥.@cstruct sc_link}
	}
	
	𝐣𝐥.@doc """
	 The sc_list object provides a linked list.
	
	## Reference
	
	[sc_containers.h:808](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:808:16)
	""" sc_list
	𝐣𝐥.@doc """
	 The sc_list object provides a linked list.
	
	## Reference
	
	[sc_containers.h:819](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:819:1)
	""" sc_list_t
	export sc_list, sc_list_t
	𝐣𝐥.@ctypedef sc_list_t 𝐣𝐥.@cstruct sc_list {
		elem_count::size_t
		first::𝐣𝐥.Ptr{sc_link_t}
		last::𝐣𝐥.Ptr{sc_link_t}
		allocator_owned::𝐣𝐥.Cint
		allocator::𝐣𝐥.Ptr{sc_mempool_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_memory_used(list::𝐣𝐥.Ptr{sc_list_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	```
	
	 Calculate the total memory used by a list. 
	
	## Parameters
	
	  * `list`:        The list.
	  * `is_dynamic`:  True if created with sc_list_new,                         false if initialized with sc_list_init
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:827](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:827:21)
	""" sc_list_memory_used
	export sc_list_memory_used
	𝐣𝐥.@cextern sc_list_memory_used(list::𝐣𝐥.Ptr{sc_list_t}, is_dynamic::𝐣𝐥.Cint)::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_new(allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_list_t}
	```
	
	 Allocate a new, empty linked list. 
	
	## Parameters
	
	  * `allocator`:    Memory allocator for sc_link_t, can be NULL                          in which case an internal allocator is created.
	
	## Returns
	
	                  Pointer to a newly allocated, empty list object.
	
	## Reference
	
	[sc_containers.h:834](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:834:21)
	""" sc_list_new
	export sc_list_new
	𝐣𝐥.@cextern sc_list_new(allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_list_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_destroy(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a linked list structure in O(N). 
	
	## Parameters
	
	  * `list`:     All memory allocated for this list is freed.
	
	NOTE: If allocator was provided in sc_list_new, it will not be destroyed.
	
	## Reference
	
	[sc_containers.h:840](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:840:21)
	""" sc_list_destroy
	export sc_list_destroy
	𝐣𝐥.@cextern sc_list_destroy(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_init(list::𝐣𝐥.Ptr{sc_list_t}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	```
	
	 Initialize a list object with an external link allocator. 
	
	## Parameters
	
	  * `list`:       List structure to be initialized.
	  * `allocator`:  External memory allocator for sc_link_t,                             which must exist already.
	
	## Reference
	
	[sc_containers.h:847](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:847:21)
	""" sc_list_init
	export sc_list_init
	𝐣𝐥.@cextern sc_list_init(list::𝐣𝐥.Ptr{sc_list_t}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_reset(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	```
	
	 Remove all elements from a list in O(N). 
	
	## Parameters
	
	  * `list`:       List structure to be emptied.
	
	NOTE: Calling sc_list_init, then any list operations,       then sc_list_reset is memory neutral.
	
	## Reference
	
	[sc_containers.h:854](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:854:21)
	""" sc_list_reset
	export sc_list_reset
	𝐣𝐥.@cextern sc_list_reset(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_unlink(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	```
	
	 Unlink all list elements without returning them to the mempool. This runs in O(1) but is dangerous because the link memory stays alive. 
	
	## Parameters
	
	  * `list`:       List structure to be unlinked.
	
	## Reference
	
	[sc_containers.h:860](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:860:21)
	""" sc_list_unlink
	export sc_list_unlink
	𝐣𝐥.@cextern sc_list_unlink(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_prepend(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	```
	
	 Insert a list element at the beginning of the list. 
	
	## Parameters
	
	  * `list`:     Valid list object.
	  * `data`:         A new link is created holding this data.
	
	## Returns
	
	                  The link that has been created for data.
	
	## Reference
	
	[sc_containers.h:867](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:867:21)
	""" sc_list_prepend
	export sc_list_prepend
	𝐣𝐥.@cextern sc_list_prepend(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_append(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	```
	
	 Insert a list element at the end of the list. 
	
	## Parameters
	
	  * `list`:     Valid list object.
	  * `data`:         A new link is created holding this data.
	
	## Returns
	
	                  The link that has been created for data.
	
	## Reference
	
	[sc_containers.h:874](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:874:21)
	""" sc_list_append
	export sc_list_append
	𝐣𝐥.@cextern sc_list_append(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_insert(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	```
	
	 Insert an element after a given list position. 
	
	## Parameters
	
	  * `list`:     Valid list object.
	  * `pred`:     The predecessor of the element to be inserted.
	  * `data`:         A new link is created holding this data.
	
	## Returns
	
	                  The link that has been created for data.
	
	## Reference
	
	[sc_containers.h:882](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:882:21)
	""" sc_list_insert
	export sc_list_insert
	𝐣𝐥.@cextern sc_list_insert(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_remove(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Remove an element after a given list position. 
	
	## Parameters
	
	  * `list`:     Valid, non-empty list object.
	  * `pred`:  The predecessor of the element to be removed.                   If *pred* == NULL, the first element is removed,                   which is equivalent to calling sc_list_pop (list).
	
	## Returns
	
	           The data of the removed and freed link.
	
	## Reference
	
	[sc_containers.h:892](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:892:21)
	""" sc_list_remove
	export sc_list_remove
	𝐣𝐥.@cextern sc_list_remove(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_list_pop(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Remove an element from the front of the list. 
	
	## Parameters
	
	  * `list`:     Valid, non-empty list object.
	
	## Returns
	
	 Returns the data of the removed first list element.
	
	## Reference
	
	[sc_containers.h:898](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:898:21)
	""" sc_list_pop
	export sc_list_pop
	𝐣𝐥.@cextern sc_list_pop(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	 The sc_hash implements a hash table. It uses an array which has linked lists as elements.
	
	## Reference
	
	[sc_containers.h:917](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:917:1)
	""" sc_hash_t
	𝐣𝐥.@doc """
	 The sc_hash implements a hash table. It uses an array which has linked lists as elements.
	
	## Reference
	
	[sc_containers.h:903](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:903:16)
	""" sc_hash
	export sc_hash, sc_hash_t
	𝐣𝐥.@ctypedef sc_hash_t 𝐣𝐥.@cstruct sc_hash {
		elem_count::size_t
		slots::𝐣𝐥.Ptr{sc_array_t}
		user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		hash_fn::sc_hash_function_t
		equal_fn::sc_equal_function_t
		(resize_checks, resize_actions)::size_t
		allocator_owned::𝐣𝐥.Cint
		allocator::𝐣𝐥.Ptr{sc_mempool_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_function_string(s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, u::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cuint
	```
	
	 Compute a hash value from a null-terminated string. This hash function is NOT cryptographically safe! Use libcrypt then. 
	
	## Parameters
	
	  * `s`:        Null-terminated string to be hashed.
	  * `u`:        Not used.
	
	## Returns
	
	              The computed hash value as an unsigned integer.
	
	## Reference
	
	[sc_containers.h:925](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:925:21)
	""" sc_hash_function_string
	export sc_hash_function_string
	𝐣𝐥.@cextern sc_hash_function_string(s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, u::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cuint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_memory_used(hash::𝐣𝐥.Ptr{sc_hash_t})::size_t
	```
	
	 Calculate the memory used by a hash table. 
	
	## Parameters
	
	  * `hash`:        The hash table.
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:931](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:931:21)
	""" sc_hash_memory_used
	export sc_hash_memory_used
	𝐣𝐥.@cextern sc_hash_memory_used(hash::𝐣𝐥.Ptr{sc_hash_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_new(hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_hash_t}
	```
	
	 Create a new hash table. The number of hash slots is chosen dynamically. 
	
	## Parameters
	
	  * `hash_fn`:     Function to compute the hash value.
	  * `equal_fn`:    Function to test two objects for equality.
	  * `user_data`:   User data passed through to the hash function.
	  * `allocator`:   Memory allocator for sc_link_t, can be NULL.
	
	## Reference
	
	[sc_containers.h:940](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:940:21)
	""" sc_hash_new
	export sc_hash_new
	𝐣𝐥.@cextern sc_hash_new(hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_hash_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a hash table.
	
	## Details
	
	 If the allocator is owned, this runs in O(1), otherwise in O(N). 
	
	NOTE: If allocator was provided in sc_hash_new, it will not be destroyed.
	
	## Reference
	
	[sc_containers.h:949](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:949:21)
	""" sc_hash_destroy
	export sc_hash_destroy
	𝐣𝐥.@cextern sc_hash_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_destroy_null(phash::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_hash_t}})::𝐣𝐥.Cvoid
	```
	
	 Destroy a hash table and set its pointer to NULL. Destruction is done using sc_hash_destroy. 
	
	## Parameters
	
	  * `phash`:        Address of pointer to hash table.                              On output, pointer is NULLed.
	
	## Reference
	
	[sc_containers.h:956](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:956:21)
	""" sc_hash_destroy_null
	export sc_hash_destroy_null
	𝐣𝐥.@cextern sc_hash_destroy_null(phash::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_hash_t}})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_truncate(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Remove all entries from a hash table in O(N).
	
	## Details
	
	 If the allocator is owned, it calls sc_hash_unlink and sc_mempool_truncate. Otherwise, it calls sc_list_reset on every hash slot which is slower.
	
	## Reference
	
	[sc_containers.h:963](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:963:21)
	""" sc_hash_truncate
	export sc_hash_truncate
	𝐣𝐥.@cextern sc_hash_truncate(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_unlink(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Unlink all hash elements without returning them to the mempool.
	
	## Details
	
	 If the allocator is not owned, this runs faster than sc_hash_truncate,    but is dangerous because of potential memory leaks. 
	
	## Parameters
	
	  * `hash`:       Hash structure to be unlinked.
	
	## Reference
	
	[sc_containers.h:971](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:971:21)
	""" sc_hash_unlink
	export sc_hash_unlink
	𝐣𝐥.@cextern sc_hash_unlink(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_unlink_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Same effect as unlink and destroy, but in O(1). This is dangerous because of potential memory leaks. 
	
	## Parameters
	
	  * `hash`:       Hash structure to be unlinked and destroyed.
	
	## Reference
	
	[sc_containers.h:977](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:977:21)
	""" sc_hash_unlink_destroy
	export sc_hash_unlink_destroy
	𝐣𝐥.@cextern sc_hash_unlink_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_lookup(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	```
	
	 Check if an object is contained in the hash table. 
	
	## Parameters
	
	  * `v`:      The object to be looked up.
	  * `found`:  If found != NULL, *found is set to the address of the                     pointer to the already contained object if the object                     is found.  You can assign to **found to override.
	
	## Returns
	
	 Returns true if object is found, false otherwise.
	
	## Reference
	
	[sc_containers.h:986](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:986:21)
	""" sc_hash_lookup
	export sc_hash_lookup
	𝐣𝐥.@cextern sc_hash_lookup(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_insert_unique(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	```
	
	 Insert an object into a hash table if it is not contained already. 
	
	## Parameters
	
	  * `v`:      The object to be inserted.
	  * `found`:  If found != NULL, *found is set to the address of the                     pointer to the already contained, or if not present,                     the new object.  You can assign to **found to override.
	
	## Returns
	
	 Returns true if object is added, false if it is already contained.
	
	## Reference
	
	[sc_containers.h:995](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:995:21)
	""" sc_hash_insert_unique
	export sc_hash_insert_unique
	𝐣𝐥.@cextern sc_hash_insert_unique(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_remove(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}})::𝐣𝐥.Cint
	```
	
	 Remove an object from a hash table. 
	
	## Parameters
	
	  * `v`:      The object to be removed.
	  * `found`:  If found != NULL, *found is set to the object                       that is removed if that exists.
	
	## Returns
	
	 Returns true if object is found, false if is not contained.
	
	## Reference
	
	[sc_containers.h:1004](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1004:21)
	""" sc_hash_remove
	export sc_hash_remove
	𝐣𝐥.@cextern sc_hash_remove(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_foreach(hash::𝐣𝐥.Ptr{sc_hash_t}, fn::sc_hash_foreach_t)::𝐣𝐥.Cvoid
	```
	
	 Invoke a callback for every member of the hash table. The functions hash_fn and equal_fn are not called by this function.
	
	## Reference
	
	[sc_containers.h:1009](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1009:21)
	""" sc_hash_foreach
	export sc_hash_foreach
	𝐣𝐥.@cextern sc_hash_foreach(hash::𝐣𝐥.Ptr{sc_hash_t}, fn::sc_hash_foreach_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_print_statistics(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint, hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	```
	
	 Compute and print statistical information about the occupancy.
	
	## Reference
	
	[sc_containers.h:1013](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1013:21)
	""" sc_hash_print_statistics
	export sc_hash_print_statistics
	𝐣𝐥.@cextern sc_hash_print_statistics(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint, hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_containers.h:1025](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1025:1)
	""" sc_hash_array_data_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_containers.h:1017](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1017:16)
	""" sc_hash_array_data
	export sc_hash_array_data, sc_hash_array_data_t
	𝐣𝐥.@ctypedef sc_hash_array_data_t 𝐣𝐥.@cstruct sc_hash_array_data {
		pa::𝐣𝐥.Ptr{sc_array_t}
		hash_fn::sc_hash_function_t
		equal_fn::sc_equal_function_t
		user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
		current_item::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	}
	
	𝐣𝐥.@doc """
	 The sc_hash_array implements an array backed up by a hash table. This enables O(1) access for array elements.
	
	## Reference
	
	[sc_containers.h:1037](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1037:1)
	""" sc_hash_array_t
	𝐣𝐥.@doc """
	 The sc_hash_array implements an array backed up by a hash table. This enables O(1) access for array elements.
	
	## Reference
	
	[sc_containers.h:1030](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1030:16)
	""" sc_hash_array
	export sc_hash_array, sc_hash_array_t
	𝐣𝐥.@ctypedef sc_hash_array_t 𝐣𝐥.@cstruct sc_hash_array {
		a::sc_array_t
		internal_data::sc_hash_array_data_t
		h::𝐣𝐥.Ptr{sc_hash_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_memory_used(ha::𝐣𝐥.Ptr{sc_hash_array_t})::size_t
	```
	
	 Calculate the memory used by a hash array. 
	
	## Parameters
	
	  * `ha`:          The hash array.
	
	## Returns
	
	                 Memory used in bytes.
	
	## Reference
	
	[sc_containers.h:1043](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1043:21)
	""" sc_hash_array_memory_used
	export sc_hash_array_memory_used
	𝐣𝐥.@cextern sc_hash_array_memory_used(ha::𝐣𝐥.Ptr{sc_hash_array_t})::size_t
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_new(elem_size::size_t, hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_hash_array_t}
	```
	
	 Create a new hash array. 
	
	## Parameters
	
	  * `elem_size`:   Size of one array element in bytes.
	  * `hash_fn`:     Function to compute the hash value.
	  * `equal_fn`:    Function to test two objects for equality.
	
	## Reference
	
	[sc_containers.h:1050](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1050:21)
	""" sc_hash_array_new
	export sc_hash_array_new
	𝐣𝐥.@cextern sc_hash_array_new(elem_size::size_t, hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_hash_array_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_destroy(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	```
	
	 Destroy a hash array.
	
	## Reference
	
	[sc_containers.h:1057](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1057:21)
	""" sc_hash_array_destroy
	export sc_hash_array_destroy
	𝐣𝐥.@cextern sc_hash_array_destroy(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_is_valid(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cint
	```
	
	 Check the internal consistency of a hash array.
	
	## Reference
	
	[sc_containers.h:1061](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1061:21)
	""" sc_hash_array_is_valid
	export sc_hash_array_is_valid
	𝐣𝐥.@cextern sc_hash_array_is_valid(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_truncate(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	```
	
	 Remove all elements from the hash array. 
	
	## Parameters
	
	  * `hash_array`:   Hash array to truncate.
	
	## Reference
	
	[sc_containers.h:1066](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1066:21)
	""" sc_hash_array_truncate
	export sc_hash_array_truncate
	𝐣𝐥.@cextern sc_hash_array_truncate(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_lookup(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Check if an object is contained in a hash array.
	
	## Parameters
	
	  * `v`:          A pointer to the object.
	  * `position`:   If position != NULL, *position is set to the                         array position of the already contained object                         if found.
	
	## Returns
	
	                 Returns true if object is found, false otherwise.
	
	## Reference
	
	[sc_containers.h:1076](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1076:21)
	""" sc_hash_array_lookup
	export sc_hash_array_lookup
	𝐣𝐥.@cextern sc_hash_array_lookup(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_insert_unique(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Insert an object into a hash array if it is not contained already. The object is not copied into the array.  Use the return value for that. New objects are guaranteed to be added at the end of the array.
	
	## Parameters
	
	  * `v`:          A pointer to the object.  Used for search only.
	  * `position`:   If position != NULL, *position is set to the                         array position of the already contained, or if                         not present, the new object.
	
	## Returns
	
	                 Returns NULL if the object is already contained.                         Otherwise returns its new address in the array.
	
	## Reference
	
	[sc_containers.h:1090](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1090:21)
	""" sc_hash_array_insert_unique
	export sc_hash_array_insert_unique
	𝐣𝐥.@cextern sc_hash_array_insert_unique(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_hash_array_rip(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, rip::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	```
	
	 Extract the array data from a hash array and destroy everything else. 
	
	## Parameters
	
	  * `hash_array`:   The hash array is destroyed after extraction.
	  * `rip`:          Array structure that will be overwritten.                          All previous array data (if any) will be leaked.                          The filled array can be freed with sc_array_reset.
	
	## Reference
	
	[sc_containers.h:1099](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1099:21)
	""" sc_hash_array_rip
	export sc_hash_array_rip
	𝐣𝐥.@cextern sc_hash_array_rip(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, rip::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 The sc_recycle_array object provides an array of slots that can be reused.
	
	## Details
	
	 It keeps a list of free slots in the array which will be used for insertion while available.  Otherwise, the array is grown.
	
	## Reference
	
	[sc_containers.h:1116](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1116:1)
	""" sc_recycle_array_t
	𝐣𝐥.@doc """
	 The sc_recycle_array object provides an array of slots that can be reused.
	
	## Details
	
	 It keeps a list of free slots in the array which will be used for insertion while available.  Otherwise, the array is grown.
	
	## Reference
	
	[sc_containers.h:1107](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1107:16)
	""" sc_recycle_array
	export sc_recycle_array, sc_recycle_array_t
	𝐣𝐥.@ctypedef sc_recycle_array_t 𝐣𝐥.@cstruct sc_recycle_array {
		elem_count::size_t
		a::sc_array_t
		f::sc_array_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_init(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	```
	
	 Initialize a recycle array.
	
	## Parameters
	
	  * `elem_size`:   Size of the objects to be stored in the array.
	
	## Reference
	
	[sc_containers.h:1122](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1122:21)
	""" sc_recycle_array_init
	export sc_recycle_array_init
	𝐣𝐥.@cextern sc_recycle_array_init(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_reset(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t})::𝐣𝐥.Cvoid
	```
	
	 Reset a recycle array.
	
	## Details
	
	 As with all _reset functions, calling _init, then any array operations, then _reset is memory neutral.
	
	## Reference
	
	[sc_containers.h:1130](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1130:21)
	""" sc_recycle_array_reset
	export sc_recycle_array_reset
	𝐣𝐥.@cextern sc_recycle_array_reset(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_insert(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Insert an object into the recycle array. The object is not copied into the array.  Use the return value for that.
	
	## Parameters
	
	  * `position`:   If position != NULL, *position is set to the                         array position of the inserted object.
	
	## Returns
	
	                 Returns the new address of the object in the array.
	
	## Reference
	
	[sc_containers.h:1139](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1139:21)
	""" sc_recycle_array_insert
	export sc_recycle_array_insert
	𝐣𝐥.@cextern sc_recycle_array_insert(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_recycle_array_remove(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	```
	
	 Remove an object from the recycle array.  It must be valid.
	
	## Parameters
	
	  * `position`:   Index into the array for the object to remove.
	
	## Returns
	
	                The pointer to the removed object.  Will be valid                        as long as no other function is called                        on this recycle array.
	
	## Reference
	
	[sc_containers.h:1149](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_containers.h:1149:21)
	""" sc_recycle_array_remove
	export sc_recycle_array_remove
	𝐣𝐥.@cextern sc_recycle_array_remove(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}
	
	𝐣𝐥.@doc """
	 The value of zero means no error. 
	
	## Reference
	
	[sc_io.h:36](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:36:3)
	""" SC_IO_ERROR_NONE
	𝐣𝐥.@doc """
	 The io object is now disfunctional. 
	
	## Reference
	
	[sc_io.h:37](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:37:3)
	""" SC_IO_ERROR_FATAL
	𝐣𝐥.@doc """
	 Another io operation may resolve it.                                The function just returned was a noop. 
	
	## Reference
	
	[sc_io.h:38](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:38:3)
	""" SC_IO_ERROR_AGAIN
	𝐣𝐥.@doc """
	 Error values for io.
	
	## Reference
	
	[sc_io.h:41](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:41:1)
	""" sc_io_error_t
	export SC_IO_ERROR_AGAIN, SC_IO_ERROR_FATAL, SC_IO_ERROR_NONE, sc_io_error_t
	𝐣𝐥.@ctypedef sc_io_error_t 𝐣𝐥.@cenum {
		SC_IO_ERROR_NONE = 𝐣𝐥.Cint(0)
		SC_IO_ERROR_FATAL = 𝐣𝐥.Cint(-1)
		SC_IO_ERROR_AGAIN = 𝐣𝐥.Cint(-2)
	}
	
	𝐣𝐥.@doc """
	 Semantics as \"a\" in fopen. 
	
	## Reference
	
	[sc_io.h:46](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:46:3)
	""" SC_IO_MODE_APPEND
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:49](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:49:1)
	""" sc_io_mode_t
	𝐣𝐥.@doc """
	 Invalid entry to close list 
	
	## Reference
	
	[sc_io.h:47](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:47:3)
	""" SC_IO_MODE_LAST
	𝐣𝐥.@doc """
	 Semantics as \"w\" in fopen. 
	
	## Reference
	
	[sc_io.h:45](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:45:3)
	""" SC_IO_MODE_WRITE
	export SC_IO_MODE_APPEND, SC_IO_MODE_LAST, SC_IO_MODE_WRITE, sc_io_mode_t
	𝐣𝐥.@ctypedef sc_io_mode_t 𝐣𝐥.@cenum {
		SC_IO_MODE_WRITE = 𝐣𝐥.Cuint(0)
		SC_IO_MODE_APPEND = 𝐣𝐥.Cuint(1)
		SC_IO_MODE_LAST = 𝐣𝐥.Cuint(2)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:53](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:53:3)
	""" SC_IO_ENCODE_NONE
	𝐣𝐥.@doc """
	 Invalid entry to close list 
	
	## Reference
	
	[sc_io.h:54](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:54:3)
	""" SC_IO_ENCODE_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:56](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:56:1)
	""" sc_io_encode_t
	export SC_IO_ENCODE_LAST, SC_IO_ENCODE_NONE, sc_io_encode_t
	𝐣𝐥.@ctypedef sc_io_encode_t 𝐣𝐥.@cenum {
		SC_IO_ENCODE_NONE = 𝐣𝐥.Cuint(0)
		SC_IO_ENCODE_LAST = 𝐣𝐥.Cuint(1)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:65](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:65:1)
	""" sc_io_type_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:60](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:60:3)
	""" SC_IO_TYPE_BUFFER
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:61](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:61:3)
	""" SC_IO_TYPE_FILENAME
	𝐣𝐥.@doc """
	 Invalid entry to close list 
	
	## Reference
	
	[sc_io.h:63](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:63:3)
	""" SC_IO_TYPE_LAST
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:62](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:62:3)
	""" SC_IO_TYPE_FILEFILE
	export SC_IO_TYPE_BUFFER, SC_IO_TYPE_FILEFILE, SC_IO_TYPE_FILENAME, SC_IO_TYPE_LAST, sc_io_type_t
	𝐣𝐥.@ctypedef sc_io_type_t 𝐣𝐥.@cenum {
		SC_IO_TYPE_BUFFER = 𝐣𝐥.Cuint(0)
		SC_IO_TYPE_FILENAME = 𝐣𝐥.Cuint(1)
		SC_IO_TYPE_FILEFILE = 𝐣𝐥.Cuint(2)
		SC_IO_TYPE_LAST = 𝐣𝐥.Cuint(3)
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:78](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:78:1)
	""" sc_io_sink_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:67](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:67:16)
	""" sc_io_sink
	export sc_io_sink, sc_io_sink_t
	𝐣𝐥.@ctypedef sc_io_sink_t 𝐣𝐥.@cstruct sc_io_sink {
		iotype::sc_io_type_t
		mode::sc_io_mode_t
		encode::sc_io_encode_t
		buffer::𝐣𝐥.Ptr{sc_array_t}
		buffer_bytes::size_t
		file::𝐣𝐥.Ptr{FILE}
		bytes_in::size_t
		bytes_out::size_t
	}
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:92](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:92:1)
	""" sc_io_source_t
	𝐣𝐥.@doc """
	## Reference
	
	[sc_io.h:80](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:80:16)
	""" sc_io_source
	export sc_io_source, sc_io_source_t
	𝐣𝐥.@ctypedef sc_io_source_t 𝐣𝐥.@cstruct sc_io_source {
		iotype::sc_io_type_t
		encode::sc_io_encode_t
		buffer::𝐣𝐥.Ptr{sc_array_t}
		buffer_bytes::size_t
		file::𝐣𝐥.Ptr{FILE}
		bytes_in::size_t
		bytes_out::size_t
		mirror::𝐣𝐥.Ptr{sc_io_sink_t}
		mirror_buffer::𝐣𝐥.Ptr{sc_array_t}
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_new(iotype::sc_io_type_t, mode::sc_io_mode_t, encode::sc_io_encode_t, var\"?vararg?\"...)::𝐣𝐥.Ptr{sc_io_sink_t}
	```
	
	 Create a generic data sink. 
	
	## Parameters
	
	  * `iotype`:           Type of the sink.                              Depending on iotype, varargs must follow:                              BUFFER: sc_array_t * (existing array).                              FILENAME: const char * (name of file to open).                              FILEFILE: FILE * (file open for writing).                              These buffers are only borrowed by the sink.
	  * `mode`:             Mode to add data to sink.                              For type FILEFILE, data is always appended.
	  * `encode`:           Type of data encoding.
	
	## Returns
	
	                      Newly allocated sink, or NULL on error.
	
	## Reference
	
	[sc_io.h:106](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:106:21)
	""" sc_io_sink_new
	export sc_io_sink_new
	𝐣𝐥.@cextern sc_io_sink_new(iotype::sc_io_type_t, mode::sc_io_mode_t, encode::sc_io_encode_t, var"?vararg?"...)::𝐣𝐥.Ptr{sc_io_sink_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_destroy(sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	```
	
	 Free data sink. Calls sc_io_sink_complete and discards the final counts. Errors from complete lead to SC_IO_ERROR_FATAL returned from this function. Call sc_io_sink_complete yourself if bytes_out is of interest. 
	
	## Parameters
	
	  * `sink`:         The sink object to complete and free.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:117](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:117:21)
	""" sc_io_sink_destroy
	export sc_io_sink_destroy
	𝐣𝐥.@cextern sc_io_sink_destroy(sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_write(sink::𝐣𝐥.Ptr{sc_io_sink_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, bytes_avail::size_t)::𝐣𝐥.Cint
	```
	
	 Write data to a sink.  Data may be buffered and sunk in a later call. The internal counters sink->bytes_in and sink->bytes_out are updated. 
	
	## Parameters
	
	  * `sink`:         The sink object to write to.
	  * `data`:             Data passed into sink.
	  * `bytes_avail`:      Number of data bytes passed in.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:126](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:126:21)
	""" sc_io_sink_write
	export sc_io_sink_write
	𝐣𝐥.@cextern sc_io_sink_write(sink::𝐣𝐥.Ptr{sc_io_sink_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, bytes_avail::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_complete(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Flush all buffered output data to sink. This function may return SC_IO_ERROR_AGAIN if another write is required. Currently this may happen if BUFFER requires an integer multiple of bytes. If successful, the updated value of bytes read and written is returned in bytes_in/out, and the sink status is reset as if the sink had just been created.  In particular, the bytes counters are reset to zero. The internal state of the sink is not changed otherwise. It is legal to continue writing to the sink hereafter. The sink actions taken depend on its type. BUFFER, FILEFILE: none. FILENAME: call fclose on sink->file. 
	
	## Parameters
	
	  * `sink`:         The sink object to write to.
	  * `bytes_in`:     Bytes received since the last new or complete                              call.  May be NULL.
	  * `bytes_out`:    Bytes written since the last new or complete                              call.  May be NULL.
	
	## Returns
	
	                      0 if completed, nonzero on error.
	
	## Reference
	
	[sc_io.h:147](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:147:21)
	""" sc_io_sink_complete
	export sc_io_sink_complete
	𝐣𝐥.@cextern sc_io_sink_complete(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_sink_align(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_align::size_t)::𝐣𝐥.Cint
	```
	
	 Align sink to a byte boundary by writing zeros. 
	
	## Parameters
	
	  * `sink`:         The sink object to align.
	  * `bytes_align`:      Byte boundary.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:156](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:156:21)
	""" sc_io_sink_align
	export sc_io_sink_align
	𝐣𝐥.@cextern sc_io_sink_align(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_align::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_new(iotype::sc_io_type_t, encode::sc_io_encode_t, var\"?vararg?\"...)::𝐣𝐥.Ptr{sc_io_source_t}
	```
	
	 Create a generic data source. 
	
	## Parameters
	
	  * `iotype`:           Type of the source.                              Depending on iotype, varargs must follow:                              BUFFER: sc_array_t * (existing array).                              FILENAME: const char * (name of file to open).                              FILEFILE: FILE * (file open for reading).
	  * `encode`:           Type of data encoding.
	
	## Returns
	
	                      Newly allocated source, or NULL on error.
	
	## Reference
	
	[sc_io.h:168](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:168:21)
	""" sc_io_source_new
	export sc_io_source_new
	𝐣𝐥.@cextern sc_io_source_new(iotype::sc_io_type_t, encode::sc_io_encode_t, var"?vararg?"...)::𝐣𝐥.Ptr{sc_io_source_t}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_destroy(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	```
	
	 Free data source. Calls sc_io_source_complete and requires it to return no error. This is to avoid discarding buffered data that has not been passed to read. 
	
	## Parameters
	
	  * `source`:       The source object to free.
	
	## Returns
	
	                      0 on success.  Nonzero if an error is                              encountered or is_complete returns one.
	
	## Reference
	
	[sc_io.h:178](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:178:21)
	""" sc_io_source_destroy
	export sc_io_source_destroy
	𝐣𝐥.@cextern sc_io_source_destroy(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_read(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Read data from a source. The internal counters source->bytes_in and source->bytes_out are updated. Data is read until the data buffer has not enough room anymore, or source becomes empty.  It is possible that data already read internally remains in the source object for the next call.  Call sc_io_source_complete and check its return value to find out. Returns an error if bytes_out is NULL and less than bytes_avail are read. 
	
	## Parameters
	
	  * `source`:       The source object to read from.
	  * `data`:             Data buffer for reading from sink.                              If NULL the output data will be thrown away.
	  * `bytes_avail`:      Number of bytes available in data buffer.
	  * `bytes_out`:    If not NULL, byte count read into data buffer.                              Otherwise, requires to read exactly bytes_avail.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:195](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:195:21)
	""" sc_io_source_read
	export sc_io_source_read
	𝐣𝐥.@cextern sc_io_source_read(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_complete(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Determine whether all data buffered from source has been returned by read. If it returns SC_IO_ERROR_AGAIN, another sc_io_source_read is required. If the call returns no error, the internal counters source->bytes_in and source->bytes_out are returned to the caller if requested, and reset to 0. The internal state of the source is not changed otherwise. It is legal to continue reading from the source hereafter.
	
	## Parameters
	
	  * `source`:       The source object to read from.
	  * `bytes_in`:     If not NULL and true is returned,                              the total size of the data sourced.
	  * `bytes_out`:    If not NULL and true is returned,                              total bytes passed out by source_read.
	
	## Returns
	
	                      SC_IO_ERROR_AGAIN if buffered data remaining.                              Otherwise return ERROR_NONE and reset counters.
	
	## Reference
	
	[sc_io.h:214](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:214:21)
	""" sc_io_source_complete
	export sc_io_source_complete
	𝐣𝐥.@cextern sc_io_source_complete(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_align(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_align::size_t)::𝐣𝐥.Cint
	```
	
	 Align source to a byte boundary by skipping. 
	
	## Parameters
	
	  * `source`:       The source object to align.
	  * `bytes_align`:      Byte boundary.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:223](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:223:21)
	""" sc_io_source_align
	export sc_io_source_align
	𝐣𝐥.@cextern sc_io_source_align(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_align::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_activate_mirror(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	```
	
	 Activate a buffer that mirrors (i.e., stores) the data that was read. 
	
	## Parameters
	
	  * `source`:       The source object to activate mirror in.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:230](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:230:21)
	""" sc_io_source_activate_mirror
	export sc_io_source_activate_mirror
	𝐣𝐥.@cextern sc_io_source_activate_mirror(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_io_source_read_mirror(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	```
	
	 Read data from the source's mirror. Same behaviour as sc_io_source_read. 
	
	## Parameters
	
	  * `source`:       The source object to read mirror data from.
	
	## Returns
	
	                      0 on success, nonzero on error.
	
	## Reference
	
	[sc_io.h:237](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:237:21)
	""" sc_io_source_read_mirror
	export sc_io_source_read_mirror
	𝐣𝐥.@cextern sc_io_source_read_mirror(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_vtk_write_binary(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	```
	
	 This function writes numeric binary data in VTK base64 encoding. 
	
	## Parameters
	
	  * `vtkfile`:        Stream opened for writing.
	  * `numeric_data`:   A pointer to a numeric data array.
	  * `byte_length`:    The length of the data array in bytes.
	
	## Returns
	
	               Returns 0 on success, -1 on file error.
	
	## Reference
	
	[sc_io.h:248](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:248:21)
	""" sc_vtk_write_binary
	export sc_vtk_write_binary
	𝐣𝐥.@cextern sc_vtk_write_binary(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_vtk_write_compressed(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	```
	
	 This function writes numeric binary data in VTK compressed format. 
	
	## Parameters
	
	  * `vtkfile`:        Stream opened for writing.
	  * `numeric_data`:   A pointer to a numeric data array.
	  * `byte_length`:    The length of the data array in bytes.
	
	## Returns
	
	               Returns 0 on success, -1 on file error.
	
	## Reference
	
	[sc_io.h:257](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:257:21)
	""" sc_vtk_write_compressed
	export sc_vtk_write_compressed
	𝐣𝐥.@cextern sc_vtk_write_compressed(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_fwrite(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Write memory content to a file. 
	
	## Parameters
	
	  * `ptr`:      Data array to write to disk.
	  * `size`:     Size of one array member.
	  * `nmemb`:    Number of array members.
	  * `file`: File pointer, must be opened for writing.
	  * `errmsg`:   Error message passed to SC_CHECK_ABORT.
	
	NOTE:                This function aborts on file errors.
	
	## Reference
	
	[sc_io.h:269](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:269:21)
	""" sc_fwrite
	export sc_fwrite
	𝐣𝐥.@cextern sc_fwrite(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_fread(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	```
	
	 Read file content into memory. 
	
	## Parameters
	
	  * `ptr`:     Data array to read from disk.
	  * `size`:     Size of one array member.
	  * `nmemb`:    Number of array members.
	  * `file`: File pointer, must be opened for reading.
	  * `errmsg`:   Error message passed to SC_CHECK_ABORT.
	
	NOTE:                This function aborts on file errors.
	
	## Reference
	
	[sc_io.h:280](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:280:21)
	""" sc_fread
	export sc_fread
	𝐣𝐥.@cextern sc_fread(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_fflush_fsync_fclose(file::𝐣𝐥.Ptr{FILE})::𝐣𝐥.Cvoid
	```
	
	 Best effort to flush a file's data to disc and close it. 
	
	## Parameters
	
	  * `file`:         File open for writing.
	
	## Reference
	
	[sc_io.h:286](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_io.h:286:21)
	""" sc_fflush_fsync_fclose
	export sc_fflush_fsync_fclose
	𝐣𝐥.@cextern sc_fflush_fsync_fclose(file::𝐣𝐥.Ptr{FILE})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	 An unsigned 128 bit integer represented as two uint64_t. 
	
	## Reference
	
	[sc_uint128.h:49](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:49:1)
	""" sc_uint128_t
	𝐣𝐥.@doc """
	 An unsigned 128 bit integer represented as two uint64_t. 
	
	## Reference
	
	[sc_uint128.h:44](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:44:16)
	""" sc_uint128
	export sc_uint128, sc_uint128_t
	𝐣𝐥.@ctypedef sc_uint128_t 𝐣𝐥.@cstruct sc_uint128 {
		high_bits::uint64_t
		low_bits::uint64_t
	}
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	```
	
	 Compare the sc_uint128_t *a* and the sc_uint128_t *b.* 
	
	## Parameters
	
	  * `a`: A pointer to a sc_uint128_t.
	  * `b`: A pointer to a sc_uint128_t.
	
	## Returns
	
	        Returns -1 if a < b,                         1 if a > b and                         0 if a == b.
	
	## Reference
	
	[sc_uint128.h:58](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:58:21)
	""" sc_uint128_compare
	export sc_uint128_compare
	𝐣𝐥.@cextern sc_uint128_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cint
	```
	
	 Checks if the sc_uint128_t *a* and the sc_uint128_t *b* are equal. 
	
	## Parameters
	
	  * `a`: A pointer to a sc_uint128_t.
	  * `b`: A pointer to a sc_uint128_t.
	
	## Returns
	
	        Returns a true value if *a* and *b* are equal,                false otherwise.
	
	## Reference
	
	[sc_uint128.h:66](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:66:21)
	""" sc_uint128_is_equal
	export sc_uint128_is_equal
	𝐣𝐥.@cextern sc_uint128_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_init(a::𝐣𝐥.Ptr{sc_uint128_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	```
	
	 Initializes an unsigned 128 bit integer to a given value. 
	
	## Parameters
	
	  * `a`:        A pointer to the sc_uint128_t that will be                          initialized.
	  * `high`:     The given high bits to initialize *a.*
	  * `low`:      The given low bits to initialize *a.*
	
	## Reference
	
	[sc_uint128.h:75](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:75:21)
	""" sc_uint128_init
	export sc_uint128_init
	𝐣𝐥.@cextern sc_uint128_init(a::𝐣𝐥.Ptr{sc_uint128_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cint
	```
	
	 Returns the bit_number-th bit of *input.* This function checks a bit of an existing, initialized value. 
	
	## Parameters
	
	  * `input`:      A pointer to a sc_uint128_t.
	  * `bit_number`: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= *bit_number* < 128.
	
	## Returns
	
	                    True if the checked bit is set, false if not.
	
	## Reference
	
	[sc_uint128.h:86](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:86:21)
	""" sc_uint128_chk_bit
	export sc_uint128_chk_bit
	𝐣𝐥.@cextern sc_uint128_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cint
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_set_bit(a::𝐣𝐥.Ptr{sc_uint128_t}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	```
	
	 Sets the exponent-th bit of *a* to one and keep all other bits. This function modifies an existing, initialized value. 
	
	## Parameters
	
	  * `a`:        A pointer to a sc_uint128_t.
	  * `exponent`:      The bit (0-based from the rightmost bit)                          that is set to one by logical or.                          0 <= *exponent* < 128.
	
	## Reference
	
	[sc_uint128.h:96](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:96:21)
	""" sc_uint128_set_bit
	export sc_uint128_set_bit
	𝐣𝐥.@cextern sc_uint128_set_bit(a::𝐣𝐥.Ptr{sc_uint128_t}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, output::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Copies an initialized sc_uint128_t to a sc_uint128_t. 
	
	## Parameters
	
	  * `input`:    A pointer to the sc_uint128 that is copied.
	  * `output`:   A pointer to a sc_uint128_t.                          The high and low bits of *output* will                          be set to the high and low bits of                          *input,* respectively.
	
	## Reference
	
	[sc_uint128.h:105](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:105:21)
	""" sc_uint128_copy
	export sc_uint128_copy
	𝐣𝐥.@cextern sc_uint128_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, output::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Adds the uint128_t *b* to the uint128_t *a.* *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a sc_uint128_t.
	  * `b`:       A pointer to a sc_uint128_t.
	  * `result`:  A pointer to a sc_uint128_t.                      The sum *a* + *b* will be saved in *result.*
	
	## Reference
	
	[sc_uint128.h:116](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:116:21)
	""" sc_uint128_add
	export sc_uint128_add
	𝐣𝐥.@cextern sc_uint128_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Subtracts the uint128_t *b* from the uint128_t *a.* This function assumes that the result is >= 0. *result* == *a* or *result* == *b* is not allowed. *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a sc_uint128_t.
	  * `b`:       A pointer to a sc_uint128_t.
	  * `result`:  A pointer to a sc_uint128_t.                      The difference *a* - *b* will be saved in *result.*
	
	## Reference
	
	[sc_uint128.h:129](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:129:21)
	""" sc_uint128_sub
	export sc_uint128_sub
	𝐣𝐥.@cextern sc_uint128_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise negation of the uint128_t *a.* *a* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a sc_uint128_t.
	  * `result`:   A pointer to a sc_uint128_t.                      The bitwise negation of *a* will be saved in                      *result.*
	
	## Reference
	
	[sc_uint128.h:140](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:140:21)
	""" sc_uint128_bitwise_neg
	export sc_uint128_bitwise_neg
	𝐣𝐥.@cextern sc_uint128_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:        A pointer to a sc_uint128_t.
	  * `b`:        A pointer to a sc_uint128_t.
	  * `result`:   A pointer to a sc_uint128_t.                      The bitwise or of *a* and *b* will be                      saved in *result.*
	
	## Reference
	
	[sc_uint128.h:152](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:152:21)
	""" sc_uint128_bitwise_or
	export sc_uint128_bitwise_or
	𝐣𝐥.@cextern sc_uint128_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *result* is allowed. Furthermore, *a* == *result* and/or *b* == *result* is allowed. 
	
	## Parameters
	
	  * `a`:       A pointer to a sc_uint128_t.
	  * `b`:       A pointer to a sc_uint128_t.
	  * `result`:  A pointer to a sc_uint128_t.                      The bitwise and of *a* and *b* will be saved.                      in *result.*
	
	## Reference
	
	[sc_uint128.h:165](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:165:21)
	""" sc_uint128_bitwise_and
	export sc_uint128_bitwise_and
	𝐣𝐥.@cextern sc_uint128_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit right shift of uint128_t *input* by shift_count bits. We shift in zeros from the left. If *shift_count* >= 128, *result* is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a sc_uint128_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a sc_uint128_t.                              The right shifted number will be saved                              in *result.*
	
	## Reference
	
	[sc_uint128.h:179](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:179:21)
	""" sc_uint128_shift_right
	export sc_uint128_shift_right
	𝐣𝐥.@cextern sc_uint128_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bit left shift of uint128_t *input* by shift_count bits. We shift in zeros from the right. If *shift_count* >= 128, *result* is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. *input* == *result* is allowed. 
	
	## Parameters
	
	  * `input`:       A pointer to a sc_uint128_t.
	  * `shift_count`: Bits to shift. *shift_count* >= 0.
	  * `result`:      A pointer to a sc_uint128_t.                              The left shifted number will be saved                              in *result.*
	
	## Reference
	
	[sc_uint128.h:193](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:193:21)
	""" sc_uint128_shift_left
	export sc_uint128_shift_left
	𝐣𝐥.@cextern sc_uint128_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_add_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Adds the uint128 *b* to the uint128_t *a.* The result is saved in *a.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t. *a*                      will be overwritten by *a* + *b.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:203](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:203:21)
	""" sc_uint128_add_inplace
	export sc_uint128_add_inplace
	𝐣𝐥.@cextern sc_uint128_add_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_sub_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Subtracts the uint128_t *b* from the uint128_t *a.* The result is saved in *a.* *a* == *b* is allowed. This function assumes that the result is >= 0. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t.                      *a* will be overwritten by *a* - *b.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:213](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:213:21)
	""" sc_uint128_sub_inplace
	export sc_uint128_sub_inplace
	𝐣𝐥.@cextern sc_uint128_sub_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_or_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise or of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t.                      The bitwise or will be saved in *a.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:222](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:222:21)
	""" sc_uint128_bitwise_or_inplace
	export sc_uint128_bitwise_or_inplace
	𝐣𝐥.@cextern sc_uint128_bitwise_or_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	```
	𝐣𝐥.@cextern sc_uint128_bitwise_and_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	```
	
	 Calculates the bitwise and of the uint128_t *a* and the uint128_t *b.* *a* == *b* is allowed. 
	
	## Parameters
	
	  * `a`:   A pointer to a sc_uint128_t.                      The bitwise and will be saved in *a.*
	  * `b`:   A pointer to a sc_uint128_t.
	
	## Reference
	
	[sc_uint128.h:231](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_uint128.h:231:21)
	""" sc_uint128_bitwise_and_inplace
	export sc_uint128_bitwise_and_inplace
	𝐣𝐥.@cextern sc_uint128_bitwise_and_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:2](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:2:9)
	""" :(@_CONFIG_SC_CONFIG_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:2](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:2:9)
	""" _CONFIG_SC_CONFIG_H
	export @_CONFIG_SC_CONFIG_H
	macro _CONFIG_SC_CONFIG_H() return quote 1 end end
	const _CONFIG_SC_CONFIG_H = (@_CONFIG_SC_CONFIG_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:13](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:13:9)
	""" SC_CC
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:13](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:13:9)
	""" :(@SC_CC)
	export @SC_CC, SC_CC
	macro SC_CC() return quote "cc" end end
	const SC_CC = (@SC_CC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:18](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:18:9)
	""" SC_CFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:18](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:18:9)
	""" :(@SC_CFLAGS)
	export @SC_CFLAGS, SC_CFLAGS
	macro SC_CFLAGS() return quote "-g -O2" end end
	const SC_CFLAGS = (@SC_CFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:23](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:23:9)
	""" :(@SC_CPP)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:23](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:23:9)
	""" SC_CPP
	export @SC_CPP, SC_CPP
	macro SC_CPP() return quote "cc -E" end end
	const SC_CPP = (@SC_CPP)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:28](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:28:9)
	""" SC_CPPFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:28](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:28:9)
	""" :(@SC_CPPFLAGS)
	export @SC_CPPFLAGS, SC_CPPFLAGS
	macro SC_CPPFLAGS() return quote "-I/workspace/destdir/include" end end
	const SC_CPPFLAGS = (@SC_CPPFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:33](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:33:9)
	""" :(@SC_CXX)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:33](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:33:9)
	""" SC_CXX
	export @SC_CXX, SC_CXX
	macro SC_CXX() return quote "c++" end end
	const SC_CXX = (@SC_CXX)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:38](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:38:9)
	""" :(@SC_CXXFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:38](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:38:9)
	""" SC_CXXFLAGS
	export @SC_CXXFLAGS, SC_CXXFLAGS
	macro SC_CXXFLAGS() return quote "-g -O2" end end
	const SC_CXXFLAGS = (@SC_CXXFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:53](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:53:9)
	""" :(@SC_ENABLE_MEMALIGN)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:53](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:53:9)
	""" SC_ENABLE_MEMALIGN
	export @SC_ENABLE_MEMALIGN, SC_ENABLE_MEMALIGN
	macro SC_ENABLE_MEMALIGN() return quote 1 end end
	const SC_ENABLE_MEMALIGN = (@SC_ENABLE_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:85](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:85:9)
	""" :(@SC_ENABLE_USE_REALLOC)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:85](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:85:9)
	""" SC_ENABLE_USE_REALLOC
	export @SC_ENABLE_USE_REALLOC, SC_ENABLE_USE_REALLOC
	macro SC_ENABLE_USE_REALLOC() return quote 1 end end
	const SC_ENABLE_USE_REALLOC = (@SC_ENABLE_USE_REALLOC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:90](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:90:9)
	""" :(@SC_ENABLE_V4L2)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:90](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:90:9)
	""" SC_ENABLE_V4L2
	export @SC_ENABLE_V4L2, SC_ENABLE_V4L2
	macro SC_ENABLE_V4L2() return quote 1 end end
	const SC_ENABLE_V4L2 = (@SC_ENABLE_V4L2)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:95](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:95:9)
	""" :(@SC_F77)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:95](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:95:9)
	""" SC_F77
	export @SC_F77, SC_F77
	macro SC_F77() return quote "gfortran" end end
	const SC_F77 = (@SC_F77)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:118](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:118:9)
	""" SC_FC
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:118](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:118:9)
	""" :(@SC_FC)
	export @SC_FC, SC_FC
	macro SC_FC() return quote "gfortran" end end
	const SC_FC = (@SC_FC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:123](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:123:9)
	""" SC_FCFLAGS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:123](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:123:9)
	""" :(@SC_FCFLAGS)
	export @SC_FCFLAGS, SC_FCFLAGS
	macro SC_FCFLAGS() return quote "-g -O2" end end
	const SC_FCFLAGS = (@SC_FCFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:149](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:149:9)
	""" :(@SC_FFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:149](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:149:9)
	""" SC_FFLAGS
	export @SC_FFLAGS, SC_FFLAGS
	macro SC_FFLAGS() return quote "-g -O2" end end
	const SC_FFLAGS = (@SC_FFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:157](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:157:9)
	""" :(@SC_HAVE_BACKTRACE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:157](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:157:9)
	""" SC_HAVE_BACKTRACE
	export @SC_HAVE_BACKTRACE, SC_HAVE_BACKTRACE
	macro SC_HAVE_BACKTRACE() return quote 1 end end
	const SC_HAVE_BACKTRACE = (@SC_HAVE_BACKTRACE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:162](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:162:9)
	""" :(@SC_HAVE_BACKTRACE_SYMBOLS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:162](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:162:9)
	""" SC_HAVE_BACKTRACE_SYMBOLS
	export @SC_HAVE_BACKTRACE_SYMBOLS, SC_HAVE_BACKTRACE_SYMBOLS
	macro SC_HAVE_BACKTRACE_SYMBOLS() return quote 1 end end
	const SC_HAVE_BACKTRACE_SYMBOLS = (@SC_HAVE_BACKTRACE_SYMBOLS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:167](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:167:9)
	""" SC_HAVE_DLFCN_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:167](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:167:9)
	""" :(@SC_HAVE_DLFCN_H)
	export @SC_HAVE_DLFCN_H, SC_HAVE_DLFCN_H
	macro SC_HAVE_DLFCN_H() return quote 1 end end
	const SC_HAVE_DLFCN_H = (@SC_HAVE_DLFCN_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:172](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:172:9)
	""" SC_HAVE_EXECINFO_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:172](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:172:9)
	""" :(@SC_HAVE_EXECINFO_H)
	export @SC_HAVE_EXECINFO_H, SC_HAVE_EXECINFO_H
	macro SC_HAVE_EXECINFO_H() return quote 1 end end
	const SC_HAVE_EXECINFO_H = (@SC_HAVE_EXECINFO_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:177](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:177:9)
	""" SC_HAVE_FCNTL_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:177](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:177:9)
	""" :(@SC_HAVE_FCNTL_H)
	export @SC_HAVE_FCNTL_H, SC_HAVE_FCNTL_H
	macro SC_HAVE_FCNTL_H() return quote 1 end end
	const SC_HAVE_FCNTL_H = (@SC_HAVE_FCNTL_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:182](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:182:9)
	""" :(@SC_HAVE_FSYNC)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:182](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:182:9)
	""" SC_HAVE_FSYNC
	export @SC_HAVE_FSYNC, SC_HAVE_FSYNC
	macro SC_HAVE_FSYNC() return quote 1 end end
	const SC_HAVE_FSYNC = (@SC_HAVE_FSYNC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:187](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:187:9)
	""" :(@SC_HAVE_INTTYPES_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:187](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:187:9)
	""" SC_HAVE_INTTYPES_H
	export @SC_HAVE_INTTYPES_H, SC_HAVE_INTTYPES_H
	macro SC_HAVE_INTTYPES_H() return quote 1 end end
	const SC_HAVE_INTTYPES_H = (@SC_HAVE_INTTYPES_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:192](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:192:9)
	""" SC_HAVE_LINUX_VIDEODEV2_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:192](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:192:9)
	""" :(@SC_HAVE_LINUX_VIDEODEV2_H)
	export @SC_HAVE_LINUX_VIDEODEV2_H, SC_HAVE_LINUX_VIDEODEV2_H
	macro SC_HAVE_LINUX_VIDEODEV2_H() return quote 1 end end
	const SC_HAVE_LINUX_VIDEODEV2_H = (@SC_HAVE_LINUX_VIDEODEV2_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:215](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:215:9)
	""" SC_HAVE_MEMORY_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:215](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:215:9)
	""" :(@SC_HAVE_MEMORY_H)
	export @SC_HAVE_MEMORY_H, SC_HAVE_MEMORY_H
	macro SC_HAVE_MEMORY_H() return quote 1 end end
	const SC_HAVE_MEMORY_H = (@SC_HAVE_MEMORY_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:223](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:223:9)
	""" :(@SC_HAVE_POSIX_MEMALIGN)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:223](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:223:9)
	""" SC_HAVE_POSIX_MEMALIGN
	export @SC_HAVE_POSIX_MEMALIGN, SC_HAVE_POSIX_MEMALIGN
	macro SC_HAVE_POSIX_MEMALIGN() return quote 1 end end
	const SC_HAVE_POSIX_MEMALIGN = (@SC_HAVE_POSIX_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:228](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:228:9)
	""" :(@SC_HAVE_QSORT_R)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:228](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:228:9)
	""" SC_HAVE_QSORT_R
	export @SC_HAVE_QSORT_R, SC_HAVE_QSORT_R
	macro SC_HAVE_QSORT_R() return quote 1 end end
	const SC_HAVE_QSORT_R = (@SC_HAVE_QSORT_R)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:233](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:233:9)
	""" :(@SC_HAVE_SIGNAL_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:233](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:233:9)
	""" SC_HAVE_SIGNAL_H
	export @SC_HAVE_SIGNAL_H, SC_HAVE_SIGNAL_H
	macro SC_HAVE_SIGNAL_H() return quote 1 end end
	const SC_HAVE_SIGNAL_H = (@SC_HAVE_SIGNAL_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:238](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:238:9)
	""" SC_HAVE_STDINT_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:238](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:238:9)
	""" :(@SC_HAVE_STDINT_H)
	export @SC_HAVE_STDINT_H, SC_HAVE_STDINT_H
	macro SC_HAVE_STDINT_H() return quote 1 end end
	const SC_HAVE_STDINT_H = (@SC_HAVE_STDINT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:243](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:243:9)
	""" SC_HAVE_STDLIB_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:243](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:243:9)
	""" :(@SC_HAVE_STDLIB_H)
	export @SC_HAVE_STDLIB_H, SC_HAVE_STDLIB_H
	macro SC_HAVE_STDLIB_H() return quote 1 end end
	const SC_HAVE_STDLIB_H = (@SC_HAVE_STDLIB_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:248](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:248:9)
	""" :(@SC_HAVE_STRINGS_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:248](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:248:9)
	""" SC_HAVE_STRINGS_H
	export @SC_HAVE_STRINGS_H, SC_HAVE_STRINGS_H
	macro SC_HAVE_STRINGS_H() return quote 1 end end
	const SC_HAVE_STRINGS_H = (@SC_HAVE_STRINGS_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:253](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:253:9)
	""" :(@SC_HAVE_STRING_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:253](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:253:9)
	""" SC_HAVE_STRING_H
	export @SC_HAVE_STRING_H, SC_HAVE_STRING_H
	macro SC_HAVE_STRING_H() return quote 1 end end
	const SC_HAVE_STRING_H = (@SC_HAVE_STRING_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:258](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:258:9)
	""" :(@SC_HAVE_STRTOL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:258](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:258:9)
	""" SC_HAVE_STRTOL
	export @SC_HAVE_STRTOL, SC_HAVE_STRTOL
	macro SC_HAVE_STRTOL() return quote 1 end end
	const SC_HAVE_STRTOL = (@SC_HAVE_STRTOL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:263](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:263:9)
	""" :(@SC_HAVE_STRTOLL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:263](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:263:9)
	""" SC_HAVE_STRTOLL
	export @SC_HAVE_STRTOLL, SC_HAVE_STRTOLL
	macro SC_HAVE_STRTOLL() return quote 1 end end
	const SC_HAVE_STRTOLL = (@SC_HAVE_STRTOLL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:268](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:268:9)
	""" SC_HAVE_SYS_IOCTL_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:268](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:268:9)
	""" :(@SC_HAVE_SYS_IOCTL_H)
	export @SC_HAVE_SYS_IOCTL_H, SC_HAVE_SYS_IOCTL_H
	macro SC_HAVE_SYS_IOCTL_H() return quote 1 end end
	const SC_HAVE_SYS_IOCTL_H = (@SC_HAVE_SYS_IOCTL_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:273](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:273:9)
	""" SC_HAVE_SYS_SELECT_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:273](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:273:9)
	""" :(@SC_HAVE_SYS_SELECT_H)
	export @SC_HAVE_SYS_SELECT_H, SC_HAVE_SYS_SELECT_H
	macro SC_HAVE_SYS_SELECT_H() return quote 1 end end
	const SC_HAVE_SYS_SELECT_H = (@SC_HAVE_SYS_SELECT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:278](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:278:9)
	""" SC_HAVE_SYS_STAT_H
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:278](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:278:9)
	""" :(@SC_HAVE_SYS_STAT_H)
	export @SC_HAVE_SYS_STAT_H, SC_HAVE_SYS_STAT_H
	macro SC_HAVE_SYS_STAT_H() return quote 1 end end
	const SC_HAVE_SYS_STAT_H = (@SC_HAVE_SYS_STAT_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:283](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:283:9)
	""" :(@SC_HAVE_SYS_TIME_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:283](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:283:9)
	""" SC_HAVE_SYS_TIME_H
	export @SC_HAVE_SYS_TIME_H, SC_HAVE_SYS_TIME_H
	macro SC_HAVE_SYS_TIME_H() return quote 1 end end
	const SC_HAVE_SYS_TIME_H = (@SC_HAVE_SYS_TIME_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:288](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:288:9)
	""" :(@SC_HAVE_SYS_TYPES_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:288](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:288:9)
	""" SC_HAVE_SYS_TYPES_H
	export @SC_HAVE_SYS_TYPES_H, SC_HAVE_SYS_TYPES_H
	macro SC_HAVE_SYS_TYPES_H() return quote 1 end end
	const SC_HAVE_SYS_TYPES_H = (@SC_HAVE_SYS_TYPES_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:293](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:293:9)
	""" :(@SC_HAVE_TIME_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:293](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:293:9)
	""" SC_HAVE_TIME_H
	export @SC_HAVE_TIME_H, SC_HAVE_TIME_H
	macro SC_HAVE_TIME_H() return quote 1 end end
	const SC_HAVE_TIME_H = (@SC_HAVE_TIME_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:298](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:298:9)
	""" :(@SC_HAVE_UNISTD_H)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:298](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:298:9)
	""" SC_HAVE_UNISTD_H
	export @SC_HAVE_UNISTD_H, SC_HAVE_UNISTD_H
	macro SC_HAVE_UNISTD_H() return quote 1 end end
	const SC_HAVE_UNISTD_H = (@SC_HAVE_UNISTD_H)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:303](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:303:9)
	""" SC_HAVE_ZLIB
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:303](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:303:9)
	""" :(@SC_HAVE_ZLIB)
	export @SC_HAVE_ZLIB, SC_HAVE_ZLIB
	macro SC_HAVE_ZLIB() return quote 1 end end
	const SC_HAVE_ZLIB = (@SC_HAVE_ZLIB)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:311](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:311:9)
	""" :(@SC_LDFLAGS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:311](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:311:9)
	""" SC_LDFLAGS
	export @SC_LDFLAGS, SC_LDFLAGS
	macro SC_LDFLAGS() return quote "-L/workspace/destdir/lib" end end
	const SC_LDFLAGS = (@SC_LDFLAGS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:316](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:316:9)
	""" :(@SC_LIBS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:316](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:316:9)
	""" SC_LIBS
	export @SC_LIBS, SC_LIBS
	macro SC_LIBS() return quote "  -lz -lm   " end end
	const SC_LIBS = (@SC_LIBS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:324](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:324:9)
	""" :(@SC_LT_OBJDIR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:324](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:324:9)
	""" SC_LT_OBJDIR
	export @SC_LT_OBJDIR, SC_LT_OBJDIR
	macro SC_LT_OBJDIR() return quote ".libs/" end end
	const SC_LT_OBJDIR = (@SC_LT_OBJDIR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:329](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:329:9)
	""" SC_MEMALIGN
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:329](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:329:9)
	""" :(@SC_MEMALIGN)
	export @SC_MEMALIGN, SC_MEMALIGN
	macro SC_MEMALIGN() return quote 1 end end
	const SC_MEMALIGN = (@SC_MEMALIGN)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:334](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:334:9)
	""" :(@SC_MEMALIGN_BYTES)
	export @SC_MEMALIGN_BYTES
	macro SC_MEMALIGN_BYTES() return quote ((@SC_SIZEOF_VOID_P)) end end
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:351](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:351:9)
	""" :(@SC_PACKAGE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:351](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:351:9)
	""" SC_PACKAGE
	export @SC_PACKAGE, SC_PACKAGE
	macro SC_PACKAGE() return quote "libsc" end end
	const SC_PACKAGE = (@SC_PACKAGE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:356](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:356:9)
	""" :(@SC_PACKAGE_BUGREPORT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:356](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:356:9)
	""" SC_PACKAGE_BUGREPORT
	export @SC_PACKAGE_BUGREPORT, SC_PACKAGE_BUGREPORT
	macro SC_PACKAGE_BUGREPORT() return quote "p4est@ins.uni-bonn.de" end end
	const SC_PACKAGE_BUGREPORT = (@SC_PACKAGE_BUGREPORT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:361](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:361:9)
	""" SC_PACKAGE_NAME
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:361](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:361:9)
	""" :(@SC_PACKAGE_NAME)
	export @SC_PACKAGE_NAME, SC_PACKAGE_NAME
	macro SC_PACKAGE_NAME() return quote "libsc" end end
	const SC_PACKAGE_NAME = (@SC_PACKAGE_NAME)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:366](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:366:9)
	""" SC_PACKAGE_STRING
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:366](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:366:9)
	""" :(@SC_PACKAGE_STRING)
	export @SC_PACKAGE_STRING, SC_PACKAGE_STRING
	macro SC_PACKAGE_STRING() return quote "libsc 2.3.1" end end
	const SC_PACKAGE_STRING = (@SC_PACKAGE_STRING)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:371](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:371:9)
	""" SC_PACKAGE_TARNAME
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:371](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:371:9)
	""" :(@SC_PACKAGE_TARNAME)
	export @SC_PACKAGE_TARNAME, SC_PACKAGE_TARNAME
	macro SC_PACKAGE_TARNAME() return quote "libsc" end end
	const SC_PACKAGE_TARNAME = (@SC_PACKAGE_TARNAME)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:376](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:376:9)
	""" SC_PACKAGE_URL
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:376](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:376:9)
	""" :(@SC_PACKAGE_URL)
	export @SC_PACKAGE_URL, SC_PACKAGE_URL
	macro SC_PACKAGE_URL() return quote "" end end
	const SC_PACKAGE_URL = (@SC_PACKAGE_URL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:381](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:381:9)
	""" SC_PACKAGE_VERSION
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:381](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:381:9)
	""" :(@SC_PACKAGE_VERSION)
	export @SC_PACKAGE_VERSION, SC_PACKAGE_VERSION
	macro SC_PACKAGE_VERSION() return quote "2.3.1" end end
	const SC_PACKAGE_VERSION = (@SC_PACKAGE_VERSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:398](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:398:9)
	""" :(@SC_SIZEOF_INT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:398](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:398:9)
	""" SC_SIZEOF_INT
	export @SC_SIZEOF_INT, SC_SIZEOF_INT
	macro SC_SIZEOF_INT() return quote 4 end end
	const SC_SIZEOF_INT = (@SC_SIZEOF_INT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:403](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:403:9)
	""" :(@SC_SIZEOF_LONG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:403](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:403:9)
	""" SC_SIZEOF_LONG
	export @SC_SIZEOF_LONG, SC_SIZEOF_LONG
	macro SC_SIZEOF_LONG() return quote 8 end end
	const SC_SIZEOF_LONG = (@SC_SIZEOF_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:408](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:408:9)
	""" :(@SC_SIZEOF_LONG_LONG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:408](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:408:9)
	""" SC_SIZEOF_LONG_LONG
	export @SC_SIZEOF_LONG_LONG, SC_SIZEOF_LONG_LONG
	macro SC_SIZEOF_LONG_LONG() return quote 8 end end
	const SC_SIZEOF_LONG_LONG = (@SC_SIZEOF_LONG_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:413](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:413:9)
	""" :(@SC_SIZEOF_UNSIGNED_LONG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:413](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:413:9)
	""" SC_SIZEOF_UNSIGNED_LONG
	export @SC_SIZEOF_UNSIGNED_LONG, SC_SIZEOF_UNSIGNED_LONG
	macro SC_SIZEOF_UNSIGNED_LONG() return quote 8 end end
	const SC_SIZEOF_UNSIGNED_LONG = (@SC_SIZEOF_UNSIGNED_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:418](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:418:9)
	""" SC_SIZEOF_UNSIGNED_LONG_LONG
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:418](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:418:9)
	""" :(@SC_SIZEOF_UNSIGNED_LONG_LONG)
	export @SC_SIZEOF_UNSIGNED_LONG_LONG, SC_SIZEOF_UNSIGNED_LONG_LONG
	macro SC_SIZEOF_UNSIGNED_LONG_LONG() return quote 8 end end
	const SC_SIZEOF_UNSIGNED_LONG_LONG = (@SC_SIZEOF_UNSIGNED_LONG_LONG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:423](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:423:9)
	""" :(@SC_SIZEOF_VOID_P)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:423](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:423:9)
	""" SC_SIZEOF_VOID_P
	export @SC_SIZEOF_VOID_P, SC_SIZEOF_VOID_P
	macro SC_SIZEOF_VOID_P() return quote 8 end end
	const SC_SIZEOF_VOID_P = (@SC_SIZEOF_VOID_P)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:428](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:428:9)
	""" SC_STDC_HEADERS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:428](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:428:9)
	""" :(@SC_STDC_HEADERS)
	export @SC_STDC_HEADERS, SC_STDC_HEADERS
	macro SC_STDC_HEADERS() return quote 1 end end
	const SC_STDC_HEADERS = (@SC_STDC_HEADERS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:433](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:433:9)
	""" :(@SC_USE_REALLOC)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:433](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:433:9)
	""" SC_USE_REALLOC
	export @SC_USE_REALLOC, SC_USE_REALLOC
	macro SC_USE_REALLOC() return quote 1 end end
	const SC_USE_REALLOC = (@SC_USE_REALLOC)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:438](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:438:9)
	""" SC_VERSION
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:438](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:438:9)
	""" :(@SC_VERSION)
	export @SC_VERSION, SC_VERSION
	macro SC_VERSION() return quote "2.3.1" end end
	const SC_VERSION = (@SC_VERSION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:443](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:443:9)
	""" :(@SC_VERSION_MAJOR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:443](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:443:9)
	""" SC_VERSION_MAJOR
	export @SC_VERSION_MAJOR, SC_VERSION_MAJOR
	macro SC_VERSION_MAJOR() return quote 2 end end
	const SC_VERSION_MAJOR = (@SC_VERSION_MAJOR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:448](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:448:9)
	""" :(@SC_VERSION_MINOR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:448](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:448:9)
	""" SC_VERSION_MINOR
	export @SC_VERSION_MINOR, SC_VERSION_MINOR
	macro SC_VERSION_MINOR() return quote 3 end end
	const SC_VERSION_MINOR = (@SC_VERSION_MINOR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:453](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:453:9)
	""" :(@SC_VERSION_POINT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_config.h:453](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_config.h:453:9)
	""" SC_VERSION_POINT
	export @SC_VERSION_POINT, SC_VERSION_POINT
	macro SC_VERSION_POINT() return quote 1 end end
	const SC_VERSION_POINT = (@SC_VERSION_POINT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:203](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:203:9)
	""" sc_MPI_SUCCESS
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:203](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:203:9)
	""" :(@sc_MPI_SUCCESS)
	export @sc_MPI_SUCCESS, sc_MPI_SUCCESS
	macro sc_MPI_SUCCESS() return quote 0 end end
	const sc_MPI_SUCCESS = (@sc_MPI_SUCCESS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:211](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:211:9)
	""" :(@sc_MPI_IDENT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:211](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:211:9)
	""" sc_MPI_IDENT
	export @sc_MPI_IDENT, sc_MPI_IDENT
	macro sc_MPI_IDENT() return quote (1) end end
	const sc_MPI_IDENT = (@sc_MPI_IDENT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:212](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:212:9)
	""" sc_MPI_CONGRUENT
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:212](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:212:9)
	""" :(@sc_MPI_CONGRUENT)
	export @sc_MPI_CONGRUENT, sc_MPI_CONGRUENT
	macro sc_MPI_CONGRUENT() return quote (2) end end
	const sc_MPI_CONGRUENT = (@sc_MPI_CONGRUENT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:213](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:213:9)
	""" :(@sc_MPI_SIMILAR)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:213](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:213:9)
	""" sc_MPI_SIMILAR
	export @sc_MPI_SIMILAR, sc_MPI_SIMILAR
	macro sc_MPI_SIMILAR() return quote (3) end end
	const sc_MPI_SIMILAR = (@sc_MPI_SIMILAR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:214](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:214:9)
	""" sc_MPI_UNEQUAL
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:214](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:214:9)
	""" :(@sc_MPI_UNEQUAL)
	export @sc_MPI_UNEQUAL, sc_MPI_UNEQUAL
	macro sc_MPI_UNEQUAL() return quote (-1) end end
	const sc_MPI_UNEQUAL = (@sc_MPI_UNEQUAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:216](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:216:9)
	""" :(@sc_MPI_ANY_SOURCE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:216](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:216:9)
	""" sc_MPI_ANY_SOURCE
	export @sc_MPI_ANY_SOURCE, sc_MPI_ANY_SOURCE
	macro sc_MPI_ANY_SOURCE() return quote (-2) end end
	const sc_MPI_ANY_SOURCE = (@sc_MPI_ANY_SOURCE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:217](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:217:9)
	""" sc_MPI_ANY_TAG
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:217](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:217:9)
	""" :(@sc_MPI_ANY_TAG)
	export @sc_MPI_ANY_TAG, sc_MPI_ANY_TAG
	macro sc_MPI_ANY_TAG() return quote (-1) end end
	const sc_MPI_ANY_TAG = (@sc_MPI_ANY_TAG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:256](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:256:9)
	""" :(@sc_MPI_UNDEFINED)
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:256](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:256:9)
	""" sc_MPI_UNDEFINED
	export @sc_MPI_UNDEFINED, sc_MPI_UNDEFINED
	macro sc_MPI_UNDEFINED() return quote (-32766) end end
	const sc_MPI_UNDEFINED = (@sc_MPI_UNDEFINED)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:258](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:258:9)
	""" sc_MPI_ERR_GROUP
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:258](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:258:9)
	""" :(@sc_MPI_ERR_GROUP)
	export @sc_MPI_ERR_GROUP, sc_MPI_ERR_GROUP
	macro sc_MPI_ERR_GROUP() return quote (-123456) end end
	const sc_MPI_ERR_GROUP = (@sc_MPI_ERR_GROUP)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:382](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:382:9)
	""" sc_MPI_THREAD_SINGLE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:382](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:382:9)
	""" :(@sc_MPI_THREAD_SINGLE)
	export @sc_MPI_THREAD_SINGLE, sc_MPI_THREAD_SINGLE
	macro sc_MPI_THREAD_SINGLE() return quote 0 end end
	const sc_MPI_THREAD_SINGLE = (@sc_MPI_THREAD_SINGLE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:383](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:383:9)
	""" sc_MPI_THREAD_FUNNELED
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:383](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:383:9)
	""" :(@sc_MPI_THREAD_FUNNELED)
	export @sc_MPI_THREAD_FUNNELED, sc_MPI_THREAD_FUNNELED
	macro sc_MPI_THREAD_FUNNELED() return quote 1 end end
	const sc_MPI_THREAD_FUNNELED = (@sc_MPI_THREAD_FUNNELED)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:384](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:384:9)
	""" sc_MPI_THREAD_SERIALIZED
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:384](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:384:9)
	""" :(@sc_MPI_THREAD_SERIALIZED)
	export @sc_MPI_THREAD_SERIALIZED, sc_MPI_THREAD_SERIALIZED
	macro sc_MPI_THREAD_SERIALIZED() return quote 2 end end
	const sc_MPI_THREAD_SERIALIZED = (@sc_MPI_THREAD_SERIALIZED)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:385](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:385:9)
	""" sc_MPI_THREAD_MULTIPLE
	𝐣𝐥.@doc """
	## Reference
	
	[sc_mpi.h:385](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc_mpi.h:385:9)
	""" :(@sc_MPI_THREAD_MULTIPLE)
	export @sc_MPI_THREAD_MULTIPLE, sc_MPI_THREAD_MULTIPLE
	macro sc_MPI_THREAD_MULTIPLE() return quote 3 end end
	const sc_MPI_THREAD_MULTIPLE = (@sc_MPI_THREAD_MULTIPLE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:154](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:154:9)
	""" :(@SC_EPS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:154](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:154:9)
	""" SC_EPS
	export @SC_EPS, SC_EPS
	macro SC_EPS() return quote 2.220446049250313e-16 end end
	const SC_EPS = (@SC_EPS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:302](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:302:9)
	""" :(@SC_LC_GLOBAL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:302](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:302:9)
	""" SC_LC_GLOBAL
	export @SC_LC_GLOBAL, SC_LC_GLOBAL
	macro SC_LC_GLOBAL() return quote 1 end end
	const SC_LC_GLOBAL = (@SC_LC_GLOBAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:303](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:303:9)
	""" SC_LC_NORMAL
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:303](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:303:9)
	""" :(@SC_LC_NORMAL)
	export @SC_LC_NORMAL, SC_LC_NORMAL
	macro SC_LC_NORMAL() return quote 2 end end
	const SC_LC_NORMAL = (@SC_LC_NORMAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:319](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:319:9)
	""" :(@SC_LP_DEFAULT)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:319](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:319:9)
	""" SC_LP_DEFAULT
	export @SC_LP_DEFAULT, SC_LP_DEFAULT
	macro SC_LP_DEFAULT() return quote (-1) end end
	const SC_LP_DEFAULT = (@SC_LP_DEFAULT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:320](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:320:9)
	""" SC_LP_ALWAYS
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:320](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:320:9)
	""" :(@SC_LP_ALWAYS)
	export @SC_LP_ALWAYS, SC_LP_ALWAYS
	macro SC_LP_ALWAYS() return quote 0 end end
	const SC_LP_ALWAYS = (@SC_LP_ALWAYS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:321](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:321:9)
	""" :(@SC_LP_TRACE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:321](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:321:9)
	""" SC_LP_TRACE
	export @SC_LP_TRACE, SC_LP_TRACE
	macro SC_LP_TRACE() return quote 1 end end
	const SC_LP_TRACE = (@SC_LP_TRACE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:322](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:322:9)
	""" :(@SC_LP_DEBUG)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:322](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:322:9)
	""" SC_LP_DEBUG
	export @SC_LP_DEBUG, SC_LP_DEBUG
	macro SC_LP_DEBUG() return quote 2 end end
	const SC_LP_DEBUG = (@SC_LP_DEBUG)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:323](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:323:9)
	""" :(@SC_LP_VERBOSE)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:323](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:323:9)
	""" SC_LP_VERBOSE
	export @SC_LP_VERBOSE, SC_LP_VERBOSE
	macro SC_LP_VERBOSE() return quote 3 end end
	const SC_LP_VERBOSE = (@SC_LP_VERBOSE)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:324](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:324:9)
	""" :(@SC_LP_INFO)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:324](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:324:9)
	""" SC_LP_INFO
	export @SC_LP_INFO, SC_LP_INFO
	macro SC_LP_INFO() return quote 4 end end
	const SC_LP_INFO = (@SC_LP_INFO)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:325](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:325:9)
	""" :(@SC_LP_STATISTICS)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:325](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:325:9)
	""" SC_LP_STATISTICS
	export @SC_LP_STATISTICS, SC_LP_STATISTICS
	macro SC_LP_STATISTICS() return quote 5 end end
	const SC_LP_STATISTICS = (@SC_LP_STATISTICS)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:326](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:326:9)
	""" SC_LP_PRODUCTION
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:326](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:326:9)
	""" :(@SC_LP_PRODUCTION)
	export @SC_LP_PRODUCTION, SC_LP_PRODUCTION
	macro SC_LP_PRODUCTION() return quote 6 end end
	const SC_LP_PRODUCTION = (@SC_LP_PRODUCTION)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:327](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:327:9)
	""" :(@SC_LP_ESSENTIAL)
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:327](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:327:9)
	""" SC_LP_ESSENTIAL
	export @SC_LP_ESSENTIAL, SC_LP_ESSENTIAL
	macro SC_LP_ESSENTIAL() return quote 7 end end
	const SC_LP_ESSENTIAL = (@SC_LP_ESSENTIAL)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:328](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:328:9)
	""" SC_LP_ERROR
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:328](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:328:9)
	""" :(@SC_LP_ERROR)
	export @SC_LP_ERROR, SC_LP_ERROR
	macro SC_LP_ERROR() return quote 8 end end
	const SC_LP_ERROR = (@SC_LP_ERROR)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:329](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:329:9)
	""" SC_LP_SILENT
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:329](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:329:9)
	""" :(@SC_LP_SILENT)
	export @SC_LP_SILENT, SC_LP_SILENT
	macro SC_LP_SILENT() return quote 9 end end
	const SC_LP_SILENT = (@SC_LP_SILENT)
	
	𝐣𝐥.@doc """
	## Reference
	
	[sc.h:341](~/.julia/artifacts/a40f15e12fad7b987329d6248611cd87ab292df5/include/sc.h:341:9)
	""" :(@SC_LP_THRESHOLD)
	export @SC_LP_THRESHOLD
	macro SC_LP_THRESHOLD() return quote (@SC_LP_INFO) end end
end
