var documenterSearchIndex = {"docs":
[{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2021-present Michael Schlottke-Lakemper, Hendrik Ranocha, and Alexander AstaninPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"reference/#P4est.jl-API","page":"Reference","title":"P4est.jl API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = P4est","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [P4est, P4est.LibP4est]","category":"page"},{"location":"reference/#P4est.LibP4est.P4EST_BUILD_2D","page":"Reference","title":"P4est.LibP4est.P4EST_BUILD_2D","text":"Reference\n\np4est_config.h:10\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_BUILD_3D","page":"Reference","title":"P4est.LibP4est.P4EST_BUILD_3D","text":"Reference\n\np4est_config.h:15\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_BUILD_P6EST","page":"Reference","title":"P4est.LibP4est.P4EST_BUILD_P6EST","text":"Reference\n\np4est_config.h:20\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CC","page":"Reference","title":"P4est.LibP4est.P4EST_CC","text":"Reference\n\np4est_config.h:25\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CFLAGS","page":"Reference","title":"P4est.LibP4est.P4EST_CFLAGS","text":"Reference\n\np4est_config.h:30\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CHILDREN","page":"Reference","title":"P4est.LibP4est.P4EST_CHILDREN","text":"Reference\n\np4est_connectivity.h:51\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_BALANCE_FIRST_COUNT","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_BALANCE_FIRST_COUNT","text":"Reference\n\np4est_base.h:131\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_BALANCE_FIRST_LOAD","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_BALANCE_FIRST_LOAD","text":"Reference\n\np4est_base.h:132\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_BALANCE_SECOND_COUNT","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_BALANCE_SECOND_COUNT","text":"Reference\n\np4est_base.h:133\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_BALANCE_SECOND_LOAD","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_BALANCE_SECOND_LOAD","text":"Reference\n\np4est_base.h:134\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_COUNT_PERTREE","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_COUNT_PERTREE","text":"Reference\n\np4est_base.h:130\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_CHECKSUM","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_CHECKSUM","text":"Reference\n\np4est_base.h:146\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_COUNT","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_COUNT","text":"Reference\n\np4est_base.h:139\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_EXCHANGE","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_EXCHANGE","text":"Reference\n\np4est_base.h:141\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_EXPAND_COUNT","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_EXPAND_COUNT","text":"Reference\n\np4est_base.h:142\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_EXPAND_LOAD","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_EXPAND_LOAD","text":"Reference\n\np4est_base.h:143\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_LOAD","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_LOAD","text":"Reference\n\np4est_base.h:140\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_SUPPORT_COUNT","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_SUPPORT_COUNT","text":"Reference\n\np4est_base.h:144\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_GHOST_SUPPORT_LOAD","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_GHOST_SUPPORT_LOAD","text":"Reference\n\np4est_base.h:145\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_LNODES_ALL","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_LNODES_ALL","text":"Reference\n\np4est_base.h:153\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_LNODES_OWNED","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_LNODES_OWNED","text":"Reference\n\np4est_base.h:152\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_LNODES_PASS","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_LNODES_PASS","text":"Reference\n\np4est_base.h:151\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_LNODES_TEST","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_LNODES_TEST","text":"Reference\n\np4est_base.h:150\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_NODES_QUERY","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_NODES_QUERY","text":"Reference\n\np4est_base.h:147\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_NODES_REPLY","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_NODES_REPLY","text":"Reference\n\np4est_base.h:148\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_PARTITION_CORRECTION","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_PARTITION_CORRECTION","text":"Reference\n\np4est_base.h:138\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_PARTITION_GIVEN","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_PARTITION_GIVEN","text":"Reference\n\np4est_base.h:135\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_PARTITION_WEIGHTED_HIGH","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_PARTITION_WEIGHTED_HIGH","text":"Reference\n\np4est_base.h:137\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_PARTITION_WEIGHTED_LOW","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_PARTITION_WEIGHTED_LOW","text":"Reference\n\np4est_base.h:136\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_SAVE","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_SAVE","text":"Reference\n\np4est_base.h:149\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_TAG_FIRST","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_TAG_FIRST","text":"Reference\n\np4est_base.h:129\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_COMM_TAG_LAST","page":"Reference","title":"P4est.LibP4est.P4EST_COMM_TAG_LAST","text":"Reference\n\np4est_base.h:154\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CONNECT_CORNER","page":"Reference","title":"P4est.LibP4est.P4EST_CONNECT_CORNER","text":"Reference\n\np4est_connectivity.h:91\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CONNECT_FACE","page":"Reference","title":"P4est.LibP4est.P4EST_CONNECT_FACE","text":"Reference\n\np4est_connectivity.h:90\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CONNECT_FULL","page":"Reference","title":"P4est.LibP4est.P4EST_CONNECT_FULL","text":"Reference\n\np4est_connectivity.h:92\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CONN_ENCODE_LAST","page":"Reference","title":"P4est.LibP4est.P4EST_CONN_ENCODE_LAST","text":"Invalid entry to close the list. \n\nReference\n\np4est_connectivity.h:104\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CONN_ENCODE_NONE","page":"Reference","title":"P4est.LibP4est.P4EST_CONN_ENCODE_NONE","text":"Reference\n\np4est_connectivity.h:103\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CPP","page":"Reference","title":"P4est.LibP4est.P4EST_CPP","text":"Reference\n\np4est_config.h:35\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_CPPFLAGS","page":"Reference","title":"P4est.LibP4est.P4EST_CPPFLAGS","text":"Reference\n\np4est_config.h:40\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_DIM","page":"Reference","title":"P4est.LibP4est.P4EST_DIM","text":"Reference\n\np4est_connectivity.h:45\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ENABLE_BUILD_2D","page":"Reference","title":"P4est.LibP4est.P4EST_ENABLE_BUILD_2D","text":"Reference\n\np4est_config.h:51\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ENABLE_BUILD_3D","page":"Reference","title":"P4est.LibP4est.P4EST_ENABLE_BUILD_3D","text":"Reference\n\np4est_config.h:56\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ENABLE_BUILD_P6EST","page":"Reference","title":"P4est.LibP4est.P4EST_ENABLE_BUILD_P6EST","text":"Reference\n\np4est_config.h:61\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ENABLE_MEMALIGN","page":"Reference","title":"P4est.LibP4est.P4EST_ENABLE_MEMALIGN","text":"Reference\n\np4est_config.h:70\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ENABLE_VTK_BINARY","page":"Reference","title":"P4est.LibP4est.P4EST_ENABLE_VTK_BINARY","text":"Reference\n\np4est_config.h:105\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ENABLE_VTK_COMPRESSION","page":"Reference","title":"P4est.LibP4est.P4EST_ENABLE_VTK_COMPRESSION","text":"Reference\n\np4est_config.h:110\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_FTRANSFORM","page":"Reference","title":"P4est.LibP4est.P4EST_FTRANSFORM","text":"Reference\n\np4est_connectivity.h:67\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_GLOIDX_BITS","page":"Reference","title":"P4est.LibP4est.P4EST_GLOIDX_BITS","text":"Reference\n\np4est_base.h:117\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_ARPA_INET_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_ARPA_INET_H","text":"Reference\n\np4est_config.h:160\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_DLFCN_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_DLFCN_H","text":"Reference\n\np4est_config.h:165\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_INTTYPES_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_INTTYPES_H","text":"Reference\n\np4est_config.h:170\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_MEMORY_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_MEMORY_H","text":"Reference\n\np4est_config.h:181\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_NETINET_IN_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_NETINET_IN_H","text":"Reference\n\np4est_config.h:186\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_POSIX_MEMALIGN","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_POSIX_MEMALIGN","text":"Reference\n\np4est_config.h:194\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_STDINT_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_STDINT_H","text":"Reference\n\np4est_config.h:199\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_STDLIB_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_STDLIB_H","text":"Reference\n\np4est_config.h:204\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_STRINGS_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_STRINGS_H","text":"Reference\n\np4est_config.h:209\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_STRING_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_STRING_H","text":"Reference\n\np4est_config.h:214\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_SYS_STAT_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_SYS_STAT_H","text":"Reference\n\np4est_config.h:219\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_SYS_TYPES_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_SYS_TYPES_H","text":"Reference\n\np4est_config.h:224\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_UNISTD_H","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_UNISTD_H","text":"Reference\n\np4est_config.h:229\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_HAVE_ZLIB","page":"Reference","title":"P4est.LibP4est.P4EST_HAVE_ZLIB","text":"Reference\n\np4est_config.h:234\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_INSUL","page":"Reference","title":"P4est.LibP4est.P4EST_INSUL","text":"Reference\n\np4est_connectivity.h:55\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_LDFLAGS","page":"Reference","title":"P4est.LibP4est.P4EST_LDFLAGS","text":"Reference\n\np4est_config.h:239\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_LIBS","page":"Reference","title":"P4est.LibP4est.P4EST_LIBS","text":"Reference\n\np4est_config.h:244\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_LOCIDX_BITS","page":"Reference","title":"P4est.LibP4est.P4EST_LOCIDX_BITS","text":"Reference\n\np4est_base.h:105\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_LT_OBJDIR","page":"Reference","title":"P4est.LibP4est.P4EST_LT_OBJDIR","text":"Reference\n\np4est_config.h:249\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.P4EST_MAXLEVEL","text":"Reference\n\np4est.h:51\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_MEMALIGN","page":"Reference","title":"P4est.LibP4est.P4EST_MEMALIGN","text":"Reference\n\np4est_config.h:254\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_OLD_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.P4EST_OLD_MAXLEVEL","text":"Reference\n\np4est.h:50\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_OLD_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.P4EST_OLD_QMAXLEVEL","text":"Reference\n\np4est.h:54\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_ONDISK_FORMAT","page":"Reference","title":"P4est.LibP4est.P4EST_ONDISK_FORMAT","text":"Reference\n\np4est_connectivity.h:76\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE","text":"Reference\n\np4est_config.h:279\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE_BUGREPORT","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE_BUGREPORT","text":"Reference\n\np4est_config.h:284\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE_NAME","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE_NAME","text":"Reference\n\np4est_config.h:289\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE_STRING","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE_STRING","text":"Reference\n\np4est_config.h:294\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE_TARNAME","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE_TARNAME","text":"Reference\n\np4est_config.h:299\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE_URL","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE_URL","text":"Reference\n\np4est_config.h:304\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_PACKAGE_VERSION","page":"Reference","title":"P4est.LibP4est.P4EST_PACKAGE_VERSION","text":"Reference\n\np4est_config.h:309\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_QCOORD_BITS","page":"Reference","title":"P4est.LibP4est.P4EST_QCOORD_BITS","text":"Reference\n\np4est_base.h:80\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.P4EST_QMAXLEVEL","text":"Reference\n\np4est.h:55\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_SIZEOF_VOID_P","page":"Reference","title":"P4est.LibP4est.P4EST_SIZEOF_VOID_P","text":"Reference\n\np4est_config.h:329\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_STDC_HEADERS","page":"Reference","title":"P4est.LibP4est.P4EST_STDC_HEADERS","text":"Reference\n\np4est_config.h:334\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_STRING","page":"Reference","title":"P4est.LibP4est.P4EST_STRING","text":"Reference\n\np4est_connectivity.h:70\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_TOPIDX_BITS","page":"Reference","title":"P4est.LibP4est.P4EST_TOPIDX_BITS","text":"Reference\n\np4est_base.h:92\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_TOPIDX_FITS_32","page":"Reference","title":"P4est.LibP4est.P4EST_TOPIDX_FITS_32","text":"Reference\n\np4est_base.h:98\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VERSION","page":"Reference","title":"P4est.LibP4est.P4EST_VERSION","text":"Reference\n\np4est_config.h:339\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VERSION_MAJOR","page":"Reference","title":"P4est.LibP4est.P4EST_VERSION_MAJOR","text":"Reference\n\np4est_config.h:344\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VERSION_MINOR","page":"Reference","title":"P4est.LibP4est.P4EST_VERSION_MINOR","text":"Reference\n\np4est_config.h:349\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VERSION_POINT","page":"Reference","title":"P4est.LibP4est.P4EST_VERSION_POINT","text":"Reference\n\np4est_config.h:354\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VTK_BINARY","page":"Reference","title":"P4est.LibP4est.P4EST_VTK_BINARY","text":"Reference\n\np4est_config.h:359\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VTK_COMPRESSION","page":"Reference","title":"P4est.LibP4est.P4EST_VTK_COMPRESSION","text":"Reference\n\np4est_config.h:364\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VTK_GLOIDX","page":"Reference","title":"P4est.LibP4est.P4EST_VTK_GLOIDX","text":"Reference\n\np4est_base.h:119\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VTK_LOCIDX","page":"Reference","title":"P4est.LibP4est.P4EST_VTK_LOCIDX","text":"Reference\n\np4est_base.h:107\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VTK_QCOORD","page":"Reference","title":"P4est.LibP4est.P4EST_VTK_QCOORD","text":"Reference\n\np4est_base.h:82\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P4EST_VTK_TOPIDX","page":"Reference","title":"P4est.LibP4est.P4EST_VTK_TOPIDX","text":"Reference\n\np4est_base.h:94\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P6EST_COMM_BALANCE","page":"Reference","title":"P4est.LibP4est.P6EST_COMM_BALANCE","text":"Reference\n\np6est.h:463\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P6EST_COMM_GHOST","page":"Reference","title":"P4est.LibP4est.P6EST_COMM_GHOST","text":"Reference\n\np6est.h:462\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P6EST_COMM_PARTITION","page":"Reference","title":"P4est.LibP4est.P6EST_COMM_PARTITION","text":"Reference\n\np6est.h:461\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CHILDREN","page":"Reference","title":"P4est.LibP4est.P8EST_CHILDREN","text":"Reference\n\np8est_connectivity.h:50\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CONNECT_CORNER","page":"Reference","title":"P4est.LibP4est.P8EST_CONNECT_CORNER","text":"Reference\n\np8est_connectivity.h:94\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CONNECT_EDGE","page":"Reference","title":"P4est.LibP4est.P8EST_CONNECT_EDGE","text":"Reference\n\np8est_connectivity.h:93\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CONNECT_FACE","page":"Reference","title":"P4est.LibP4est.P8EST_CONNECT_FACE","text":"Reference\n\np8est_connectivity.h:92\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CONNECT_FULL","page":"Reference","title":"P4est.LibP4est.P8EST_CONNECT_FULL","text":"Reference\n\np8est_connectivity.h:95\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CONN_ENCODE_LAST","page":"Reference","title":"P4est.LibP4est.P8EST_CONN_ENCODE_LAST","text":"Invalid entry to close the list. \n\nReference\n\np8est_connectivity.h:107\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_CONN_ENCODE_NONE","page":"Reference","title":"P4est.LibP4est.P8EST_CONN_ENCODE_NONE","text":"Reference\n\np8est_connectivity.h:106\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_DIM","page":"Reference","title":"P4est.LibP4est.P8EST_DIM","text":"Reference\n\np8est_connectivity.h:41\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_EDGES","page":"Reference","title":"P4est.LibP4est.P8EST_EDGES","text":"Reference\n\np8est_connectivity.h:54\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_FTRANSFORM","page":"Reference","title":"P4est.LibP4est.P8EST_FTRANSFORM","text":"Reference\n\np8est_connectivity.h:68\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_INSUL","page":"Reference","title":"P4est.LibP4est.P8EST_INSUL","text":"Reference\n\np8est_connectivity.h:56\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.P8EST_MAXLEVEL","text":"Reference\n\np8est.h:47\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_OLD_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.P8EST_OLD_MAXLEVEL","text":"Reference\n\np8est.h:46\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_OLD_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.P8EST_OLD_QMAXLEVEL","text":"Reference\n\np8est.h:50\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_ONDISK_FORMAT","page":"Reference","title":"P4est.LibP4est.P8EST_ONDISK_FORMAT","text":"Reference\n\np8est_connectivity.h:77\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.P8EST_QMAXLEVEL","text":"Reference\n\np8est.h:51\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.P8EST_STRING","page":"Reference","title":"P4est.LibP4est.P8EST_STRING","text":"Reference\n\np8est_connectivity.h:71\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_CC","page":"Reference","title":"P4est.LibP4est.SC_CC","text":"Reference\n\nsc_config.h:13\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_CFLAGS","page":"Reference","title":"P4est.LibP4est.SC_CFLAGS","text":"Reference\n\nsc_config.h:18\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_CPP","page":"Reference","title":"P4est.LibP4est.SC_CPP","text":"Reference\n\nsc_config.h:23\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_CPPFLAGS","page":"Reference","title":"P4est.LibP4est.SC_CPPFLAGS","text":"Reference\n\nsc_config.h:28\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_CXX","page":"Reference","title":"P4est.LibP4est.SC_CXX","text":"Reference\n\nsc_config.h:33\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_CXXFLAGS","page":"Reference","title":"P4est.LibP4est.SC_CXXFLAGS","text":"Reference\n\nsc_config.h:38\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_ENABLE_MEMALIGN","page":"Reference","title":"P4est.LibP4est.SC_ENABLE_MEMALIGN","text":"Reference\n\nsc_config.h:53\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_ENABLE_USE_REALLOC","page":"Reference","title":"P4est.LibP4est.SC_ENABLE_USE_REALLOC","text":"Reference\n\nsc_config.h:85\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_ENABLE_V4L2","page":"Reference","title":"P4est.LibP4est.SC_ENABLE_V4L2","text":"Reference\n\nsc_config.h:90\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_EPS","page":"Reference","title":"P4est.LibP4est.SC_EPS","text":"Reference\n\nsc.h:154\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_F77","page":"Reference","title":"P4est.LibP4est.SC_F77","text":"Reference\n\nsc_config.h:95\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_FC","page":"Reference","title":"P4est.LibP4est.SC_FC","text":"Reference\n\nsc_config.h:118\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_FCFLAGS","page":"Reference","title":"P4est.LibP4est.SC_FCFLAGS","text":"Reference\n\nsc_config.h:123\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_FFLAGS","page":"Reference","title":"P4est.LibP4est.SC_FFLAGS","text":"Reference\n\nsc_config.h:149\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_BACKTRACE","page":"Reference","title":"P4est.LibP4est.SC_HAVE_BACKTRACE","text":"Reference\n\nsc_config.h:157\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_BACKTRACE_SYMBOLS","page":"Reference","title":"P4est.LibP4est.SC_HAVE_BACKTRACE_SYMBOLS","text":"Reference\n\nsc_config.h:162\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_DLFCN_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_DLFCN_H","text":"Reference\n\nsc_config.h:167\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_EXECINFO_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_EXECINFO_H","text":"Reference\n\nsc_config.h:172\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_FCNTL_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_FCNTL_H","text":"Reference\n\nsc_config.h:177\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_FSYNC","page":"Reference","title":"P4est.LibP4est.SC_HAVE_FSYNC","text":"Reference\n\nsc_config.h:182\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_INTTYPES_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_INTTYPES_H","text":"Reference\n\nsc_config.h:187\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_LINUX_VIDEODEV2_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_LINUX_VIDEODEV2_H","text":"Reference\n\nsc_config.h:192\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_MEMORY_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_MEMORY_H","text":"Reference\n\nsc_config.h:215\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_POSIX_MEMALIGN","page":"Reference","title":"P4est.LibP4est.SC_HAVE_POSIX_MEMALIGN","text":"Reference\n\nsc_config.h:223\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_QSORT_R","page":"Reference","title":"P4est.LibP4est.SC_HAVE_QSORT_R","text":"Reference\n\nsc_config.h:228\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_SIGNAL_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_SIGNAL_H","text":"Reference\n\nsc_config.h:233\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_STDINT_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_STDINT_H","text":"Reference\n\nsc_config.h:238\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_STDLIB_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_STDLIB_H","text":"Reference\n\nsc_config.h:243\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_STRINGS_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_STRINGS_H","text":"Reference\n\nsc_config.h:248\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_STRING_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_STRING_H","text":"Reference\n\nsc_config.h:253\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_STRTOL","page":"Reference","title":"P4est.LibP4est.SC_HAVE_STRTOL","text":"Reference\n\nsc_config.h:258\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_STRTOLL","page":"Reference","title":"P4est.LibP4est.SC_HAVE_STRTOLL","text":"Reference\n\nsc_config.h:263\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_SYS_IOCTL_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_SYS_IOCTL_H","text":"Reference\n\nsc_config.h:268\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_SYS_SELECT_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_SYS_SELECT_H","text":"Reference\n\nsc_config.h:273\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_SYS_STAT_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_SYS_STAT_H","text":"Reference\n\nsc_config.h:278\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_SYS_TIME_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_SYS_TIME_H","text":"Reference\n\nsc_config.h:283\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_SYS_TYPES_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_SYS_TYPES_H","text":"Reference\n\nsc_config.h:288\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_TIME_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_TIME_H","text":"Reference\n\nsc_config.h:293\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_UNISTD_H","page":"Reference","title":"P4est.LibP4est.SC_HAVE_UNISTD_H","text":"Reference\n\nsc_config.h:298\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_HAVE_ZLIB","page":"Reference","title":"P4est.LibP4est.SC_HAVE_ZLIB","text":"Reference\n\nsc_config.h:303\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_ENCODE_LAST","page":"Reference","title":"P4est.LibP4est.SC_IO_ENCODE_LAST","text":"Invalid entry to close list \n\nReference\n\nsc_io.h:54\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_ENCODE_NONE","page":"Reference","title":"P4est.LibP4est.SC_IO_ENCODE_NONE","text":"Reference\n\nsc_io.h:53\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_ERROR_AGAIN","page":"Reference","title":"P4est.LibP4est.SC_IO_ERROR_AGAIN","text":"Another io operation may resolve it.                                The function just returned was a noop. \n\nReference\n\nsc_io.h:38\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_ERROR_FATAL","page":"Reference","title":"P4est.LibP4est.SC_IO_ERROR_FATAL","text":"The io object is now disfunctional. \n\nReference\n\nsc_io.h:37\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_ERROR_NONE","page":"Reference","title":"P4est.LibP4est.SC_IO_ERROR_NONE","text":"The value of zero means no error. \n\nReference\n\nsc_io.h:36\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_MODE_APPEND","page":"Reference","title":"P4est.LibP4est.SC_IO_MODE_APPEND","text":"Semantics as \"a\" in fopen. \n\nReference\n\nsc_io.h:46\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_MODE_LAST","page":"Reference","title":"P4est.LibP4est.SC_IO_MODE_LAST","text":"Invalid entry to close list \n\nReference\n\nsc_io.h:47\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_MODE_WRITE","page":"Reference","title":"P4est.LibP4est.SC_IO_MODE_WRITE","text":"Semantics as \"w\" in fopen. \n\nReference\n\nsc_io.h:45\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_TYPE_BUFFER","page":"Reference","title":"P4est.LibP4est.SC_IO_TYPE_BUFFER","text":"Reference\n\nsc_io.h:60\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_TYPE_FILEFILE","page":"Reference","title":"P4est.LibP4est.SC_IO_TYPE_FILEFILE","text":"Reference\n\nsc_io.h:62\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_TYPE_FILENAME","page":"Reference","title":"P4est.LibP4est.SC_IO_TYPE_FILENAME","text":"Reference\n\nsc_io.h:61\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_IO_TYPE_LAST","page":"Reference","title":"P4est.LibP4est.SC_IO_TYPE_LAST","text":"Invalid entry to close list \n\nReference\n\nsc_io.h:63\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LC_GLOBAL","page":"Reference","title":"P4est.LibP4est.SC_LC_GLOBAL","text":"Reference\n\nsc.h:302\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LC_NORMAL","page":"Reference","title":"P4est.LibP4est.SC_LC_NORMAL","text":"Reference\n\nsc.h:303\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LDFLAGS","page":"Reference","title":"P4est.LibP4est.SC_LDFLAGS","text":"Reference\n\nsc_config.h:311\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LIBS","page":"Reference","title":"P4est.LibP4est.SC_LIBS","text":"Reference\n\nsc_config.h:316\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_ALWAYS","page":"Reference","title":"P4est.LibP4est.SC_LP_ALWAYS","text":"Reference\n\nsc.h:320\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_DEBUG","page":"Reference","title":"P4est.LibP4est.SC_LP_DEBUG","text":"Reference\n\nsc.h:322\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_DEFAULT","page":"Reference","title":"P4est.LibP4est.SC_LP_DEFAULT","text":"Reference\n\nsc.h:319\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_ERROR","page":"Reference","title":"P4est.LibP4est.SC_LP_ERROR","text":"Reference\n\nsc.h:328\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_ESSENTIAL","page":"Reference","title":"P4est.LibP4est.SC_LP_ESSENTIAL","text":"Reference\n\nsc.h:327\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_INFO","page":"Reference","title":"P4est.LibP4est.SC_LP_INFO","text":"Reference\n\nsc.h:324\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_PRODUCTION","page":"Reference","title":"P4est.LibP4est.SC_LP_PRODUCTION","text":"Reference\n\nsc.h:326\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_SILENT","page":"Reference","title":"P4est.LibP4est.SC_LP_SILENT","text":"Reference\n\nsc.h:329\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_STATISTICS","page":"Reference","title":"P4est.LibP4est.SC_LP_STATISTICS","text":"Reference\n\nsc.h:325\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_TRACE","page":"Reference","title":"P4est.LibP4est.SC_LP_TRACE","text":"Reference\n\nsc.h:321\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LP_VERBOSE","page":"Reference","title":"P4est.LibP4est.SC_LP_VERBOSE","text":"Reference\n\nsc.h:323\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_LT_OBJDIR","page":"Reference","title":"P4est.LibP4est.SC_LT_OBJDIR","text":"Reference\n\nsc_config.h:324\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_MEMALIGN","page":"Reference","title":"P4est.LibP4est.SC_MEMALIGN","text":"Reference\n\nsc_config.h:329\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE","text":"Reference\n\nsc_config.h:351\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE_BUGREPORT","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE_BUGREPORT","text":"Reference\n\nsc_config.h:356\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE_NAME","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE_NAME","text":"Reference\n\nsc_config.h:361\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE_STRING","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE_STRING","text":"Reference\n\nsc_config.h:366\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE_TARNAME","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE_TARNAME","text":"Reference\n\nsc_config.h:371\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE_URL","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE_URL","text":"Reference\n\nsc_config.h:376\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_PACKAGE_VERSION","page":"Reference","title":"P4est.LibP4est.SC_PACKAGE_VERSION","text":"Reference\n\nsc_config.h:381\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_SIZEOF_INT","page":"Reference","title":"P4est.LibP4est.SC_SIZEOF_INT","text":"Reference\n\nsc_config.h:398\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_SIZEOF_LONG","page":"Reference","title":"P4est.LibP4est.SC_SIZEOF_LONG","text":"Reference\n\nsc_config.h:403\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_SIZEOF_LONG_LONG","page":"Reference","title":"P4est.LibP4est.SC_SIZEOF_LONG_LONG","text":"Reference\n\nsc_config.h:408\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_SIZEOF_UNSIGNED_LONG","page":"Reference","title":"P4est.LibP4est.SC_SIZEOF_UNSIGNED_LONG","text":"Reference\n\nsc_config.h:413\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_SIZEOF_UNSIGNED_LONG_LONG","page":"Reference","title":"P4est.LibP4est.SC_SIZEOF_UNSIGNED_LONG_LONG","text":"Reference\n\nsc_config.h:418\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_SIZEOF_VOID_P","page":"Reference","title":"P4est.LibP4est.SC_SIZEOF_VOID_P","text":"Reference\n\nsc_config.h:423\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_STDC_HEADERS","page":"Reference","title":"P4est.LibP4est.SC_STDC_HEADERS","text":"Reference\n\nsc_config.h:428\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_AG_ALLTOALL","page":"Reference","title":"P4est.LibP4est.SC_TAG_AG_ALLTOALL","text":"Reference\n\nsc_mpi.h:56\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_AG_RECURSIVE_A","page":"Reference","title":"P4est.LibP4est.SC_TAG_AG_RECURSIVE_A","text":"Reference\n\nsc_mpi.h:57\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_AG_RECURSIVE_B","page":"Reference","title":"P4est.LibP4est.SC_TAG_AG_RECURSIVE_B","text":"Reference\n\nsc_mpi.h:58\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_AG_RECURSIVE_C","page":"Reference","title":"P4est.LibP4est.SC_TAG_AG_RECURSIVE_C","text":"Reference\n\nsc_mpi.h:59\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_FIRST","page":"Reference","title":"P4est.LibP4est.SC_TAG_FIRST","text":"Reference\n\nsc_mpi.h:55\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_LAST","page":"Reference","title":"P4est.LibP4est.SC_TAG_LAST","text":"Reference\n\nsc_mpi.h:75\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_CENSUS","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_CENSUS","text":"Reference\n\nsc_mpi.h:60\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_CENSUSV","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_CENSUSV","text":"Reference\n\nsc_mpi.h:61\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_NARY","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_NARY","text":"Reference\n\nsc_mpi.h:71\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_NBX","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_NBX","text":"Reference\n\nsc_mpi.h:62\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_NBXV","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_NBXV","text":"Reference\n\nsc_mpi.h:63\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_PAYLOAD","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_PAYLOAD","text":"Reference\n\nsc_mpi.h:67\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_RANGES","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_RANGES","text":"Reference\n\nsc_mpi.h:66\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_RECURSIVE","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_RECURSIVE","text":"Reference\n\nsc_mpi.h:70\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_SUPER_EXTRA","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_SUPER_EXTRA","text":"Reference\n\nsc_mpi.h:69\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_SUPER_TRUE","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_SUPER_TRUE","text":"Reference\n\nsc_mpi.h:68\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_WRAPPER","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_WRAPPER","text":"Reference\n\nsc_mpi.h:64\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_NOTIFY_WRAPPERV","page":"Reference","title":"P4est.LibP4est.SC_TAG_NOTIFY_WRAPPERV","text":"Reference\n\nsc_mpi.h:65\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_PSORT_HI","page":"Reference","title":"P4est.LibP4est.SC_TAG_PSORT_HI","text":"Reference\n\nsc_mpi.h:74\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_PSORT_LO","page":"Reference","title":"P4est.LibP4est.SC_TAG_PSORT_LO","text":"Reference\n\nsc_mpi.h:73\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_TAG_REDUCE","page":"Reference","title":"P4est.LibP4est.SC_TAG_REDUCE","text":"Reference\n\nsc_mpi.h:72\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_USE_REALLOC","page":"Reference","title":"P4est.LibP4est.SC_USE_REALLOC","text":"Reference\n\nsc_config.h:433\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_VERSION","page":"Reference","title":"P4est.LibP4est.SC_VERSION","text":"Reference\n\nsc_config.h:438\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_VERSION_MAJOR","page":"Reference","title":"P4est.LibP4est.SC_VERSION_MAJOR","text":"Reference\n\nsc_config.h:443\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_VERSION_MINOR","page":"Reference","title":"P4est.LibP4est.SC_VERSION_MINOR","text":"Reference\n\nsc_config.h:448\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.SC_VERSION_POINT","page":"Reference","title":"P4est.LibP4est.SC_VERSION_POINT","text":"Reference\n\nsc_config.h:453\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est._CONFIG_P_EST_CONFIG_H","page":"Reference","title":"P4est.LibP4est._CONFIG_P_EST_CONFIG_H","text":"Reference\n\np4est_config.h:2\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est._CONFIG_SC_CONFIG_H","page":"Reference","title":"P4est.LibP4est._CONFIG_SC_CONFIG_H","text":"Reference\n\nsc_config.h:2\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_ANY_SOURCE","page":"Reference","title":"P4est.LibP4est.sc_MPI_ANY_SOURCE","text":"Reference\n\nsc_mpi.h:216\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_ANY_TAG","page":"Reference","title":"P4est.LibP4est.sc_MPI_ANY_TAG","text":"Reference\n\nsc_mpi.h:217\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_CONGRUENT","page":"Reference","title":"P4est.LibP4est.sc_MPI_CONGRUENT","text":"Reference\n\nsc_mpi.h:212\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_ERR_GROUP","page":"Reference","title":"P4est.LibP4est.sc_MPI_ERR_GROUP","text":"Reference\n\nsc_mpi.h:258\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_IDENT","page":"Reference","title":"P4est.LibP4est.sc_MPI_IDENT","text":"Reference\n\nsc_mpi.h:211\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_SIMILAR","page":"Reference","title":"P4est.LibP4est.sc_MPI_SIMILAR","text":"Reference\n\nsc_mpi.h:213\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_SUCCESS","page":"Reference","title":"P4est.LibP4est.sc_MPI_SUCCESS","text":"Reference\n\nsc_mpi.h:203\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_THREAD_FUNNELED","page":"Reference","title":"P4est.LibP4est.sc_MPI_THREAD_FUNNELED","text":"Reference\n\nsc_mpi.h:383\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_THREAD_MULTIPLE","page":"Reference","title":"P4est.LibP4est.sc_MPI_THREAD_MULTIPLE","text":"Reference\n\nsc_mpi.h:385\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_THREAD_SERIALIZED","page":"Reference","title":"P4est.LibP4est.sc_MPI_THREAD_SERIALIZED","text":"Reference\n\nsc_mpi.h:384\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_THREAD_SINGLE","page":"Reference","title":"P4est.LibP4est.sc_MPI_THREAD_SINGLE","text":"Reference\n\nsc_mpi.h:382\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_UNDEFINED","page":"Reference","title":"P4est.LibP4est.sc_MPI_UNDEFINED","text":"Reference\n\nsc_mpi.h:256\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.sc_MPI_UNEQUAL","page":"Reference","title":"P4est.LibP4est.sc_MPI_UNEQUAL","text":"Reference\n\nsc_mpi.h:214\n\n\n\n\n\n","category":"constant"},{"location":"reference/#P4est.LibP4est.p2est_quadrant","page":"Reference","title":"P4est.LibP4est.p2est_quadrant","text":"A 1D quadrant datatype: this is used to encode a \"layer\" of a column in the 2D+1D AMR scheme.\n\nReference\n\np6est.h:126\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p2est_quadrant_t","page":"Reference","title":"P4est.LibP4est.p2est_quadrant_t","text":"A 1D quadrant datatype: this is used to encode a \"layer\" of a column in the 2D+1D AMR scheme.\n\nReference\n\np6est.h:161\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est","page":"Reference","title":"P4est.LibP4est.p4est","text":"The p4est forest datatype \n\nReference\n\np4est.h:135\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_coarsen_t","page":"Reference","title":"P4est.LibP4est.p4est_coarsen_t","text":"Callback function prototype to decide for coarsening. \n\nParameters\n\np4est:       the forest\nwhich_tree:  the tree containing quadrant\nquadrants:   Pointers to 4 siblings in Morton ordering.\n\nReturns\n\nnonzero if the quadrants shall be replaced with their parent.\n\nReference\n\np4est.h:223\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_comm_tag","page":"Reference","title":"P4est.LibP4est.p4est_comm_tag","text":"Tags for MPI messages \n\nReference\n\np4est_base.h:127\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_comm_tag_t","page":"Reference","title":"P4est.LibP4est.p4est_comm_tag_t","text":"Tags for MPI messages \n\nReference\n\np4est_base.h:156\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connect_type_t","page":"Reference","title":"P4est.LibP4est.p4est_connect_type_t","text":"Characterize a type of adjacency.\n\nDetails\n\nSeveral functions involve relationships between neighboring trees and/or quadrants, and their behavior depends on how one defines adjacency: 1) entities are adjacent if they share a face, or 2) entities are adjacent if they share a face or corner. p4estconnecttypet is used to choose the desired behavior. This enum must fit into an int8t.\n\nReference\n\np4est_connectivity.h:94\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connectivity","page":"Reference","title":"P4est.LibP4est.p4est_connectivity","text":"This structure holds the 2D inter-tree connectivity information. Identification of arbitrary faces and corners is possible.\n\nDetails\n\nThe arrays treeto* are stored in z ordering. For corners the order wrt. yx is 00 01 10 11. For faces the order is -x +x -y +y. They are allocated [0][0]..[0][3]..[numtrees-1][0]..[numtrees-1][3].\n\nThe values for treetoface are 0..7 where ttf % 4 gives the face number and ttf / 4 the face orientation code. The orientation is 0 for edges that are aligned in z-order, and 1 for edges that are running opposite in z-order.\n\nIt is valid to specify numvertices as 0. In this case vertices and treetovertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[numvertices-1][0]..[num_vertices-1][2].\n\nThe corners are only stored when they connect trees. In this case treetocorner indexes into ctt_offset. Otherwise the treetocorner entry must be -1 and this corner is ignored. If numcorners == 0, treetocorner and cornerto_* arrays are set to NULL.\n\nThe arrays cornerto* store a variable number of entries per corner. For corner c these are at position [cttoffset[c]]..[cttoffset[c+1]-1]. Their number for corner c is cttoffset[c+1] - cttoffset[c]. The entries encode all trees adjacent to corner c. The size of the cornerto* arrays is numctt = cttoffset[num_corners].\n\nThe *toattr arrays may have arbitrary contents defined by the user.\n\nReference\n\np4est_connectivity.h:151\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_encode_t","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_encode_t","text":"Typedef for serialization method. \n\nReference\n\np4est_connectivity.h:106\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_t","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_t","text":"This structure holds the 2D inter-tree connectivity information. Identification of arbitrary faces and corners is possible.\n\nDetails\n\nThe arrays treeto* are stored in z ordering. For corners the order wrt. yx is 00 01 10 11. For faces the order is -x +x -y +y. They are allocated [0][0]..[0][3]..[numtrees-1][0]..[numtrees-1][3].\n\nThe values for treetoface are 0..7 where ttf % 4 gives the face number and ttf / 4 the face orientation code. The orientation is 0 for edges that are aligned in z-order, and 1 for edges that are running opposite in z-order.\n\nIt is valid to specify numvertices as 0. In this case vertices and treetovertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[numvertices-1][0]..[num_vertices-1][2].\n\nThe corners are only stored when they connect trees. In this case treetocorner indexes into ctt_offset. Otherwise the treetocorner entry must be -1 and this corner is ignored. If numcorners == 0, treetocorner and cornerto_* arrays are set to NULL.\n\nThe arrays cornerto* store a variable number of entries per corner. For corner c these are at position [cttoffset[c]]..[cttoffset[c+1]-1]. Their number for corner c is cttoffset[c+1] - cttoffset[c]. The entries encode all trees adjacent to corner c. The size of the cornerto* arrays is numctt = cttoffset[num_corners].\n\nThe *toattr arrays may have arbitrary contents defined by the user.\n\nReference\n\np4est_connectivity.h:181\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_corner_info_t","page":"Reference","title":"P4est.LibP4est.p4est_corner_info_t","text":"Reference\n\np4est_connectivity.h:202\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_corner_transform_t","page":"Reference","title":"P4est.LibP4est.p4est_corner_transform_t","text":"Reference\n\np4est_connectivity.h:195\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange","text":"Transient storage for asynchronous ghost exchange. \n\nReference\n\np4est_ghost.h:256\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_t","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_t","text":"Transient storage for asynchronous ghost exchange. \n\nReference\n\np4est_ghost.h:269\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_ghost_t","page":"Reference","title":"P4est.LibP4est.p4est_ghost_t","text":"quadrants that neighbor the local domain \n\nReference\n\np4est_ghost.h:79\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_gloidx_t","page":"Reference","title":"P4est.LibP4est.p4est_gloidx_t","text":"Typedef for globally unique indexing of quadrants. \n\nReference\n\np4est_base.h:115\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_init_t","page":"Reference","title":"P4est.LibP4est.p4est_init_t","text":"Callback function prototype to initialize the quadrant's user data. \n\nParameters\n\np4est:         the forest\nwhich_tree:    the tree containing quadrant\nquadrant:  the quadrant to be initialized: if datasize > 0,                           the data to be initialized is at                           *quadrant->p.userdata;* otherwise, the                           non-pointer user data (such as                           quadrant->p.user_int) can be initialized\n\nReference\n\np4est.h:203\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_inspect","page":"Reference","title":"P4est.LibP4est.p4est_inspect","text":"Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p4est main structure.\n\nDetails\n\nThe balanceranges and balancenotify* times are collected whenever an inspect structure is present in p4est.\n\nReference\n\np4est_extended.h:61\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_inspect_t","page":"Reference","title":"P4est.LibP4est.p4est_inspect_t","text":"Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p4est main structure. Declared in p4est_extended.h.  Used to profile important algorithms.\n\nReference\n\np4est.h:132\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_info","page":"Reference","title":"P4est.LibP4est.p4est_iter_corner_info","text":"The information that is available to the user-defined p4estitercorner_t callback.\n\nDetails\n\nIf treeboundary is false, the corner is on the interior of a tree. When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When treeboundary is true, its value is P4ESTCONNECT_FACE/CORNER depending on the location of the corner relative to the tree.\n\nReference\n\np4est_iterate.h:173\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_info_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_corner_info_t","text":"The information that is available to the user-defined p4estitercorner_t callback.\n\nDetails\n\nIf treeboundary is false, the corner is on the interior of a tree. When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When treeboundary is true, its value is P4ESTCONNECT_FACE/CORNER depending on the location of the corner relative to the tree.\n\nReference\n\np4est_iterate.h:181\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_side","page":"Reference","title":"P4est.LibP4est.p4est_iter_corner_side","text":"Information about one side of a corner in the forest.  If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nDetails\n\nthe faces field provides some additional information about the local topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that there is a common face between these two sides of the corner.\n\nReference\n\np4est_iterate.h:152\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_side_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_corner_side_t","text":"Information about one side of a corner in the forest.  If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nDetails\n\nthe faces field provides some additional information about the local topology: if side[i]->faces[j] == side[k]->faces[l], this indicates that there is a common face between these two sides of the corner.\n\nReference\n\np4est_iterate.h:162\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_corner_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_corner_t","text":"The prototype for a function that p4est_iterate will execute wherever quadrants meet at a conformal corner\n\nDetails\n\ni.e. the callback will not execute on a hanging corner.\n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p4est_iterate()\n\nNOTE: the forest does not need to be corner balanced for p4estiterate() to correctly execute a callback function at corners, only face balanced (see p4estbalance()).\n\nReference\n\np4est_iterate.h:195\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_info","page":"Reference","title":"P4est.LibP4est.p4est_iter_face_info","text":"The information that is available to the user-defined p4estiterface_t callback.\n\nDetails\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside boundary of the forest, then there is only one side.  If treeboundary is false, the face is on the interior of a tree.  When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the face. When treeboundary is true, its value is P4ESTCONNECT_FACE.\n\nReference\n\np4est_iterate.h:116\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_info_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_face_info_t","text":"The information that is available to the user-defined p4estiterface_t callback.\n\nDetails\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside boundary of the forest, then there is only one side.  If treeboundary is false, the face is on the interior of a tree.  When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the face. When treeboundary is true, its value is P4ESTCONNECT_FACE.\n\nReference\n\np4est_iterate.h:127\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_side","page":"Reference","title":"P4est.LibP4est.p4est_iter_face_side","text":"Information about one side of a face in the forest.\n\nDetails\n\nIf a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order.  If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nReference\n\np4est_iterate.h:75\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_side_data","page":"Reference","title":"P4est.LibP4est.p4est_iter_face_side_data","text":"Reference\n\np4est_iterate.h:82\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_side_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_face_side_t","text":"Information about one side of a face in the forest.\n\nDetails\n\nIf a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order.  If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nReference\n\np4est_iterate.h:103\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_face_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_face_t","text":"The prototype for a function that p4est_iterate will execute wherever two quadrants share a face: the face can be a 2:1 hanging face, it does not have to be conformal.\n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p4est_iterate()\n\nNOTE: the forest must be face balanced for p4estiterate() to execute a callback function on faces (see p4estbalance()).\n\nReference\n\np4est_iterate.h:139\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_volume_info","page":"Reference","title":"P4est.LibP4est.p4est_iter_volume_info","text":"The information that is available to the user-defined p4estitervolume_t callback function.\n\nDetails\n\ntreeid gives the index in p4est->trees of the tree to which    quad belongs. quadid gives the index of quad within tree's quadrants array.\n\nReference\n\np4est_iterate.h:47\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_volume_info_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_volume_info_t","text":"The information that is available to the user-defined p4estitervolume_t callback function.\n\nDetails\n\ntreeid gives the index in p4est->trees of the tree to which    quad belongs. quadid gives the index of quad within tree's quadrants array.\n\nReference\n\np4est_iterate.h:56\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_iter_volume_t","page":"Reference","title":"P4est.LibP4est.p4est_iter_volume_t","text":"The prototype for a function that p4est_iterate will execute at every quadrant local to the current process. \n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p4est_iterate()\n\nReference\n\np4est_iterate.h:63\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lid_t","page":"Reference","title":"P4est.LibP4est.p4est_lid_t","text":"A datatype to handle the linear id in 2D. \n\nReference\n\np4est_extended.h:51\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes","page":"Reference","title":"P4est.LibP4est.p4est_lnodes","text":"Store a parallel numbering of Lobatto points of a given degree > 0.\n\nDetails\n\nEach element has degree+1 nodes per face and vnodes = (degree+1)^2 nodes per volume. numlocalelements is the number of local quadrants in the p4est. elementnodes is of dimension vnodes * numlocal_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); so for degree == 2, this is the layout of nodes:\n\n     f_3  c_2           c_3      6---7---8      |       | f_0  3   4   5  f_1      |       |      0---1---2  c_0           c_1         f_2\n\nelementnodes indexes into the set of local nodes, layed out as follows: local nodes = [<––-ownedcount––->|<––-nonlocalnodes––->]             = [<––––––––numlocalnodes––––––––->] nonlocalnodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.\n\nWhether nodes are hanging or not is decided based on the element faces. This information is encoded in facecode with one int8t per element. If no faces are hanging, the value is zero, otherwise the facecode is interpreted by p4estlnodes_decode.\n\nIndependent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree touching the node.\n\nWhat is meant by touching? A quadrant is said to touch all faces/corners that are incident on it, and by extension all nodes that are contained in those faces/corners.\n\n     X +-----------+         o |           |         o |           | +-----+ o |     p     | |  q  | o |           | |     | o |           | +-----+ O +-----------+\n\nIn this example degree = 6.  There are 5 nodes that live on the face between q and p, and one at each corner of that face.  The face is incident on q, so q owns the nodes on the face (provided q is from a lower tree or has a lower index than p).  The lower corner is incident on q, so q owns it as well.  The upper corner is not incident on q, so q cannot own it.\n\nglobalownedcount contains the number of independent nodes owned by each process.\n\nThe sharers array contains items of type p4estlnodesrank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.\n\ndegree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces and corners) rather than the C^0 Lobatto nodes:\n\nif degree == -1, then one node is assigned per face, and no nodes are assigned per volume or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 4, and the nodes are listed in face-order:\n\n     f_3  c_2           c_3      +---3---+      |       | f_0  0       1  f_1      |       |      +---2---+  c_0           c_1         f_2\n\nif degree == -2, then one node is assigned per face and per corner and no nodes are assigned per volume.  In this case, vnodes == 8, and the nodes are listed in face-order, followed by corner-order:\n\n     f_3  c_2           c_3      6---3---7      |       | f_0  0       1  f_1      |       |      4---2---5  c_0           c_1         f_2\n\nReference\n\np4est_lnodes.h:132\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_buffer","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_buffer","text":"p4estlnodesbuffer_t handles the communication of data associated with nodes.\n\nDetails\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared*begin and a shared*end call.\n\nrecv_buffers is an array of arrays that is used in lnodesshareall*. *recvbuffers[j]* corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->shared_nodes.  At the completion of lnodesshareall or lnodesshareallend, recvbuffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\nReference\n\np4est_lnodes.h:278\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_buffer_t","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_buffer_t","text":"p4estlnodesbuffer_t handles the communication of data associated with nodes.\n\nDetails\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared*begin and a shared*end call.\n\nrecv_buffers is an array of arrays that is used in lnodesshareall*. *recvbuffers[j]* corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->shared_nodes.  At the completion of lnodesshareall or lnodesshareallend, recvbuffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\nReference\n\np4est_lnodes.h:284\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_code_t","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_code_t","text":"Reference\n\np4est_lnodes.h:33\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_rank","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_rank","text":"The structure stored in the sharers array.\n\nDetails\n\nsharednodes is a sorted array of p4estlocidxt that indexes into local nodes.  The sharednodes array has a contiguous (or empty) section of nodes owned by the current rank. sharedmineoffset and sharedminecount identify this section by indexing the sharednodes array, not the local nodes array. ownedoffset and ownedcount define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p4estlnodes_t.\n\nReference\n\np4est_lnodes.h:160\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_rank_t","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_rank_t","text":"The structure stored in the sharers array.\n\nDetails\n\nsharednodes is a sorted array of p4estlocidxt that indexes into local nodes.  The sharednodes array has a contiguous (or empty) section of nodes owned by the current rank. sharedmineoffset and sharedminecount identify this section by indexing the sharednodes array, not the local nodes array. ownedoffset and ownedcount define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p4estlnodes_t.\n\nReference\n\np4est_lnodes.h:167\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_t","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_t","text":"Store a parallel numbering of Lobatto points of a given degree > 0.\n\nDetails\n\nEach element has degree+1 nodes per face and vnodes = (degree+1)^2 nodes per volume. numlocalelements is the number of local quadrants in the p4est. elementnodes is of dimension vnodes * numlocal_elements and lists the nodes of each element in lexicographic yx-order (x varies fastest); so for degree == 2, this is the layout of nodes:\n\n     f_3  c_2           c_3      6---7---8      |       | f_0  3   4   5  f_1      |       |      0---1---2  c_0           c_1         f_2\n\nelementnodes indexes into the set of local nodes, layed out as follows: local nodes = [<––-ownedcount––->|<––-nonlocalnodes––->]             = [<––––––––numlocalnodes––––––––->] nonlocalnodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + global_offset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.\n\nWhether nodes are hanging or not is decided based on the element faces. This information is encoded in facecode with one int8t per element. If no faces are hanging, the value is zero, otherwise the facecode is interpreted by p4estlnodes_decode.\n\nIndependent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree touching the node.\n\nWhat is meant by touching? A quadrant is said to touch all faces/corners that are incident on it, and by extension all nodes that are contained in those faces/corners.\n\n     X +-----------+         o |           |         o |           | +-----+ o |     p     | |  q  | o |           | |     | o |           | +-----+ O +-----------+\n\nIn this example degree = 6.  There are 5 nodes that live on the face between q and p, and one at each corner of that face.  The face is incident on q, so q owns the nodes on the face (provided q is from a lower tree or has a lower index than p).  The lower corner is incident on q, so q owns it as well.  The upper corner is not incident on q, so q cannot own it.\n\nglobalownedcount contains the number of independent nodes owned by each process.\n\nThe sharers array contains items of type p4estlnodesrank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.\n\ndegree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces and corners) rather than the C^0 Lobatto nodes:\n\nif degree == -1, then one node is assigned per face, and no nodes are assigned per volume or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 4, and the nodes are listed in face-order:\n\n     f_3  c_2           c_3      +---3---+      |       | f_0  0       1  f_1      |       |      +---2---+  c_0           c_1         f_2\n\nif degree == -2, then one node is assigned per face and per corner and no nodes are assigned per volume.  In this case, vnodes == 8, and the nodes are listed in face-order, followed by corner-order:\n\n     f_3  c_2           c_3      6---3---7      |       | f_0  0       1  f_1      |       |      4---2---5  c_0           c_1         f_2\n\nReference\n\np4est_lnodes.h:147\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_locidx_t","page":"Reference","title":"P4est.LibP4est.p4est_locidx_t","text":"Typedef for processor-local indexing of quadrants and nodes. \n\nReference\n\np4est_base.h:103\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_t","page":"Reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_t","text":"This structure can be used as the status of a face neighbor iterator. It always contains the face and subface of the neighbor to be processed.\n\nReference\n\np4est_mesh.h:152\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_mesh_t","page":"Reference","title":"P4est.LibP4est.p4est_mesh_t","text":"This structure contains complete mesh information on a 2:1 balanced forest. It stores the locally relevant neighborhood, that is, all locally owned quadrants and one layer of adjacent ghost quadrants and their owners.\n\nDetails\n\nFor each local quadrant, its tree number is stored in quadtotree. The quadtotree array is NULL by default and can be enabled using p4estmeshnewext. For each ghost quadrant, its owner rank is stored in ghosttoproc. For each level, an array of local quadrant numbers is stored in quadlevel. The quadlevel array is NULL by default and can be enabled using p4estmeshnewext.\n\nThe quadtoquad list stores one value for each local quadrant's face. This value is in 0..localnumquadrants-1 for local quadrants, or in localnumquadrants + (0..ghostnumquadrants-1) for ghost quadrants.\n\nThe quadtoface list has equally many entries that are either: 1. A value of v = 0..7 indicates one same-size neighbor.    This value is decoded as v = r * 4 + nf, where nf = 0..3 is the    neighbor's connecting face number and r = 0..1 is the relative    orientation of the neighbor's face; see p4estconnectivity.h. 2. A value of v = 8..23 indicates a double-size neighbor.    This value is decoded as v = 8 + h * 8 + r * 4 + nf, where    r and nf are as above and h = 0..1 is the number of the subface.    h designates the subface of the large neighbor that the quadrant    touches (this is the same as the large neighbor's face corner). 3. A value of v = -8..-1 indicates two half-size neighbors.    In this case the corresponding quadtoquad index points into the    quadtohalf array that stores two quadrant numbers per index,    and the orientation of the smaller faces follows from 8 + v.    The entries of quadtohalf encode between local and ghost quadrant    in the same way as the quadtoquad values described above.    The small neighbors in quadto_half are stored in the sequence    of the face corners of this, i.e., the large quadrant.\n\nA quadrant on the boundary of the forest sees itself and its face number.\n\nThe quadtocorner list stores corner neighbors that are not face neighbors. On the inside of a tree, there is precisely one such neighbor per corner. In this case, its index is encoded as described above for quadtoquad. The neighbor's matching corner number is always diagonally opposite, that is, corner number ^ 3.\n\nOn the inside of an inter-tree face, we have precisely one corner neighbor. If a corner is an inter-tree corner, then the number of corner neighbors may be any non-negative number.  In both cases, the quadtocorner value is in    localnumquadrants + localnumghosts + [0 .. localnumcorners - 1]. After subtracting the number of local and ghost quadrants, it indexes into corneroffset, which encodes a group of corner neighbors. Each group contains the quadrant numbers encoded as usual for quadtoquad in cornerquad, and the corner number from the neighbor as corner_corner.\n\nCorners with no diagonal neighbor at all are assigned the value -3.  This only happens on the domain boundary, which is necessarily a tree boundary. Corner-neighbors for hanging nodes are assigned the value -1.\n\nTODO: In case of an inter-tree corner neighbor relation in a brick-like       situation (exactly one neighbor, diagonally opposite corner number),       use the same encoding as for corners within a tree.\n\nReference\n\np4est_mesh.h:128\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_qcoord_t","page":"Reference","title":"P4est.LibP4est.p4est_qcoord_t","text":"Typedef for quadrant coordinates. \n\nReference\n\np4est_base.h:78\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_quadrant","page":"Reference","title":"P4est.LibP4est.p4est_quadrant","text":"The 2D quadrant datatype \n\nReference\n\np4est.h:71\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_data","page":"Reference","title":"P4est.LibP4est.p4est_quadrant_data","text":"Reference\n\np4est.h:79\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_t","page":"Reference","title":"P4est.LibP4est.p4est_quadrant_t","text":"The 2D quadrant datatype \n\nReference\n\np4est.h:111\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_refine_t","page":"Reference","title":"P4est.LibP4est.p4est_refine_t","text":"Callback function prototype to decide for refinement. \n\nParameters\n\np4est:       the forest\nwhich_tree:  the tree containing quadrant\nquadrant:    the quadrant that may be refined\n\nReturns\n\nnonzero if the quadrant shall be refined.\n\nReference\n\np4est.h:213\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_replace_t","page":"Reference","title":"P4est.LibP4est.p4est_replace_t","text":"Callback function prototype to replace one set of quadrants with another.\n\nDetails\n\nThis is used by extended routines when the quadrants of an existing, valid p4est are changed.  The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.\n\nParameters\n\nnum_outgoing: The number of outgoing quadrants.\noutgoing:     The outgoing quadrants: after the callback, the                          userdata, if *p4est->datasize* is nonzero,                          will be destroyed.\nnum_incoming: The number of incoming quadrants.\nincoming: The incoming quadrants: prior to the callback,                          the userdata, if *p4est->datasize* is nonzero,                          is allocated, and the p4estinitt callback,                          if it has been provided, will be called.\n\nIf the mesh is being refined, numoutgoing will be 1 and numincoming will be 4, and vice versa if the mesh is being coarsened.\n\nReference\n\np4est_extended.h:109\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_t","page":"Reference","title":"P4est.LibP4est.p4est_t","text":"The p4est forest datatype \n\nReference\n\np4est.h:173\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_topidx_t","page":"Reference","title":"P4est.LibP4est.p4est_topidx_t","text":"Typedef for counting topological entities (trees, tree vertices). \n\nReference\n\np4est_base.h:90\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_tree","page":"Reference","title":"P4est.LibP4est.p4est_tree","text":"The p4est tree datatype \n\nReference\n\np4est.h:114\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_tree_t","page":"Reference","title":"P4est.LibP4est.p4est_tree_t","text":"The p4est tree datatype \n\nReference\n\np4est.h:126\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p4est_weight_t","page":"Reference","title":"P4est.LibP4est.p4est_weight_t","text":"Callback function prototype to calculate weights for partitioning. \n\nParameters\n\np4est:       the forest\nwhich_tree:  the tree containing quadrant\n\nReturns\n\na 32bit integer >= 0 as the quadrant weight. \n\nNOTE:    Global sum of weights must fit into a 64bit integer.\n\nReference\n\np4est.h:233\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est","page":"Reference","title":"P4est.LibP4est.p6est","text":"The p6est forest datatype \n\nReference\n\np6est.h:164\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_column_t","page":"Reference","title":"P4est.LibP4est.p6est_coarsen_column_t","text":"Callback function prototype to decide for horizontal coarsening. \n\nParameters\n\ncolumns:      Pointers to 4 sibling columns.\n\nReturns\n\nnonzero if the columns shall be replaced with their parent.\n\nReference\n\np6est.h:264\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_layer_t","page":"Reference","title":"P4est.LibP4est.p6est_coarsen_layer_t","text":"Callback function prototype to decide for vertical coarsening. \n\nParameters\n\nlayers:      Pointers to 2 vertical sibling layers.\n\nReturns\n\nnonzero if the layers shall be replaced with their parent.\n\nReference\n\np6est.h:272\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_comm_tag_t","page":"Reference","title":"P4est.LibP4est.p6est_comm_tag_t","text":"Reference\n\np6est.h:465\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_connectivity","page":"Reference","title":"P4est.LibP4est.p6est_connectivity","text":"This structure holds the 2D+1D inter-tree connectivity information. It is essentially a wrapper of the 2D p4estconnecitivityt datatype, with some additional information about how the third dimension is embedded.\n\nReference\n\np6est.h:64\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_connectivity_t","page":"Reference","title":"P4est.LibP4est.p6est_connectivity_t","text":"This structure holds the 2D+1D inter-tree connectivity information. It is essentially a wrapper of the 2D p4estconnecitivityt datatype, with some additional information about how the third dimension is embedded.\n\nReference\n\np6est.h:77\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_init_t","page":"Reference","title":"P4est.LibP4est.p6est_init_t","text":"Callback function prototype to initialize the layers's user data.\n\nParameters\n\np6est:        the forest\nwhich_tree:   the tree in the forest\ncolumn:       the column in the tree in the forest\nlayer:        the layer in the column in the tree in the                         forest, whose user_data is to be initialized\n\nReference\n\np6est.h:199\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_quadrant_data","page":"Reference","title":"P4est.LibP4est.p6est_quadrant_data","text":"Reference\n\np6est.h:132\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_refine_column_t","page":"Reference","title":"P4est.LibP4est.p6est_refine_column_t","text":"Callback function prototype to decide whether to horizontally refine a column, i.e., horizontally refine all of the layers in the column. \n\nReturns\n\nnonzero if the layer shall be refined.\n\nReference\n\np6est.h:247\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_refine_layer_t","page":"Reference","title":"P4est.LibP4est.p6est_refine_layer_t","text":"Callback function prototype to decide whether to vertically refine a layer. \n\nReturns\n\nnonzero if the layer shall be refined.\n\nReference\n\np6est.h:255\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_replace_t","page":"Reference","title":"P4est.LibP4est.p6est_replace_t","text":"Callback function prototype to transfer information from outgoing layers to incoming layers.\n\nDetails\n\nThis is used by extended routines when the layers of an existing, valid p6est are changed.  The callback allows the user to make changes to newly initialized layers before the layers that they replace are destroyed.\n\nParameters\n\nnum_outcolumns:  The number of columns that contain the outgoing                             layers: will be either 1 or 4.\nnum_outlayers:   The number of outgoing layers: will be either 1                             (a single layer is being refined), 2 (two                             layers are being vertically coarsened), or 4                             (four layers are being horizontally coarsened).\noutcolumns:      The columns of the outgoing layers\noutlayers:       The outgoing layers: after the callback, the                             userdata, if *p6est->datasize* is nonzero,                             will be destroyed.\nnum_incolumns:   The number of columns that contain the outgoing                             layers: will be either 1 or 4.\nnum_inlayers:    The number of incoming layers: will be either 1                             (coarsening), 2 (vertical refinement), or 4                             (horizontal refinement)\nincolumns:       The columns of the incoming layers\ninlayers:    The incoming layers: prior to the callback,                             the userdata, if *p6est->datasize* is nonzero,                             is allocated, and the p6estinitt callback,                             if it has been provided, will be called.\n\nReference\n\np6est.h:232\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_t","page":"Reference","title":"P4est.LibP4est.p6est_t","text":"The p6est forest datatype \n\nReference\n\np6est.h:189\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p6est_weight_t","page":"Reference","title":"P4est.LibP4est.p6est_weight_t","text":"Callback function prototype to calculate weights for partitioning. \n\nReturns\n\na 32bit integer >= 0 as the quadrant weight. \n\nNOTE:    Global sum of weights must fit into a 64bit integer.\n\nReference\n\np6est.h:281\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est","page":"Reference","title":"P4est.LibP4est.p8est","text":"The p8est forest datatype \n\nReference\n\np8est.h:131\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_coarsen_t","page":"Reference","title":"P4est.LibP4est.p8est_coarsen_t","text":"Callback function prototype to decide for coarsening. \n\nParameters\n\np8est:       the forest\nwhich_tree:  the tree containing quadrant\nquadrants:   Pointers to 8 siblings in Morton ordering.\n\nReturns\n\nnonzero if the quadrants shall be replaced with their parent.\n\nReference\n\np8est.h:219\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connect_type_t","page":"Reference","title":"P4est.LibP4est.p8est_connect_type_t","text":"Characterize a type of adjacency.\n\nDetails\n\nSeveral functions involve relationships between neighboring trees and/or quadrants, and their behavior depends on how one defines adjacency: 1) entities are adjacent if they share a face, or 2) entities are adjacent if they share a face or corner, or 3) entities are adjacent if they share a face, corner or edge. p8estconnecttypet is used to choose the desired behavior. This enum must fit into an int8t.\n\nReference\n\np8est_connectivity.h:97\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connectivity","page":"Reference","title":"P4est.LibP4est.p8est_connectivity","text":"This structure holds the 3D inter-tree connectivity information. Identification of arbitrary faces, edges and corners is possible.\n\nDetails\n\nThe arrays treeto* are stored in z ordering. For corners the order wrt. zyx is 000 001 010 011 100 101 110 111. For faces the order is -x +x -y +y -z +z. They are allocated [0][0]..[0][N-1]..[numtrees-1][0]..[numtrees-1][N-1]. where N is 6 for tree and face, 8 for corner, 12 for edge.\n\nThe values for treetoface are in 0..23 where ttf % 6 gives the face number and ttf / 6 the face orientation code. The orientation is determined as follows.  Let myface and otherface be the two face numbers of the connecting trees in 0..5.  Then the first face corner of the lower of myface and otherface connects to a face corner numbered 0..3 in the higher of myface and otherface.  The face orientation is defined as this number.  If myface == otherface, treating either of both faces as the lower one leads to the same result.\n\nIt is valid to specify numvertices as 0. In this case vertices and treetovertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[numvertices-1][0]..[num_vertices-1][2].\n\nThe edges are only stored when they connect trees. In this case treetoedge indexes into ett_offset. Otherwise the treetoedge entry must be -1 and this edge is ignored. If numedges == 0, treetoedge and edgeto_* arrays are set to NULL.\n\nThe arrays edgeto* store a variable number of entries per edge. For edge e these are at position [ettoffset[e]]..[ettoffset[e+1]-1]. Their number for edge e is ettoffset[e+1] - ettoffset[e]. The entries encode all trees adjacent to edge e. The size of the edgeto* arrays is numett = ettoffset[numedges]. The edgeto_edge array holds values in 0..23, where the lower 12 indicate one edge orientation and the higher 12 the opposite edge orientation.\n\nThe corners are only stored when they connect trees. In this case treetocorner indexes into ctt_offset. Otherwise the treetocorner entry must be -1 and this corner is ignored. If numcorners == 0, treetocorner and cornerto_* arrays are set to NULL.\n\nThe arrays cornerto* store a variable number of entries per corner. For corner c these are at position [cttoffset[c]]..[cttoffset[c+1]-1]. Their number for corner c is cttoffset[c+1] - cttoffset[c]. The entries encode all trees adjacent to corner c. The size of the cornerto* arrays is numctt = cttoffset[num_corners].\n\nThe *toattr arrays may have arbitrary contents defined by the user.\n\nReference\n\np8est_connectivity.h:172\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_encode_t","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_encode_t","text":"Typedef for serialization method. \n\nReference\n\np8est_connectivity.h:109\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_t","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_t","text":"This structure holds the 3D inter-tree connectivity information. Identification of arbitrary faces, edges and corners is possible.\n\nDetails\n\nThe arrays treeto* are stored in z ordering. For corners the order wrt. zyx is 000 001 010 011 100 101 110 111. For faces the order is -x +x -y +y -z +z. They are allocated [0][0]..[0][N-1]..[numtrees-1][0]..[numtrees-1][N-1]. where N is 6 for tree and face, 8 for corner, 12 for edge.\n\nThe values for treetoface are in 0..23 where ttf % 6 gives the face number and ttf / 6 the face orientation code. The orientation is determined as follows.  Let myface and otherface be the two face numbers of the connecting trees in 0..5.  Then the first face corner of the lower of myface and otherface connects to a face corner numbered 0..3 in the higher of myface and otherface.  The face orientation is defined as this number.  If myface == otherface, treating either of both faces as the lower one leads to the same result.\n\nIt is valid to specify numvertices as 0. In this case vertices and treetovertex are set to NULL. Otherwise the vertex coordinates are stored in the array vertices as [0][0]..[0][2]..[numvertices-1][0]..[num_vertices-1][2].\n\nThe edges are only stored when they connect trees. In this case treetoedge indexes into ett_offset. Otherwise the treetoedge entry must be -1 and this edge is ignored. If numedges == 0, treetoedge and edgeto_* arrays are set to NULL.\n\nThe arrays edgeto* store a variable number of entries per edge. For edge e these are at position [ettoffset[e]]..[ettoffset[e+1]-1]. Their number for edge e is ettoffset[e+1] - ettoffset[e]. The entries encode all trees adjacent to edge e. The size of the edgeto* arrays is numett = ettoffset[numedges]. The edgeto_edge array holds values in 0..23, where the lower 12 indicate one edge orientation and the higher 12 the opposite edge orientation.\n\nThe corners are only stored when they connect trees. In this case treetocorner indexes into ctt_offset. Otherwise the treetocorner entry must be -1 and this corner is ignored. If numcorners == 0, treetocorner and cornerto_* arrays are set to NULL.\n\nThe arrays cornerto* store a variable number of entries per corner. For corner c these are at position [cttoffset[c]]..[cttoffset[c+1]-1]. Their number for corner c is cttoffset[c+1] - cttoffset[c]. The entries encode all trees adjacent to corner c. The size of the cornerto* arrays is numctt = cttoffset[num_corners].\n\nThe *toattr arrays may have arbitrary contents defined by the user.\n\nReference\n\np8est_connectivity.h:211\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_corner_info_t","page":"Reference","title":"P4est.LibP4est.p8est_corner_info_t","text":"Reference\n\np8est_connectivity.h:246\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_corner_transform_t","page":"Reference","title":"P4est.LibP4est.p8est_corner_transform_t","text":"Reference\n\np8est_connectivity.h:239\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_edge_info_t","page":"Reference","title":"P4est.LibP4est.p8est_edge_info_t","text":"Reference\n\np8est_connectivity.h:232\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_edge_transform_t","page":"Reference","title":"P4est.LibP4est.p8est_edge_transform_t","text":"Reference\n\np8est_connectivity.h:225\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange","text":"Transient storage for asynchronous ghost exchange. \n\nReference\n\np8est_ghost.h:255\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_t","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_t","text":"Transient storage for asynchronous ghost exchange. \n\nReference\n\np8est_ghost.h:268\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_ghost_t","page":"Reference","title":"P4est.LibP4est.p8est_ghost_t","text":"quadrants that neighbor the local domain \n\nReference\n\np8est_ghost.h:78\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_init_t","page":"Reference","title":"P4est.LibP4est.p8est_init_t","text":"Callback function prototype to initialize the quadrant's user data. \n\nParameters\n\np8est:         the forest\nwhich_tree:    the tree containing quadrant\nquadrant:  the quadrant to be initialized: if datasize > 0,                           the data to be initialized is at                           *quadrant->p.userdata;* otherwise, the                           non-pointer user data (such as                           quadrant->p.user_int) can be initialized\n\nReference\n\np8est.h:199\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_inspect","page":"Reference","title":"P4est.LibP4est.p8est_inspect","text":"Reference\n\np8est_extended.h:66\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_inspect_t","page":"Reference","title":"P4est.LibP4est.p8est_inspect_t","text":"Data pertaining to selecting, inspecting, and profiling algorithms. A pointer to this structure is hooked into the p8est main structure. Declared in p8est_extended.h.  Used to profile important algorithms.\n\nReference\n\np8est.h:128\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_info","page":"Reference","title":"P4est.LibP4est.p8est_iter_corner_info","text":"The information that is availalbe to the user-defined p8estitercorner_t callback.\n\nDetails\n\nIf treeboundary is false, the corner is on the interior of a tree. When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When treeboundary is true, its value is P8ESTCONNECT_FACE/EDGE/CORNER depending on the location of the corner relative to the tree.\n\nReference\n\np8est_iterate.h:252\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_info_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_corner_info_t","text":"The information that is availalbe to the user-defined p8estitercorner_t callback.\n\nDetails\n\nIf treeboundary is false, the corner is on the interior of a tree. When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the corner. When treeboundary is true, its value is P8ESTCONNECT_FACE/EDGE/CORNER depending on the location of the corner relative to the tree.\n\nReference\n\np8est_iterate.h:260\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_side","page":"Reference","title":"P4est.LibP4est.p8est_iter_corner_side","text":"Reference\n\np8est_iterate.h:230\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_side_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_corner_side_t","text":"Reference\n\np8est_iterate.h:241\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_corner_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_corner_t","text":"The prototype for a function that p8est_iterate will execute wherever the corner is a corner for all quadrants that touch it\n\nDetails\n\ni.e. the callback will not execute on a corner that sits on a hanging face or edge.\n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p8est_iterate()\n\nNOTE: the forest does not need to be corner balanced for p8est_iterate() to execute a callback function at corners, only face and edge balanced.\n\nReference\n\np8est_iterate.h:274\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_info","page":"Reference","title":"P4est.LibP4est.p8est_iter_edge_info","text":"The information about all sides of an edge in the forest. If treeboundary is false, the edge is on the interior of a tree. When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the edge. When treeboundary is true, its value is P8ESTCONNECT_FACE/EDGE depending on the location of the edge relative to the tree.\n\nReference\n\np8est_iterate.h:198\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_info_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_edge_info_t","text":"The information about all sides of an edge in the forest. If treeboundary is false, the edge is on the interior of a tree. When treeboundary is false, sides[0] contains the lowest z-order quadrant that touches the edge. When treeboundary is true, its value is P8ESTCONNECT_FACE/EDGE depending on the location of the edge relative to the tree.\n\nReference\n\np8est_iterate.h:206\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_side","page":"Reference","title":"P4est.LibP4est.p8est_iter_edge_side","text":"Reference\n\np8est_iterate.h:155\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_side_data","page":"Reference","title":"P4est.LibP4est.p8est_iter_edge_side_data","text":"Reference\n\np8est_iterate.h:166\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_side_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_edge_side_t","text":"Reference\n\np8est_iterate.h:189\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_edge_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_edge_t","text":"The prototype for a function that p8est_iterate will execute wherever the edge is an edge of all quadrants that touch it i.e. the callback will not execute on an edge the sits on a hanging face.\n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p8est_iterate()\n\nNOTE: the forest must be edge balanced for p8est_iterate() to execute a callback function on edges.\n\nReference\n\np8est_iterate.h:218\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_info","page":"Reference","title":"P4est.LibP4est.p8est_iter_face_info","text":"The information that is available to the user-defined p8estiterface_t callback.\n\nDetails\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside of the forest, then there is only one side.  If treeboundary is false, the face is on the interior of a tree.  When treeboundary false, sides[0] contains the lowest z-order quadrant that touches the face. When treeboundary is true, its value is P8ESTCONNECT_FACE.\n\nReference\n\np8est_iterate.h:114\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_info_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_face_info_t","text":"The information that is available to the user-defined p8estiterface_t callback.\n\nDetails\n\nThe orientation is 0 if the face is within one tree; otherwise, it is the same as the orientation value between the two trees given in the connectivity.  If the face is on the outside of the forest, then there is only one side.  If treeboundary is false, the face is on the interior of a tree.  When treeboundary false, sides[0] contains the lowest z-order quadrant that touches the face. When treeboundary is true, its value is P8ESTCONNECT_FACE.\n\nReference\n\np8est_iterate.h:125\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_side","page":"Reference","title":"P4est.LibP4est.p8est_iter_face_side","text":"Information about one side of a face in the forest.  If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nReference\n\np8est_iterate.h:73\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_side_data","page":"Reference","title":"P4est.LibP4est.p8est_iter_face_side_data","text":"Reference\n\np8est_iterate.h:80\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_side_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_face_side_t","text":"Information about one side of a face in the forest.  If a quad is local (is_ghost is false), then its quadid indexes the tree's quadrant array; otherwise, it indexes the ghosts array. If the face is hanging, then the quadrants are listed in z-order. If a quadrant should be present, but it is not included in the ghost layer, then quad = NULL, is_ghost is true, and quadid = -1.\n\nReference\n\np8est_iterate.h:101\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_face_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_face_t","text":"The prototype for a function that p8est_iterate() will execute wherever two quadrants share a face: the face can be a 2:1 hanging face, it does not have to be conformal.\n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p8est_iterate()\n\nNOTE: the forest must be face balanced for p8estiterate() to execute a callback function on faces (see p8estbalance()).\n\nReference\n\np8est_iterate.h:137\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_volume_info","page":"Reference","title":"P4est.LibP4est.p8est_iter_volume_info","text":"The information that is available to the user-defined p8estitervolume_t callback function.\n\nDetails\n\ntreeid gives the index in p4est->trees of the tree to which    quad belongs. quadid gives the index of quad within tree's quadrants array.\n\nReference\n\np8est_iterate.h:47\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_volume_info_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_volume_info_t","text":"The information that is available to the user-defined p8estitervolume_t callback function.\n\nDetails\n\ntreeid gives the index in p4est->trees of the tree to which    quad belongs. quadid gives the index of quad within tree's quadrants array.\n\nReference\n\np8est_iterate.h:56\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_iter_volume_t","page":"Reference","title":"P4est.LibP4est.p8est_iter_volume_t","text":"The prototype for a function that p8est_iterate() will execute at every quadrant local to the current process. \n\nParameters\n\ninfo:          information about a quadrant provided to the user\nuser_data: the user context passed to p8est_iterate()\n\nReference\n\np8est_iterate.h:63\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lid_t","page":"Reference","title":"P4est.LibP4est.p8est_lid_t","text":"A datatype to handle the linear id in 3D. We use the implementation of unsigned 128 bit integer in libsc, i.e., a struct with the members highbits and lowbits (both uint64_t).\n\nReference\n\np8est_extended.h:56\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes","page":"Reference","title":"P4est.LibP4est.p8est_lnodes","text":"Store a parallel numbering of Lobatto points of a given degree > 0.\n\nDetails\n\nEach element has degree+1 nodes per edge and vnodes = (degree+1)^3 nodes per volume. elementnodes is of dimension vnodes * numlocalelements and lists the nodes of each element in lexicographic yx-order (x varies fastest); elementnodes indexes into the set of local nodes, layed out as follows: local nodes = [<––-ownedcount––->|<––-nonlocalnodes––->]             = [<––––––––numlocalnodes––––––––->] nonlocalnodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + globaloffset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.\n\nWhether nodes are hanging or not is decided based on the element faces and edges. This information is encoded in facecode with one int16t per element. If no faces or edges are hanging, the value is zero, otherwise the facecode is interpreted by p8estlnodes_decode.\n\nIndependent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree touching the node.\n\nWhat is meant by touching? A quadrant is said to touch all faces/edges/corners that are incident on it, and by extension all nodes that are contained in those faces/edges/corners.\n\n        X      +-----------+             x     |\\           \\            x      | \\           \\             . x   |  \\           \\            x   X  |   +-----------+ +-----+     . .   |   |           | |\\     \\   X   o  +   |           | | +-----+   o .    \\  |     p     | + |  q  |      o    \\ |           |  \\|     |     o      \\|           |   +-----+      O      +-----------+\n\nIn this example degree = 3.  There are 4 nodes that live on the face between q and p, two on each edge and one at each corner of that face. The face is incident on q, so q owns the nodes marked '.' on the face (provided q is from a lower tree or has a lower index than p). The bottom and front edges are incident on q, so q owns its nodes marked 'o' as well. The front lower corner is incident on q, so q owns its node 'O' as well.  The other edges and corners are not incident on q, so q cannot own their nodes, marked 'x' and 'X'.\n\nglobalownedcount contains the number of independent nodes owned by each process.\n\nThe sharers array contains items of type p8estlnodesrank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.\n\ndegree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces, edge  and corners) rather than the C^0 Lobatto nodes:\n\nif degree == -1, then one node is assigned per face, and no nodes are assigned per volume, per edge,  or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 6, and the nodes are listed in face-order.\n\nif degree == -2, then one node is assigned per face and per edge and no nodes are assigned per volume or per corner.  In this case, vnodes == 18, and the nodes are listed in face-order, followed by edge-order.\n\nif degree == -3, then one node is assigned per face, per edge and per corner and no nodes are assigned per volume.  In this case, vnodes == 26, and the nodes are listed in face-order, followed by edge-order, followed by corner-order.\n\nReference\n\np8est_lnodes.h:112\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_buffer","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_buffer","text":"p8estlnodesbuffer_t handles the communication of data associated with nodes.\n\nDetails\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared*begin and a shared*end call.\n\nrecv_buffers is an array of arrays that is used in lnodesshareall*. *recvbuffers[j]* corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->shared_nodes.  At the completion of lnodesshareall or lnodesshareallend, recvbuffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\nReference\n\np8est_lnodes.h:318\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_buffer_t","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_buffer_t","text":"p8estlnodesbuffer_t handles the communication of data associated with nodes.\n\nDetails\n\nsend_buffers is an array of arrays: one buffer for each process to which the current process sends node-data.  It should not be altered between a shared*begin and a shared*end call.\n\nrecv_buffers is an array of arrays that is used in lnodesshareall*. *recvbuffers[j]* corresponds with lnodes->sharers[j]: it is the same length as lnodes->sharers[j]->shared_nodes.  At the completion of lnodesshareall or lnodesshareallend, recvbuffers[j] contains the node-data from the process lnodes->sharers[j]->rank (unless j is the current rank, in which case recv_buffers[j] is empty).\n\nReference\n\np8est_lnodes.h:324\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_code_t","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_code_t","text":"Reference\n\np8est_lnodes.h:33\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_rank","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_rank","text":"The structure stored in the sharers array.\n\nDetails\n\nsharednodes is a sorted array of p4estlocidxt that indexes into local nodes.  The sharednodes array has a contiguous (or empty) section of nodes owned by the current rank. sharedmineoffset and sharedminecount identify this section by indexing the sharednodes array, not the local nodes array. ownedoffset and ownedcount define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p8estlnodes_t.\n\nReference\n\np8est_lnodes.h:140\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_rank_t","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_rank_t","text":"The structure stored in the sharers array.\n\nDetails\n\nsharednodes is a sorted array of p4estlocidxt that indexes into local nodes.  The sharednodes array has a contiguous (or empty) section of nodes owned by the current rank. sharedmineoffset and sharedminecount identify this section by indexing the sharednodes array, not the local nodes array. ownedoffset and ownedcount define the section of local nodes that is owned by the listed rank (the section may be empty). For the current process these coincide with those in p8estlnodes_t.\n\nReference\n\np8est_lnodes.h:147\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_t","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_t","text":"Store a parallel numbering of Lobatto points of a given degree > 0.\n\nDetails\n\nEach element has degree+1 nodes per edge and vnodes = (degree+1)^3 nodes per volume. elementnodes is of dimension vnodes * numlocalelements and lists the nodes of each element in lexicographic yx-order (x varies fastest); elementnodes indexes into the set of local nodes, layed out as follows: local nodes = [<––-ownedcount––->|<––-nonlocalnodes––->]             = [<––––––––numlocalnodes––––––––->] nonlocalnodes contains the globally unique numbers for independent nodes that are owned by other processes; for local nodes, the globally unique numbers are given by i + globaloffset, where i is the local number. Hanging nodes are always local and don't have a global number. They index the geometrically corresponding independent nodes of a neighbor.\n\nWhether nodes are hanging or not is decided based on the element faces and edges. This information is encoded in facecode with one int16t per element. If no faces or edges are hanging, the value is zero, otherwise the facecode is interpreted by p8estlnodes_decode.\n\nIndependent nodes can be shared by multiple MPI ranks. The owner rank of a node is the one from the lowest numbered element on the lowest numbered octree touching the node.\n\nWhat is meant by touching? A quadrant is said to touch all faces/edges/corners that are incident on it, and by extension all nodes that are contained in those faces/edges/corners.\n\n        X      +-----------+             x     |\\           \\            x      | \\           \\             . x   |  \\           \\            x   X  |   +-----------+ +-----+     . .   |   |           | |\\     \\   X   o  +   |           | | +-----+   o .    \\  |     p     | + |  q  |      o    \\ |           |  \\|     |     o      \\|           |   +-----+      O      +-----------+\n\nIn this example degree = 3.  There are 4 nodes that live on the face between q and p, two on each edge and one at each corner of that face. The face is incident on q, so q owns the nodes marked '.' on the face (provided q is from a lower tree or has a lower index than p). The bottom and front edges are incident on q, so q owns its nodes marked 'o' as well. The front lower corner is incident on q, so q owns its node 'O' as well.  The other edges and corners are not incident on q, so q cannot own their nodes, marked 'x' and 'X'.\n\nglobalownedcount contains the number of independent nodes owned by each process.\n\nThe sharers array contains items of type p8estlnodesrank_t that hold the ranks that own or share independent local nodes. If there are no shared nodes on this processor, it is empty. Otherwise, it is sorted by rank and the current process is included.\n\ndegree < 0 indicates that the lnodes data structure is being used to number the quadrant boundary object (faces, edge  and corners) rather than the C^0 Lobatto nodes:\n\nif degree == -1, then one node is assigned per face, and no nodes are assigned per volume, per edge,  or per corner: this numbering can be used for low-order Raviart-Thomas elements.  In this case, vnodes == 6, and the nodes are listed in face-order.\n\nif degree == -2, then one node is assigned per face and per edge and no nodes are assigned per volume or per corner.  In this case, vnodes == 18, and the nodes are listed in face-order, followed by edge-order.\n\nif degree == -3, then one node is assigned per face, per edge and per corner and no nodes are assigned per volume.  In this case, vnodes == 26, and the nodes are listed in face-order, followed by edge-order, followed by corner-order.\n\nReference\n\np8est_lnodes.h:127\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_t","page":"Reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_t","text":"This structure can be used as the status of a face neighbor iterator. It always contains the face and subface of the neighbor to be processed.\n\nReference\n\np8est_mesh.h:192\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_mesh_t","page":"Reference","title":"P4est.LibP4est.p8est_mesh_t","text":"This structure contains complete mesh information on a 2:1 balanced forest. It stores the locally relevant neighborhood, that is, all locally owned quadrants and one layer of adjacent ghost quadrants and their owners.\n\nDetails\n\nFor each local quadrant, its tree number is stored in quadtotree. The quadtotree array is NULL by default and can be enabled using p8estmeshnewext. For each ghost quadrant, its owner rank is stored in ghosttoproc. For each level, an array of local quadrant numbers is stored in quadlevel. The quadlevel array is NULL by default and can be enabled using p8estmeshnewext.\n\nThe quadtoquad list stores one value for each local quadrant's face. This value is in 0..localnumquadrants-1 for local quadrants, or in localnumquadrants + (0..ghostnumquadrants-1) for ghost quadrants.\n\nThe quadtoface list has equally many entries that are either: 1. A value of v = 0..23 indicates one same-size neighbor.    This value is decoded as v = r * 6 + nf, where nf = 0..5 is the    neighbor's connecting face number and r = 0..3 is the relative    orientation of the neighbor's face; see p8estconnectivity.h. 2. A value of v = 24..119 indicates a double-size neighbor.    This value is decoded as v = 24 + h * 24 + r * 6 + nf, where    r and nf are as above and h = 0..3 is the number of the subface.    h designates the subface of the large neighbor that the quadrant    touches (this is the same as the large neighbor's face corner). 3. A value of v = -24..-1 indicates four half-size neighbors.    In this case the corresponding quadtoquad index points into the    quadtohalf array that stores four quadrant numbers per index,    and the orientation of the smaller faces follows from 24 + v.    The entries of quadtohalf encode between local and ghost quadrant    in the same way as the quadtoquad values described above.    The small neighbors in quadto_half are stored in the sequence    of the face corners of this, i.e., the large quadrant.\n\nA quadrant on the boundary of the forest sees itself and its face number.\n\nThe quadtoedge list stores edge neighbors that are not face neighbors. On the inside of a tree, there are one or two of those depending on size. Between trees, there can be any number of same- or different-sized neighbors. For same-tree same-size neighbors, we record their number in quadtoedge by the same convention as described for quadtoquad above.  In this case, the neighbor's matching edge number is always diagonally opposite, that is, edge number ^ 3.\n\nFor half- and double-size and all inter-tree edge neighbors, the quadtoedge value is in    localnumquadrants + localnumghosts + [0 .. localnumedges - 1]. After subtracting the number of local and ghost quadrants, it indexes into edgeoffset, which encodes a group of edge neighbors. Each member of a group may be one same/double-size quadrant or two half-size quadrants; this is determined by the value of the edgeedge field as follows. 1. A value of e = 0..23 indicates one same-size neighbor.    This value is encoded as e = r * 12 + ne, where ne = 0..11 is the    neighbor's connecting edge number and r = 0..1 indicates an edge flip. 2. A value of e = 24..71 indicates a double-size neighbor.    This value is decoded as e = 24 + h * 24 + r * 12 + ne, where    r and ne are as above and h = 0..1 is the number of the subedge.    h designates the subedge of the large neighbor that the quadrant    touches (this is the same as the large neighbor's edge corner). 3. A value of e = -24..-1 indicates two half-size neighbors.    They are represented by two consecutive entries of the edgequad and    edgeedge arrays with identical values for edgeedge.    The orientation of the smaller edges follows from 24 + e.    The small neighbors in edgequad are stored in the sequence    of the edge corners of this, i.e., the large quadrant.\n\nEdges with no diagonal neighbor at all are assigned the value -3.  This only happens on the domain boundary, which is necessarily a tree boundary. Edge neighbors for face-hanging nodes are assigned the value -1.\n\nThe quadtocorner list stores corner neighbors that are not face or edge neighbors.  On the inside of a tree, there is precisely one such neighbor per corner.  In this case, its index is encoded as described above for quadtoquad.  The neighbor's matching corner number is always diagonally opposite, that is, corner number ^ 7.\n\nOn the inside of an inter-tree face, we have precisely one corner neighbor. If a corner is across an inter-tree edge or corner, then the number of corner neighbors may be any non-negative number.  In all three cases, the quadtocorner value is in    localnumquadrants + localnumghosts + [0 .. localnumcorners - 1]. After subtracting the number of local and ghost quadrants, it indexes into corneroffset, which encodes a group of corner neighbors. Each group contains the quadrant numbers encoded as usual for quadtoquad in cornerquad, and the corner number from the neighbor as corner_corner.\n\nCorners with no diagonal neighbor at all are assigned the value -3.  This only happens on the domain boundary, which is necessarily a tree boundary. Corner-neighbors for face- and edge-hanging nodes are assigned the value -1.\n\nTODO: In case of an inter-tree neighbor relation in a brick-like       situation (one same-size neighbor, diagonally opposite edge/corner),       use the same encoding as for edges/corners within a tree.\n\nReference\n\np8est_mesh.h:168\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_quadrant","page":"Reference","title":"P4est.LibP4est.p8est_quadrant","text":"The 3D quadrant (i.e., octant) datatype \n\nReference\n\np8est.h:67\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_data","page":"Reference","title":"P4est.LibP4est.p8est_quadrant_data","text":"Reference\n\np8est.h:75\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_t","page":"Reference","title":"P4est.LibP4est.p8est_quadrant_t","text":"The 3D quadrant (i.e., octant) datatype \n\nReference\n\np8est.h:107\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_refine_t","page":"Reference","title":"P4est.LibP4est.p8est_refine_t","text":"Callback function prototype to decide for refinement. \n\nParameters\n\np8est:       the forest\nwhich_tree:  the tree containing quadrant\nquadrant:    the quadrant that may be refined\n\nReturns\n\nnonzero if the quadrant shall be refined.\n\nReference\n\np8est.h:209\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_replace_t","page":"Reference","title":"P4est.LibP4est.p8est_replace_t","text":"Callback function prototype to replace one set of quadrants with another.\n\nDetails\n\nThis is used by extended routines when the quadrants of an existing, valid p8est are changed.  The callback allows the user to make changes to newly initialized quadrants before the quadrants that they replace are destroyed.\n\nParameters\n\nnum_outgoing: The number of outgoing quadrants.\noutgoing:     The outgoing quadrants: after the callback, the                          userdata, if *p8est->datasize* is nonzero,                          will be destroyed.\nnum_incoming: The number of incoming quadrants.\nincoming: The incoming quadrants: prior to the callback,                          the userdata, if *p8est->datasize* is nonzero,                          is allocated, and the p8estinitt callback,                          if it has been provided, will be called.\n\nIf the mesh is being refined, numoutgoing will be 1 and numincoming will be 8, and vice versa if the mesh is being coarsened.\n\nReference\n\np8est_extended.h:114\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_t","page":"Reference","title":"P4est.LibP4est.p8est_t","text":"The p8est forest datatype \n\nReference\n\np8est.h:169\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_tree","page":"Reference","title":"P4est.LibP4est.p8est_tree","text":"The p8est tree datatype \n\nReference\n\np8est.h:110\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_tree_t","page":"Reference","title":"P4est.LibP4est.p8est_tree_t","text":"The p8est tree datatype \n\nReference\n\np8est.h:122\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.p8est_weight_t","page":"Reference","title":"P4est.LibP4est.p8est_weight_t","text":"Callback function prototype to calculate weights for partitioning. \n\nParameters\n\np8est:       the forest\nwhich_tree:  the tree containing quadrant\n\nReturns\n\na 32bit integer >= 0 as the quadrant weight. \n\nNOTE:    Global sum of weights must fit into a 64bit integer.\n\nReference\n\np8est.h:229\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm","text":"Reference\n\nsc_mpi.h:262\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_MPI_Datatype","page":"Reference","title":"P4est.LibP4est.sc_MPI_Datatype","text":"Reference\n\nsc_mpi.h:264\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group","text":"Reference\n\nsc_mpi.h:263\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_MPI_Op","page":"Reference","title":"P4est.LibP4est.sc_MPI_Op","text":"Reference\n\nsc_mpi.h:265\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_MPI_Request","page":"Reference","title":"P4est.LibP4est.sc_MPI_Request","text":"Reference\n\nsc_mpi.h:266\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_MPI_Status","page":"Reference","title":"P4est.LibP4est.sc_MPI_Status","text":"References\n\nsc_mpi.h:267\n\nsc_mpi.h:275\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_abort_handler_t","page":"Reference","title":"P4est.LibP4est.sc_abort_handler_t","text":"Reference\n\nsc.h:472\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_array","page":"Reference","title":"P4est.LibP4est.sc_array","text":"The scarray object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index.  Their address may change. The number of elements (== elemcount) of the array can be changed by  scarrayresize and scarrayrewind. Elements can be sorted with scarraysort. If the array is sorted, it can be searched with scarraybsearch. A priority queue is implemented with pqueueadd and pqueuepop (untested).\n\nReference\n\nsc_containers.h:99\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_array_t","page":"Reference","title":"P4est.LibP4est.sc_array_t","text":"The scarray object provides a dynamic array of equal-size elements. Elements are accessed by their 0-based index.  Their address may change. The number of elements (== elemcount) of the array can be changed by  scarrayresize and scarrayrewind. Elements can be sorted with scarraysort. If the array is sorted, it can be searched with scarraybsearch. A priority queue is implemented with pqueueadd and pqueuepop (untested).\n\nReference\n\nsc_containers.h:113\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_array_type_t","page":"Reference","title":"P4est.LibP4est.sc_array_type_t","text":"Function to determine the enumerable type of an object in an array. \n\nParameters\n\narray:   Array containing the object.\nindex:   The location of the object.\ndata:    Arbitrary user data.\n\nReference\n\nsc_containers.h:369\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_equal_function_t","page":"Reference","title":"P4est.LibP4est.sc_equal_function_t","text":"Function to check equality of two objects. \n\nParameters\n\nu:   Arbitrary user data.\n\nReturns\n\nReturns false if *v1 is unequal *v2 and true otherwise.\n\nReference\n\nsc_containers.h:81\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_handler_t","page":"Reference","title":"P4est.LibP4est.sc_handler_t","text":"Reference\n\nsc.h:467\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash","page":"Reference","title":"P4est.LibP4est.sc_hash","text":"The sc_hash implements a hash table. It uses an array which has linked lists as elements.\n\nReference\n\nsc_containers.h:903\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_array","page":"Reference","title":"P4est.LibP4est.sc_hash_array","text":"The schasharray implements an array backed up by a hash table. This enables O(1) access for array elements.\n\nReference\n\nsc_containers.h:1030\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_array_data","page":"Reference","title":"P4est.LibP4est.sc_hash_array_data","text":"Reference\n\nsc_containers.h:1017\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_array_data_t","page":"Reference","title":"P4est.LibP4est.sc_hash_array_data_t","text":"Reference\n\nsc_containers.h:1025\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_array_t","page":"Reference","title":"P4est.LibP4est.sc_hash_array_t","text":"The schasharray implements an array backed up by a hash table. This enables O(1) access for array elements.\n\nReference\n\nsc_containers.h:1037\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_foreach_t","page":"Reference","title":"P4est.LibP4est.sc_hash_foreach_t","text":"Function to call on every data item of a hash table. \n\nParameters\n\nv:   The address of the pointer to the current object.\nu:   Arbitrary user data.\n\nReturns\n\nReturn true if the traversal should continue, false to stop.\n\nReference\n\nsc_containers.h:89\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_function_t","page":"Reference","title":"P4est.LibP4est.sc_hash_function_t","text":"Function to compute a hash value of an object. \n\nParameters\n\nv:   The object to hash.\nu:   Arbitrary user data.\n\nReturns\n\nReturns an unsigned integer.\n\nReference\n\nsc_containers.h:75\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_hash_t","page":"Reference","title":"P4est.LibP4est.sc_hash_t","text":"The sc_hash implements a hash table. It uses an array which has linked lists as elements.\n\nReference\n\nsc_containers.h:917\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_encode_t","page":"Reference","title":"P4est.LibP4est.sc_io_encode_t","text":"Reference\n\nsc_io.h:56\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_error_t","page":"Reference","title":"P4est.LibP4est.sc_io_error_t","text":"Error values for io.\n\nReference\n\nsc_io.h:41\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_mode_t","page":"Reference","title":"P4est.LibP4est.sc_io_mode_t","text":"Reference\n\nsc_io.h:49\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_sink","page":"Reference","title":"P4est.LibP4est.sc_io_sink","text":"Reference\n\nsc_io.h:67\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_sink_t","page":"Reference","title":"P4est.LibP4est.sc_io_sink_t","text":"Reference\n\nsc_io.h:78\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_source","page":"Reference","title":"P4est.LibP4est.sc_io_source","text":"Reference\n\nsc_io.h:80\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_source_t","page":"Reference","title":"P4est.LibP4est.sc_io_source_t","text":"Reference\n\nsc_io.h:92\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_io_type_t","page":"Reference","title":"P4est.LibP4est.sc_io_type_t","text":"Reference\n\nsc_io.h:65\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_link","page":"Reference","title":"P4est.LibP4est.sc_link","text":"The sc_link structure is one link of a linked list.\n\nReference\n\nsc_containers.h:799\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_link_t","page":"Reference","title":"P4est.LibP4est.sc_link_t","text":"The sc_link structure is one link of a linked list.\n\nReference\n\nsc_containers.h:804\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_list","page":"Reference","title":"P4est.LibP4est.sc_list","text":"The sc_list object provides a linked list.\n\nReference\n\nsc_containers.h:808\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_list_t","page":"Reference","title":"P4est.LibP4est.sc_list_t","text":"The sc_list object provides a linked list.\n\nReference\n\nsc_containers.h:819\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_log_handler_t","page":"Reference","title":"P4est.LibP4est.sc_log_handler_t","text":"Reference\n\nsc.h:468\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mempool","page":"Reference","title":"P4est.LibP4est.sc_mempool","text":"The scmempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool)    and are transparently reused. If the zeroand_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.\n\nReference\n\nsc_containers.h:677\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mempool_t","page":"Reference","title":"P4est.LibP4est.sc_mempool_t","text":"The scmempool object provides a large pool of equal-size elements. The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool)    and are transparently reused. If the zeroand_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it.\n\nReference\n\nsc_containers.h:692\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mstamp","page":"Reference","title":"P4est.LibP4est.sc_mstamp","text":"A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See scmempoolt for that purpose.\n\nReference\n\nsc_containers.h:604\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_mstamp_t","page":"Reference","title":"P4est.LibP4est.sc_mstamp_t","text":"A data container to create memory items of the same size. Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See scmempoolt for that purpose.\n\nReference\n\nsc_containers.h:613\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_recycle_array","page":"Reference","title":"P4est.LibP4est.sc_recycle_array","text":"The screcyclearray object provides an array of slots that can be reused.\n\nDetails\n\nIt keeps a list of free slots in the array which will be used for insertion while available.  Otherwise, the array is grown.\n\nReference\n\nsc_containers.h:1107\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_t","page":"Reference","title":"P4est.LibP4est.sc_recycle_array_t","text":"The screcyclearray object provides an array of slots that can be reused.\n\nDetails\n\nIt keeps a list of free slots in the array which will be used for insertion while available.  Otherwise, the array is grown.\n\nReference\n\nsc_containers.h:1116\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_tag_t","page":"Reference","title":"P4est.LibP4est.sc_tag_t","text":"Reference\n\nsc_mpi.h:77\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_uint128","page":"Reference","title":"P4est.LibP4est.sc_uint128","text":"An unsigned 128 bit integer represented as two uint64_t. \n\nReference\n\nsc_uint128.h:44\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.sc_uint128_t","page":"Reference","title":"P4est.LibP4est.sc_uint128_t","text":"An unsigned 128 bit integer represented as two uint64_t. \n\nReference\n\nsc_uint128.h:49\n\n\n\n\n\n","category":"type"},{"location":"reference/#P4est.LibP4est.P2EST_DATA_UNINITIALIZED","page":"Reference","title":"P4est.LibP4est.P2EST_DATA_UNINITIALIZED","text":"𝐣𝐥.@cextern P2EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReference\n\np6est.h:286\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_DATA_UNINITIALIZED","page":"Reference","title":"P4est.LibP4est.P4EST_DATA_UNINITIALIZED","text":"𝐣𝐥.@cextern P4EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReference\n\np4est.h:237\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_ESSENTIALF","page":"Reference","title":"P4est.LibP4est.P4EST_ESSENTIALF","text":"𝐣𝐥.@cextern P4EST_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:292\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_ESSENTIALF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_ESSENTIALF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:246\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_INFOF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_INFOF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:240\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_LDEBUGF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_LDEBUGF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:236\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_LERRORF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_LERRORF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:248\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_LOGF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_LOGF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:214\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_PRODUCTIONF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_PRODUCTIONF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:244\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_STATISTICSF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_STATISTICSF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:242\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_TRACEF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_TRACEF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:234\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_GLOBAL_VERBOSEF","page":"Reference","title":"P4est.LibP4est.P4EST_GLOBAL_VERBOSEF","text":"𝐣𝐥.@cextern P4EST_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:238\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_INFOF","page":"Reference","title":"P4est.LibP4est.P4EST_INFOF","text":"𝐣𝐥.@cextern P4EST_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:286\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_LDEBUGF","page":"Reference","title":"P4est.LibP4est.P4EST_LDEBUGF","text":"𝐣𝐥.@cextern P4EST_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:282\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_LERRORF","page":"Reference","title":"P4est.LibP4est.P4EST_LERRORF","text":"𝐣𝐥.@cextern P4EST_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:294\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_LOGF","page":"Reference","title":"P4est.LibP4est.P4EST_LOGF","text":"𝐣𝐥.@cextern P4EST_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:216\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_PRODUCTIONF","page":"Reference","title":"P4est.LibP4est.P4EST_PRODUCTIONF","text":"𝐣𝐥.@cextern P4EST_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:290\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_STATISTICSF","page":"Reference","title":"P4est.LibP4est.P4EST_STATISTICSF","text":"𝐣𝐥.@cextern P4EST_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:288\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_TRACEF","page":"Reference","title":"P4est.LibP4est.P4EST_TRACEF","text":"𝐣𝐥.@cextern P4EST_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:280\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P4EST_VERBOSEF","page":"Reference","title":"P4est.LibP4est.P4EST_VERBOSEF","text":"𝐣𝐥.@cextern P4EST_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\np4est_base.h:284\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.P8EST_DATA_UNINITIALIZED","page":"Reference","title":"P4est.LibP4est.P8EST_DATA_UNINITIALIZED","text":"𝐣𝐥.@cextern P8EST_DATA_UNINITIALIZED::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReference\n\np8est.h:233\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_ABORTF","page":"Reference","title":"P4est.LibP4est.SC_ABORTF","text":"𝐣𝐥.@cextern SC_ABORTF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:177\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_CHECK_ABORTF","page":"Reference","title":"P4est.LibP4est.SC_CHECK_ABORTF","text":"𝐣𝐥.@cextern SC_CHECK_ABORTF(success::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:180\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_ESSENTIALF","page":"Reference","title":"P4est.LibP4est.SC_ESSENTIALF","text":"𝐣𝐥.@cextern SC_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:434\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GEN_LOGF","page":"Reference","title":"P4est.LibP4est.SC_GEN_LOGF","text":"𝐣𝐥.@cextern SC_GEN_LOGF(package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:351\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_ESSENTIALF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_ESSENTIALF","text":"𝐣𝐥.@cextern SC_GLOBAL_ESSENTIALF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:390\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_INFOF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_INFOF","text":"𝐣𝐥.@cextern SC_GLOBAL_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:384\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_LDEBUGF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_LDEBUGF","text":"𝐣𝐥.@cextern SC_GLOBAL_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:380\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_LERRORF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_LERRORF","text":"𝐣𝐥.@cextern SC_GLOBAL_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:392\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_LOGF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_LOGF","text":"𝐣𝐥.@cextern SC_GLOBAL_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:354\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_PRODUCTIONF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_PRODUCTIONF","text":"𝐣𝐥.@cextern SC_GLOBAL_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:388\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_STATISTICSF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_STATISTICSF","text":"𝐣𝐥.@cextern SC_GLOBAL_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:386\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_TRACEF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_TRACEF","text":"𝐣𝐥.@cextern SC_GLOBAL_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:378\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_GLOBAL_VERBOSEF","page":"Reference","title":"P4est.LibP4est.SC_GLOBAL_VERBOSEF","text":"𝐣𝐥.@cextern SC_GLOBAL_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:382\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_INFOF","page":"Reference","title":"P4est.LibP4est.SC_INFOF","text":"𝐣𝐥.@cextern SC_INFOF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:428\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_LDEBUGF","page":"Reference","title":"P4est.LibP4est.SC_LDEBUGF","text":"𝐣𝐥.@cextern SC_LDEBUGF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:424\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_LERRORF","page":"Reference","title":"P4est.LibP4est.SC_LERRORF","text":"𝐣𝐥.@cextern SC_LERRORF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:436\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_LOGF","page":"Reference","title":"P4est.LibP4est.SC_LOGF","text":"𝐣𝐥.@cextern SC_LOGF(priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:356\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_PRODUCTIONF","page":"Reference","title":"P4est.LibP4est.SC_PRODUCTIONF","text":"𝐣𝐥.@cextern SC_PRODUCTIONF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:432\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_STATISTICSF","page":"Reference","title":"P4est.LibP4est.SC_STATISTICSF","text":"𝐣𝐥.@cextern SC_STATISTICSF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:430\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_TRACEF","page":"Reference","title":"P4est.LibP4est.SC_TRACEF","text":"𝐣𝐥.@cextern SC_TRACEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:422\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.SC_VERBOSEF","page":"Reference","title":"P4est.LibP4est.SC_VERBOSEF","text":"𝐣𝐥.@cextern SC_VERBOSEF(fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:426\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_balance","page":"Reference","title":"P4est.LibP4est.p4est_balance","text":"𝐣𝐥.@cextern p4est_balance(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid\n\n2:1 balance the size differences of neighboring elements in a forest. \n\nParameters\n\np4est:  The p4est to be worked on.\nbtype:      Balance type (face or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\n\nReference\n\np4est.h:360\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_balance_ext","page":"Reference","title":"P4est.LibP4est.p4est_balance_ext","text":"𝐣𝐥.@cextern p4est_balance_ext(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid\n\n2:1 balance the size differences of neighboring elements in a forest. \n\nParameters\n\np4est:  The p4est to be worked on.\nbtype:      Balance type (face or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np4est_extended.h:484\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_balance_subtree_ext","page":"Reference","title":"P4est.LibP4est.p4est_balance_subtree_ext","text":"𝐣𝐥.@cextern p4est_balance_subtree_ext(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t, which_tree::p4est_topidx_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid\n\nReference\n\np4est_extended.h:489\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_checksum","page":"Reference","title":"P4est.LibP4est.p4est_checksum","text":"𝐣𝐥.@cextern p4est_checksum(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cuint\n\nCompute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize. \n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nReference\n\np4est.h:393\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_checksum_partition","page":"Reference","title":"P4est.LibP4est.p4est_checksum_partition","text":"𝐣𝐥.@cextern p4est_checksum_partition(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cuint\n\nCompute a partition-dependent checksum for a forest. \n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nReference\n\np4est.h:398\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_child_corner_faces","page":"Reference","title":"P4est.LibP4est.p4est_child_corner_faces","text":"𝐣𝐥.@cextern p4est_child_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[4]\n\nStore the faces for each child and corner, can be -1. \n\nReference\n\np4est_connectivity.h:217\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_coarsen","page":"Reference","title":"P4est.LibP4est.p4est_coarsen","text":"𝐣𝐥.@cextern p4est_coarsen(p4est::𝐣𝐥.Ptr{p4est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p4est_coarsen_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid\n\nCoarsen a forest. \n\nParameters\n\np4est:  The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncoarsen_fn: Callback function that returns true if a                        family of quadrants shall be coarsened\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\n\nReference\n\np4est.h:347\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_coarsen_ext","page":"Reference","title":"P4est.LibP4est.p4est_coarsen_ext","text":"𝐣𝐥.@cextern p4est_coarsen_ext(p4est::𝐣𝐥.Ptr{p4est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p4est_coarsen_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid\n\nCoarsen a forest. \n\nParameters\n\np4est: The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncallback_orphans: Boolean to enable calling coarsenfn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsenrecursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.                        With coarsenrecursive false and callbackorphans true,                        it is guaranteed that every quadrant is passed exactly                        once into the coarsen_fn callback.\ncoarsen_fn: Callback function that returns true if a                        family of quadrants shall be coarsened.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np4est_extended.h:467\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connect_type_int","page":"Reference","title":"P4est.LibP4est.p4est_connect_type_int","text":"𝐣𝐥.@cextern p4est_connect_type_int(btype::p4est_connect_type_t)::𝐣𝐥.Cint\n\nConvert the p4estconnecttype_t into a number. \n\nParameters\n\nbtype:    The balance type to convert.\n\nReturns\n\n          Returns 1 or 2.\n\nReference\n\np4est_connectivity.h:112\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connect_type_string","page":"Reference","title":"P4est.LibP4est.p4est_connect_type_string","text":"𝐣𝐥.@cextern p4est_connect_type_string(btype::p4est_connect_type_t)::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}\n\nConvert the p4estconnecttype_t into a const string. \n\nParameters\n\nbtype:    The balance type to convert.\n\nReturns\n\n          Returns a pointer to a constant string.\n\nReference\n\np4est_connectivity.h:118\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_bcast","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_bcast","text":"𝐣𝐥.@cextern p4est_connectivity_bcast(conn_in::𝐣𝐥.Ptr{p4est_connectivity_t}, root::𝐣𝐥.Cint, comm::sc_MPI_Comm)::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nBroadcast a connectivity structure that exists only on one process to all.  On the other processors, it will be allocated using p4estconnectivitynew.  \n\nParameters\n\nconn_in: For the root process the connectivity to be broadcast,                      for the other processes it must be NULL.\nroot:    The rank of the process that provides the connectivity.\ncomm:    The MPI communicator.\n\nReturns\n\n         For the root process this is a pointer to *conn_in.*                      Else, a pointer to a newly allocated connectivity                      structure with the same values as *conn_in* on the                      root process.\n\nReference\n\np4est_connectivity.h:289\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_complete","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_complete","text":"𝐣𝐥.@cextern p4est_connectivity_complete(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid\n\nInternally connect a connectivity based on treetovertex information. Periodicity that is not inherent in the list of vertices will be lost. \n\nParameters\n\nconn:     The connectivity needs to have proper vertices                          and treetovertex fields.  The treetotree                          and treetoface fields must be allocated                          and satisfy p4estconnectivityis_valid (conn)                          but will be overwritten.  The corner                          fields will be freed and allocated anew.\n\nReference\n\np4est_connectivity.h:583\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_deflate","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_deflate","text":"𝐣𝐥.@cextern p4est_connectivity_deflate(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, code::p4est_connectivity_encode_t)::𝐣𝐥.Ptr{sc_array_t}\n\nAllocate memory and store the connectivity information there. \n\nParameters\n\nconn:     The connectivity structure to be exported to memory.\ncode:     Encoding and compression method for serialization.\n\nReturns\n\n          Newly created array that contains the information.\n\nReference\n\np4est_connectivity.h:333\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_destroy","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_destroy","text":"𝐣𝐥.@cextern p4est_connectivity_destroy(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid\n\nDestroy a connectivity structure.  Also destroy all attributes.\n\nReference\n\np4est_connectivity.h:295\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_face_neighbor_corner","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_face_neighbor_corner","text":"𝐣𝐥.@cextern p4est_connectivity_face_neighbor_corner(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. \n\nParameters\n\nc:    A corner number in 0..3.\nf:    A face number that touches the corner c.\nnf:   A neighbor face that is on the other side of nothing.\no:    The orientation between tree boundary faces f and nothing.\n\nReturns\n\n      The number of the corner seen from the neighbor tree.\n\nReference\n\np4est_connectivity.h:238\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_face_neighbor_face_corner","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_face_neighbor_face_corner","text":"𝐣𝐥.@cextern p4est_connectivity_face_neighbor_face_corner(fc::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a face corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. \n\nParameters\n\nfc:   A face corner number in 0..1.\nf:    A face that the face corner number fc is relative to.\nnf:   A neighbor face that is on the other side of nothing.\no:    The orientation between tree boundary faces f and nothing.\n\nReturns\n\n      The face corner number relative to the neighbor's face.\n\nReference\n\np4est_connectivity.h:227\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_inflate","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_inflate","text":"𝐣𝐥.@cextern p4est_connectivity_inflate(buffer::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate new connectivity from a memory buffer. \n\nParameters\n\nbuffer:   The connectivity is created from this memory buffer.\n\nReturns\n\n          The newly created connectivity, or NULL on error.\n\nReference\n\np4est_connectivity.h:356\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_is_equal","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_is_equal","text":"𝐣𝐥.@cextern p4est_connectivity_is_equal(conn1::𝐣𝐥.Ptr{p4est_connectivity_t}, conn2::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint\n\nCheck two connectivity structures for equality. \n\nReturns\n\n      Returns true if structures are equal, false otherwise.\n\nReference\n\np4est_connectivity.h:316\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_is_equivalent","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_is_equivalent","text":"𝐣𝐥.@cextern p4est_connectivity_is_equivalent(conn1::𝐣𝐥.Ptr{p4est_connectivity_t}, conn2::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint\n\np4estconnectivityis_equivalent This function compares two connectivities for equivalence: it returns true if they are the same connectivity, or if they have the same topology.  The definition of topological sameness is strict: there is no attempt made to determine whether permutation and/or rotation of the trees makes the connectivities equivalent.\n\nParameters\n\nconn1:    a valid connectivity\nconn2:    a valid connectivity\n\nReference\n\np4est_connectivity.h:672\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_is_valid","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_is_valid","text":"𝐣𝐥.@cextern p4est_connectivity_is_valid(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint\n\nExamine a connectivity structure. \n\nReturns\n\n      Returns true if structure is valid, false otherwise.\n\nReference\n\np4est_connectivity.h:310\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_join_faces","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_join_faces","text":"𝐣𝐥.@cextern p4est_connectivity_join_faces(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, tree_left::p4est_topidx_t, tree_right::p4est_topidx_t, face_left::𝐣𝐥.Cint, face_right::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\np4estconnectivityjoin_faces This function takes an existing valid connectivity conn and modifies it by joining two tree faces that are currently boundary faces. \n\nParameters\n\nconn:        connectivity that will be altered.\ntree_left:   tree that will be on the left side of the joined                             faces.\ntree_right:  tree that will be on the right side of the                             joined faces.\nface_left:   face of tree_left that will be joined.\nface_right:  face of tree_right that will be joined.\norientation: the orientation of face_left and                             face_right once joined (see the description                             of p4estconnectivityt to understand                             orientation).\n\nReference\n\np4est_connectivity.h:654\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_load","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_load","text":"𝐣𝐥.@cextern p4est_connectivity_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, bytes::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nLoad a connectivity structure from disk. \n\nParameters\n\nfilename:         Name of the file to read.\nbytes:        Size in bytes of connectivity on disk or NULL.\n\nReturns\n\n          Returns valid connectivity, or NULL on file error.\n\nReference\n\np4est_connectivity.h:363\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_memory_used","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_memory_used","text":"𝐣𝐥.@cextern p4est_connectivity_memory_used(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::size_t\n\nCalculate memory usage of a connectivity structure. \n\nParameters\n\nconn:   Connectivity structure.\n\nReturns\n\n        Memory used in bytes.\n\nReference\n\np4est_connectivity.h:187\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new","text":"𝐣𝐥.@cextern p4est_connectivity_new(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_corners::p4est_topidx_t, num_ctt::p4est_topidx_t)::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nAllocate a connectivity structure. The attribute fields are initialized to NULL. \n\nParameters\n\nnum_vertices:   Number of total vertices (i.e. geometric points).\nnum_trees:      Number of trees in the forest.\nnum_corners:    Number of tree-connecting corners.\nnum_ctt:        Number of total trees in cornertotree array.\n\nReturns\n\n                A connectivity structure with allocated arrays.\n\nReference\n\np4est_connectivity.h:249\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_brick","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_brick","text":"𝐣𝐥.@cextern p4est_connectivity_new_brick(mi::𝐣𝐥.Cint, ni::𝐣𝐥.Cint, periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nA rectangular m by n array of trees with configurable periodicity. The brick is periodic in x and y if periodica and periodicb are true, respectively.\n\nReference\n\np4est_connectivity.h:493\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_byname","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_byname","text":"𝐣𝐥.@cextern p4est_connectivity_new_byname(name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate connectivity structure from predefined catalogue. \n\nParameters\n\nname:            Invokes connectivitynew* function.              brick23         brick (2, 3, 0, 0)              corner          corner              cubed           cubed              disk            disk              moebius         moebius              periodic        periodic              pillow          pillow              rotwrap         rotwrap              star            star              unit            unitsquare\n\nReturns\n\n  An initialized connectivity if name is defined, NULL else.\n\nReference\n\np4est_connectivity.h:511\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_copy","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_copy","text":"𝐣𝐥.@cextern p4est_connectivity_new_copy(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_corners::p4est_topidx_t, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cdouble)}, ttv::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttf::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, ttc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, coff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)})::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nAllocate a connectivity structure and populate from constants. The attribute fields are initialized to NULL. \n\nParameters\n\nnum_vertices:   Number of total vertices (i.e. geometric points).\nnum_trees:      Number of trees in the forest.\nnum_corners:    Number of tree-connecting corners.\ncoff:           Corner-to-tree offsets (numcorners + 1 values).                            This must always be non-NULL; in trivial cases                            it is just a pointer to a p4esttopix value of 0.\n\nReturns\n\n                The connectivity is checked for validity.\n\nReference\n\np4est_connectivity.h:264\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_corner","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_corner","text":"𝐣𝐥.@cextern p4est_connectivity_new_corner()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for a three-tree mesh around a corner.\n\nReference\n\np4est_connectivity.h:391\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_cubed","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_cubed","text":"𝐣𝐥.@cextern p4est_connectivity_new_cubed()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for the six sides of a unit cube. The ordering of the trees is as follows: 0 1                                            2 3 <– 3: axis-aligned top side                                              4 5. This choice has been made for maximum symmetry (see treeto* in .c file).\n\nReference\n\np4est_connectivity.h:411\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_disk","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_disk","text":"𝐣𝐥.@cextern p4est_connectivity_new_disk(periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for a five-tree flat spherical disk. This disk can just as well be used as a square to test non-Cartesian maps. Without any mapping this connectivity covers the square [-3, 3]**2. \n\nDetails\n\nNOTE: The API of this function has changed to accept two arguments.       You can query the #define P4ESTCONNDISK_PERIODIC to check       whether the new version with the argument is in effect.\n\nThe ordering of the trees is as follows:   4                                          1 2 3                                            0.\n\nThe outside x faces may be identified topologically. The outside y faces may be identified topologically. Both identifications may be specified simultaneously. The general shape and periodicity are the same as those obtained with p4estconnectivitynewbrick (1, 1, periodica, periodic_b).\n\nWhen setting periodic_a and periodic_b to false, the result is the same as that of p4estconnectivitynewdisknonperiodic.\n\nParameters\n\nperiodic_a:       Bool to make disk periodic in x direction.\nperiodic_b:       Bool to make disk periodic in y direction.\n\nReturns\n\n                  Initialized and usable connectivity.\n\nReference\n\np4est_connectivity.h:444\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_disk2d","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_disk2d","text":"𝐣𝐥.@cextern p4est_connectivity_new_disk2d()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure that maps a 2d disk.\n\nDetails\n\nThis is a 5 trees connectivity meant to be used together with p4estgeometrynew_disk2d to map the disk.\n\nReference\n\np4est_connectivity.h:487\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_disk_nonperiodic","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_disk_nonperiodic","text":"𝐣𝐥.@cextern p4est_connectivity_new_disk_nonperiodic()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for a five-tree flat spherical disk. This disk can just as well be used as a square to test non-Cartesian maps. Without any mapping this connectivity covers the square [-3, 3]**2. \n\nReturns\n\n                  Initialized and usable connectivity.\n\nReference\n\np4est_connectivity.h:418\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_icosahedron","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_icosahedron","text":"𝐣𝐥.@cextern p4est_connectivity_new_icosahedron()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity for mapping the sphere using an icosahedron.\n\nDetails\n\nThe regular icosadron is a polyhedron with 20 faces, each of which is an equilateral triangle. To build the p4est connectivity, we group faces 2 by 2 to from 10 quadrangles, and thus 10 trees.\n\nThis connectivity is meant to be used together with p4estgeometrynew_icosahedron to map the sphere.\n\nThe flat connectivity looks like that: Vextex numbering:\n\nA00   A01   A02   A03   A04   /   \\ /   \\ /   \\ /   \\ /   \\ A05---A06---A07---A08---A09---A10   \\   / \\   / \\   / \\   / \\   / \\    A11---A12---A13---A14---A15---A16      \\  /  \\  /  \\  /  \\  /  \\  /      A17   A18   A19   A20   A21\n\nOrigin in A05.\n\nTree numbering:\n\n0  2  4  6  8  1  3  5  7  9\n\nReference\n\np4est_connectivity.h:475\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_moebius","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_moebius","text":"𝐣𝐥.@cextern p4est_connectivity_new_moebius()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for a five-tree moebius band.\n\nReference\n\np4est_connectivity.h:399\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_periodic","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_periodic","text":"𝐣𝐥.@cextern p4est_connectivity_new_periodic()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for an all-periodic unit square.\n\nReference\n\np4est_connectivity.h:372\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_pillow","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_pillow","text":"𝐣𝐥.@cextern p4est_connectivity_new_pillow()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for two trees on top of each other.\n\nReference\n\np4est_connectivity.h:395\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_rotwrap","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_rotwrap","text":"𝐣𝐥.@cextern p4est_connectivity_new_rotwrap()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for a periodic unit square. The left and right faces are identified, and bottom and top opposite.\n\nReference\n\np4est_connectivity.h:377\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_shell2d","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_shell2d","text":"𝐣𝐥.@cextern p4est_connectivity_new_shell2d()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure that builds a 2d spherical shell. p8estconnectivitynew_shell \n\nReference\n\np4est_connectivity.h:480\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_star","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_star","text":"𝐣𝐥.@cextern p4est_connectivity_new_star()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for a six-tree star.\n\nReference\n\np4est_connectivity.h:403\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_twotrees","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_twotrees","text":"𝐣𝐥.@cextern p4est_connectivity_new_twotrees(l_face::𝐣𝐥.Cint, r_face::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for two trees being rotated w.r.t. each other in a user-defined way \n\nParameters\n\nl_face:      index of left face\nr_face:      index of right face\norientation: orientation of trees w.r.t. each other\n\nReference\n\np4est_connectivity.h:385\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_new_unitsquare","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_new_unitsquare","text":"𝐣𝐥.@cextern p4est_connectivity_new_unitsquare()::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a connectivity structure for the unit square.\n\nReference\n\np4est_connectivity.h:368\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_permute","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_permute","text":"𝐣𝐥.@cextern p4est_connectivity_permute(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, perm::𝐣𝐥.Ptr{sc_array_t}, is_current_to_new::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\np4estconnectivitypermute Given a permutation perm of the trees in a connectivity conn, permute the trees of conn in place and update conn to match. \n\nParameters\n\nconn:                The connectivity whose trees are                                     permuted.\nperm:                    A permutation array, whose elements are                                     size_t's.\nis_current_to_new:       if true, the jth entry of perm is the                                     new index for the entry whose current                                     index is j, otherwise the jth entry of                                     perm is the current index of the tree                                     whose index will be j after the                                     permutation.\n\nReference\n\np4est_connectivity.h:606\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_read_inp","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_read_inp","text":"𝐣𝐥.@cextern p4est_connectivity_read_inp(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nCreate a p4est connectivity from an ABAQUS input file.\n\nDetails\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below.  The *Node section gives the vertex number and x, y, and z components for each vertex.  The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4                     3   +–––––––––-+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +–––––––––-+   1                   2\n\nand in 3D they are given as:\n\n8                     7  +––––––––––-+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+––––––––––-+6  |    |                |    |  +––|––––––––+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +––––––––––-+       1                     2\n\n *Heading\n  box.inp\n *Node\n 1,  -5, -5, 0\n 2,   5, -5, 0\n 3,   5,  5, 0\n 4,  -5,  5, 0\n 5,   0, -5, 0\n 6,   5,  0, 0\n 7,   0,  5, 0\n 8,  -5,  0, 0\n 9,   1, -1, 0\n 10,  0,  0, 0\n 11, -2,  1, 0\n *Element, type=CPS4, ELSET=Surface1\n 1,  1, 10, 11, 8\n 2,  3, 10, 9,  6\n 3,  9, 10, 1,  5\n 4,  7,  4, 8, 11\n 5, 11, 10, 3,  7\n 6,  2,  6, 9,  5\n\nThis function reads a mesh from filename and returns an associated p4est connectivity.\n\nParameters\n\nfilename:         file to read the connectivity from\n\nReturns\n\nan allocated connectivity associated with the mesh in filename          or NULL if an error occurred.\n\nReference\n\np4est_connectivity.h:851\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_read_inp_stream","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_read_inp_stream","text":"𝐣𝐥.@cextern p4est_connectivity_read_inp_stream(stream::𝐣𝐥.Ptr{FILE}, num_vertices::𝐣𝐥.Ptr{p4est_topidx_t}, num_trees::𝐣𝐥.Ptr{p4est_topidx_t}, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t})::𝐣𝐥.Cint\n\nRead an ABAQUS input file from a file stream.\n\nDetails\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below.  The *Node section gives the vertex number and x, y, and z components for each vertex.  The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4                     3   +–––––––––-+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +–––––––––-+   1                   2\n\nand in 3D they are given as:\n\n8                     7  +––––––––––-+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+––––––––––-+6  |    |                |    |  +––|––––––––+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +––––––––––-+       1                     2\n\n *Heading\n  box.inp\n *Node\n 1,  -5, -5, 0\n 2,   5, -5, 0\n 3,   5,  5, 0\n 4,  -5,  5, 0\n 5,   0, -5, 0\n 6,   5,  0, 0\n 7,   0,  5, 0\n 8,  -5,  0, 0\n 9,   1, -1, 0\n 10,  0,  0, 0\n 11, -2,  1, 0\n *Element, type=CPS4, ELSET=Surface1\n 1,  1, 10, 11, 8\n 2,  3, 10, 9,  6\n 3,  9, 10, 1,  5\n 4,  7,  4, 8, 11\n 5, 11, 10, 3,  7\n 6,  2,  6, 9,  5\n\nThis code can be called two ways.  The first, when vertex==NULL and tree_to_vertex==NULL, is used to count the number of trees and vertices in the connectivity to be generated by the .inp mesh in the stream.  The second, when vertices!=NULL and tree_to_vertex!=NULL, fill vertices and tree_to_vertex.  In this case num_vertices and num_trees need to be set to the maximum number of entries allocated in vertices and tree_to_vertex.\n\nParameters\n\nstream:         file stream to read the connectivity from\nnum_vertices:   the number of vertices in the connectivity\nnum_trees:      the number of trees in the connectivity\nvertices:       the list of vertices of the connectivity\ntree_to_vertex: the tree_to_vertex map of the connectivity\n\nReturns\n\n0 if successful and nonzero if not\n\nReference\n\np4est_connectivity.h:770\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_reduce","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_reduce","text":"𝐣𝐥.@cextern p4est_connectivity_reduce(conn::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cvoid\n\nRemoves corner information of a connectivity  such that enough information is left to run p4estconnectivitycomplete successfully.  The reduced connectivity still passes p4estconnectivityis_valid. \n\nParameters\n\nconn:     The connectivity to be reduced.\n\nReference\n\np4est_connectivity.h:590\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_refine","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_refine","text":"𝐣𝐥.@cextern p4est_connectivity_refine(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, num_per_edge::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nUniformly refine a connectivity. This is useful if you would like to uniformly refine by something other than a power of 2.\n\nParameters\n\nconn:         A valid connectivity\nnum_per_edge: The number of new trees in each direction.                      Must use no more than P4ESTOLDQMAXLEVEL bits.\n\nReturns\n\na refined connectivity.\n\nReference\n\np4est_connectivity.h:523\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_save","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_save","text":"𝐣𝐥.@cextern p4est_connectivity_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t})::𝐣𝐥.Cint\n\nSave a connectivity structure to disk. \n\nParameters\n\nfilename:         Name of the file to write.\nconnectivity:     Valid connectivity structure.\n\nReturns\n\n                  Returns 0 on success, nonzero on file error.\n\nReference\n\np4est_connectivity.h:342\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_set_attr","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_set_attr","text":"𝐣𝐥.@cextern p4est_connectivity_set_attr(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, bytes_per_tree::size_t)::𝐣𝐥.Cvoid\n\nAllocate or free the attribute fields in a connectivity. \n\nParameters\n\nconn:         The conn->*toattr fields must either be NULL                              or previously be allocated by this function.\nbytes_per_tree:   If 0, treetoattr is freed (being NULL is ok).                              If positive, requested space is allocated.\n\nReference\n\np4est_connectivity.h:304\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_sink","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_sink","text":"𝐣𝐥.@cextern p4est_connectivity_sink(conn::𝐣𝐥.Ptr{p4est_connectivity_t}, sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint\n\nWrite connectivity to a sink object. \n\nParameters\n\nconn:     The connectivity to be written.\nsink: The connectivity is written into this sink.\n\nReturns\n\n          0 on success, nonzero on error.\n\nReference\n\np4est_connectivity.h:325\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_connectivity_source","page":"Reference","title":"P4est.LibP4est.p4est_connectivity_source","text":"𝐣𝐥.@cextern p4est_connectivity_source(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Ptr{p4est_connectivity_t}\n\nRead connectivity from a source object. \n\nParameters\n\nsource:       The connectivity is read from this source.\n\nReturns\n\n          The newly created connectivity, or NULL on error.\n\nReference\n\np4est_connectivity.h:350\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_copy","page":"Reference","title":"P4est.LibP4est.p4est_copy","text":"𝐣𝐥.@cextern p4est_copy(input::𝐣𝐥.Ptr{p4est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_t}\n\nMake a deep copy of a p4est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:  If true, data are copied.                         If false, data_size is set to 0.\n\nReturns\n\nReturns a valid p4est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.\n\nReference\n\np4est.h:299\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_copy_ext","page":"Reference","title":"P4est.LibP4est.p4est_copy_ext","text":"𝐣𝐥.@cextern p4est_copy_ext(input::𝐣𝐥.Ptr{p4est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_t}\n\nMake a deep copy of a p4est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:  If true, data are copied.                         If false, data_size is set to 0.\nduplicate_mpicomm:  If true, MPI communicator is copied.\n\nReturns\n\nReturns a valid p4est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.\n\nReference\n\np4est_extended.h:416\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_corner_face_corners","page":"Reference","title":"P4est.LibP4est.p4est_corner_face_corners","text":"𝐣𝐥.@cextern p4est_corner_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[4]\n\nStore the face corner numbers for the faces touching a tree corner. \n\nReference\n\np4est_connectivity.h:214\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_corner_faces","page":"Reference","title":"P4est.LibP4est.p4est_corner_faces","text":"𝐣𝐥.@cextern p4est_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[4]\n\nStore the face numbers 0..3 for each tree corner. \n\nReference\n\np4est_connectivity.h:211\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_destroy","page":"Reference","title":"P4est.LibP4est.p4est_destroy","text":"𝐣𝐥.@cextern p4est_destroy(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Cvoid\n\nDestroy a p4est.\n\nDetails\n\nNOTE: The connectivity structure is not destroyed with the p4est.\n\nReference\n\np4est.h:284\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_expand_face_transform","page":"Reference","title":"P4est.LibP4est.p4est_expand_face_transform","text":"𝐣𝐥.@cextern p4est_expand_face_transform(iface::𝐣𝐥.Cint, nface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::𝐣𝐥.Cvoid\n\nFill an array with the axis combination of a face neighbor transform. \n\nParameters\n\niface:       The number of the originating face.\nnface:       Encoded as nface = r * 4 + nf, where nf = 0..3 is                          the neigbbor's connecting face number and r = 0..1                          is the relative orientation to the neighbor's face.                          This encoding matches p4estconnectivityt.\nftransform:  This array holds 9 integers.              [0,2]       The coordinate axis sequence of the origin face,                          the first referring to the tangential and the second                          to the normal.  A permutation of (0, 1).              [3,5]       The coordinate axis sequence of the target face.              [6,8]       Edge reversal flag for tangential axis (boolean);                          face code in [0, 3] for the normal coordinate q:                          0: q' = -q                          1: q' = q + 1                          2: q' = q - 1                          3: q' = 2 - q              [1,4,7]     0 (unused for compatibility with 3D).\n\nReference\n\np4est_connectivity.h:545\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_face_corners","page":"Reference","title":"P4est.LibP4est.p4est_face_corners","text":"𝐣𝐥.@cextern p4est_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[4]\n\nStore the corner numbers 0..4 for each tree face. \n\nReference\n\np4est_connectivity.h:205\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_face_dual","page":"Reference","title":"P4est.LibP4est.p4est_face_dual","text":"𝐣𝐥.@cextern p4est_face_dual::𝐣𝐥.Cconst(𝐣𝐥.Cint)[4]\n\nStore the face numbers in the face neighbor's system. \n\nReference\n\np4est_connectivity.h:208\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_face_quadrant_exists","page":"Reference","title":"P4est.LibP4est.p4est_face_quadrant_exists","text":"𝐣𝐥.@cextern p4est_face_quadrant_exists(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, face::𝐣𝐥.Ptr{𝐣𝐥.Cint}, hang::𝐣𝐥.Ptr{𝐣𝐥.Cint}, owner_rank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::p4est_locidx_t\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nDetails\n\nFor quadrants across tree boundaries it checks if the quadrant exists across any face, but not across corners.\n\nParameters\n\np4est:        The forest in which to search for q.\nghost:        The ghost layer in which to search for q.\ntreeid:       The tree to which q belongs.\nq:            The quadrant that is being searched for.\nface:      On input, face id across which q was created.                           On output, the neighbor's face number augmented                           by orientation, so face is in 0..7.\nhang:      If not NULL, signals that q is bigger than                           the quadrant it came from.  The child id                           of that originating quadrant is passed into hang.                           On output, hang holds the hanging face number                           of q that is in contact with its originator.\nowner_rank:   Filled with the rank of the owner if it is found                           and undefined otherwise.\n\nReturns\n\n  Returns the local number of *q* if the quadrant exists              in the local forest or in the ghost_layer.  Otherwise,              returns -2 for a domain boundary and -1 if not found.\n\nReference\n\np4est_ghost.h:185\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_find_corner_transform","page":"Reference","title":"P4est.LibP4est.p4est_find_corner_transform","text":"𝐣𝐥.@cextern p4est_find_corner_transform(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, itree::p4est_topidx_t, icorner::𝐣𝐥.Cint, ci::𝐣𝐥.Ptr{p4est_corner_info_t})::𝐣𝐥.Cvoid\n\nFills an array with information about corner neighbors. \n\nParameters\n\nitree:    The number of the originating tree.\nicorner:  The number of the originating corner.\nci:   A p4estcornerinfo_t structure with initialized array.\n\nReference\n\np4est_connectivity.h:568\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_find_face_transform","page":"Reference","title":"P4est.LibP4est.p4est_find_face_transform","text":"𝐣𝐥.@cextern p4est_find_face_transform(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, itree::p4est_topidx_t, iface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::p4est_topidx_t\n\nFill an array with the axis combinations of a tree neighbor transform. \n\nParameters\n\nitree:       The number of the originating tree.\niface:       The number of the originating tree's face.\nftransform:  This array holds 9 integers.              [0,2]       The coordinate axis sequence of the origin face.              [3,5]       The coordinate axis sequence of the target face.              [6,8]       Edge reverse flag for axis t; face code for axis n.              [1,4,7]     0 (unused for compatibility with 3D).\n\nReturns\n\n              The face neighbor tree if it exists, -1 otherwise.\n\nReference\n\np4est_connectivity.h:558\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_get_plex_data_ext","page":"Reference","title":"P4est.LibP4est.p4est_get_plex_data_ext","text":"𝐣𝐥.@cextern p4est_get_plex_data_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_ghost_t}}, lnodes::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_lnodes_t}}, ctype::p4est_connect_type_t, overlap::𝐣𝐥.Cint, first_local_quad::𝐣𝐥.Ptr{p4est_locidx_t}, out_points_per_dim::𝐣𝐥.Ptr{sc_array_t}, out_cone_sizes::𝐣𝐥.Ptr{sc_array_t}, out_cones::𝐣𝐥.Ptr{sc_array_t}, out_cone_orientations::𝐣𝐥.Ptr{sc_array_t}, out_vertex_coords::𝐣𝐥.Ptr{sc_array_t}, out_children::𝐣𝐥.Ptr{sc_array_t}, out_parents::𝐣𝐥.Ptr{sc_array_t}, out_childids::𝐣𝐥.Ptr{sc_array_t}, out_leaves::𝐣𝐥.Ptr{sc_array_t}, out_remotes::𝐣𝐥.Ptr{sc_array_t}, custom_numbering::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nCreate the data necessary to create a PETsc DMPLEX representation of a forest, as well as the accompanying lnodes and ghost layer.  The forest must be at least face balanced (see p4estbalance()).  See test/testplex2.c for example usage.\n\nDetails\n\nAll arrays should be initialized to hold sizeof (p4estlocidxt), except for out_remotes, which should be initialized to hold (2 * sizeof (p4estlocidxt)).\n\nParameters\n\np4est:                 the forest\nghost:                 the ghost layer\nlnodes:                the lnodes\nctype:                 the type of adjacency for the overlap\noverlap:               the number of layers of overlap (zero                                      is acceptable)\nfirst_local_quad:      the local quadrants are assigned                                      contiguous plex indices, starting with                                      this index\nout_points_per_dim:    filled with argument for                                      DMPlexCreateFromDAG()\nout_cone_sizes:        filled with argument for                                      DMPlexCreateFromDAG()\nout_cones:             filled with argument for                                      DMPlexCreateFromDAG()\nout_cone_orientations: filled with argument for                                      DMPlexCreateFromDAG()\nout_vertex_coords:     filled with argument for                                      DMPlexCreateFromDAG()\nout_children:          filled with argument for                                      DMPlexSetTree()\nout_parents:           filled with argument for                                      DMPlexSetTree()\nout_childids:          filled with argument for                                      DMPlexSetTree()\nout_leaves:            filled with argument for                                      PetscSFSetGraph()\nout_remotes:           filled with argument for                                      PetscSFSetGraph()\ncustom_numbering:      Whether or use the default numbering                                      (0) of DMPlex child ids or the custom                                      (1).\n\nReference\n\np4est_extended.h:635\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_bsearch","page":"Reference","title":"P4est.LibP4est.p4est_ghost_bsearch","text":"𝐣𝐥.@cextern p4est_ghost_bsearch(ghost::𝐣𝐥.Ptr{p4est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::ssize_t\n\nConduct binary search for exact match on a range of the ghost layer. \n\nParameters\n\nghost:            The ghost layer.\nwhich_proc:       The owner of the searched quadrant.  Can be -1.\nwhich_tree:       The tree of the searched quadrant.  Can be -1.\nq:                Valid quadrant is searched in the ghost layer.\n\nReturns\n\n                  Offset in the ghost layer, or -1 if not found.\n\nReference\n\np4est_ghost.h:144\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_checksum","page":"Reference","title":"P4est.LibP4est.p4est_ghost_checksum","text":"𝐣𝐥.@cextern p4est_ghost_checksum(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cuint\n\nCompute the parallel checksum of a ghost layer. \n\nParameters\n\np4est:   The MPI information of this p4est will be used.\nghost:   A ghost layer obtained from the p4est.\n\nReturns\n\n         Parallel checksum on rank 0, 0 otherwise.\n\nReference\n\np4est_ghost.h:237\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_contains","page":"Reference","title":"P4est.LibP4est.p4est_ghost_contains","text":"𝐣𝐥.@cextern p4est_ghost_contains(ghost::𝐣𝐥.Ptr{p4est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::ssize_t\n\nConduct binary search for ancestor on range of the ghost layer. \n\nParameters\n\nghost:            The ghost layer.\nwhich_proc:       The owner of the searched quadrant.  Can be -1.\nwhich_tree:       The tree of the searched quadrant.  Can be -1.\nq:                Valid quadrant's ancestor is searched.\n\nReturns\n\n                  Offset in the ghost layer, or -1 if not found.\n\nReference\n\np4est_ghost.h:156\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_destroy","page":"Reference","title":"P4est.LibP4est.p4est_ghost_destroy","text":"𝐣𝐥.@cextern p4est_ghost_destroy(ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid\n\nFrees all memory used for the ghost layer. \n\nReference\n\np4est_ghost.h:135\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom","text":"𝐣𝐥.@cextern p4est_ghost_exchange_custom(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. \n\nParameters\n\np4est:            The forest used for reference.\nghost:            The ghost layer used for reference.\ndata_size:        The data size to transfer per quadrant.\nmirror_data:      One data pointer per mirror quadrant as input.\nghost_data:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least data_size for each ghost.\n\nReference\n\np4est_ghost.h:300\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_begin","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_begin","text":"𝐣𝐥.@cextern p4est_ghost_exchange_custom_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4estghostexchangecustom. The return type is always non-NULL and must be passed to p4estghostexchangecustom_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. \n\nParameters\n\nmirror_data: Not required to stay alive any longer.\nghost_data:  Must stay alive into the completion call.\n\nReturns\n\n      Transient storage for messages in progress.\n\nReference\n\np4est_ghost.h:317\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_end","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_end","text":"𝐣𝐥.@cextern p4est_ghost_exchange_custom_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications. \n\nParameters\n\nData: created ONLY by p4estghostexchangecustombegin.                  It is deallocated before this function returns.\n\nReference\n\np4est_ghost.h:326\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_levels","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_levels","text":"𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. This function restricts the transfer to a range of refinement levels. The memory for quadrants outside the level range is not dereferenced. \n\nParameters\n\np4est:            The forest used for reference.\nghost:            The ghost layer used for reference.\nminlevel:         Level of the largest quads to be exchanged.                              Use <= 0 for no restriction.\nmaxlevel:         Level of the smallest quads to be exchanged.                              Use >= P4EST_QMAXLEVEL for no restriction.\ndata_size:        The data size to transfer per quadrant.\nmirror_data:      One data pointer per mirror quadrant as input.\nghost_data:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least data_size for each ghost.\n\nReference\n\np4est_ghost.h:345\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_levels_begin","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_levels_begin","text":"𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4estghostexchangecustomlevels. The return type is always non-NULL and must be passed to p4estghostexchangecustomlevels_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. \n\nParameters\n\nmirror_data: Not required to stay alive any longer.\nghost_data:  Must stay alive into the completion call.\n\nReturns\n\n      Transient storage for messages in progress.\n\nReference\n\np4est_ghost.h:364\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_custom_levels_end","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_custom_levels_end","text":"𝐣𝐥.@cextern p4est_ghost_exchange_custom_levels_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications. \n\nParameters\n\nData: created ONLY by p4estghostexchangecustomlevels_begin.                  It is deallocated before this function returns.\n\nReference\n\np4est_ghost.h:373\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_data","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_data","text":"𝐣𝐥.@cextern p4est_ghost_exchange_data(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nTransfer data for local quadrants that are ghosts to other processors. Send the data stored in the quadrant's userdata.  This is either the pointer variable itself if `p4est->datasize` is 0, or the content of the referenced memory field if p4est->data_size is positive. \n\nParameters\n\np4est:            The forest used for reference.\nghost:            The ghost layer used for reference.\nghost_data:   Pre-allocated contiguous data for all ghost                              quadrants in sequence.  If p4est->datasize is                              0, must at least hold sizeof (void *) bytes for                              each, otherwise p4est->datasize each.\n\nReference\n\np4est_ghost.h:251\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_data_begin","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_data_begin","text":"𝐣𝐥.@cextern p4est_ghost_exchange_data_begin(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_ghost_exchange_t}\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p4estghostexchangedata. The return type is always non-NULL and must be passed to p4estghostexchangedata_end to complete the exchange. The ghost data must not be accessed before completion. \n\nParameters\n\nghost_data:  Must stay alive into the completion call.\n\nReturns\n\n      Transient storage for messages in progress.\n\nReference\n\np4est_ghost.h:279\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_exchange_data_end","page":"Reference","title":"P4est.LibP4est.p4est_ghost_exchange_data_end","text":"𝐣𝐥.@cextern p4est_ghost_exchange_data_end(exc::𝐣𝐥.Ptr{p4est_ghost_exchange_t})::𝐣𝐥.Cvoid\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications. \n\nParameters\n\nData: created ONLY by p4estghostexchangedatabegin.                  It is deallocated before this function returns.\n\nReference\n\np4est_ghost.h:287\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_expand","page":"Reference","title":"P4est.LibP4est.p4est_ghost_expand","text":"𝐣𝐥.@cextern p4est_ghost_expand(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid\n\nExpand the size of the ghost layer and mirrors by one additional layer of adjacency. \n\nParameters\n\np4est:            The forest from which the ghost layer was                              generated.\nghost:        The ghost layer to be expanded.\n\nReference\n\np4est_ghost.h:382\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_expand_by_lnodes","page":"Reference","title":"P4est.LibP4est.p4est_ghost_expand_by_lnodes","text":"𝐣𝐥.@cextern p4est_ghost_expand_by_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid\n\nExpand the ghost layer as in p4estghostexpand(), but use node support to define adjacency instead of geometric adjacency.\n\nParameters\n\np4est:        The forest from which the ghost layer was                              generated.\nlnodes:       The nodes to support.\nghost:        The ghost layer to be expanded.\n\nReference\n\np4est_lnodes.h:235\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_is_valid","page":"Reference","title":"P4est.LibP4est.p4est_ghost_is_valid","text":"𝐣𝐥.@cextern p4est_ghost_is_valid(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cint\n\nExamine if a ghost structure is valid. Test if within a ghost-structure the array ghosts is in p4estquadrantcomparepiggy order. Test if localnum in piggy3 data member of the quadrants in ghosts and mirrors are in ascending order (ascending within each rank for ghost).\n\nDetails\n\nTest if the p4estlocidxt arrays are in ascending order (for mirrorprocmirrors ascending within each rank) \n\nParameters\n\np4est:    the forest.\nghost:    Ghost layer structure.\n\nReturns\n\ntrue if ghost is valid\n\nReference\n\np4est_ghost.h:93\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_memory_used","page":"Reference","title":"P4est.LibP4est.p4est_ghost_memory_used","text":"𝐣𝐥.@cextern p4est_ghost_memory_used(ghost::𝐣𝐥.Ptr{p4est_ghost_t})::size_t\n\nCalculate the memory usage of the ghost layer. \n\nParameters\n\nghost:    Ghost layer structure.\n\nReturns\n\n          Memory used in bytes.\n\nReference\n\np4est_ghost.h:100\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_new","page":"Reference","title":"P4est.LibP4est.p4est_ghost_new","text":"𝐣𝐥.@cextern p4est_ghost_new(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_ghost_t}\n\nBuilds the ghost layer.\n\nDetails\n\nThis will gather the quadrants from each neighboring proc to build one layer of face and corner based ghost elements around the ones they own.\n\nParameters\n\np4est:            The forest for which the ghost layer will be                              generated.\nbtype:            Which ghosts to include (across face, corner                              or full).\n\nReturns\n\n                  A fully initialized ghost layer.\n\nReference\n\np4est_ghost.h:131\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_ghost_support_lnodes","page":"Reference","title":"P4est.LibP4est.p4est_ghost_support_lnodes","text":"𝐣𝐥.@cextern p4est_ghost_support_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t})::𝐣𝐥.Cvoid\n\nExpand the ghost layer to include the support of all nodes supported on the local partition.\n\nParameters\n\np4est:        The forest from which the ghost layer was                              generated.\nlnodes:       The nodes to support.\nghost:        The ghost layer to be expanded.\n\nReference\n\np4est_lnodes.h:223\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_init","page":"Reference","title":"P4est.LibP4est.p4est_init","text":"𝐣𝐥.@cextern p4est_init(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nRegisters p4est with the SC Library and sets the logging behavior. This function is optional. This function must only be called before additional threads are created. If this function is not called or called with loghandler == NULL, the default SC log handler will be used. If this function is not called or called with logthreshold == SCLPDEFAULT, the default SC log threshold will be used. The default SC log settings can be changed with scsetlog_defaults ().\n\nReference\n\np4est_base.h:342\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_is_balanced","page":"Reference","title":"P4est.LibP4est.p4est_is_balanced","text":"𝐣𝐥.@cextern p4est_is_balanced(p4est::𝐣𝐥.Ptr{p4est_t}, btype::p4est_connect_type_t)::𝐣𝐥.Cint\n\nCheck a forest to see if it is balanced.\n\nDetails\n\nThis function builds the ghost layer and discards it when done.\n\nParameters\n\np4est:    The p4est to be tested.\nbtype:    Balance type (face, corner or default, full).\n\nReturns\n\nReturns true if balanced, false otherwise.\n\nReference\n\np4est_ghost.h:229\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_iterate","page":"Reference","title":"P4est.LibP4est.p4est_iterate","text":"𝐣𝐥.@cextern p4est_iterate(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p4est_iter_volume_t, iter_face::p4est_iter_face_t, iter_corner::p4est_iter_corner_t)::𝐣𝐥.Cvoid\n\nExecute user supplied callbacks at every volume, face, and corner in the local forest.\n\nDetails\n\np4estiterate executes the user-supplied callback functions at every volume, face, and corner in the local forest. The ghostlayer may be NULL. The user_data pointer is not touched by p4est_iterate, but is passed to each of the callbacks.  Any of the callbacks may be NULL. The callback functions are interspersed with each other, i.e. some face callbacks will occur between volume callbacks, and some corner callbacks will occur between face callbacks:\n\nvolume callbacks occur in the sorted Morton-index order. 2) a face callback is not executed until after the volume callbacks have    been executed for the quadrants that share it. 3) a corner callback is not executed until the face callbacks have been    executed for all faces that touch the corner. 4) it is not always the case that every face callback for a given quadrant    is executed before any of the corner callbacks. 5) callbacks are not executed at faces or corners that only involve ghost    quadrants, i.e. that are not adjacent in the local section of the    forest.\n\nParameters\n\np4est:          the forest\nghost_layer:    optional: when not given, callbacks at the                           boundaries of the local partition cannot provide                           quadrant data about ghost quadrants: missing                           (p4estquadrantt *) pointers are set to NULL,                           missing indices are set to -1.\nuser_data:  optional context to supply to each callback\niter_volume:    callback function for every quadrant's interior\niter_face:      callback function for every face between                           quadrants\niter_corner:    callback function for every corner between                           quadrants\n\nReference\n\np4est_iterate.h:233\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_iterate_ext","page":"Reference","title":"P4est.LibP4est.p4est_iterate_ext","text":"𝐣𝐥.@cextern p4est_iterate_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p4est_iter_volume_t, iter_face::p4est_iter_face_t, iter_corner::p4est_iter_corner_t, remote::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\np4estiterateext adds the option remote: if this is false, then it is the same as p4est_iterate; if this is true, then corner callbacks are also called on corners for hanging faces touched by local quadrants.\n\nReference\n\np4est_extended.h:529\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_add","page":"Reference","title":"P4est.LibP4est.p4est_lid_add","text":"𝐣𝐥.@cextern p4est_lid_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nAdds the uint128t b to the uint128t a. result == a or result == b is not allowed. a == b is allowed. \n\nParameters\n\na:       A pointer to a p4estlidt.\nb:       A pointer to a p4estlidt.\nresult:  A pointer to a p4estlidt.                      The sum a + b will be saved in result.\n\nReference\n\np4est_extended.h:197\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_add_inplace","page":"Reference","title":"P4est.LibP4est.p4est_lid_add_inplace","text":"𝐣𝐥.@cextern p4est_lid_add_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid\n\nAdds the p4estlidt b to the p4estlidt a. The result is saved in a. a == b is allowed. \n\nParameters\n\na:   A pointer to a p4estlidt. a                      will be overwritten by a + b.\nb:       A pointer to a p4estlidt.\n\nReference\n\np4est_extended.h:284\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_and","page":"Reference","title":"P4est.LibP4est.p4est_lid_bitwise_and","text":"𝐣𝐥.@cextern p4est_lid_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise and of the uint128t a and the uint128t b. a == result is allowed. Furthermore, a == result and/or b == result is allowed. \n\nParameters\n\na:       A pointer to a p4estlidt.\nb:       A pointer to a p4estlidt.\nresult:  A pointer to a p4estlidt.                      The bitwise and of a and b will be saved.                      in result.\n\nReference\n\np4est_extended.h:246\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_and_inplace","page":"Reference","title":"P4est.LibP4est.p4est_lid_bitwise_and_inplace","text":"𝐣𝐥.@cextern p4est_lid_bitwise_and_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid\n\nCalculates the bitwise and of the uint128t a and the uint128t b. a == b is allowed. \n\nParameters\n\na:   A pointer to a p4estlidt.                      The bitwise and will be saved in a.\nb:   A pointer to a p4estlidt.\n\nReference\n\np4est_extended.h:312\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_neg","page":"Reference","title":"P4est.LibP4est.p4est_lid_bitwise_neg","text":"𝐣𝐥.@cextern p4est_lid_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise negation of the uint128_t a. a == result is allowed. \n\nParameters\n\na:        A pointer to a p4estlidt.\nresult:   A pointer to a p4estlidt.                      The bitwise negation of a will be saved in                      result.\n\nReference\n\np4est_extended.h:221\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_or","page":"Reference","title":"P4est.LibP4est.p4est_lid_bitwise_or","text":"𝐣𝐥.@cextern p4est_lid_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise or of the uint128_t a and b. a == result is allowed. Furthermore, a == result and/or b == result is allowed. \n\nParameters\n\na:        A pointer to a p4estlidt.\nb:        A pointer to a p4estlidt.\nresult:   A pointer to a p4estlidt.                      The bitwise or of a and b will be                      saved in result.\n\nReference\n\np4est_extended.h:233\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_bitwise_or_inplace","page":"Reference","title":"P4est.LibP4est.p4est_lid_bitwise_or_inplace","text":"𝐣𝐥.@cextern p4est_lid_bitwise_or_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid\n\nCalculates the bitwise or of the uint128t a and the uint128t b. a == b is allowed. \n\nParameters\n\na:   A pointer to a p4estlidt.                      The bitwise or will be saved in a.\nb:   A pointer to a p4estlidt.\n\nReference\n\np4est_extended.h:303\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_chk_bit","page":"Reference","title":"P4est.LibP4est.p4est_lid_chk_bit","text":"𝐣𝐥.@cextern p4est_lid_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nReturns the bit_number-th bit of input. This function checks a bit of an existing, initialized value. \n\nParameters\n\ninput:      A pointer to a p4estlidt.\nbit_number: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= bit_number < 64.\n\nReturns\n\n                True if bit is set, false if not.\n\nReference\n\np4est_extended.h:167\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_compare","page":"Reference","title":"P4est.LibP4est.p4est_lid_compare","text":"𝐣𝐥.@cextern p4est_lid_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cint\n\nCompare the p4estlidt a and the p4estlidt b. \n\nParameters\n\na: A pointer to a p4estlidt.\nb: A pointer to a p4estlidt.\n\nReturns\n\n    Returns -1 if a < b,                         1 if a > b and                         0 if a == b.\n\nReference\n\np4est_extended.h:123\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_copy","page":"Reference","title":"P4est.LibP4est.p4est_lid_copy","text":"𝐣𝐥.@cextern p4est_lid_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, output::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nCopies an initialized p4estlidt to a p4estlidt. \n\nParameters\n\ninput:    A pointer to the p4estlidt that is copied.\noutput:   A pointer to a p4estlidt.                          The low bits of output will                          be set to the low bits of                          input and high bits are ignored.\n\nReference\n\np4est_extended.h:186\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_init","page":"Reference","title":"P4est.LibP4est.p4est_lid_init","text":"𝐣𝐥.@cextern p4est_lid_init(input::𝐣𝐥.Ptr{p4est_lid_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid\n\nInitializes an unsigned 64 bit integer. high is just a  a placeholder to use the same interface in 3D. \n\nParameters\n\ninput:  A pointer to a p4estlidt that will be intialized.\nhigh:       The given high bits must be zero.\nlow:        The given low bits to initialize input.\n\nReference\n\np4est_extended.h:141\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_is_equal","page":"Reference","title":"P4est.LibP4est.p4est_lid_is_equal","text":"𝐣𝐥.@cextern p4est_lid_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cint\n\nChecks if the p4estlidt a and the p4estlidt b are equal. \n\nParameters\n\na: A pointer to a p4estlidt.\nb: A pointer to a p4estlidt.\n\nReturns\n\n    Returns a true value if *a* and *b* are equal,                false otherwise\n\nReference\n\np4est_extended.h:132\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_bit","page":"Reference","title":"P4est.LibP4est.p4est_lid_set_bit","text":"𝐣𝐥.@cextern p4est_lid_set_bit(input::𝐣𝐥.Ptr{p4est_lid_t}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSets the exponent-th bit of a to one. This function modifies an existing, initialized value. \n\nParameters\n\ninput:      A pointer to a p4estlidt.\nbit_number: The bit (counted from the right hand side)                            that is set to one by logical or.                            Require 0 <= bit_number < 64.\n\nReference\n\np4est_extended.h:177\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_one","page":"Reference","title":"P4est.LibP4est.p4est_lid_set_one","text":"𝐣𝐥.@cextern p4est_lid_set_one(input::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nInitializes a linear index to one. \n\nParameters\n\ninput:     A pointer to a p4estlidt that will be intialized.\n\nReference\n\np4est_extended.h:152\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_uint64","page":"Reference","title":"P4est.LibP4est.p4est_lid_set_uint64","text":"𝐣𝐥.@cextern p4est_lid_set_uint64(input::𝐣𝐥.Ptr{p4est_lid_t}, u::uint64_t)::𝐣𝐥.Cvoid\n\nInitializes a linear index to an unsigned 64 bit integer. \n\nParameters\n\ninput:     A pointer to a p4estlidt that will be intialized.\n\nReference\n\np4est_extended.h:157\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_set_zero","page":"Reference","title":"P4est.LibP4est.p4est_lid_set_zero","text":"𝐣𝐥.@cextern p4est_lid_set_zero(input::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nInitializes a linear index to zero. \n\nParameters\n\ninput:     A pointer to a p4estlidt that will be intialized.\n\nReference\n\np4est_extended.h:147\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_shift_left","page":"Reference","title":"P4est.LibP4est.p4est_lid_shift_left","text":"𝐣𝐥.@cextern p4est_lid_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bit left shift of uint128t input by shiftcount bits. We shift in zeros from the right. If shift_count >= 64, result is 0. All bits left from the 63th bit (counted zero based from the right hand side) drop out. input == result is allowed. \n\nParameters\n\ninput:       A pointer to a p4estlidt.\nshift_count: Bits to shift. shift_count >= 0.\nresult:      A pointer to a p4estlidt.                              The left shifted number will be saved                              in result.\n\nReference\n\np4est_extended.h:274\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_shift_right","page":"Reference","title":"P4est.LibP4est.p4est_lid_shift_right","text":"𝐣𝐥.@cextern p4est_lid_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bit right shift of uint128t input by shiftcount bits. We shift in zeros from the left. If shift_count >= 64, result is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. input == result is allowed. \n\nParameters\n\ninput:       A pointer to a p4estlidt.\nshift_count: Bits to shift. shift_count >= 0.\nresult:      A pointer to a p4estlidt.                              The right shifted number will be saved                              in result.\n\nReference\n\np4est_extended.h:260\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_sub","page":"Reference","title":"P4est.LibP4est.p4est_lid_sub","text":"𝐣𝐥.@cextern p4est_lid_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)}, result::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nSubstracts the p4estlidt b from the p4estlidt a. This function assumes that the result is >= 0. result == a or result == b is not allowed. a == b is allowed. \n\nParameters\n\na:       A pointer to a p4estlidt.\nb:       A pointer to a p4estlidt.\nresult:  A pointer to a p4estlidt.                      The difference a - b will be saved in result.\n\nReference\n\np4est_extended.h:210\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lid_sub_inplace","page":"Reference","title":"P4est.LibP4est.p4est_lid_sub_inplace","text":"𝐣𝐥.@cextern p4est_lid_sub_inplace(a::𝐣𝐥.Ptr{p4est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid\n\nSubstracts the uint128t b from the uint128t a. The result is saved in a. a == b is allowed. This function assumes that the result is >= 0. \n\nParameters\n\na:   A pointer to a p4estlidt.                      a will be overwritten by a - b.\nb:   A pointer to a p4estlidt.\n\nReference\n\np4est_extended.h:294\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_buffer_destroy","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_buffer_destroy","text":"𝐣𝐥.@cextern p4est_lnodes_buffer_destroy(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid\n\nReference\n\np4est_lnodes.h:348\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_destroy","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_destroy","text":"𝐣𝐥.@cextern p4est_lnodes_destroy(lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Cvoid\n\nReference\n\np4est_lnodes.h:213\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_new","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_new","text":"𝐣𝐥.@cextern p4est_lnodes_new(p4est::𝐣𝐥.Ptr{p4est_t}, ghost_layer::𝐣𝐥.Ptr{p4est_ghost_t}, degree::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p4est_lnodes_t}\n\nReference\n\np4est_lnodes.h:209\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_all","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_share_all","text":"𝐣𝐥.@cextern p4est_lnodes_share_all(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}\n\nEquivalent to calling p4estlnodesshareallend directly after p4estlnodesshareallbegin.  Use if there is no local work that can be done to mask the communication cost. \n\nReturns\n\n      A fully initialized buffer that contains the received data.                  After processing this data, the buffer must be freed with                  p4est_lnodes_buffer_destroy.\n\nReference\n\np4est_lnodes.h:345\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_all_begin","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_share_all_begin","text":"𝐣𝐥.@cextern p4est_lnodes_share_all_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}\n\np4estlnodesshareallbegin\n\nDetails\n\nnode_data is a userdefined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every process that shares an entry with the current one, the value in the *nodedata* array of that process is written into a buffer->recv_buffers entry as described above.  The user can then perform some arbitrary work that requires the data from all processes that share a node (such as reduce, max, min, etc.).  When the work concludes, the buffer should be destroyed with p4estlnodesbuffer_destroy.\n\nValues of node_data are not guaranteed to be sent, and buffer->recv_buffer entries are not guaranteed to be received until the buffer created by p4estlnodesshareallbegin is passed to p4estlnodesshareallend.\n\nReference\n\np4est_lnodes.h:332\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_all_end","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_share_all_end","text":"𝐣𝐥.@cextern p4est_lnodes_share_all_end(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid\n\nReference\n\np4est_lnodes.h:335\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_owned","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_share_owned","text":"𝐣𝐥.@cextern p4est_lnodes_share_owned(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Cvoid\n\nEquivalent to calling p4estlnodesshareownedend directly after p4estlnodesshareownedbegin.  Use if there is no local work that can be done to mask the communication cost.\n\nReference\n\np4est_lnodes.h:313\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_owned_begin","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_share_owned_begin","text":"𝐣𝐥.@cextern p4est_lnodes_share_owned_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p4est_lnodes_t})::𝐣𝐥.Ptr{p4est_lnodes_buffer_t}\n\np4estlnodesshareownedbegin\n\nDetails\n\nnode_data is a user-defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every local nodes entry that is owned by a process other than the current one, the value in the node_data array of the owning process is written directly into the node_data array of the current process.  Values of node_data are not guaranteed to be sent or received until the buffer created by p4estlnodesshareownedbegin is passed to p4estlnodesshareownedend.\n\nTo be memory neutral, the buffer created by p4estlnodesshareownedbegin must be destroying with p4estlnodesbufferdestroy (it is not destroyed by p4estlnodesshareowned_end).\n\nReference\n\np4est_lnodes.h:302\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_lnodes_share_owned_end","page":"Reference","title":"P4est.LibP4est.p4est_lnodes_share_owned_end","text":"𝐣𝐥.@cextern p4est_lnodes_share_owned_end(buffer::𝐣𝐥.Ptr{p4est_lnodes_buffer_t})::𝐣𝐥.Cvoid\n\nReference\n\np4est_lnodes.h:306\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_load","page":"Reference","title":"P4est.LibP4est.p4est_load","text":"𝐣𝐥.@cextern p4est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}\n\nLoad the complete connectivity/p4est structure from disk.\n\nDetails\n\nThis is a collective operation that all MPI processes need to call.  All processes read from the same file, so the filename given needs to be identical over all parallel invocations.\n\nBy default, a file can only be loaded with the same number of processors that it was stored with.  The defaults can be changed with p4estloadext() in p4est_extended.h.\n\nThe revision counter of the loaded p4est is set to zero.\n\nParameters\n\nfilename:         Name of the file to read.\nmpicomm:          A valid MPI communicator.\ndata_size:        Size of data for each quadrant which can be                              zero.  Then userdatapool is set to NULL.                              If datasize is zero, loaddata is ignored.\nload_data:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.\nuser_pointer:     Assign to the userpointer member of the p4est                              before initfn is called the first time.\nconnectivity:    Connectivity must be destroyed separately.\n\nReturns\n\n      Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument.\n\nNOTE:            Aborts on file errors or invalid file contents.\n\nReference\n\np4est.h:454\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_load_ext","page":"Reference","title":"P4est.LibP4est.p4est_load_ext","text":"𝐣𝐥.@cextern p4est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}\n\nLoad the complete connectivity/p4est structure from disk. It is possible to load the file with a different number of processors than has been used to write it.  The partition will then be uniform. \n\nParameters\n\nfilename:         Name of the file to read.\nmpicomm:          A valid MPI communicator.\ndata_size:        Size of data for each quadrant which can be                              zero.  Then userdatapool is set to NULL.                              If datasize is zero, loaddata is ignored.\nload_data:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.\nautopartition:    Ignore saved partition and make it uniform.\nbroadcasthead:    Have only rank 0 read headers and bcast them.\nuser_pointer:     Assign to the userpointer member of the p4est                              before initfn is called the first time.\nconnectivity:    Connectivity must be destroyed separately.\n\nReturns\n\n      Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument.\n\nNOTE:            Aborts on file errors or invalid file contents.\n\nReference\n\np4est_extended.h:578\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_memory_used","page":"Reference","title":"P4est.LibP4est.p4est_memory_used","text":"𝐣𝐥.@cextern p4est_memory_used(p4est::𝐣𝐥.Ptr{p4est_t})::size_t\n\nCalculate local memory usage of a forest structure. Not collective.  The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use p4estconnectivitymemory_usage (p4est->connectivity). \n\nParameters\n\np4est:    Valid forest structure.\n\nReturns\n\n          Memory used in bytes.\n\nReference\n\np4est.h:182\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_destroy","page":"Reference","title":"P4est.LibP4est.p4est_mesh_destroy","text":"𝐣𝐥.@cextern p4est_mesh_destroy(mesh::𝐣𝐥.Ptr{p4est_mesh_t})::𝐣𝐥.Cvoid\n\nDestroy a p4est_mesh structure. \n\nParameters\n\nmesh:     Mesh structure previously created by p4estmeshnew.\n\nReference\n\np4est_mesh.h:175\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_data","page":"Reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_data","text":"𝐣𝐥.@cextern p4est_mesh_face_neighbor_data(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nGet the user data for the current face neighbor. \n\nParameters\n\nmfn:           Internal status of the iterator.\nghost_data:    Data for the ghost quadrants that has been                               synchronized with p4estghostexchange_data.\n\nReturns\n\n                   A pointer to the user data for the current                               neighbor.\n\nReference\n\np4est_mesh.h:313\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_init","page":"Reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_init","text":"𝐣𝐥.@cextern p4est_mesh_face_neighbor_init(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, which_tree::p4est_topidx_t, quadrant::𝐣𝐥.Ptr{p4est_quadrant_t})::𝐣𝐥.Cvoid\n\nInitialize a mesh neighbor iterator by quadrant pointer. \n\nParameters\n\nmfn:         A p4estmeshfaceneighbort to be initialized.\nwhich_tree:  Tree of quadrant whose neighbors are looped over.\nquadrant:    Pointer to quadrant contained in which_tree.\n\nReference\n\np4est_mesh.h:282\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_init2","page":"Reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_init2","text":"𝐣𝐥.@cextern p4est_mesh_face_neighbor_init2(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, which_tree::p4est_topidx_t, quadrant_id::p4est_locidx_t)::𝐣𝐥.Cvoid\n\nInitialize a mesh neighbor iterator by quadrant index. \n\nParameters\n\nmfn:         A p4estmeshfaceneighbort to be initialized.\nwhich_tree:  Tree of quadrant whose neighbors are looped over.\nquadrant_id: Index relative to which_tree of quadrant.\n\nReference\n\np4est_mesh.h:269\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_face_neighbor_next","page":"Reference","title":"P4est.LibP4est.p4est_mesh_face_neighbor_next","text":"𝐣𝐥.@cextern p4est_mesh_face_neighbor_next(mfn::𝐣𝐥.Ptr{p4est_mesh_face_neighbor_t}, ntree::𝐣𝐥.Ptr{p4est_topidx_t}, nquad::𝐣𝐥.Ptr{p4est_locidx_t}, nface::𝐣𝐥.Ptr{𝐣𝐥.Cint}, nrank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Ptr{p4est_quadrant_t}\n\nMove the iterator forward to loop around neighbors of the quadrant. \n\nParameters\n\nmfn:      Internal status of the iterator.\nntree:    If not NULL, the tree number of the neighbor.\nnquad:    If not NULL, the quadrant number within tree.                          For ghosts instead the number in ghost layer.\nnface:    If not NULL, neighbor's face as in p4estmesht.\nnrank:    If not NULL, the owner process of the neighbor.\n\nReturns\n\n              Either a real quadrant or one from the ghost layer.                          Returns NULL when the iterator is done.\n\nReference\n\np4est_mesh.h:300\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_get_neighbors","page":"Reference","title":"P4est.LibP4est.p4est_mesh_get_neighbors","text":"𝐣𝐥.@cextern p4est_mesh_get_neighbors(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, curr_quad_id::p4est_locidx_t, direction::p4est_locidx_t, neighboring_quads::𝐣𝐥.Ptr{sc_array_t}, neighboring_encs::𝐣𝐥.Ptr{sc_array_t}, neighboring_qids::𝐣𝐥.Ptr{sc_array_t})::p4est_locidx_t\n\nLookup neighboring quads of quadrant in a specific direction. \n\nParameters\n\np4est:              Forest to be worked with.\nghost:              Ghost layer.\nmesh:               Mesh structure.\ncurr_quad_id:       Process-local id of current quad.\ndirection:          Direction i in which to look for adjacent                                 quadrants is encoded as follows:                                  0 .. 3 neighbor(-s) across face i,                                  4 .. 7 neighbor(-s) across corner i-4. TODO: Allow any combination of empty output arrays.\nneighboring_quads:  Array containing neighboring quad(-s).                                 Needs to be empty on input, size of                                 p4estquadrantt *.  May be NULL, then                                 neighboring_qids must not be NULL.\nneighboring_qids:   Array containing quadrant ids for neighboring                                 quadrants. May be NULL, then no neighboring                                 qids are collected.                                 If non-NULL the array needs to be empty and                                 will contain int. CAUTION: Note, that the encodings differ from the encodings saved in the          mesh. TODO: Encodings are the same as in p4estmesh for all quadrants. TODO: Ghosts can be encoded by returning the quadtoquad convention in qid.       For ghost quadrants, we add -300 to the values in p4estmesh.       This means that values below -100 belong to ghosts, values above to locals.          Positive values are for local quadrants, negative values indicate          ghost quadrants.          Faces:     1 ..   8 => same size neighbor                                 (r * 4 + nf) + 1; nf = 0 .. 3 face index;                                 r = 0 .. 1 relative orientation                     9 ..  24 => double size neighbor                                 9 + h * 8 + r * 4 + nf; h = 0 .. 1 number                                 of the subface; r, nf as above                    25 ..  32 => half-size neighbors                                 25 + r * 4 + nf; r, nf as above          Corners:   1 ..   4 => size not encoded for corners                                 nc + 1; nc = 0 .. 3 corner index\nneighboring_encs:   Array containing encodings for neighboring                                 quads.                                 Needs to be empty, contains int.\n\nReference\n\np4est_mesh.h:232\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_get_quadrant","page":"Reference","title":"P4est.LibP4est.p4est_mesh_get_quadrant","text":"𝐣𝐥.@cextern p4est_mesh_get_quadrant(p4est::𝐣𝐥.Ptr{p4est_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, qid::p4est_locidx_t)::𝐣𝐥.Ptr{p4est_quadrant_t}\n\nAccess a process-local quadrant inside a forest. Needs a mesh with populated quadtotree array. This is a special case of p4estmeshquadrant_cumulative.\n\nParameters\n\np4est:  The forest.\nmesh:   The mesh.\nqid:    Process-local id of the quadrant (cumulative over trees).\n\nReturns\n\n        A pointer to the requested quadrant.\n\nReference\n\np4est_mesh.h:186\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_memory_used","page":"Reference","title":"P4est.LibP4est.p4est_mesh_memory_used","text":"𝐣𝐥.@cextern p4est_mesh_memory_used(mesh::𝐣𝐥.Ptr{p4est_mesh_t})::size_t\n\nCalculate the memory usage of the mesh structure. \n\nParameters\n\nmesh:     Mesh structure.\n\nReturns\n\n          Memory used in bytes.\n\nReference\n\np4est_mesh.h:158\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_new","page":"Reference","title":"P4est.LibP4est.p4est_mesh_new","text":"𝐣𝐥.@cextern p4est_mesh_new(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_mesh_t}\n\nCreate a p4estmesh structure. This function does not populate the quadtotree and quadlevel fields. To populate them, use p4estmeshnew_ext. \n\nParameters\n\np4est:    A forest that is fully 2:1 balanced.\nghost:    The ghost layer created from the provided p4est.\nbtype:    Determines the highest codimension of neighbors.\n\nReturns\n\n          A fully allocated mesh structure.\n\nReference\n\np4est_mesh.h:168\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_new_ext","page":"Reference","title":"P4est.LibP4est.p4est_mesh_new_ext","text":"𝐣𝐥.@cextern p4est_mesh_new_ext(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, compute_tree_index::𝐣𝐥.Cint, compute_level_lists::𝐣𝐥.Cint, btype::p4est_connect_type_t)::𝐣𝐥.Ptr{p4est_mesh_t}\n\nCreate a new mesh. \n\nParameters\n\np4est:                A forest that is fully 2:1 balanced.\nghost:                The ghost layer created from the                                  provided p4est.\ncompute_tree_index:   Boolean to decide whether to allocate and                                  compute the quadtotree list.\ncompute_level_lists:  Boolean to decide whether to compute the                                  level lists in quad_level.\nbtype:                Currently ignored, only face neighbors                                  are stored.\n\nReturns\n\n                      A fully allocated mesh structure.\n\nReference\n\np4est_extended.h:396\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_mesh_quadrant_cumulative","page":"Reference","title":"P4est.LibP4est.p4est_mesh_quadrant_cumulative","text":"𝐣𝐥.@cextern p4est_mesh_quadrant_cumulative(p4est::𝐣𝐥.Ptr{p4est_t}, mesh::𝐣𝐥.Ptr{p4est_mesh_t}, cumulative_id::p4est_locidx_t, which_tree::𝐣𝐥.Ptr{p4est_topidx_t}, quadrant_id::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Ptr{p4est_quadrant_t}\n\nFind a quadrant based on its cumulative number in the local forest. If the quadtotree field of the mesh structure exists, this is O(1). Otherwise, we perform a binary search over the processor-local trees.\n\nParameters\n\np4est:           Forest to be worked with.\nmesh:            A mesh derived from the forest.\ncumulative_id:   Cumulative index over all trees of quadrant.                              Must refer to a local (non-ghost) quadrant.\nwhich_tree:   If not NULL, the input value can be -1                              or an initial guess for the quadrant's tree                              and output is the tree of returned quadrant.\nquadrant_id:     If not NULL, the number of quadrant in tree.\n\nReturns\n\n                  The identified quadrant.\n\nReference\n\np4est_mesh.h:255\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_new","page":"Reference","title":"P4est.LibP4est.p4est_new","text":"𝐣𝐥.@cextern p4est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_t}\n\nCreate a new forest with an initial coarse mesh. The new forest consists of equi-partitioned root quadrants. When there are more processors than trees, some processors are empty.\n\nParameters\n\nmpicomm:       A valid MPI communicator.\nconnectivity:  This is the connectivity information that                           the forest is built with.  Note the p4est                           does not take ownership of the memory.\ndata_size:     This is the size of data for each quadrant which                           can be zero.  Then userdatapool is set to NULL.\ninit_fn:       Callback function to initialize the user_data                           which is already allocated automatically.\nuser_pointer:  Assign to the userpointer member of the p4est                           before initfn is called the first time.\n\nReturns\n\nThis returns a valid forest.\n\nNOTE: The connectivity structure must not be destroyed       during the lifetime of this forest.\n\nReference\n\np4est.h:275\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_new_ext","page":"Reference","title":"P4est.LibP4est.p4est_new_ext","text":"𝐣𝐥.@cextern p4est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p4est_t}\n\nCreate a new forest. This is a more general form of p4estnew. The forest created is either uniformly refined at a given level or created with the coarsest possible refinement that fits the exact partition that would have been created in the uniform mode. The latter, coarse refinement depends on the number of MPI processes! The initial level is currently limited to P4ESTOLDQMAXLEVEL. Regardless, p4estrefine can go as deep as P4EST_QMAXLEVEL.\n\nParameters\n\nmpicomm:          A valid MPI communicator.\nconnectivity:     This is the connectivity information that                              the forest is built with.  Note the forest                              does not take ownership of the memory.\nmin_quadrants:    Minimum initial quadrants per processor.                              Makes the refinement pattern mpisize-specific.                              For maximum reproducibility, set this to 0.\nmin_level:        The forest is refined at most to this level.                              Later coarsening and refinement is unaffected.                              May be negative or 0, then it has no effect.\nfill_uniform:     If true, fill the forest with a uniform mesh                              instead of the coarsest possible one.                              The latter is partition-specific, which                              is not a good idea wrt. reproducibility.\ndata_size:        The size of data for each quadrant.\ninit_fn:          Callback function to initialize the userdata                              which is internally allocated using datasize.\nuser_pointer:     Assigned to the userpointer member of the                              forest before initfn is called the first time.\n\nReturns\n\n                  Valid p4est object.\n\nReference\n\np4est_extended.h:377\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_package_id","page":"Reference","title":"P4est.LibP4est.p4est_package_id","text":"𝐣𝐥.@cextern p4est_package_id::𝐣𝐥.Cint\n\nthe libsc package id for p4est (set in p4est_init()) \n\nReference\n\np4est_base.h:319\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_partition","page":"Reference","title":"P4est.LibP4est.p4est_partition","text":"𝐣𝐥.@cextern p4est_partition(p4est::𝐣𝐥.Ptr{p4est_t}, allow_for_coarsening::𝐣𝐥.Cint, weight_fn::p4est_weight_t)::𝐣𝐥.Cvoid\n\nEqually partition the forest. The partition can be by element count or by a user-defined weight.\n\nDetails\n\nThe forest will be partitioned between processors such that they have an approximately equal number of quadrants (or sum of weights).\n\nOn one process, the function noops and does not call the weight callback. Otherwise, the weight callback is called once per quadrant in order.\n\nParameters\n\np4est:      The forest that will be partitioned.\nallow_for_coarsening: Slightly modify partition such that                            quadrant families are not split between ranks.\nweight_fn:  A weighting function or NULL                            for uniform partitioning.                            When running with mpisize == 1, never called.                            Otherwise, called in order for all quadrants                            if not NULL. A weighting function with constant                            weight 1 on each quadrant is equivalent                            to weight_fn == NULL but other constant weightings                            may result in different uniform partitionings.\n\nReference\n\np4est.h:385\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_partition_ext","page":"Reference","title":"P4est.LibP4est.p4est_partition_ext","text":"𝐣𝐥.@cextern p4est_partition_ext(p4est::𝐣𝐥.Ptr{p4est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p4est_weight_t)::p4est_gloidx_t\n\nRepartition the forest.\n\nDetails\n\nThe forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).\n\nParameters\n\np4est:      The forest that will be partitioned.\npartition_for_coarsening:     If true, the partition                            is modified to allow one level of coarsening.\nweight_fn:  A weighting function or NULL                            for uniform partitioning. A weighting function                            with constant weight 1 on each quadrant is                            equivalent to weight_fn == NULL but other constant                            weightings may result in different uniform                            partitionings.\n\nReturns\n\n     The global number of shipped quadrants\n\nReference\n\np4est_extended.h:511\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_partition_for_coarsening","page":"Reference","title":"P4est.LibP4est.p4est_partition_for_coarsening","text":"𝐣𝐥.@cextern p4est_partition_for_coarsening(p4est::𝐣𝐥.Ptr{p4est_t}, num_quadrants_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t\n\nCorrect partition to allow one level of coarsening.\n\nParameters\n\np4est:                     forest whose partition is corrected\nnum_quadrants_in_proc: partition that will be corrected\n\nReturns\n\n                           absolute number of moved quadrants\n\nReference\n\np4est_extended.h:521\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_partition_lnodes","page":"Reference","title":"P4est.LibP4est.p4est_partition_lnodes","text":"𝐣𝐥.@cextern p4est_partition_lnodes(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, degree::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nPartition using weights based on the number of nodes assigned to each element in lnodes\n\nParameters\n\np4est:                    the forest to be repartitioned\nghost:                    the ghost layer\ndegree:                   the degree that would be passed to p4estlnodesnew()\npartition_for_coarsening: whether the partition should allow                                         coarsening (i.e. group siblings who                                         might merge)\n\nReference\n\np4est_lnodes.h:249\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_partition_lnodes_detailed","page":"Reference","title":"P4est.LibP4est.p4est_partition_lnodes_detailed","text":"𝐣𝐥.@cextern p4est_partition_lnodes_detailed(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, nodes_per_volume::𝐣𝐥.Cint, nodes_per_face::𝐣𝐥.Cint, nodes_per_corner::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nPartition using weights that are broken down by where they reside: in volumes, on faces, or on corners.\n\nReference\n\np4est_lnodes.h:256\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_partition_to_p6est_partition","page":"Reference","title":"P4est.LibP4est.p4est_partition_to_p6est_partition","text":"𝐣𝐥.@cextern p4est_partition_to_p6est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, num_columns_in_proc::𝐣𝐥.Ptr{p4est_locidx_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid\n\nReference\n\np6est.h:490\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_qcoord_to_vertex","page":"Reference","title":"P4est.LibP4est.p4est_qcoord_to_vertex","text":"𝐣𝐥.@cextern p4est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p4est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid\n\nTransform a quadrant coordinate into the space spanned by tree vertices. \n\nParameters\n\nconnectivity:     Connectivity must provide the vertices.\ntreeid:           Identify the tree that contains x, y.\nx,: y             Quadrant coordinates relative to treeid.\nvxyz:            Transformed coordinates in vertex space.\n\nReference\n\np4est.h:249\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_exists","page":"Reference","title":"P4est.LibP4est.p4est_quadrant_exists","text":"𝐣𝐥.@cextern p4est_quadrant_exists(p4est::𝐣𝐥.Ptr{p4est_t}, ghost::𝐣𝐥.Ptr{p4est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, exists_arr::𝐣𝐥.Ptr{sc_array_t}, rproc_arr::𝐣𝐥.Ptr{sc_array_t}, rquad_arr::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nDetails\n\nFor quadrants across tree corners it checks if the quadrant exists in any of the corner neighbors, thus it can execute multiple queries.\n\nParameters\n\np4est:        The forest in which to search for q\nghost:        The ghost layer in which to search for q\ntreeid:       The tree to which q belongs (can be extended).\nq:            The quadrant that is being searched for.\nexists_arr: Must exist and be of of elemsize = sizeof (int)                           for inter-tree corner cases.  Is resized by this                           function to one entry for each corner search                           and set to true/false depending on its existence                           in the local forest or ghostlayer.\nrproc_arr: If not NULL is filled with one rank per query.\nrquad_arr: If not NULL is filled with one quadrant per query.                           Its piggy3 member is defined as well.\n\nReturns\n\ntrue if the quadrant exists in the local forest or in the                  ghost_layer, and false if doesn't exist in either.\n\nReference\n\np4est_ghost.h:213\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_find_owner","page":"Reference","title":"P4est.LibP4est.p4est_quadrant_find_owner","text":"𝐣𝐥.@cextern p4est_quadrant_find_owner(p4est::𝐣𝐥.Ptr{p4est_t}, treeid::p4est_topidx_t, face::𝐣𝐥.Cint, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)})::𝐣𝐥.Cint\n\nGets the processor id of a quadrant's owner. The quadrant can lie outside of a tree across faces (and only faces).\n\nParameters\n\np4est:  The forest in which to search for a quadrant.\ntreeid: The tree to which the quadrant belongs.\nface:   Supply a face direction if known, or -1 otherwise.\nq:      The quadrant that is being searched for.\n\nReturns\n\nProcessor id of the owner                or -1 if the quadrant lies outside of the mesh.\n\nWARNING: Does not work for tree edge or corner neighbors.\n\nReference\n\np4est_ghost.h:115\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_linear_id_ext128","page":"Reference","title":"P4est.LibP4est.p4est_quadrant_linear_id_ext128","text":"𝐣𝐥.@cextern p4est_quadrant_linear_id_ext128(quadrant::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_quadrant_t)}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{p4est_lid_t})::𝐣𝐥.Cvoid\n\nComputes the linear position as p4estlidt of a quadrant in a uniform grid. The grid and quadrant levels need not coincide. If they do, this is the inverse of p4estquadrantset_morton. \n\nParameters\n\nquadrant:  Quadrant whose linear index will be computed.                       If the quadrant is smaller than the grid (has a higher                       quadrant->level), the result is computed from its                       ancestor at the grid's level.                       If the quadrant has a smaller level than the grid (it                       is bigger than a grid cell), the grid cell sharing its                       lower left corner is used as reference.\nlevel:     The level of the regular grid compared to which the                       linear position is to be computed.\nid:     A pointer to an allocated or static p4estlidt.                       id will be the linear position of this quadrant on a                       uniform grid.\n\nNOTE: The user_data of quadrant is never modified.\n\nReference\n\np4est_extended.h:332\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_quadrant_set_morton_ext128","page":"Reference","title":"P4est.LibP4est.p4est_quadrant_set_morton_ext128","text":"𝐣𝐥.@cextern p4est_quadrant_set_morton_ext128(quadrant::𝐣𝐥.Ptr{p4est_quadrant_t}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_lid_t)})::𝐣𝐥.Cvoid\n\nSet quadrant Morton indices based on linear position given as p4estlidt in uniform grid. This is the inverse operation of p4estquadrantlinear_id. \n\nParameters\n\nquadrant:  Quadrant whose Morton indices will be set.\nlevel:     Level of the grid and of the resulting quadrant.\nid:        Linear index of the quadrant on a uniform grid.\n\nNOTE: The user_data of quadrant is never modified.\n\nReference\n\np4est_extended.h:343\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_refine","page":"Reference","title":"P4est.LibP4est.p4est_refine","text":"𝐣𝐥.@cextern p4est_refine(p4est::𝐣𝐥.Ptr{p4est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p4est_refine_t, init_fn::p4est_init_t)::𝐣𝐥.Cvoid\n\nRefine a forest. \n\nParameters\n\np4est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nrefine_fn: Callback function that must return true if a quadrant                       shall be refined.  If refinerecursive is true,                       refinefn is called for every existing and newly                       created quadrant.  Otherwise, it is called for every                       existing quadrant.  It is possible that a refinement                       request made by the callback is ignored.  To catch                       this case, you can examine whether initfn gets                       called, or use p4estrefineext in p4estextended.h                       and examine whether replace_fn gets called.\ninit_fn:   Callback function to initialize the user_data of newly                       created quadrants, which is already allocated.  This                       function pointer may be NULL.\n\nReference\n\np4est.h:334\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_refine_ext","page":"Reference","title":"P4est.LibP4est.p4est_refine_ext","text":"𝐣𝐥.@cextern p4est_refine_ext(p4est::𝐣𝐥.Ptr{p4est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p4est_refine_t, init_fn::p4est_init_t, replace_fn::p4est_replace_t)::𝐣𝐥.Cvoid\n\nRefine a forest with a bounded refinement level and a replace option. \n\nParameters\n\np4est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nmaxlevel:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p4est.h.\nrefine_fn:  Callback function that must return true if a quadrant                        shall be refined.  If refinerecursive is true,                        refinefn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether initfn or                        replacefn gets called.\ninit_fn:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.\n\nReference\n\np4est_extended.h:440\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_reset_data","page":"Reference","title":"P4est.LibP4est.p4est_reset_data","text":"𝐣𝐥.@cextern p4est_reset_data(p4est::𝐣𝐥.Ptr{p4est_t}, data_size::size_t, init_fn::p4est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nReset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.\n\nParameters\n\ndata_size:     This is the size of data for each quadrant which                           can be zero.  Then userdatapool is set to NULL.\ninit_fn:       Callback function to initialize the user_data                           which is already allocated automatically.                           May be NULL.\nuser_pointer:  Assign to the userpointer member of the p4est                           before initfn is called the first time.\n\nReference\n\np4est.h:314\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_revision","page":"Reference","title":"P4est.LibP4est.p4est_revision","text":"𝐣𝐥.@cextern p4est_revision(p4est::𝐣𝐥.Ptr{p4est_t})::𝐣𝐥.Clong\n\nReturn the revision counter of the forest. Not collective, even though the revision value is the same on all ranks. A newly created forest starts with a revision counter of zero. Every refine, coarsen, partition, and balance that actually changes the mesh increases the counter by one.  Operations with no effect keep the old value. \n\nParameters\n\np8est:    The forest must be valid.\n\nReturns\n\n          Non-negative number.\n\nReference\n\np4est.h:192\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_save","page":"Reference","title":"P4est.LibP4est.p4est_save","text":"𝐣𝐥.@cextern p4est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p4est::𝐣𝐥.Ptr{p4est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSave the complete connectivity/p4est data to disk.\n\nDetails\n\nThis is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations.\n\nBy default, we write the current processor count and partition into the file header.  This makes the file depend on mpisize.  For changing this see p4estsaveext() in p4est_extended.h.\n\nThe revision counter is not saved to the file, since that would make files different that come from different revisions but store the same mesh.\n\nParameters\n\nfilename:    Name of the file to write.\np4est:       Valid forest structure.\nsave_data:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.\n\nNOTE:            Aborts on file errors. \n\nNOTE:            If p4est is not configured to use MPI-IO, some processes                  return from this function before the file is complete, in                  which case immediate read-access to the file may require a                  call to scMPIBarrier.\n\nReference\n\np4est.h:423\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_save_ext","page":"Reference","title":"P4est.LibP4est.p4est_save_ext","text":"𝐣𝐥.@cextern p4est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p4est::𝐣𝐥.Ptr{p4est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSave the complete connectivity/p4est data to disk.  This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p4estloadext for information on the autopartition parameter. \n\nParameters\n\nfilename:    Name of the file to write.\np4est:       Valid forest structure.\nsave_data:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.\nsave_partition:   If false, save file as if 1 core was used.                              If true, save core count and partition.                         Advantage: Partition can be recovered on loading                              with same mpisize and autopartition false.                         Disadvantage: Makes the file depend on mpisize.                  Either way the file can be loaded with autopartition true.\n\nNOTE:            Aborts on file errors.\n\nReference\n\np4est_extended.h:554\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_source_ext","page":"Reference","title":"P4est.LibP4est.p4est_source_ext","text":"𝐣𝐥.@cextern p4est_source_ext(src::𝐣𝐥.Ptr{sc_io_source_t}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p4est_connectivity_t}})::𝐣𝐥.Ptr{p4est_t}\n\nThe same as p4estloadext, but reading the connectivity/p4est from an open sciosource_t stream.\n\nReference\n\np4est_extended.h:587\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_version","page":"Reference","title":"P4est.LibP4est.p4est_version","text":"𝐣𝐥.@cextern p4est_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}\n\nReturn the full version of p4est.\n\nReturns\n\n      Return the version of p4est using the format                  `VERSION_MAJOR.VERSION_MINOR.VERSION_POINT`,                  where `VERSION_POINT` can contain dots and                  characters, e.g. to indicate the additional                  number of commits and a git commit hash.\n\nReference\n\np4est_base.h:530\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_version_major","page":"Reference","title":"P4est.LibP4est.p4est_version_major","text":"𝐣𝐥.@cextern p4est_version_major()::𝐣𝐥.Cint\n\nReturn the major version of p4est.\n\nReturns\n\n      Return the major version of p4est.\n\nReference\n\np4est_base.h:536\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p4est_version_minor","page":"Reference","title":"P4est.LibP4est.p4est_version_minor","text":"𝐣𝐥.@cextern p4est_version_minor()::𝐣𝐥.Cint\n\nReturn the minor version of p4est.\n\nReturns\n\n      Return the minor version of p4est.\n\nReference\n\np4est_base.h:542\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_balance","page":"Reference","title":"P4est.LibP4est.p6est_balance","text":"𝐣𝐥.@cextern p6est_balance(p6est::𝐣𝐥.Ptr{p6est_t}, btype::p8est_connect_type_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid\n\nBalance a forest.\n\nParameters\n\np6est:     The p6est to be worked on.\nbtype:     Balance type (face, corner or default, full).\ninit_fn:   Callback function to initialize the user_data                       which is already allocated automatically.\n\nReference\n\np6est.h:455\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_balance_ext","page":"Reference","title":"P4est.LibP4est.p6est_balance_ext","text":"𝐣𝐥.@cextern p6est_balance_ext(p6est::𝐣𝐥.Ptr{p6est_t}, btype::p8est_connect_type_t, max_diff::𝐣𝐥.Cint, min_diff::𝐣𝐥.Cint, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid\n\n2:1 balance the size differences of neighboring elements in a forest. \n\nParameters\n\np6est:  The p6est to be worked on.\nbtype:      Balance type (face or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.\nmax_diff:   The maximum difference between the horizontal                        refinement level and the vertical refinement level\nmin_diff:   The minimum difference between the horizontal                        refinement level and the vertical refinement level\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np6est_extended.h:280\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_checksum","page":"Reference","title":"P4est.LibP4est.p6est_checksum","text":"𝐣𝐥.@cextern p6est_checksum(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cuint\n\nCompute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize. \n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nReference\n\np6est.h:507\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_columns","page":"Reference","title":"P4est.LibP4est.p6est_coarsen_columns","text":"𝐣𝐥.@cextern p6est_coarsen_columns(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_column_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid\n\nCoarsen the columns of a sheet.\n\nParameters\n\np6est:  The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncoarsen_fn: Callback function that returns true if a                        family of columns shall be coarsened\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\n\nReference\n\np6est.h:429\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_columns_ext","page":"Reference","title":"P4est.LibP4est.p6est_coarsen_columns_ext","text":"𝐣𝐥.@cextern p6est_coarsen_columns_ext(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_column_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid\n\nHorizontally coarsen a forest. \n\nParameters\n\np6est: The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncallback_orphans: Boolean to enable calling coarsenfn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsenrecursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.\ncoarsen_fn: Callback function that returns true if a                        family of quadrants shall be coarsened.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np6est_extended.h:215\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_layers","page":"Reference","title":"P4est.LibP4est.p6est_coarsen_layers","text":"𝐣𝐥.@cextern p6est_coarsen_layers(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_layer_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid\n\nCoarsen the layers of a sheet.\n\nParameters\n\np6est:  The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncoarsen_fn: Callback function that returns true if a                        family of layers shall be coarsened\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\n\nReference\n\np6est.h:443\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_coarsen_layers_ext","page":"Reference","title":"P4est.LibP4est.p6est_coarsen_layers_ext","text":"𝐣𝐥.@cextern p6est_coarsen_layers_ext(p6est::𝐣𝐥.Ptr{p6est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p6est_coarsen_layer_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid\n\nVertically coarsen a forest. \n\nParameters\n\np6est: The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncallback_orphans: Boolean to enable calling coarsenfn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsenrecursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.\ncoarsen_fn: Callback function that returns true if a                        family of quadrants shall be coarsened.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np6est_extended.h:241\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_compress_columns","page":"Reference","title":"P4est.LibP4est.p6est_compress_columns","text":"𝐣𝐥.@cextern p6est_compress_columns(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid\n\nReference\n\np6est.h:624\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_connectivity_destroy","page":"Reference","title":"P4est.LibP4est.p6est_connectivity_destroy","text":"𝐣𝐥.@cextern p6est_connectivity_destroy(conn::𝐣𝐥.Ptr{p6est_connectivity_t})::𝐣𝐥.Cvoid\n\nDestroy a p6est_connectivity structure \n\nReference\n\np6est.h:97\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_connectivity_new","page":"Reference","title":"P4est.LibP4est.p6est_connectivity_new","text":"𝐣𝐥.@cextern p6est_connectivity_new(conn4::𝐣𝐥.Ptr{p4est_connectivity_t}, top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, height::𝐣𝐥.Cdouble[3])::𝐣𝐥.Ptr{p6est_connectivity_t}\n\nCreate a p6estconnectivityt from a p4estconnectivityt.  All fields are copied, so all inputs can be safey destroyed.\n\nParameters\n\nconn4:         the 2D connectivity\ntop_vertices:  if NULL, then the sheet has a uniform vertical                          profile; otherwise, top_vertices gives teh                          vertices of the top of the sheet; should be the                          same size as conn4->treetovertex\nheight:        if top_vertices == NULL, then this gives the                          offset fro the bottom of the sheet to the top.\n\nReturns\n\nthe 2D+1D connectivity information.\n\nReference\n\np6est.h:92\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_copy","page":"Reference","title":"P4est.LibP4est.p6est_copy","text":"𝐣𝐥.@cextern p6est_copy(input::𝐣𝐥.Ptr{p6est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p6est_t}\n\nMake a deep copy of a p6est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless.\n\nParameters\n\ncopy_data:  If true, data are copied.                         If false, data_size is set to 0.\n\nReturns\n\nReturns a valid p6est that does not depend on the input.\n\nReference\n\np6est.h:356\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_copy_ext","page":"Reference","title":"P4est.LibP4est.p6est_copy_ext","text":"𝐣𝐥.@cextern p6est_copy_ext(input::𝐣𝐥.Ptr{p6est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p6est_t}\n\nMake a deep copy of a p6est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL.\n\nParameters\n\ncopy_data:  If true, data are copied.                         If false, data_size is set to 0.\nduplicate_mpicomm:  If true, MPI communicator is copied.\n\nReturns\n\nReturns a valid p6est that does not depend on the input.\n\nReference\n\np6est_extended.h:85\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_destroy","page":"Reference","title":"P4est.LibP4est.p6est_destroy","text":"𝐣𝐥.@cextern p6est_destroy(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid\n\nDestroy a p6est.\n\nDetails\n\nNOTE: The connectivity structure is not destroyed with the p6est.\n\nReference\n\np6est.h:345\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_load","page":"Reference","title":"P4est.LibP4est.p6est_load","text":"𝐣𝐥.@cextern p6est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p6est_connectivity_t}})::𝐣𝐥.Ptr{p6est_t}\n\nLoad the complete connectivity/p6est structure from disk.\n\nParameters\n\nfilename:         Name of the file to read.\nmpicomm:          A valid MPI communicator.\ndata_size:        Size of data for each quadrant which can be                              zero.  Then userdatapool is set to NULL.                              If datasize is zero, loaddata is ignored.\nload_data:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.\nuser_pointer:     Assign to the userpointer member of the p6est                              before initfn is called the first time.\nconnectivity:    Connectivity must be destroyed separately.\n\nReturns\n\n      Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument.\n\nNOTE:            Aborts on file errors or invalid file contents.\n\nReference\n\np6est.h:541\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_load_ext","page":"Reference","title":"P4est.LibP4est.p6est_load_ext","text":"𝐣𝐥.@cextern p6est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p6est_connectivity_t}})::𝐣𝐥.Ptr{p6est_t}\n\nLoad the complete connectivity/p6est structure from disk.\n\nDetails\n\nIt is possible to load the file with a different number of processors than has been used to write it.  The partition will then be uniform.\n\nParameters\n\nfilename:         Name of the file to read.\nmpicomm:          A valid MPI communicator.\ndata_size:        Size of data for each quadrant which can be                              zero.  Then userdatapool is set to NULL.                              If datasize is zero, loaddata is ignored.\nload_data:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.\nautopartition:    Ignore saved partition and make it uniform.\nbroadcasthead:    Have only rank 0 read headers and bcast them.\nuser_pointer:     Assign to the userpointer member of the p6est                              before initfn is called the first time.\nconnectivity:    Connectivity must be destroyed separately.\n\nReturns\n\n      Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument.\n\nNOTE:            Aborts on file errors or invalid file contents.\n\nReference\n\np6est_extended.h:133\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_new","page":"Reference","title":"P4est.LibP4est.p6est_new","text":"𝐣𝐥.@cextern p6est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}\n\nCreate a new forest.\n\nDetails\n\nThe new forest consists of equi-partitioned root quadrants. When there are more processors than trees, some processors are empty.\n\nParameters\n\nmpicomm:       A valid MPI communicator.\nconnectivity:  This is the connectivity information that                           the forest is built with.  Note the p6est                           does not take ownership of the memory.\ndata_size:     This is the size of data for each quadrant which                           can be zero.  Then userdatapool is set to NULL.\ninit_fn:       Callback function to initialize the user_data                           which is already allocated automatically.\nuser_pointer:  Assign to the userpointer member of the p6est                           before initfn is called the first time.\n\nReturns\n\nThis returns a valid forest.\n\nNOTE: The connectivity structure must not be destroyed       during the lifetime of this forest.\n\nReference\n\np6est.h:313\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_new_ext","page":"Reference","title":"P4est.LibP4est.p6est_new_ext","text":"𝐣𝐥.@cextern p6est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, min_zlevel::𝐣𝐥.Cint, num_zroot::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}\n\nCreate a new forest. This is a more general form of p6estnew(). See the documentation of p6estnew() for basic usage.\n\nParameters\n\nmin_quadrants:    Minimum initial quadrants per processor.                              Makes the refinement pattern mpisize-specific.\nmin_level:        The forest is horizontally refined at least to                              this level.  May be negative or 0, then it has                              no effect.\nmin_zlevel:       The forest is vertically refined at least to                              this level.  May be negative or 0, then it has                              no effect.\nnum_zroot:        The number of \"root\" vertical layers                              (used when non-power-of-2 layers are desired)\nfill_uniform:     If true, fill the forest with a uniform mesh                              instead of the coarsest possible one.                              The latter is partition-specific so that                              is usually not a good idea.\n\nReference\n\np6est_extended.h:66\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_new_from_p4est","page":"Reference","title":"P4est.LibP4est.p6est_new_from_p4est","text":"𝐣𝐥.@cextern p6est_new_from_p4est(p4est::𝐣𝐥.Ptr{p4est_t}, top_vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, height::𝐣𝐥.Cdouble[3], min_zlevel::𝐣𝐥.Cint, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p6est_t}\n\nCreate a new forest from an already created p4est that represents columns.\n\nParameters\n\np4est:         A valid p4est.  A deep copy will be created, so                           this can be destroyed without affectin the new                           p6est object.\ntop_vertices:  the same as in p6estconectivitynew()\nheight:        the same as in p6estconectivitynew()\nmin_zlevel:    the same as in p6est_new()\ndata_size:     the same as in p6est_new()\ninit_fn:       the same as in p6est_new()\nuser_pointer:  the same as in p6est_new()\n\nReturns\n\nThis returns a valid forest.  The user must destroy the connectivity for the new p6est independently.\n\nReference\n\np6est.h:334\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_partition","page":"Reference","title":"P4est.LibP4est.p6est_partition","text":"𝐣𝐥.@cextern p6est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, weight_fn::p6est_weight_t)::p4est_gloidx_t\n\nEqually partition the forest.\n\nDetails\n\nThe forest will be partitioned between processors where they each have an approximately equal number of quadrants.\n\nNote that p6est->layers and p6est->globalfirstlayers may change during this call.  Address pointers referencing these objects from before p6est_partition is called become invalid.\n\nParameters\n\np6est:      The forest that will be partitioned.\nweight_fn:  A weighting function or NULL                            for uniform partitioning.\n\nReference\n\np6est.h:480\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_partition_correct","page":"Reference","title":"P4est.LibP4est.p6est_partition_correct","text":"𝐣𝐥.@cextern p6est_partition_correct(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid\n\nReference\n\np6est.h:482\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_partition_ext","page":"Reference","title":"P4est.LibP4est.p6est_partition_ext","text":"𝐣𝐥.@cextern p6est_partition_ext(p6est::𝐣𝐥.Ptr{p6est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p6est_weight_t)::p4est_gloidx_t\n\nRepartition the forest.\n\nDetails\n\nThe forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).\n\nParameters\n\np6est:      The forest that will be partitioned.\npartition_for_coarsening:     If true, the partition                            is modified to allow one level of coarsening.\nweight_fn:  A weighting function or NULL                            for uniform partitioning.\n\nReturns\n\n     The global number of shipped quadrants\n\nReference\n\np6est_extended.h:261\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_partition_for_coarsening","page":"Reference","title":"P4est.LibP4est.p6est_partition_for_coarsening","text":"𝐣𝐥.@cextern p6est_partition_for_coarsening(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t\n\nReference\n\np6est.h:496\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_partition_given","page":"Reference","title":"P4est.LibP4est.p6est_partition_given","text":"𝐣𝐥.@cextern p6est_partition_given(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t\n\nReference\n\np6est.h:499\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_partition_to_p4est_partition","page":"Reference","title":"P4est.LibP4est.p6est_partition_to_p4est_partition","text":"𝐣𝐥.@cextern p6est_partition_to_p4est_partition(p6est::𝐣𝐥.Ptr{p6est_t}, num_layers_in_proc::𝐣𝐥.Ptr{p4est_locidx_t}, num_columns_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Cvoid\n\nReference\n\np6est.h:485\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_qcoord_to_vertex","page":"Reference","title":"P4est.LibP4est.p6est_qcoord_to_vertex","text":"𝐣𝐥.@cextern p6est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p6est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, z::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid\n\nTransform a quadrant coordinate into the space spanned by tree vertices.\n\nParameters\n\nconnectivity:     Connectivity must provide the vertices.\ntreeid:           Identify the tree that contains x, y.\nx,: y             Quadrant coordinates relative to treeid.\nvxy:             Transformed coordinates in vertex space.\n\nReference\n\np6est.h:116\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_refine_columns","page":"Reference","title":"P4est.LibP4est.p6est_refine_columns","text":"𝐣𝐥.@cextern p6est_refine_columns(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p6est_refine_column_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid\n\nRefine the columns of a sheet.\n\nParameters\n\np6est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nrefine_fn: Callback function that must return true if a column                       shall be refined into smaller columns.  If                       refinerecursive is true, refinefn is called for                       every existing and newly created column.                       Otherwise, it is called for every existing column.                       It is possible that a refinement request made by the                       callback is ignored.  To catch this case, you can                       examine whether initfn gets called, or use                       p6estrefinecolumnsext in p6estextended.h and examine                       whether replacefn gets called.\ninit_fn:   Callback function to initialize the user_data of newly                       created layers within columns, which are already                       allocated.  This function pointer may be NULL.\n\nReference\n\np6est.h:392\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_refine_columns_ext","page":"Reference","title":"P4est.LibP4est.p6est_refine_columns_ext","text":"𝐣𝐥.@cextern p6est_refine_columns_ext(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p6est_refine_column_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid\n\nHorizontally refine a forest with a bounded refinement level and a replace option.\n\nParameters\n\np6est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nmaxlevel:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p4est.h.\nrefine_fn:  Callback function that must return true if a quadrant                        shall be refined.  If refinerecursive is true,                        refinefn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether initfn or                        replacefn gets called.\ninit_fn:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.\n\nReference\n\np6est_extended.h:161\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_refine_layers","page":"Reference","title":"P4est.LibP4est.p6est_refine_layers","text":"𝐣𝐥.@cextern p6est_refine_layers(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p6est_refine_layer_t, init_fn::p6est_init_t)::𝐣𝐥.Cvoid\n\nRefine the layers within the columns of a sheet.\n\nParameters\n\np6est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nrefine_fn: Callback function that must return true if a layer                       shall be refined into smaller layers.  If                       refinerecursive is true, refinefn is called for                       every existing and newly created layer.                       Otherwise, it is called for every existing layer.                       It is possible that a refinement request made by the                       callback is ignored.  To catch this case, you can                       examine whether initfn gets called, or use                       p6estrefinelayersext in p6estextended.h and examine                       whether replacefn gets called.\ninit_fn:   Callback function to initialize the user_data of newly                       created layers, which are already allocated.  This                       function pointer may be NULL.\n\nReference\n\np6est.h:415\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_refine_layers_ext","page":"Reference","title":"P4est.LibP4est.p6est_refine_layers_ext","text":"𝐣𝐥.@cextern p6est_refine_layers_ext(p6est::𝐣𝐥.Ptr{p6est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p6est_refine_layer_t, init_fn::p6est_init_t, replace_fn::p6est_replace_t)::𝐣𝐥.Cvoid\n\nVertically refine a forest with a bounded refinement level and a replace option.\n\nParameters\n\np6est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nmaxlevel:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p4est.h.\nrefine_fn:  Callback function that must return true if a quadrant                        shall be refined.  If refinerecursive is true,                        refinefn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether initfn or                        replacefn gets called.\ninit_fn:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.\n\nReference\n\np6est_extended.h:190\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_reset_data","page":"Reference","title":"P4est.LibP4est.p6est_reset_data","text":"𝐣𝐥.@cextern p6est_reset_data(p6est::𝐣𝐥.Ptr{p6est_t}, data_size::size_t, init_fn::p6est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nReset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.\n\nParameters\n\ndata_size:     This is the size of data for each quadrant which                           can be zero.  Then userdatapool is set to NULL.\ninit_fn:       Callback function to initialize the user_data                           which is already allocated automatically.\nuser_pointer:  Assign to the userpointer member of the p6est                           before initfn is called the first time.\n\nReference\n\np6est.h:370\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_save","page":"Reference","title":"P4est.LibP4est.p6est_save","text":"𝐣𝐥.@cextern p6est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p6est::𝐣𝐥.Ptr{p6est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSave the complete connectivity/p6est data to disk.  This is a collective\n\nDetails\n\noperation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations. \n\nParameters\n\nfilename:    Name of the file to write.\np6est:       Valid forest structure.\nsave_data:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.\n\nNOTE:            Aborts on file errors.\n\nReference\n\np6est.h:520\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_save_ext","page":"Reference","title":"P4est.LibP4est.p6est_save_ext","text":"𝐣𝐥.@cextern p6est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p6est::𝐣𝐥.Ptr{p6est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSave the complete connectivity/p6est data to disk.\n\nDetails\n\nThis is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations.  See p6estloadext() for information on the autopartition parameter.\n\nParameters\n\nfilename:    Name of the file to write.\np6est:       Valid forest structure.\nsave_data:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.\nsave_partition:   If false, save file as if 1 core was used.                              If true, save core count and partition.                         Advantage: Partition can be recovered on loading                              with same mpisize and autopartition false.                         Disadvantage: Makes the file depend on mpisize.                  Either way the file can be loaded with autopartition true.\n\nNOTE:            Aborts on file errors.\n\nReference\n\np6est_extended.h:107\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_tree_get_vertices","page":"Reference","title":"P4est.LibP4est.p6est_tree_get_vertices","text":"𝐣𝐥.@cextern p6est_tree_get_vertices(conn::𝐣𝐥.Ptr{p6est_connectivity_t}, which_tree::p4est_topidx_t, vertices::𝐣𝐥.Cdouble[24])::𝐣𝐥.Cvoid\n\nGet the vertices of the corners of a tree.\n\nParameters\n\nconn:         the 2D+1D connectivity structure\nwhich_tree:   a tree in the forest\nvertices:     the coordinates of the corners of the tree\n\nReference\n\np6est.h:105\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p6est_update_offsets","page":"Reference","title":"P4est.LibP4est.p6est_update_offsets","text":"𝐣𝐥.@cextern p6est_update_offsets(p6est::𝐣𝐥.Ptr{p6est_t})::𝐣𝐥.Cvoid\n\nReference\n\np6est.h:625\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_balance","page":"Reference","title":"P4est.LibP4est.p8est_balance","text":"𝐣𝐥.@cextern p8est_balance(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid\n\n2:1 balance the size differences of neighboring elements in a forest. \n\nParameters\n\np8est:  The p8est to be worked on.\nbtype:      Balance type (face, edge, or corner/full).  Examples:                        Finite volume or discontinuous Galerkin methods only                        require face balance.  Continuous finite element                        methods usually require edge balance.  Corner balance                        is almost never required mathematically; it just                        produces a smoother mesh grading.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\n\nReference\n\np8est.h:360\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_balance_ext","page":"Reference","title":"P4est.LibP4est.p8est_balance_ext","text":"𝐣𝐥.@cextern p8est_balance_ext(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid\n\n2:1 balance the size differences of neighboring elements in a forest. \n\nParameters\n\np8est:  The p8est to be worked on.\nbtype:      Balance type (face, edge, or corner/full).                        Corner balance is almost never required when                        discretizing a PDE; just causes smoother mesh grading.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np8est_extended.h:488\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_balance_subtree_ext","page":"Reference","title":"P4est.LibP4est.p8est_balance_subtree_ext","text":"𝐣𝐥.@cextern p8est_balance_subtree_ext(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t, which_tree::p4est_topidx_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid\n\nReference\n\np8est_extended.h:493\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_checksum","page":"Reference","title":"P4est.LibP4est.p8est_checksum","text":"𝐣𝐥.@cextern p8est_checksum(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cuint\n\nCompute the checksum for a forest. Based on quadrant arrays only. It is independent of partition and mpisize. \n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nReference\n\np8est.h:393\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_checksum_partition","page":"Reference","title":"P4est.LibP4est.p8est_checksum_partition","text":"𝐣𝐥.@cextern p8est_checksum_partition(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cuint\n\nCompute a partition-dependent checksum for a forest. \n\nReturns\n\nReturns the checksum on processor 0 only. 0 on other processors.\n\nReference\n\np8est.h:398\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_child_corner_edges","page":"Reference","title":"P4est.LibP4est.p8est_child_corner_edges","text":"𝐣𝐥.@cextern p8est_child_corner_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[8]\n\nStore the edges for each child and corner, can be -1. \n\nReference\n\np8est_connectivity.h:316\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_child_corner_faces","page":"Reference","title":"P4est.LibP4est.p8est_child_corner_faces","text":"𝐣𝐥.@cextern p8est_child_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[8]\n\nStore the faces for each child and corner, can be -1. \n\nReference\n\np8est_connectivity.h:313\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_child_edge_faces","page":"Reference","title":"P4est.LibP4est.p8est_child_edge_faces","text":"𝐣𝐥.@cextern p8est_child_edge_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[12])[8]\n\nStore the faces for each child and edge, can be -1. \n\nReference\n\np8est_connectivity.h:310\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_coarsen","page":"Reference","title":"P4est.LibP4est.p8est_coarsen","text":"𝐣𝐥.@cextern p8est_coarsen(p8est::𝐣𝐥.Ptr{p8est_t}, coarsen_recursive::𝐣𝐥.Cint, coarsen_fn::p8est_coarsen_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid\n\nCoarsen a forest. \n\nParameters\n\np8est:  The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncoarsen_fn: Callback function that returns true if a                        family of quadrants shall be coarsened\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\n\nReference\n\np8est.h:344\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_coarsen_ext","page":"Reference","title":"P4est.LibP4est.p8est_coarsen_ext","text":"𝐣𝐥.@cextern p8est_coarsen_ext(p8est::𝐣𝐥.Ptr{p8est_t}, coarsen_recursive::𝐣𝐥.Cint, callback_orphans::𝐣𝐥.Cint, coarsen_fn::p8est_coarsen_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid\n\nCoarsen a forest. \n\nParameters\n\np8est: The forest is changed in place.\ncoarsen_recursive: Boolean to decide on recursive coarsening.\ncallback_orphans: Boolean to enable calling coarsenfn even on                        non-families.  In this case, the second quadrant                        pointer in the argument list of the callback is NULL,                        subsequent pointers are undefined, and the return                        value is ignored.  If coarsenrecursive is true, it                        is possible that a quadrant is called once or more as                        an orphan and eventually becomes part of a family.                        With coarsenrecursive false and callbackorphans true,                        it is guaranteed that every quadrant is passed exactly                        once into the coarsen_fn callback.\ncoarsen_fn: Callback function that returns true if a                        family of quadrants shall be coarsened.\ninit_fn:    Callback function to initialize the user_data                        which is already allocated automatically.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace.\n\nReference\n\np8est_extended.h:471\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connect_type_int","page":"Reference","title":"P4est.LibP4est.p8est_connect_type_int","text":"𝐣𝐥.@cextern p8est_connect_type_int(btype::p8est_connect_type_t)::𝐣𝐥.Cint\n\nConvert the p8estconnecttype_t into a number. \n\nParameters\n\nbtype:    The balance type to convert.\n\nReturns\n\n          Returns 1, 2 or 3.\n\nReference\n\np8est_connectivity.h:115\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connect_type_string","page":"Reference","title":"P4est.LibP4est.p8est_connect_type_string","text":"𝐣𝐥.@cextern p8est_connect_type_string(btype::p8est_connect_type_t)::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}\n\nConvert the p8estconnecttype_t into a const string. \n\nParameters\n\nbtype:    The balance type to convert.\n\nReturns\n\n          Returns a pointer to a constant string.\n\nReference\n\np8est_connectivity.h:121\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_bcast","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_bcast","text":"𝐣𝐥.@cextern p8est_connectivity_bcast(conn_in::𝐣𝐥.Ptr{p8est_connectivity_t}, root::𝐣𝐥.Cint, comm::sc_MPI_Comm)::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nBroadcast a connectivity structure that exists only on one process to all.  On the other processors, it will be allocated using p8estconnectivitynew.  \n\nParameters\n\nconn_in: For the root process the connectivity to be broadcast,                      for the other processes it must be NULL.\nroot:    The rank of the process that provides the connectivity.\ncomm:    The MPI communicator.\n\nReturns\n\n         For the root process this is a pointer to *conn_in.*                      Else, a pointer to a newly allocated connectivity                      structure with the same values as *conn_in* on the                      root process.\n\nReference\n\np8est_connectivity.h:457\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_complete","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_complete","text":"𝐣𝐥.@cextern p8est_connectivity_complete(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid\n\nInternally connect a connectivity based on treetovertex information. Periodicity that is not inherent in the list of vertices will be lost. \n\nParameters\n\nconn:     The connectivity needs to have proper vertices                          and treetovertex fields.  The treetotree                          and treetoface fields must be allocated                          and satisfy p8estconnectivityis_valid (conn)                          but will be overwritten.  The edge and corner                          fields will be freed and allocated anew.\n\nReference\n\np8est_connectivity.h:704\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_deflate","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_deflate","text":"𝐣𝐥.@cextern p8est_connectivity_deflate(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, code::p8est_connectivity_encode_t)::𝐣𝐥.Ptr{sc_array_t}\n\nAllocate memory and store the connectivity information there. \n\nParameters\n\nconn:     The connectivity structure to be exported to memory.\ncode:     Encoding and compression method for serialization.\n\nReturns\n\n          Newly created array that contains the information.\n\nReference\n\np8est_connectivity.h:501\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_destroy","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_destroy","text":"𝐣𝐥.@cextern p8est_connectivity_destroy(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid\n\nDestroy a connectivity structure.  Also destroy all attributes.\n\nReference\n\np8est_connectivity.h:463\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_edge_neighbor_corner","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_edge_neighbor_corner","text":"𝐣𝐥.@cextern p8est_connectivity_edge_neighbor_corner(c::𝐣𝐥.Cint, e::𝐣𝐥.Cint, ne::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a corner across one of the adjacent edges into a neighbor tree. This version expects the neighbor edge and orientation separately. \n\nParameters\n\nc:    A corner number in 0..7.\ne:    An edge 0..11 that touches the corner c.\nne:   A neighbor edge that is on the other side of .\no:    The orientation between tree boundary edges e and .\n\nReturns\n\n      Corner number seen from the neighbor.\n\nReference\n\np8est_connectivity.h:392\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_edge_neighbor_edge_corner","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_edge_neighbor_edge_corner","text":"𝐣𝐥.@cextern p8est_connectivity_edge_neighbor_edge_corner(ec::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform an edge corner across one of the adjacent edges into a neighbor tree. \n\nParameters\n\nec:   An edge corner number in 0..1.\no:    The orientation of a tree boundary edge connection.\n\nReturns\n\n      The edge corner number seen from the other tree.\n\nReference\n\np8est_connectivity.h:381\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_corner","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_corner","text":"𝐣𝐥.@cextern p8est_connectivity_face_neighbor_corner(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. \n\nParameters\n\nc:    A corner number in 0..7.\nf:    A face number that touches the corner c.\nnf:   A neighbor face that is on the other side of nothing.\no:    The orientation between tree boundary faces f and nothing.\n\nReturns\n\n      The number of the corner seen from the neighbor tree.\n\nReference\n\np8est_connectivity.h:351\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_corner_set","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_corner_set","text":"𝐣𝐥.@cextern p8est_connectivity_face_neighbor_corner_set(c::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, set::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a corner across one of the adjacent faces into a neighbor tree. It expects a face permutation index that has been precomputed. \n\nParameters\n\nc:    A corner number in 0..7.\nf:    A face number that touches the corner c.\nnf:   A neighbor face that is on the other side of nothing.\nset:  A value from p8estfacepermutation_sets that is                  obtained using f, nf, and a valid orientation:                  ref = p8estfacepermutationrefs[f][nf];                  set = p8estfacepermutationsets[ref][orientation];\n\nReturns\n\n      The corner number in 0..7 seen from the other face.\n\nReference\n\np8est_connectivity.h:329\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_edge","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_edge","text":"𝐣𝐥.@cextern p8est_connectivity_face_neighbor_edge(e::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform an edge across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. \n\nParameters\n\ne:    A edge number in 0..11.\nf:    A face 0..5 that touches the edge e.\nnf:   A neighbor face that is on the other side of nothing.\no:    The orientation between tree boundary faces f and nothing.\n\nReturns\n\n      The edge's number seen from the neighbor.\n\nReference\n\np8est_connectivity.h:373\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_face_corner","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_face_corner","text":"𝐣𝐥.@cextern p8est_connectivity_face_neighbor_face_corner(fc::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a face corner across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. \n\nParameters\n\nfc:   A face corner number in 0..3.\nf:    A face that the face corner fc is relative to.\nnf:   A neighbor face that is on the other side of nothing.\no:    The orientation between tree boundary faces f and nothing.\n\nReturns\n\n      The face corner number relative to the neighbor's face.\n\nReference\n\np8est_connectivity.h:340\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_face_neighbor_face_edge","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_face_neighbor_face_edge","text":"𝐣𝐥.@cextern p8est_connectivity_face_neighbor_face_edge(fe::𝐣𝐥.Cint, f::𝐣𝐥.Cint, nf::𝐣𝐥.Cint, o::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nTransform a face-edge across one of the adjacent faces into a neighbor tree. This version expects the neighbor face and orientation separately. \n\nParameters\n\nfe:   A face edge number in 0..3.\nf:    A face number that touches the edge e.\nnf:   A neighbor face that is on the other side of nothing.\no:    The orientation between tree boundary faces f and nothing.\n\nReturns\n\n      The face edge number seen from the neighbor tree.\n\nReference\n\np8est_connectivity.h:362\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_inflate","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_inflate","text":"𝐣𝐥.@cextern p8est_connectivity_inflate(buffer::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate new connectivity from a memory buffer. \n\nParameters\n\nbuffer:   The connectivity is created from this memory buffer.\n\nReturns\n\n          The newly created connectivity, or NULL on error.\n\nReference\n\np8est_connectivity.h:524\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_is_equal","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_is_equal","text":"𝐣𝐥.@cextern p8est_connectivity_is_equal(conn1::𝐣𝐥.Ptr{p8est_connectivity_t}, conn2::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint\n\nCheck two connectivity structures for equality. \n\nReturns\n\n      Returns true if structures are equal, false otherwise.\n\nReference\n\np8est_connectivity.h:484\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_is_equivalent","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_is_equivalent","text":"𝐣𝐥.@cextern p8est_connectivity_is_equivalent(conn1::𝐣𝐥.Ptr{p8est_connectivity_t}, conn2::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint\n\np8estconnectivityis_equivalent This function compares two connectivities for equivalence: it returns true if they are the same connectivity, or if they have the same topology.  The definition of topological sameness is strict: there is no attempt made to determine whether permutation and/or rotation of the trees makes the connectivities equivalent.\n\nParameters\n\nconn1:    a valid connectivity\nconn2:    a valid connectivity\n\nReference\n\np8est_connectivity.h:794\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_is_valid","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_is_valid","text":"𝐣𝐥.@cextern p8est_connectivity_is_valid(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint\n\nExamine a connectivity structure. \n\nReturns\n\nReturns true if structure is valid, false otherwise.\n\nReference\n\np8est_connectivity.h:478\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_join_faces","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_join_faces","text":"𝐣𝐥.@cextern p8est_connectivity_join_faces(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, tree_left::p4est_topidx_t, tree_right::p4est_topidx_t, face_left::𝐣𝐥.Cint, face_right::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\np8estconnectivityjoin_faces This function takes an existing valid connectivity conn and modifies it by joining two tree faces that are currently boundary faces. \n\nParameters\n\nconn:        connectivity that will be altered.\ntree_left:   tree that will be on the left side of the joined                             faces.\ntree_right:  tree that will be on the right side of the                             joined faces.\nface_left:   face of tree_left that will be joined.\nface_right:  face of tree_right that will be joined.\norientation: the orientation of face_left and                             face_right once joined (see the description                             of p8estconnectivityt to understand                             orientation).\n\nReference\n\np8est_connectivity.h:776\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_load","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_load","text":"𝐣𝐥.@cextern p8est_connectivity_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, bytes::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nLoad a connectivity structure from disk. \n\nParameters\n\nfilename:         Name of the file to read.\nbytes:           Size in bytes of connectivity on disk or NULL.\n\nReturns\n\n          Returns valid connectivity, or NULL on file error.\n\nReference\n\np8est_connectivity.h:531\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_memory_used","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_memory_used","text":"𝐣𝐥.@cextern p8est_connectivity_memory_used(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::size_t\n\nCalculate memory usage of a connectivity structure. \n\nParameters\n\nconn:   Connectivity structure.\n\nReturns\n\n        Memory used in bytes.\n\nReference\n\np8est_connectivity.h:217\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new","text":"𝐣𝐥.@cextern p8est_connectivity_new(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_edges::p4est_topidx_t, num_ett::p4est_topidx_t, num_corners::p4est_topidx_t, num_ctt::p4est_topidx_t)::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nAllocate a connectivity structure. The attribute fields are initialized to NULL. \n\nParameters\n\nnum_vertices:   Number of total vertices (i.e. geometric points).\nnum_trees:      Number of trees in the forest.\nnum_edges:      Number of tree-connecting edges.\nnum_ett:        Number of total trees in edgetotree array.\nnum_corners:    Number of tree-connecting corners.\nnum_ctt:        Number of total trees in cornertotree array.\n\nReturns\n\n                A connectivity structure with allocated arrays.\n\nReference\n\np8est_connectivity.h:405\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_brick","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_brick","text":"𝐣𝐥.@cextern p8est_connectivity_new_brick(m::𝐣𝐥.Cint, n::𝐣𝐥.Cint, p::𝐣𝐥.Cint, periodic_a::𝐣𝐥.Cint, periodic_b::𝐣𝐥.Cint, periodic_c::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nAn m by n by p array with periodicity in x, y, and z if periodica, periodicb, and periodic_c are true, respectively.\n\nReference\n\np8est_connectivity.h:575\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_byname","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_byname","text":"𝐣𝐥.@cextern p8est_connectivity_new_byname(name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate connectivity structure from predefined catalogue. \n\nParameters\n\nname:            Invokes connectivitynew* function.              brick235        brick (2, 3, 5, 0, 0, 0)              periodic        periodic              rotcubes        rotcubes              rotwrap         rotwrap              shell           shell              sphere          sphere              twocubes        twocubes              twowrap         twowrap              unit            unitcube\n\nReturns\n\n  An initialized connectivity if name is defined, NULL else.\n\nReference\n\np8est_connectivity.h:623\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_copy","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_copy","text":"𝐣𝐥.@cextern p8est_connectivity_new_copy(num_vertices::p4est_topidx_t, num_trees::p4est_topidx_t, num_edges::p4est_topidx_t, num_corners::p4est_topidx_t, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cdouble)}, ttv::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ttf::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, tte::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, eoff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ett::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ete::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)}, ttc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, coff::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p4est_topidx_t)}, ctc::𝐣𝐥.Ptr{𝐣𝐥.Cconst(int8_t)})::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nAllocate a connectivity structure and populate from constants. The attribute fields are initialized to NULL. \n\nParameters\n\nnum_vertices:   Number of total vertices (i.e. geometric points).\nnum_trees:      Number of trees in the forest.\nnum_edges:      Number of tree-connecting edges.\nnum_corners:    Number of tree-connecting corners.\neoff:           Edge-to-tree offsets (numedges + 1 values).                            This must always be non-NULL; in trivial cases                            it is just a pointer to a p4esttopix value of 0.\ncoff:           Corner-to-tree offsets (numcorners + 1 values).                            This must always be non-NULL; in trivial cases                            it is just a pointer to a p4esttopix value of 0.\n\nReturns\n\n                The connectivity is checked for validity.\n\nReference\n\np8est_connectivity.h:426\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_periodic","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_periodic","text":"𝐣𝐥.@cextern p8est_connectivity_new_periodic()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure for an all-periodic unit cube.\n\nReference\n\np8est_connectivity.h:540\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_rotcubes","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_rotcubes","text":"𝐣𝐥.@cextern p8est_connectivity_new_rotcubes()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure that contains a few cubes. These are rotated against each other to stress the topology routines.\n\nReference\n\np8est_connectivity.h:570\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_rotwrap","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_rotwrap","text":"𝐣𝐥.@cextern p8est_connectivity_new_rotwrap()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure for a mostly periodic unit cube. The left and right faces are identified, and bottom and top rotated. Front and back are not identified.\n\nReference\n\np8est_connectivity.h:546\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_shell","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_shell","text":"𝐣𝐥.@cextern p8est_connectivity_new_shell()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure that builds a spherical shell. It is made up of six connected parts [-1,1]x[-1,1]x[1,2]. This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8estconnectivitycomplete.\n\nReference\n\np8est_connectivity.h:585\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_sphere","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_sphere","text":"𝐣𝐥.@cextern p8est_connectivity_new_sphere()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure that builds a solid sphere. It is made up of two layers and a cube in the center. This connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8estconnectivitycomplete.\n\nReference\n\np8est_connectivity.h:592\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_torus","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_torus","text":"𝐣𝐥.@cextern p8est_connectivity_new_torus(nSegments::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure that builds a revolution torus.\n\nDetails\n\nThis connectivity reuses vertices and relies on a geometry transformation. It is thus not suitable for p8estconnectivitycomplete.\n\nThis connectivity reuses ideas from disk2d connectivity. More precisely the torus is divided into segments arround the revolution axis, each segments is made of 5 trees (à la disk2d). The total number of trees if 5 times the number of segments.\n\nThis connectivity is meant to be used with p8estgeometrynew_torus\n\nParameters\n\nnSegments: number of trees along the great circle\n\nReference\n\np8est_connectivity.h:608\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_twocubes","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_twocubes","text":"𝐣𝐥.@cextern p8est_connectivity_new_twocubes()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure that contains two cubes.\n\nReference\n\np8est_connectivity.h:550\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_twotrees","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_twotrees","text":"𝐣𝐥.@cextern p8est_connectivity_new_twotrees(l_face::𝐣𝐥.Cint, r_face::𝐣𝐥.Cint, orientation::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure for two trees being rotated w.r.t. each other in a user-defined way. \n\nParameters\n\nl_face:      index of left face\nr_face:      index of right face\norientation: orientation of trees w.r.t. each other\n\nReference\n\np8est_connectivity.h:558\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_twowrap","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_twowrap","text":"𝐣𝐥.@cextern p8est_connectivity_new_twowrap()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure that contains two cubes where the two far ends are identified periodically.\n\nReference\n\np8est_connectivity.h:565\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_new_unitcube","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_new_unitcube","text":"𝐣𝐥.@cextern p8est_connectivity_new_unitcube()::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a connectivity structure for the unit cube.\n\nReference\n\np8est_connectivity.h:536\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_permute","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_permute","text":"𝐣𝐥.@cextern p8est_connectivity_permute(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, perm::𝐣𝐥.Ptr{sc_array_t}, is_current_to_new::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\np8estconnectivitypermute Given a permutation perm of the trees in a connectivity conn, permute the trees of conn in place and update conn to match. \n\nParameters\n\nconn:                The connectivity whose trees are                                     permuted.\nperm:                    A permutation array, whose elements are                                     size_t's.\nis_current_to_new:       if true, the jth entry of perm is the                                     new index for the entry whose current                                     index is j, otherwise the jth entry of                                     perm is the current index of the tree                                     whose index will be j after the                                     permutation.\n\nReference\n\np8est_connectivity.h:727\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_read_inp","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_read_inp","text":"𝐣𝐥.@cextern p8est_connectivity_read_inp(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nCreate a p4est connectivity from an ABAQUS input file.\n\nDetails\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below.  The *Node section gives the vertex number and x, y, and z components for each vertex.  The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4                     3   +–––––––––-+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +–––––––––-+   1                   2\n\nand in 3D they are given as:\n\n8                     7  +––––––––––-+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+––––––––––-+6  |    |                |    |  +––|––––––––+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +––––––––––-+       1                     2\n\n *Heading\n  box.inp\n *Node\n     1,    5,   -5,    5\n     2,    5,    5,    5\n     3,    5,    0,    5\n     4,   -5,    5,    5\n     5,    0,    5,    5\n     6,   -5,   -5,    5\n     7,   -5,    0,    5\n     8,    0,   -5,    5\n     9,    0,    0,    5\n    10,    5,    5,   -5\n    11,    5,   -5,   -5\n    12,    5,    0,   -5\n    13,   -5,   -5,   -5\n    14,    0,   -5,   -5\n    15,   -5,    5,   -5\n    16,   -5,    0,   -5\n    17,    0,    5,   -5\n    18,    0,    0,   -5\n    19,   -5,   -5,    0\n    20,    5,   -5,    0\n    21,    0,   -5,    0\n    22,   -5,    5,    0\n    23,   -5,    0,    0\n    24,    5,    5,    0\n    25,    0,    5,    0\n    26,    5,    0,    0\n    27,    0,    0,    0\n *Element, type=C3D8, ELSET=EB1\n     1,       6,      19,      23,       7,       8,      21,      27,       9\n     2,      19,      13,      16,      23,      21,      14,      18,      27\n     3,       7,      23,      22,       4,       9,      27,      25,       5\n     4,      23,      16,      15,      22,      27,      18,      17,      25\n     5,       8,      21,      27,       9,       1,      20,      26,       3\n     6,      21,      14,      18,      27,      20,      11,      12,      26\n     7,       9,      27,      25,       5,       3,      26,      24,       2\n     8,      27,      18,      17,      25,      26,      12,      10,      24\n\nThis function reads a mesh from filename and returns an associated p4est connectivity.\n\nParameters\n\nfilename:         file to read the connectivity from\n\nReturns\n\nan allocated connectivity associated with the mesh in filename \n\nReference\n\np8est_connectivity.h:1021\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_read_inp_stream","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_read_inp_stream","text":"𝐣𝐥.@cextern p8est_connectivity_read_inp_stream(stream::𝐣𝐥.Ptr{FILE}, num_vertices::𝐣𝐥.Ptr{p4est_topidx_t}, num_trees::𝐣𝐥.Ptr{p4est_topidx_t}, vertices::𝐣𝐥.Ptr{𝐣𝐥.Cdouble}, tree_to_vertex::𝐣𝐥.Ptr{p4est_topidx_t})::𝐣𝐥.Cint\n\nRead an ABAQUS input file from a file stream.\n\nDetails\n\nThis utility function reads a basic ABAQUS file supporting element type with the prefix C2D4, CPS4, and S4 in 2D and of type C3D8 reading them as bilinear quadrilateral and trilinear hexahedral trees respectively.\n\nA basic 2D mesh is given below.  The *Node section gives the vertex number and x, y, and z components for each vertex.  The *Element section gives the 4 vertices in 2D (8 vertices in 3D) of each element in counter clockwise order. So in 2D the nodes are given as:\n\n4                     3   +–––––––––-+   |                   |   |                   |   |                   |   |                   |   |                   |   |                   |   +–––––––––-+   1                   2\n\nand in 3D they are given as:\n\n8                     7  +––––––––––-+  |\\                    |\\  | \\                   | \\  |  \\                  |  \\  |   \\                 |   \\  |   5+––––––––––-+6  |    |                |    |  +––|––––––––+    |  4\\   |               3 \\   |    \\  |                  \\  |     \\ |                   \\ |      \\|                    \\|       +––––––––––-+       1                     2\n\n *Heading\n  box.inp\n *Node\n     1,    5,   -5,    5\n     2,    5,    5,    5\n     3,    5,    0,    5\n     4,   -5,    5,    5\n     5,    0,    5,    5\n     6,   -5,   -5,    5\n     7,   -5,    0,    5\n     8,    0,   -5,    5\n     9,    0,    0,    5\n    10,    5,    5,   -5\n    11,    5,   -5,   -5\n    12,    5,    0,   -5\n    13,   -5,   -5,   -5\n    14,    0,   -5,   -5\n    15,   -5,    5,   -5\n    16,   -5,    0,   -5\n    17,    0,    5,   -5\n    18,    0,    0,   -5\n    19,   -5,   -5,    0\n    20,    5,   -5,    0\n    21,    0,   -5,    0\n    22,   -5,    5,    0\n    23,   -5,    0,    0\n    24,    5,    5,    0\n    25,    0,    5,    0\n    26,    5,    0,    0\n    27,    0,    0,    0\n *Element, type=C3D8, ELSET=EB1\n     1,       6,      19,      23,       7,       8,      21,      27,       9\n     2,      19,      13,      16,      23,      21,      14,      18,      27\n     3,       7,      23,      22,       4,       9,      27,      25,       5\n     4,      23,      16,      15,      22,      27,      18,      17,      25\n     5,       8,      21,      27,       9,       1,      20,      26,       3\n     6,      21,      14,      18,      27,      20,      11,      12,      26\n     7,       9,      27,      25,       5,       3,      26,      24,       2\n     8,      27,      18,      17,      25,      26,      12,      10,      24\n\nThis code can be called two ways.  The first, when vertex==NULL and tree_to_vertex==NULL, is used to count the number of trees and vertices in the connectivity to be generated by the .inp mesh in the stream.  The second, when vertices!=NULL and tree_to_vertex!=NULL, fill vertices and tree_to_vertex.  In this case num_vertices and num_trees need to be set to the maximum number of entries allocated in vertices and tree_to_vertex.\n\nParameters\n\nstream:         file stream to read the connectivity from\nnum_vertices:   the number of vertices in the connectivity\nnum_trees:      the number of trees in the connectivity\nvertices:       the list of vertices of the connectivity\ntree_to_vertex: the tree_to_vertex map of the connectivity\n\nReturns\n\n0 if successful and nonzero if not\n\nReference\n\np8est_connectivity.h:923\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_reduce","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_reduce","text":"𝐣𝐥.@cextern p8est_connectivity_reduce(conn::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cvoid\n\nRemoves corner and edge information of a connectivity  such that enough information is left to run p8estconnectivitycomplete successfully.  The reduced connectivity still passes p8estconnectivityis_valid. \n\nParameters\n\nconn:     The connectivity to be reduced.\n\nReference\n\np8est_connectivity.h:711\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_refine","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_refine","text":"𝐣𝐥.@cextern p8est_connectivity_refine(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, num_per_edge::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nUniformly refine a connectivity. This is useful if you would like to uniformly refine by something other than a power of 2.\n\nParameters\n\nconn:         A valid connectivity\nnum_per_edge: The number of new trees in each direction.                      Must use no more than P8ESTOLDQMAXLEVEL bits.\n\nReturns\n\na refined connectivity.\n\nReference\n\np8est_connectivity.h:635\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_save","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_save","text":"𝐣𝐥.@cextern p8est_connectivity_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t})::𝐣𝐥.Cint\n\nSave a connectivity structure to disk. \n\nParameters\n\nfilename:         Name of the file to write.\nconnectivity:     Valid connectivity structure.\n\nReturns\n\n                  Returns 0 on success, nonzero on file error.\n\nReference\n\np8est_connectivity.h:510\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_set_attr","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_set_attr","text":"𝐣𝐥.@cextern p8est_connectivity_set_attr(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, bytes_per_tree::size_t)::𝐣𝐥.Cvoid\n\nAllocate or free the attribute fields in a connectivity. \n\nParameters\n\nconn:         The conn->*toattr fields must either be NULL                              or previously be allocated by this function.\nbytes_per_tree:   If 0, treetoattr is freed (being NULL is ok).                              If positive, requested space is allocated.\n\nReference\n\np8est_connectivity.h:472\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_sink","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_sink","text":"𝐣𝐥.@cextern p8est_connectivity_sink(conn::𝐣𝐥.Ptr{p8est_connectivity_t}, sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint\n\nWrite connectivity to a sink object. \n\nParameters\n\nconn:     The connectivity to be written.\nsink: The connectivity is written into this sink.\n\nReturns\n\n          0 on success, nonzero on error.\n\nReference\n\np8est_connectivity.h:493\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_connectivity_source","page":"Reference","title":"P4est.LibP4est.p8est_connectivity_source","text":"𝐣𝐥.@cextern p8est_connectivity_source(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Ptr{p8est_connectivity_t}\n\nRead connectivity from a source object. \n\nParameters\n\nsource:       The connectivity is read from this source.\n\nReturns\n\n          The newly created connectivity, or NULL on error.\n\nReference\n\np8est_connectivity.h:518\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_copy","page":"Reference","title":"P4est.LibP4est.p8est_copy","text":"𝐣𝐥.@cextern p8est_copy(input::𝐣𝐥.Ptr{p8est_t}, copy_data::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_t}\n\nMake a deep copy of a p8est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:  If true, data are copied.                         If false, data_size is set to 0.\n\nReturns\n\nReturns a valid p8est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.\n\nReference\n\np8est.h:296\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_copy_ext","page":"Reference","title":"P4est.LibP4est.p8est_copy_ext","text":"𝐣𝐥.@cextern p8est_copy_ext(input::𝐣𝐥.Ptr{p8est_t}, copy_data::𝐣𝐥.Cint, duplicate_mpicomm::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_t}\n\nMake a deep copy of a p8est. The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL. The revision counter of the copy is set to zero.\n\nParameters\n\ncopy_data:  If true, data are copied.                         If false, data_size is set to 0.\nduplicate_mpicomm:  If true, MPI communicator is copied.\n\nReturns\n\nReturns a valid p8est that does not depend on the input,                         except for borrowing the same connectivity.                         Its revision counter is 0.\n\nReference\n\np8est_extended.h:420\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_corner_edge_corners","page":"Reference","title":"P4est.LibP4est.p8est_corner_edge_corners","text":"𝐣𝐥.@cextern p8est_corner_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[12])[8]\n\nStore the edge corner numbers for the edges touching a tree corner.    Is -1 for invalid combinations. \n\nReference\n\np8est_connectivity.h:307\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_corner_edges","page":"Reference","title":"P4est.LibP4est.p8est_corner_edges","text":"𝐣𝐥.@cextern p8est_corner_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[3])[8]\n\nStore the edge numbers 0..11 for each tree corner. \n\nReference\n\np8est_connectivity.h:299\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_corner_face_corners","page":"Reference","title":"P4est.LibP4est.p8est_corner_face_corners","text":"𝐣𝐥.@cextern p8est_corner_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[8]\n\nStore the face corner numbers for the faces touching a tree corner.    Is -1 for invalid combinations. \n\nReference\n\np8est_connectivity.h:303\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_corner_faces","page":"Reference","title":"P4est.LibP4est.p8est_corner_faces","text":"𝐣𝐥.@cextern p8est_corner_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[3])[8]\n\nStore the face numbers 0..5 for each tree corner. \n\nReference\n\np8est_connectivity.h:296\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_destroy","page":"Reference","title":"P4est.LibP4est.p8est_destroy","text":"𝐣𝐥.@cextern p8est_destroy(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Cvoid\n\nDestroy a p8est.\n\nDetails\n\nNOTE: The connectivity structure is not destroyed with the p8est.\n\nReference\n\np8est.h:281\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_edge_corners","page":"Reference","title":"P4est.LibP4est.p8est_edge_corners","text":"𝐣𝐥.@cextern p8est_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[12]\n\nStore the corner numbers 0..8 for each tree edge. \n\nReference\n\np8est_connectivity.h:281\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_edge_edge_corners","page":"Reference","title":"P4est.LibP4est.p8est_edge_edge_corners","text":"𝐣𝐥.@cextern p8est_edge_edge_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[8])[12]\n\nStore the edge corner numbers 0..1 for the corners touching a tree edge    or -1 if combination is invalid \n\nReference\n\np8est_connectivity.h:285\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_edge_face_corners","page":"Reference","title":"P4est.LibP4est.p8est_edge_face_corners","text":"𝐣𝐥.@cextern p8est_edge_face_corners::((𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[6])[12]\n\nStore the face corner numbers 0..3 for the faces touching a tree edge.    Is -1 for invalid combinations of indices \n\nReference\n\np8est_connectivity.h:289\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_edge_face_edges","page":"Reference","title":"P4est.LibP4est.p8est_edge_face_edges","text":"𝐣𝐥.@cextern p8est_edge_face_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[12]\n\nStore the face edge numbers 0..3 for the faces touching a tree edge.    Is -1 for invalid combinations of indices \n\nReference\n\np8est_connectivity.h:293\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_edge_faces","page":"Reference","title":"P4est.LibP4est.p8est_edge_faces","text":"𝐣𝐥.@cextern p8est_edge_faces::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[2])[12]\n\nStore the face numbers 0..5 adjacent to each tree edge. \n\nReference\n\np8est_connectivity.h:278\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_expand_face_transform","page":"Reference","title":"P4est.LibP4est.p8est_expand_face_transform","text":"𝐣𝐥.@cextern p8est_expand_face_transform(iface::𝐣𝐥.Cint, nface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::𝐣𝐥.Cvoid\n\nFill an array with the axis combination of a face neighbor transform. \n\nParameters\n\niface:       The number of the originating face.\nnface:       Encoded as nface = r * 6 + nf, where nf = 0..5 is                          the neigbbor's connecting face number and r = 0..3                          is the relative orientation to the neighbor's face.                          This encoding matches p8estconnectivityt.\nftransform:  This array holds 9 integers.              [0]..[2]    The coordinate axis sequence of the origin face,                          the first two referring to the tangentials and the                          third to the normal.  A permutation of (0, 1, 2).              [3]..[5]    The coordinate axis sequence of the target face.              [6]..[8]    Edge reversal flags for tangential axes (boolean);                          face code in [0, 3] for the normal coordinate q:                          0: q' = -q                          1: q' = q + 1                          2: q' = q - 1                          3: q' = 2 - q\n\nReference\n\np8est_connectivity.h:656\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_corners","page":"Reference","title":"P4est.LibP4est.p8est_face_corners","text":"𝐣𝐥.@cextern p8est_face_corners::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[6]\n\nStore the corner numbers 0..7 for each tree face. \n\nReference\n\np8est_connectivity.h:249\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_dual","page":"Reference","title":"P4est.LibP4est.p8est_face_dual","text":"𝐣𝐥.@cextern p8est_face_dual::𝐣𝐥.Cconst(𝐣𝐥.Cint)[6]\n\nStore the face numbers in the face neighbor's system. \n\nReference\n\np8est_connectivity.h:255\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_edge_permutation_sets","page":"Reference","title":"P4est.LibP4est.p8est_face_edge_permutation_sets","text":"𝐣𝐥.@cextern p8est_face_edge_permutation_sets::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[3]\n\nStore the 3 occurring sets of 4 permutations per face. \n\nReference\n\np8est_connectivity.h:275\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_edge_permutations","page":"Reference","title":"P4est.LibP4est.p8est_face_edge_permutations","text":"𝐣𝐥.@cextern p8est_face_edge_permutations::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[8]\n\nStore only the 8 out of 24 possible permutations that occur. \n\nReference\n\np8est_connectivity.h:272\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_edges","page":"Reference","title":"P4est.LibP4est.p8est_face_edges","text":"𝐣𝐥.@cextern p8est_face_edges::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[6]\n\nStore the edge numbers 0..12 for each tree face. \n\nReference\n\np8est_connectivity.h:252\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_permutation_refs","page":"Reference","title":"P4est.LibP4est.p8est_face_permutation_refs","text":"𝐣𝐥.@cextern p8est_face_permutation_refs::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[6])[6]\n\nFor each face combination store the permutation set. The order is [myface][neighborface] \n\nReference\n\np8est_connectivity.h:267\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_permutation_sets","page":"Reference","title":"P4est.LibP4est.p8est_face_permutation_sets","text":"𝐣𝐥.@cextern p8est_face_permutation_sets::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[3]\n\nStore the 3 occurring sets of 4 permutations per face. \n\nReference\n\np8est_connectivity.h:263\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_permutations","page":"Reference","title":"P4est.LibP4est.p8est_face_permutations","text":"𝐣𝐥.@cextern p8est_face_permutations::(𝐣𝐥.Cconst(𝐣𝐥.Cint)[4])[8]\n\nStore only the 8 out of 24 possible permutations that occur. \n\nReference\n\np8est_connectivity.h:260\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_face_quadrant_exists","page":"Reference","title":"P4est.LibP4est.p8est_face_quadrant_exists","text":"𝐣𝐥.@cextern p8est_face_quadrant_exists(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, face::𝐣𝐥.Ptr{𝐣𝐥.Cint}, hang::𝐣𝐥.Ptr{𝐣𝐥.Cint}, owner_rank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::p4est_locidx_t\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nDetails\n\nFor quadrants across tree boundaries it checks if the quadrant exists across any face, but not across edges or corners.\n\nParameters\n\np8est:        The forest in which to search for q.\nghost:        The ghost layer in which to search for q.\ntreeid:       The tree to which q belongs.\nq:            The quadrant that is being searched for.\nface:      On input, face id across which q was created.                           On output, the neighbor's face number augmented                           by orientation, so face is in 0..23.\nhang:      If not NULL, signals that q is bigger than                           the quadrant it came from.  The child id                           of that originating quadrant is passed into hang.                           On output, hang holds the hanging face number                           of q that is in contact with its originator.\nowner_rank:   Filled with the rank of the owner if it is found                           and undefined otherwise.\n\nReturns\n\n  Returns the local number of *q* if the quadrant exists              in the local forest or in the ghost_layer.  Otherwise,              returns -2 for a domain boundary and -1 if not found.\n\nReference\n\np8est_ghost.h:184\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_find_corner_transform","page":"Reference","title":"P4est.LibP4est.p8est_find_corner_transform","text":"𝐣𝐥.@cextern p8est_find_corner_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, icorner::𝐣𝐥.Cint, ci::𝐣𝐥.Ptr{p8est_corner_info_t})::𝐣𝐥.Cvoid\n\nFills an array with information about corner neighbors. \n\nParameters\n\nitree:    The number of the originating tree.\nicorner:  The number of the originating corner.\nci:   A p8estcornerinfo_t structure with initialized array.\n\nReference\n\np8est_connectivity.h:689\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_find_edge_transform","page":"Reference","title":"P4est.LibP4est.p8est_find_edge_transform","text":"𝐣𝐥.@cextern p8est_find_edge_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, iedge::𝐣𝐥.Cint, ei::𝐣𝐥.Ptr{p8est_edge_info_t})::𝐣𝐥.Cvoid\n\nFills an array with information about edge neighbors. \n\nParameters\n\nitree:    The number of the originating tree.\niedge:    The number of the originating edge.\nei:   A p8estedgeinfo_t structure with initialized array.\n\nReference\n\np8est_connectivity.h:678\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_find_face_transform","page":"Reference","title":"P4est.LibP4est.p8est_find_face_transform","text":"𝐣𝐥.@cextern p8est_find_face_transform(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, itree::p4est_topidx_t, iface::𝐣𝐥.Cint, ftransform::𝐣𝐥.Cint[])::p4est_topidx_t\n\nFill an array with the axis combination of a face neighbor transform. \n\nParameters\n\nitree:       The number of the originating tree.\niface:       The number of the originating tree's face.\nftransform:  This array holds 9 integers.              [0]..[2]    The coordinate axis sequence of the origin face.              [3]..[5]    The coordinate axis sequence of the target face.              [6]..[8]    Edge reverse flag for axes t1, t2; face code for n.\n\nReturns\n\n              The face neighbor tree if it exists, -1 otherwise.\n\nReference\n\np8est_connectivity.h:668\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_get_plex_data_ext","page":"Reference","title":"P4est.LibP4est.p8est_get_plex_data_ext","text":"𝐣𝐥.@cextern p8est_get_plex_data_ext(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_ghost_t}}, lnodes::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_lnodes_t}}, ctype::p8est_connect_type_t, overlap::𝐣𝐥.Cint, first_local_quad::𝐣𝐥.Ptr{p4est_locidx_t}, out_points_per_dim::𝐣𝐥.Ptr{sc_array_t}, out_cone_sizes::𝐣𝐥.Ptr{sc_array_t}, out_cones::𝐣𝐥.Ptr{sc_array_t}, out_cone_orientations::𝐣𝐥.Ptr{sc_array_t}, out_vertex_coords::𝐣𝐥.Ptr{sc_array_t}, out_children::𝐣𝐥.Ptr{sc_array_t}, out_parents::𝐣𝐥.Ptr{sc_array_t}, out_childids::𝐣𝐥.Ptr{sc_array_t}, out_leaves::𝐣𝐥.Ptr{sc_array_t}, out_remotes::𝐣𝐥.Ptr{sc_array_t}, custom_numbering::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nCreate the data necessary to create a PETsc DMPLEX representation of a forest, as well as the accompanying lnodes and ghost layer.  The forest must be at least face balanced (see p4estbalance()).  See test/testplex2.c for example usage.\n\nDetails\n\nAll arrays should be initialized to hold sizeof (p4estlocidxt), except for out_remotes, which should be initialized to hold (2 * sizeof (p4estlocidxt)).\n\nParameters\n\np8est:                 the forest\nghost:                 the ghost layer\nlnodes:                the lnodes\nctype:                 the type of adjacency for the overlap\noverlap:               the number of layers of overlap (zero                                      is acceptable)\nfirst_local_quad:      the local quadrants are assigned                                      contiguous plex indices, starting with                                      this index\nout_points_per_dim:    filled with argument for                                      DMPlexCreateFromDAG()\nout_cone_sizes:        filled with argument for                                      DMPlexCreateFromDAG()\nout_cones:             filled with argument for                                      DMPlexCreateFromDAG()\nout_cone_orientations: filled with argument for                                      DMPlexCreateFromDAG()\nout_vertex_coords:     filled with argument for                                      DMPlexCreateFromDAG()\nout_children:          filled with argument for                                      DMPlexSetTree()\nout_parents:           filled with argument for                                      DMPlexSetTree()\nout_childids:          filled with argument for                                      DMPlexSetTree()\nout_leaves:            filled with argument for                                      PetscSFSetGraph()\nout_remotes:           filled with argument for                                      PetscSFSetGraph()\ncustom_numbering:      Whether or use the default numbering                                      (0) of DMPlex child ids or the custom                                      (1).\n\nReference\n\np8est_extended.h:641\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_bsearch","page":"Reference","title":"P4est.LibP4est.p8est_ghost_bsearch","text":"𝐣𝐥.@cextern p8est_ghost_bsearch(ghost::𝐣𝐥.Ptr{p8est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::ssize_t\n\nConduct binary search for exact match on a range of the ghost layer. \n\nParameters\n\nghost:            The ghost layer.\nwhich_proc:       The owner of the searched quadrant.  Can be -1.\nwhich_tree:       The tree of the searched quadrant.  Can be -1.\nq:                Valid quadrant is searched in the ghost layer.\n\nReturns\n\n                  Offset in the ghost layer, or -1 if not found.\n\nReference\n\np8est_ghost.h:143\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_checksum","page":"Reference","title":"P4est.LibP4est.p8est_ghost_checksum","text":"𝐣𝐥.@cextern p8est_ghost_checksum(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cuint\n\nCompute the parallel checksum of a ghost layer. \n\nParameters\n\np8est:   The MPI information of this p8est will be used.\nghost:   A ghost layer obtained from the p8est.\n\nReturns\n\n         Parallel checksum on rank 0, 0 otherwise.\n\nReference\n\np8est_ghost.h:236\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_destroy","page":"Reference","title":"P4est.LibP4est.p8est_ghost_destroy","text":"𝐣𝐥.@cextern p8est_ghost_destroy(ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid\n\nFrees all memory used for the ghost layer. \n\nReference\n\np8est_ghost.h:134\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom","text":"𝐣𝐥.@cextern p8est_ghost_exchange_custom(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. \n\nParameters\n\np8est:            The forest used for reference.\nghost:            The ghost layer used for reference.\ndata_size:        The data size to transfer per quadrant.\nmirror_data:      One data pointer per mirror quadrant.\nghost_data:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least data_size for each ghost.\n\nReference\n\np8est_ghost.h:299\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_begin","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_begin","text":"𝐣𝐥.@cextern p8est_ghost_exchange_custom_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8estghostexchangecustom. The return type is always non-NULL and must be passed to p8estghostexchangecustom_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. \n\nParameters\n\nmirror_data: Not required to stay alive any longer.\nghost_data:  Must stay alive into the completion call.\n\nReturns\n\n      Transient storage for messages in progress.\n\nReference\n\np8est_ghost.h:316\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_end","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_end","text":"𝐣𝐥.@cextern p8est_ghost_exchange_custom_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications. \n\nParameters\n\nData: created ONLY by p8estghostexchangecustombegin.                  It is deallocated before this function returns.\n\nReference\n\np8est_ghost.h:325\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_levels","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_levels","text":"𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nTransfer data for local quadrants that are ghosts to other processors. The data size is the same for all quadrants and can be chosen arbitrarily. This function restricts the transfer to a range of refinement levels. The memory for quadrants outside the level range is not dereferenced. \n\nParameters\n\np8est:            The forest used for reference.\nghost:            The ghost layer used for reference.\nminlevel:         Level of the largest quads to be exchanged.                              Use <= 0 for no restriction.\nmaxlevel:         Level of the smallest quads to be exchanged.                              Use >= P8EST_QMAXLEVEL for no restriction.\ndata_size:        The data size to transfer per quadrant.\nmirror_data:      One data pointer per mirror quadrant as input.\nghost_data:   Pre-allocated contiguous data for all ghosts                              in sequence, which must hold at least data_size for each ghost.\n\nReference\n\np8est_ghost.h:344\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_levels_begin","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_levels_begin","text":"𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, minlevel::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, data_size::size_t, mirror_data::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8estghostexchangecustomlevels. The return type is always non-NULL and must be passed to p8estghostexchangecustomlevels_end to complete the exchange. The ghost data must not be accessed before completion. The mirror data can be safely discarded right after this function returns since it is copied into internal send buffers. \n\nParameters\n\nmirror_data: Not required to stay alive any longer.\nghost_data:  Must stay alive into the completion call.\n\nReturns\n\n      Transient storage for messages in progress.\n\nReference\n\np8est_ghost.h:363\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_custom_levels_end","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_custom_levels_end","text":"𝐣𝐥.@cextern p8est_ghost_exchange_custom_levels_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications. \n\nParameters\n\nexc: created ONLY by p8estghostexchangecustomlevels_begin.                  It is deallocated before this function returns.\n\nReference\n\np8est_ghost.h:372\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_data","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_data","text":"𝐣𝐥.@cextern p8est_ghost_exchange_data(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nTransfer data for local quadrants that are ghosts to other processors. Send the data stored in the quadrant's userdata.  This is either the pointer variable itself if `p8est->datasize` is 0, or the content of the referenced memory field if p8est->data_size is positive. \n\nParameters\n\np8est:            The forest used for reference.\nghost:            The ghost layer used for reference.\nghost_data:   Pre-allocated contiguous data for all ghost                              quadrants in sequence.  If p8est->datasize is                              0, must at least hold sizeof (void *) bytes for                              each, otherwise p8est->datasize each.\n\nReference\n\np8est_ghost.h:250\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_data_begin","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_data_begin","text":"𝐣𝐥.@cextern p8est_ghost_exchange_data_begin(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_ghost_exchange_t}\n\nBegin an asynchronous ghost data exchange by posting messages. The arguments are identical to p8estghostexchangedata. The return type is always non-NULL and must be passed to p8estghostexchangedata_end to complete the exchange. The ghost data must not be accessed before completion. \n\nParameters\n\nghost_data:  Must stay alive into the completion call.\n\nReturns\n\n      Transient storage for messages in progress.\n\nReference\n\np8est_ghost.h:278\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_exchange_data_end","page":"Reference","title":"P4est.LibP4est.p8est_ghost_exchange_data_end","text":"𝐣𝐥.@cextern p8est_ghost_exchange_data_end(exc::𝐣𝐥.Ptr{p8est_ghost_exchange_t})::𝐣𝐥.Cvoid\n\nComplete an asynchronous ghost data exchange. This function waits for all pending MPI communications. \n\nParameters\n\nexc: Created ONLY by p8estghostexchangedatabegin.                      It is deallocated before this function returns.\n\nReference\n\np8est_ghost.h:286\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_expand","page":"Reference","title":"P4est.LibP4est.p8est_ghost_expand","text":"𝐣𝐥.@cextern p8est_ghost_expand(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid\n\nExpand the size of the ghost layer and mirrors by one additional layer of adjacency. \n\nParameters\n\np8est:            The forest from which the ghost layer was                              generated.\nghost:        The ghost layer to be expanded.\n\nReference\n\np8est_ghost.h:381\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_expand_by_lnodes","page":"Reference","title":"P4est.LibP4est.p8est_ghost_expand_by_lnodes","text":"𝐣𝐥.@cextern p8est_ghost_expand_by_lnodes(p4est::𝐣𝐥.Ptr{p8est_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid\n\nExpand the ghost layer as in p8estghostexpand(), but use node support to define adjacency instead of geometric adjacency.\n\nParameters\n\np8est:        The forest from which the ghost layer was                              generated.\nlnodes:       The nodes to support.\nghost:        The ghost layer to be expanded.\n\nReference\n\np8est_lnodes.h:300\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_is_valid","page":"Reference","title":"P4est.LibP4est.p8est_ghost_is_valid","text":"𝐣𝐥.@cextern p8est_ghost_is_valid(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cint\n\nExamine if a ghost structure is valid as desribed above. Test if within a ghost-structure the arrays ghosts and mirrors are in p8estquadrantcomparepiggy order. Test if localnum in piggy3 data member of the quadrants in ghosts and mirrors are in ascending order (ascending within each rank for ghost).\n\nDetails\n\nTest if the p4estlocidxt arrays are in ascending order (for mirrorprocmirrors ascending within each rank) \n\nParameters\n\np8est:    the forest.\nghost:    Ghost layer structure.\n\nReturns\n\ntrue if ghost is valid\n\nReference\n\np8est_ghost.h:92\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_memory_used","page":"Reference","title":"P4est.LibP4est.p8est_ghost_memory_used","text":"𝐣𝐥.@cextern p8est_ghost_memory_used(ghost::𝐣𝐥.Ptr{p8est_ghost_t})::size_t\n\nCalculate the memory usage of the ghost layer. \n\nParameters\n\nghost:    Ghost layer structure.\n\nReturns\n\n          Memory used in bytes.\n\nReference\n\np8est_ghost.h:99\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_new","page":"Reference","title":"P4est.LibP4est.p8est_ghost_new","text":"𝐣𝐥.@cextern p8est_ghost_new(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_ghost_t}\n\nBuilds the ghost layer.\n\nDetails\n\nThis will gather the quadrants from each neighboring proc to build one layer of face, edge and corner based ghost elements around the ones they own.\n\nParameters\n\np8est:            The forest for which the ghost layer will be                              generated.\nbtype:            Which ghosts to include (across face, edge,                              or corner/full).\n\nReturns\n\n                  A fully initialized ghost layer.\n\nReference\n\np8est_ghost.h:130\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_support_lnodes","page":"Reference","title":"P4est.LibP4est.p8est_ghost_support_lnodes","text":"𝐣𝐥.@cextern p8est_ghost_support_lnodes(p8est::𝐣𝐥.Ptr{p8est_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t})::𝐣𝐥.Cvoid\n\nExpand the ghost layer to include the support of all nodes supported on the local partition.\n\nParameters\n\np8est:        The forest from which the ghost layer was                              generated.\nlnodes:       The nodes to support.\nghost:        The ghost layer to be expanded.\n\nReference\n\np8est_lnodes.h:288\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_ghost_tree_contains","page":"Reference","title":"P4est.LibP4est.p8est_ghost_tree_contains","text":"𝐣𝐥.@cextern p8est_ghost_tree_contains(ghost::𝐣𝐥.Ptr{p8est_ghost_t}, which_proc::𝐣𝐥.Cint, which_tree::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::ssize_t\n\nConduct binary search for ancestor on range of the ghost layer. \n\nParameters\n\nghost:            The ghost layer.\nwhich_proc:       The owner of the searched quadrant.  Can be -1.\nwhich_tree:       The tree of the searched quadrant.  Can be -1.\nq:                Valid quadrant's ancestor is searched.\n\nReturns\n\n                  Offset in the ghost layer, or -1 if not found.\n\nReference\n\np8est_ghost.h:155\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_is_balanced","page":"Reference","title":"P4est.LibP4est.p8est_is_balanced","text":"𝐣𝐥.@cextern p8est_is_balanced(p8est::𝐣𝐥.Ptr{p8est_t}, btype::p8est_connect_type_t)::𝐣𝐥.Cint\n\nCheck a forest to see if it is balanced.\n\nDetails\n\nThis function builds the ghost layer and discards it when done.\n\nParameters\n\np8est:    The p8est to be tested.\nbtype:    Balance type (face, edge, corner or default, full).\n\nReturns\n\nReturns true if balanced, false otherwise.\n\nReference\n\np8est_ghost.h:228\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_iterate","page":"Reference","title":"P4est.LibP4est.p8est_iterate","text":"𝐣𝐥.@cextern p8est_iterate(p4est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p8est_iter_volume_t, iter_face::p8est_iter_face_t, iter_edge::p8est_iter_edge_t, iter_corner::p8est_iter_corner_t)::𝐣𝐥.Cvoid\n\nExecute the user-supplied callback functions at every volume, face, edge and corner in the local forest.\n\nDetails\n\nThe ghostlayer may be NULL. The *userdata* pointer is not touched by p8est_iterate, but is passed to each of the callbacks. Any of the callback functions may be NULL.  The callback functions are interspersed with each other, i.e. some face callbacks will occur between volume callbacks, and some edge callbacks will occur between face callbacks, etc.:\n\nvolume callbacks occur in the sorted Morton-index order. 2) a face callback is not executed until after the volume callbacks have    been executed for the quadrants that share it. 3) an edge callback is not executed until the face callbacks have been    executed for all faces that touch the edge. 4) a corner callback is not executed until the edge callbacks have been    executed for all edges that touch the corner. 5) it is not always the case that every face callback for a given quadrant    is executed before any of the edge or corner callbacks, and it is not    always the case that every edge callback for a given quadrant is executed    before any of the corner callbacks. 6) callbacks are not executed at faces, edges or corners that only involve    ghost quadrants, i.e. that are not adjacent in the local section of the    forest.\n\nParameters\n\np4est:          the forest\nghost_layer:    optional: when not given, callbacks at the                           boundaries of the local partition cannot provide                           quadrant data about ghost quadrants: missing                           (p8estquadrantt *) pointers are set to NULL,                           missing indices are set to -1.\nuser_data:  optional context to supply to each callback\niter_volume:    callback function for every quadrant's interior\niter_face:      callback function for every face between                           quadrants\niter_edge:      callback function for every edge between                           quadrants\niter_corner:    callback function for every corner between                           quadrants\n\nReference\n\np8est_iterate.h:316\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_iterate_ext","page":"Reference","title":"P4est.LibP4est.p8est_iterate_ext","text":"𝐣𝐥.@cextern p8est_iterate_ext(p8est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, iter_volume::p8est_iter_volume_t, iter_face::p8est_iter_face_t, iter_edge::p8est_iter_edge_t, iter_corner::p8est_iter_corner_t, remote::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\np8estiterateext adds the option remote: if this is false, then it is the same as p8est_iterate; if this is true, then corner/edge callbacks are also called on corners/edges for hanging faces/edges touched by local quadrants.\n\nReference\n\np8est_extended.h:534\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_add","page":"Reference","title":"P4est.LibP4est.p8est_lid_add","text":"𝐣𝐥.@cextern p8est_lid_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nAdds the uint128t b to the uint128t a. result == a or result == b is not allowed. a == b is allowed. \n\nParameters\n\na:       A pointer to a p8estlidt.\nb:       A pointer to a p8estlidt.\nresult:  A pointer to a p8estlidt.                      The sum a + b will be saved in result.\n\nReference\n\np8est_extended.h:202\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_add_inplace","page":"Reference","title":"P4est.LibP4est.p8est_lid_add_inplace","text":"𝐣𝐥.@cextern p8est_lid_add_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid\n\nAdds the p8estlidt b to the p8estlidt a. The result is saved in a. a == b is allowed. \n\nParameters\n\na:   A pointer to a p8estlidt. a                      will be overwritten by a + b.\nb:       A pointer to a p8estlidt.\n\nReference\n\np8est_extended.h:289\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_and","page":"Reference","title":"P4est.LibP4est.p8est_lid_bitwise_and","text":"𝐣𝐥.@cextern p8est_lid_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise and of the uint128t a and the uint128t b. a == result is allowed. Furthermore, a == result and/or b == result is allowed. \n\nParameters\n\na:       A pointer to a p8estlidt.\nb:       A pointer to a p8estlidt.\nresult:  A pointer to a p8estlidt.                      The bitwise and of a and b will be saved.                      in result.\n\nReference\n\np8est_extended.h:251\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_and_inplace","page":"Reference","title":"P4est.LibP4est.p8est_lid_bitwise_and_inplace","text":"𝐣𝐥.@cextern p8est_lid_bitwise_and_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid\n\nCalculates the bitwise and of the uint128t a and the uint128t b. a == b is allowed. \n\nParameters\n\na:   A pointer to a p8estlidt.                      The bitwise and will be saved in a.\nb:   A pointer to a p8estlidt.\n\nReference\n\np8est_extended.h:317\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_neg","page":"Reference","title":"P4est.LibP4est.p8est_lid_bitwise_neg","text":"𝐣𝐥.@cextern p8est_lid_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise negation of the uint128_t a. a == result is allowed. \n\nParameters\n\na:        A pointer to a p8estlidt.\nresult:   A pointer to a p8estlidt.                      The bitwise negation of a will be saved in                      result.\n\nReference\n\np8est_extended.h:226\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_or","page":"Reference","title":"P4est.LibP4est.p8est_lid_bitwise_or","text":"𝐣𝐥.@cextern p8est_lid_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise or of the uint128_t a and b. a == result is allowed. Furthermore, a == result and/or b == result is allowed. \n\nParameters\n\na:        A pointer to a p8estlidt.\nb:        A pointer to a p8estlidt.\nresult:   A pointer to a p8estlidt.                      The bitwise or of a and b will be                      saved in result.\n\nReference\n\np8est_extended.h:238\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_bitwise_or_inplace","page":"Reference","title":"P4est.LibP4est.p8est_lid_bitwise_or_inplace","text":"𝐣𝐥.@cextern p8est_lid_bitwise_or_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid\n\nCalculates the bitwise or of the uint128t a and the uint128t b. a == b is allowed. \n\nParameters\n\na:   A pointer to a p8estlidt.                      The bitwise or will be saved in a.\nb:   A pointer to a p8estlidt.\n\nReference\n\np8est_extended.h:308\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_chk_bit","page":"Reference","title":"P4est.LibP4est.p8est_lid_chk_bit","text":"𝐣𝐥.@cextern p8est_lid_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nReturns the bit_number-th bit of input. This function checks a bit of an existing, initialized value. \n\nParameters\n\ninput:      A pointer to a p8estlidt.\nbit_number: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= bit_number < 128.\n\nReturns\n\n                True if bit is set, false if not.\n\nReference\n\np8est_extended.h:172\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_compare","page":"Reference","title":"P4est.LibP4est.p8est_lid_compare","text":"𝐣𝐥.@cextern p8est_lid_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cint\n\nCompare the p8estlidt a and the p8estlidt b. \n\nParameters\n\na: A pointer to a p8estlidt.\nb: A pointer to a p8estlidt.\n\nReturns\n\n    Returns -1 if a < b,                         1 if a > b and                         0 if a == b.\n\nReference\n\np8est_extended.h:128\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_copy","page":"Reference","title":"P4est.LibP4est.p8est_lid_copy","text":"𝐣𝐥.@cextern p8est_lid_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, output::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nCopies an initialized p8estlidt to a p8estlidt. \n\nParameters\n\ninput:    A pointer to the sc_uint128 that is copied.\noutput:   A pointer to a p8estlidt.                          The high and low bits of output will                          be set to the high and low bits of                          input, respectively.\n\nReference\n\np8est_extended.h:191\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_init","page":"Reference","title":"P4est.LibP4est.p8est_lid_init","text":"𝐣𝐥.@cextern p8est_lid_init(input::𝐣𝐥.Ptr{p8est_lid_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid\n\nInitializes a linear index to a given value. \n\nParameters\n\na:        A pointer to the p8estlidt that will be                          initialized.\nhigh:     The given high bits to intialize a.\nlow:      The given low bits to initialize a.\n\nReference\n\np8est_extended.h:146\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_is_equal","page":"Reference","title":"P4est.LibP4est.p8est_lid_is_equal","text":"𝐣𝐥.@cextern p8est_lid_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cint\n\nChecks if the p8estlidt a and the p8estlidt b are equal. \n\nParameters\n\na: A pointer to a p8estlidt.\nb: A pointer to a p8estlidt.\n\nReturns\n\n    Returns a true value if *a* and *b* are equal,                false otherwise\n\nReference\n\np8est_extended.h:137\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_bit","page":"Reference","title":"P4est.LibP4est.p8est_lid_set_bit","text":"𝐣𝐥.@cextern p8est_lid_set_bit(input::𝐣𝐥.Ptr{p8est_lid_t}, bit_number::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSets the exponent-th bit of input to one. This function modifies an existing, initialized value. \n\nParameters\n\ninput:      A pointer to a p8estlidt.\nbit_number: The bit (counted from the right hand side)                            that is set to one by logical or.                            Require 0 <= bit_number < 128.\n\nReference\n\np8est_extended.h:182\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_one","page":"Reference","title":"P4est.LibP4est.p8est_lid_set_one","text":"𝐣𝐥.@cextern p8est_lid_set_one(input::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nInitializes a linear index to one. \n\nParameters\n\ninput:     A pointer to a p4estlidt that will be intialized.\n\nReference\n\np8est_extended.h:157\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_uint64","page":"Reference","title":"P4est.LibP4est.p8est_lid_set_uint64","text":"𝐣𝐥.@cextern p8est_lid_set_uint64(input::𝐣𝐥.Ptr{p8est_lid_t}, u::uint64_t)::𝐣𝐥.Cvoid\n\nInitializes a linear index to an unsigned 64 bit integer. \n\nParameters\n\ninput:     A pointer to a p4estlidt that will be intialized.\n\nReference\n\np8est_extended.h:162\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_set_zero","page":"Reference","title":"P4est.LibP4est.p8est_lid_set_zero","text":"𝐣𝐥.@cextern p8est_lid_set_zero(input::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nInitializes a linear index to zero. \n\nParameters\n\ninput:     A pointer to a p4estlidt that will be intialized.\n\nReference\n\np8est_extended.h:152\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_shift_left","page":"Reference","title":"P4est.LibP4est.p8est_lid_shift_left","text":"𝐣𝐥.@cextern p8est_lid_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bit left shift of uint128t input by shiftcount bits. We shift in zeros from the right. If shift_count >= 128, result is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. input == result is allowed. \n\nParameters\n\ninput:       A pointer to a p8estlidt.\nshift_count: Bits to shift. shift_count >= 0.\nresult:      A pointer to a p8estlidt.                              The left shifted number will be saved                              in result.\n\nReference\n\np8est_extended.h:279\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_shift_right","page":"Reference","title":"P4est.LibP4est.p8est_lid_shift_right","text":"𝐣𝐥.@cextern p8est_lid_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, shift_count::𝐣𝐥.Cuint, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nCalculates the bit right shift of uint128t input by shiftcount bits. We shift in zeros from the left. If shift_count >= 128, result is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. input == result is allowed. \n\nParameters\n\ninput:       A pointer to a p8estlidt.\nshift_count: Bits to shift. shift_count >= 0.\nresult:      A pointer to a p8estlidt.                              The right shifted number will be saved                              in result.\n\nReference\n\np8est_extended.h:265\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_sub","page":"Reference","title":"P4est.LibP4est.p8est_lid_sub","text":"𝐣𝐥.@cextern p8est_lid_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)}, result::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nSubstracts the p8estlidt b from the p8estlidt a. This function assumes that the result is >= 0. result == a or result == b is not allowed. a == b is allowed. \n\nParameters\n\na:       A pointer to a p8estlidt.\nb:       A pointer to a p8estlidt.\nresult:  A pointer to a p8estlidt.                      The difference a - b will be saved in result.\n\nReference\n\np8est_extended.h:215\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lid_sub_inplace","page":"Reference","title":"P4est.LibP4est.p8est_lid_sub_inplace","text":"𝐣𝐥.@cextern p8est_lid_sub_inplace(a::𝐣𝐥.Ptr{p8est_lid_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid\n\nSubstracts the uint128t b from the uint128t a. The result is saved in a. a == b is allowed. This function assumes that the result is >= 0. \n\nParameters\n\na:   A pointer to a p8estlidt.                      a will be overwritten by a - b.\nb:   A pointer to a p8estlidt.\n\nReference\n\np8est_extended.h:299\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_buffer_destroy","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_buffer_destroy","text":"𝐣𝐥.@cextern p8est_lnodes_buffer_destroy(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid\n\nReference\n\np8est_lnodes.h:388\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_destroy","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_destroy","text":"𝐣𝐥.@cextern p8est_lnodes_destroy(lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Cvoid\n\nReference\n\np8est_lnodes.h:252\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_new","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_new","text":"𝐣𝐥.@cextern p8est_lnodes_new(p8est::𝐣𝐥.Ptr{p8est_t}, ghost_layer::𝐣𝐥.Ptr{p8est_ghost_t}, degree::𝐣𝐥.Cint)::𝐣𝐥.Ptr{p8est_lnodes_t}\n\nReference\n\np8est_lnodes.h:248\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_all","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_share_all","text":"𝐣𝐥.@cextern p8est_lnodes_share_all(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}\n\nEquivalend to calling p8estlnodesshareallend directly after p8estlnodesshareallbegin.  Use if there is no local work that can be done to mask the communication cost. \n\nReturns\n\n      A fully initialized buffer that contains the received data.                  After processing this data, the buffer must be freed with                  p8est_lnodes_buffer_destroy.\n\nReference\n\np8est_lnodes.h:385\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_all_begin","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_share_all_begin","text":"𝐣𝐥.@cextern p8est_lnodes_share_all_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}\n\np8estlnodesshareallbegin\n\nDetails\n\nnode_data is a userdefined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every process that shares an entry with the current one, the value in the *nodedata* array of that process is written into a buffer->recv_buffers entry as described above.  The user can then perform some arbitrary work that requires the data from all processes that share a node (such as reduce, max, min, etc.).  When the work concludes, the buffer should be destroyed with p8estlnodesbuffer_destroy.\n\nValues of node_data are not guaranteed to be send, and buffer->recv_buffer entries are not guaranteed to be received until the buffer created by p8estlnodesshareallbegin is passed to p8estlnodesshareallend.\n\nReference\n\np8est_lnodes.h:372\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_all_end","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_share_all_end","text":"𝐣𝐥.@cextern p8est_lnodes_share_all_end(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid\n\nReference\n\np8est_lnodes.h:375\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_owned","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_share_owned","text":"𝐣𝐥.@cextern p8est_lnodes_share_owned(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Cvoid\n\nEquivalent to calling p8estlnodesshareownedend directly after p8estlnodesshareownedbegin.  Use if there is no local work that can be done to mask the communication cost.\n\nReference\n\np8est_lnodes.h:353\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_owned_begin","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_share_owned_begin","text":"𝐣𝐥.@cextern p8est_lnodes_share_owned_begin(node_data::𝐣𝐥.Ptr{sc_array_t}, lnodes::𝐣𝐥.Ptr{p8est_lnodes_t})::𝐣𝐥.Ptr{p8est_lnodes_buffer_t}\n\np8estlnodesshareownedbegin\n\nDetails\n\nnode_data is a user-defined array of arbitrary type, where each entry is associated with the lnodes local nodes entry of matching index. For every local nodes entry that is owned by a process other than the current one, the value in the node_data array of the owning process is written directly into the node_data array of the current process.  Values of node_data are not guaranteed to be sent or received until the buffer created by p8estlnodesshareownedbegin is passed to p8estlnodesshareownedend.\n\nTo be memory neutral, the buffer created by p8estlnodesshareownedbegin must be destroying with p8estlnodesbufferdestroy (it is not destroyed by p8estlnodesshareowned_end).\n\nReference\n\np8est_lnodes.h:342\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_lnodes_share_owned_end","page":"Reference","title":"P4est.LibP4est.p8est_lnodes_share_owned_end","text":"𝐣𝐥.@cextern p8est_lnodes_share_owned_end(buffer::𝐣𝐥.Ptr{p8est_lnodes_buffer_t})::𝐣𝐥.Cvoid\n\nReference\n\np8est_lnodes.h:346\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_load","page":"Reference","title":"P4est.LibP4est.p8est_load","text":"𝐣𝐥.@cextern p8est_load(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}\n\nLoad the complete connectivity/p8est structure from disk.\n\nDetails\n\nThis is a collective operation that all MPI processes need to call.  All processes read from the same file, so the filename given needs to be identical over all parallel invocations.\n\nBy default, a file can only be loaded with the same number of processors that it was stored with.  The defaults can be changed with p8estloadext() in p8est_extended.h.\n\nThe revision counter of the loaded p4est is set to zero.\n\nParameters\n\nfilename:         Name of the file to read.\nmpicomm:          A valid MPI communicator.\ndata_size:        Size of data for each quadrant which can be                              zero.  Then userdatapool is set to NULL.                              If datasize is zero, loaddata is ignored.\nload_data:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.\nuser_pointer:     Assign to the userpointer member of the p8est                              before initfn is called the first time.\nconnectivity:    Connectivity must be destroyed separately.\n\nReturns\n\n      Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument.\n\nNOTE:            Aborts on file errors or invalid file contents.\n\nReference\n\np8est.h:454\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_load_ext","page":"Reference","title":"P4est.LibP4est.p8est_load_ext","text":"𝐣𝐥.@cextern p8est_load_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}\n\nLoad the complete connectivity/p4est structure from disk. It is possible to load the file with a different number of processors than has been used to write it.  The partition will then be uniform. \n\nParameters\n\nfilename:         Name of the file to read.\nmpicomm:          A valid MPI communicator.\ndata_size:        Size of data for each quadrant which can be                              zero.  Then userdatapool is set to NULL.                              If datasize is zero, loaddata is ignored.\nload_data:        If true, the element data is loaded.  This is                              only permitted if the saved data size matches.                              If false, the stored data size is ignored.\nautopartition:    Ignore saved partition and make it uniform.\nbroadcasthead:    Have only rank 0 read headers and bcast them.\nuser_pointer:     Assign to the userpointer member of the p4est                              before initfn is called the first time.\nconnectivity:    Connectivity must be destroyed separately.\n\nReturns\n\n      Returns a valid forest structure. A pointer to a valid                  connectivity structure is returned through the last                  argument.\n\nNOTE:            Aborts on file errors or invalid file contents.\n\nReference\n\np8est_extended.h:584\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_memory_used","page":"Reference","title":"P4est.LibP4est.p8est_memory_used","text":"𝐣𝐥.@cextern p8est_memory_used(p8est::𝐣𝐥.Ptr{p8est_t})::size_t\n\nCalculate local memory usage of a forest structure. Not collective.  The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use p8estconnectivitymemory_usage (p8est->connectivity). \n\nParameters\n\np8est:    Valid forest structure.\n\nReturns\n\n          Memory used in bytes.\n\nReference\n\np8est.h:178\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_destroy","page":"Reference","title":"P4est.LibP4est.p8est_mesh_destroy","text":"𝐣𝐥.@cextern p8est_mesh_destroy(mesh::𝐣𝐥.Ptr{p8est_mesh_t})::𝐣𝐥.Cvoid\n\nDestroy a p8est_mesh structure. \n\nParameters\n\nmesh:     Mesh structure previously created by p8estmeshnew.\n\nReference\n\np8est_mesh.h:214\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_data","page":"Reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_data","text":"𝐣𝐥.@cextern p8est_mesh_face_neighbor_data(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, ghost_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nGet the user data for the current face neighbor. \n\nParameters\n\nmfn:           Internal status of the iterator.\nghost_data:    Data for the ghost quadrants that has been                               synchronized with p4estghostexchange_data.\n\nReturns\n\n                   A pointer to the user data for the current                               neighbor.\n\nReference\n\np8est_mesh.h:354\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_init","page":"Reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_init","text":"𝐣𝐥.@cextern p8est_mesh_face_neighbor_init(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, which_tree::p4est_topidx_t, quadrant::𝐣𝐥.Ptr{p8est_quadrant_t})::𝐣𝐥.Cvoid\n\nInitialize a mesh neighbor iterator by quadrant pointer. \n\nParameters\n\nmfn:         A p8estmeshfaceneighbort to be initialized.\nwhich_tree:  Tree of quadrant whose neighbors are looped over.\nquadrant:    Pointer to quadrant contained in which_tree.\n\nReference\n\np8est_mesh.h:323\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_init2","page":"Reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_init2","text":"𝐣𝐥.@cextern p8est_mesh_face_neighbor_init2(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, which_tree::p4est_topidx_t, quadrant_id::p4est_locidx_t)::𝐣𝐥.Cvoid\n\nInitialize a mesh neighbor iterator by quadrant index. \n\nParameters\n\nmfn:         A p8estmeshfaceneighbort to be initialized.\nwhich_tree:  Tree of quadrant whose neighbors are looped over.\nquadrant_id: Index relative to which_tree of quadrant.\n\nReference\n\np8est_mesh.h:310\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_face_neighbor_next","page":"Reference","title":"P4est.LibP4est.p8est_mesh_face_neighbor_next","text":"𝐣𝐥.@cextern p8est_mesh_face_neighbor_next(mfn::𝐣𝐥.Ptr{p8est_mesh_face_neighbor_t}, ntree::𝐣𝐥.Ptr{p4est_topidx_t}, nquad::𝐣𝐥.Ptr{p4est_locidx_t}, nface::𝐣𝐥.Ptr{𝐣𝐥.Cint}, nrank::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Ptr{p8est_quadrant_t}\n\nMove the iterator forward to loop around neighbors of the quadrant. \n\nParameters\n\nmfn:      Internal status of the iterator.\nntree:    If not NULL, the tree number of the neighbor.\nnquad:    If not NULL, the quadrant number within tree.                          For ghosts instead the number in ghost layer.\nnface:    If not NULL, neighbor's face as in p8estmesht.\nnrank:    If not NULL, the owner process of the neighbor.\n\nReturns\n\n              Either a real quadrant or one from the ghost layer.                          Returns NULL when the iterator is done.\n\nReference\n\np8est_mesh.h:341\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_get_neighbors","page":"Reference","title":"P4est.LibP4est.p8est_mesh_get_neighbors","text":"𝐣𝐥.@cextern p8est_mesh_get_neighbors(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, curr_quad_id::p4est_locidx_t, direction::p4est_locidx_t, neighboring_quads::𝐣𝐥.Ptr{sc_array_t}, neighboring_encs::𝐣𝐥.Ptr{sc_array_t}, neighboring_qids::𝐣𝐥.Ptr{sc_array_t})::p4est_locidx_t\n\nLookup neighboring quads of quadrant in a specific direction \n\nParameters\n\np4est:              Forest to be worked with.\nghost:              Ghost quadrants.\nmesh:               Mesh structure.\ncurr_quad_id:       Process-local ID of current quad.\ndirection:          Direction in which to look for adjacent                                 quadrants is encoded as follows:                                   0 ..  5 neighbor(-s) across fi,                                   6 .. 17 neighbor(-s) across e{i-6}                                  18 .. 25 neighbor(-s) across c_{i-18}\nneighboring_quads:  Array containing neighboring quad(-s)                                 Needs to be empty, contains                                 p4estquadrantt*. May be NULL, then neighboring_qids must not be NULL.\nneighboring_encs:   Array containing encodings for neighboring                                 quads as described below                                 Needs to be empty, contains int. CAUTION: Note, that the encodings differ from the encodings saved in the          mesh.          Positive values are for local quadrants, negative values indicate          ghost quadrants.          Faces:     1 ..  24 => same size neighbor                                 (r * 6 + nf) + 1; nf = 0 .. 5 face index;                                 r = 0 .. 3 relative orientation                    25 .. 120 => double size neighbor                                 25 + h * 24 + r * 6 + nf; h = 0 .. 3 number                                 of the subface; r, nf as above                   121 .. 144 => half size neighbors                                 121 + r * 6 + nf; r, nf as above          Edges:     1 ..  24 => same size neighbor                                 r * 12 + ne + 1; ne = 0 .. 11 edge index;                                 r = 0 .. 1 relative orientation                    25 ..  72 => double size neighbor                                 25 + h * 24 + r * 12 + ne; h = 0 .. 1 number                                 of the subedge; r, ne as above                    73 ..  96 => half size neighbors                                 73 + r * 12 + ne; r, ne as above          Corners:   1 ..   8 => nc + 1; nc = 0 .. 7 corner index\nneighboring_qids:   Array containing quadrant ids for neighboring                                 quadrants. May be NULL, then no neighboring                                 qids are collected.                                 If non-NULL the array needs to be empty and                                 will contain int.\n\nReference\n\np8est_mesh.h:273\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_get_quadrant","page":"Reference","title":"P4est.LibP4est.p8est_mesh_get_quadrant","text":"𝐣𝐥.@cextern p8est_mesh_get_quadrant(p4est::𝐣𝐥.Ptr{p8est_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, qid::p4est_locidx_t)::𝐣𝐥.Ptr{p8est_quadrant_t}\n\nAccess a process-local quadrant inside a forest. Needs a mesh with populated quadtotree array. This is a special case of p8estmeshquadrant_cumulative.\n\nParameters\n\np4est:  The forest.\nmesh:   The mesh.\nqid:    Process-local id of the quadrant (cumulative over trees).\n\nReturns\n\n        A pointer to the requested quadrant.\n\nReference\n\np8est_mesh.h:225\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_memory_used","page":"Reference","title":"P4est.LibP4est.p8est_mesh_memory_used","text":"𝐣𝐥.@cextern p8est_mesh_memory_used(mesh::𝐣𝐥.Ptr{p8est_mesh_t})::size_t\n\nCalculate the memory usage of the mesh structure. \n\nParameters\n\nmesh:     Mesh structure.\n\nReturns\n\n          Memory used in bytes.\n\nReference\n\np8est_mesh.h:198\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_new","page":"Reference","title":"P4est.LibP4est.p8est_mesh_new","text":"𝐣𝐥.@cextern p8est_mesh_new(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_mesh_t}\n\nCreate a p8estmesh structure. This function does not populate the quadtotree and quadlevel fields. To populate them, use p8estmeshnew_ext. \n\nParameters\n\np8est:    A forest that is fully 2:1 balanced.\nghost:    The ghost layer created from the provided p4est.\nbtype:    Determines the highest codimension of neighbors.\n\nReturns\n\n          A fully allocated mesh structure.\n\nReference\n\np8est_mesh.h:208\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_new_ext","page":"Reference","title":"P4est.LibP4est.p8est_mesh_new_ext","text":"𝐣𝐥.@cextern p8est_mesh_new_ext(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, compute_tree_index::𝐣𝐥.Cint, compute_level_lists::𝐣𝐥.Cint, btype::p8est_connect_type_t)::𝐣𝐥.Ptr{p8est_mesh_t}\n\nCreate a new mesh. \n\nParameters\n\np8est:                A forest that is fully 2:1 balanced.\nghost:                The ghost layer created from the                                  provided p4est.\ncompute_tree_index:   Boolean to decide whether to allocate and                                  compute the quadtotree list.\ncompute_level_lists:  Boolean to decide whether to compute the                                  level lists in quad_level.\nbtype:                Currently ignored, only face neighbors                                  are stored.\n\nReturns\n\n                      A fully allocated mesh structure.\n\nReference\n\np8est_extended.h:400\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_mesh_quadrant_cumulative","page":"Reference","title":"P4est.LibP4est.p8est_mesh_quadrant_cumulative","text":"𝐣𝐥.@cextern p8est_mesh_quadrant_cumulative(p8est::𝐣𝐥.Ptr{p8est_t}, mesh::𝐣𝐥.Ptr{p8est_mesh_t}, cumulative_id::p4est_locidx_t, which_tree::𝐣𝐥.Ptr{p4est_topidx_t}, quadrant_id::𝐣𝐥.Ptr{p4est_locidx_t})::𝐣𝐥.Ptr{p8est_quadrant_t}\n\nFind a quadrant based on its cumulative number in the local forest. If the quadtotree field of the mesh structure exists, this is O(1). Otherwise, we perform a binary search over the processor-local trees.\n\nParameters\n\np8est:           Forest to be worked with.\nmesh:            A mesh derived from the forest.\ncumulative_id:   Cumulative index over all trees of quadrant.                              Must refer to a local (non-ghost) quadrant.\nwhich_tree:   If not NULL, the input value can be -1                              or an initial guess for the quadrant's tree                              and output is the tree of returned quadrant.\nquadrant_id:     If not NULL, the number of quadrant in tree.\n\nReturns\n\n                  The identified quadrant.\n\nReference\n\np8est_mesh.h:296\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_new","page":"Reference","title":"P4est.LibP4est.p8est_new","text":"𝐣𝐥.@cextern p8est_new(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_t}\n\nCreate a new forest with an initial coarse mesh. The new forest consists of equi-partitioned root quadrants. When there are more processors than trees, some processors are empty.\n\nParameters\n\nmpicomm:       A valid MPI communicator.\nconnectivity:  This is the connectivity information that                           the forest is built with.  Note the p8est                           does not take ownership of the memory.\ndata_size:     This is the size of data for each quadrant which                           can be zero.  Then userdatapool is set to NULL.\ninit_fn:       Callback function to initialize the user_data                           which is already allocated automatically.\nuser_pointer:  Assign to the userpointer member of the p8est                           before initfn is called the first time.\n\nReturns\n\nThis returns a valid forest.\n\nNOTE: The connectivity structure must not be destroyed       during the lifetime of this forest.\n\nReference\n\np8est.h:272\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_new_ext","page":"Reference","title":"P4est.LibP4est.p8est_new_ext","text":"𝐣𝐥.@cextern p8est_new_ext(mpicomm::sc_MPI_Comm, connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, min_quadrants::p4est_locidx_t, min_level::𝐣𝐥.Cint, fill_uniform::𝐣𝐥.Cint, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{p8est_t}\n\nCreate a new forest. This is a more general form of p8estnew. The forest created is either uniformly refined at a given level or created with the coarsest possible refinement that fits the exact partition that would have been created in the uniform mode. The latter, coarse refinement depends on the number of MPI processes! The initial level is currently limited to P8ESTOLDQMAXLEVEL. Regardless, p8estrefine can go as deep as P8EST_QMAXLEVEL.\n\nParameters\n\nmpicomm:          A valid MPI communicator.\nconnectivity:     This is the connectivity information that                              the forest is built with.  Note the forest                              does not take ownership of the memory.\nmin_quadrants:    Minimum initial quadrants per processor.                              Makes the refinement pattern mpisize-specific.                              For maximum reproducibility, set this to 0.\nmin_level:        The forest is refined at most to this level.                              Later coarsening and refinement is unaffected.                              May be negative or 0, then it has no effect.\nfill_uniform:     If true, fill the forest with a uniform mesh                              instead of the coarsest possible one.                              The latter is partition-specific, which                              is not a good idea wrt. reproducibility.\ndata_size:        The size of data for each quadrant.\ninit_fn:          Callback function to initialize the userdata                              which is internally allocated using datasize.\nuser_pointer:     Assigned to the userpointer member of the                              forest before initfn is called the first time.\n\nReturns\n\n                  Valid p8est object.\n\nReference\n\np8est_extended.h:381\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_partition","page":"Reference","title":"P4est.LibP4est.p8est_partition","text":"𝐣𝐥.@cextern p8est_partition(p8est::𝐣𝐥.Ptr{p8est_t}, allow_for_coarsening::𝐣𝐥.Cint, weight_fn::p8est_weight_t)::𝐣𝐥.Cvoid\n\nEqually partition the forest. The partition can be by element count or by a user-defined weight.\n\nDetails\n\nThe forest will be partitioned between processors such that they have an approximately equal number of quadrants (or sum of weights).\n\nOn one process, the function noops and does not call the weight callback. Otherwise, the weight callback is called once per quadrant in order.\n\nParameters\n\np8est:      The forest that will be partitioned.\nallow_for_coarsening: Slightly modify partition such that                            quadrant families are not split between ranks.\nweight_fn:  A weighting function or NULL                            for uniform partitioning.                            When running with mpisize == 1, never called.                            Otherwise, called in order for all quadrants                            if not NULL. A weighting function with constant                            weight 1 on each quadrant is equivalent                            to weight_fn == NULL but other constant weightings                            may result in different uniform partitionings.\n\nReference\n\np8est.h:385\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_partition_ext","page":"Reference","title":"P4est.LibP4est.p8est_partition_ext","text":"𝐣𝐥.@cextern p8est_partition_ext(p8est::𝐣𝐥.Ptr{p8est_t}, partition_for_coarsening::𝐣𝐥.Cint, weight_fn::p8est_weight_t)::p4est_gloidx_t\n\nRepartition the forest.\n\nDetails\n\nThe forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).\n\nParameters\n\np8est:      The forest that will be partitioned.\npartition_for_coarsening:     If true, the partition                            is modified to allow one level of coarsening.\nweight_fn:  A weighting function or NULL                            for uniform partitioning. A weighting function                            with constant weight 1 on each quadrant is                            equivalent to weight_fn == NULL but other constant                            weightings may result in different uniform                            partitionings.\n\nReturns\n\n     The global number of shipped quadrants\n\nReference\n\np8est_extended.h:515\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_partition_for_coarsening","page":"Reference","title":"P4est.LibP4est.p8est_partition_for_coarsening","text":"𝐣𝐥.@cextern p8est_partition_for_coarsening(p8est::𝐣𝐥.Ptr{p8est_t}, num_quadrants_in_proc::𝐣𝐥.Ptr{p4est_locidx_t})::p4est_gloidx_t\n\nCorrect partition to allow one level of coarsening.\n\nParameters\n\np8est:                     forest whose partition is corrected\nnum_quadrants_in_proc: partition that will be corrected\n\nReturns\n\n                           absolute number of moved quadrants\n\nReference\n\np8est_extended.h:525\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_partition_lnodes","page":"Reference","title":"P4est.LibP4est.p8est_partition_lnodes","text":"𝐣𝐥.@cextern p8est_partition_lnodes(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, degree::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nPartition using weights based on the number of nodes assigned to each element in lnodes\n\nParameters\n\np8est:                    the forest to be repartitioned\nghost:                    the ghost layer\ndegree:                   the degree that would be passed to p8estlnodesnew()\npartition_for_coarsening: whether the partition should allow                                         coarsening (i.e. group siblings who                                         might merge)\n\nReference\n\np8est_lnodes.h:264\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_partition_lnodes_detailed","page":"Reference","title":"P4est.LibP4est.p8est_partition_lnodes_detailed","text":"𝐣𝐥.@cextern p8est_partition_lnodes_detailed(p4est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, nodes_per_volume::𝐣𝐥.Cint, nodes_per_face::𝐣𝐥.Cint, nodes_per_edge::𝐣𝐥.Cint, nodes_per_corner::𝐣𝐥.Cint, partition_for_coarsening::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nPartition using weights that are broken down by where they reside: in volumes, on faces, on edges, or on corners.\n\nReference\n\np8est_lnodes.h:271\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_qcoord_to_vertex","page":"Reference","title":"P4est.LibP4est.p8est_qcoord_to_vertex","text":"𝐣𝐥.@cextern p8est_qcoord_to_vertex(connectivity::𝐣𝐥.Ptr{p8est_connectivity_t}, treeid::p4est_topidx_t, x::p4est_qcoord_t, y::p4est_qcoord_t, z::p4est_qcoord_t, vxyz::𝐣𝐥.Cdouble[3])::𝐣𝐥.Cvoid\n\nTransform a quadrant coordinate into the space spanned by tree vertices. \n\nParameters\n\nconnectivity:     Connectivity must provide the vertices.\ntreeid:           Identify the tree that contains x, y, z.\nx,: y, z          Quadrant coordinates relative to treeid.\nvxyz:            Transformed coordinates in vertex space.\n\nReference\n\np8est.h:245\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_exists","page":"Reference","title":"P4est.LibP4est.p8est_quadrant_exists","text":"𝐣𝐥.@cextern p8est_quadrant_exists(p8est::𝐣𝐥.Ptr{p8est_t}, ghost::𝐣𝐥.Ptr{p8est_ghost_t}, treeid::p4est_topidx_t, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, exists_arr::𝐣𝐥.Ptr{sc_array_t}, rproc_arr::𝐣𝐥.Ptr{sc_array_t}, rquad_arr::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint\n\nChecks if quadrant exists in the local forest or the ghost layer.\n\nDetails\n\nFor quadrants across tree corners it checks if the quadrant exists in any of the corner neighbors, thus it can execute multiple queries.\n\nParameters\n\np8est:        The forest in which to search for q\nghost:        The ghost layer in which to search for q\ntreeid:       The tree to which q belongs (can be extended).\nq:            The quadrant that is being searched for.\nexists_arr: Must exist and be of of elemsize = sizeof (int)                           for inter-tree corner cases.  Is resized by this                           function to one entry for each corner search                           and set to true/false depending on its existence                           in the local forest or ghostlayer.\nrproc_arr: If not NULL is filled with one rank per query.\nrquad_arr: If not NULL is filled with one quadrant per query.                           Its piggy3 member is defined as well.\n\nReturns\n\ntrue if the quadrant exists in the local forest or in the                  ghost_layer, and false if doesn't exist in either.\n\nReference\n\np8est_ghost.h:212\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_find_owner","page":"Reference","title":"P4est.LibP4est.p8est_quadrant_find_owner","text":"𝐣𝐥.@cextern p8est_quadrant_find_owner(p8est::𝐣𝐥.Ptr{p8est_t}, treeid::p4est_topidx_t, face::𝐣𝐥.Cint, q::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)})::𝐣𝐥.Cint\n\nGets the processor id of a quadrant's owner. The quadrant can lie outside of a tree across faces (and only faces).\n\nParameters\n\np8est:  The forest in which to search for a quadrant.\ntreeid: The tree to which the quadrant belongs.\nface:   Supply a face direction if known, or -1 otherwise.\nq:      The quadrant that is being searched for.\n\nReturns\n\nProcessor id of the owner                or -1 if the quadrant lies outside of the mesh.\n\nWARNING: Does not work for tree edge or corner neighbors.\n\nReference\n\np8est_ghost.h:114\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_linear_id_ext128","page":"Reference","title":"P4est.LibP4est.p8est_quadrant_linear_id_ext128","text":"𝐣𝐥.@cextern p8est_quadrant_linear_id_ext128(quadrant::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_quadrant_t)}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{p8est_lid_t})::𝐣𝐥.Cvoid\n\nComputes the linear position as p8estlidt of a quadrant in a uniform grid. The grid and quadrant levels need not coincide. If they do, this is the inverse of p4estquadrantset_morton. \n\nParameters\n\nquadrant:  Quadrant whose linear index will be computed.                       If the quadrant is smaller than the grid (has a higher                       quadrant->level), the result is computed from its                       ancestor at the grid's level.                       If the quadrant has a smaller level than the grid (it                       is bigger than a grid cell), the grid cell sharing its                       lower left corner is used as reference.\nlevel:     The level of the regular grid compared to which the                       linear position is to be computed.\nid:     A pointer to an allocated or static p8estlidt.                       id will be the linear position of this quadrant on a                       uniform grid.\n\nNOTE: The user_data of quadrant is never modified.\n\nReference\n\np8est_extended.h:336\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_quadrant_set_morton_ext128","page":"Reference","title":"P4est.LibP4est.p8est_quadrant_set_morton_ext128","text":"𝐣𝐥.@cextern p8est_quadrant_set_morton_ext128(quadrant::𝐣𝐥.Ptr{p8est_quadrant_t}, level::𝐣𝐥.Cint, id::𝐣𝐥.Ptr{𝐣𝐥.Cconst(p8est_lid_t)})::𝐣𝐥.Cvoid\n\nSet quadrant Morton indices based on linear position given as p8estlidt in uniform grid. This is the inverse operation of p4estquadrantlinear_id. \n\nParameters\n\nquadrant:  Quadrant whose Morton indices will be set.\nlevel:     Level of the grid and of the resulting quadrant.\nid:        Linear index of the quadrant on a uniform grid.\n\nNOTE: The user_data of quadrant is never modified.\n\nReference\n\np8est_extended.h:347\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_refine","page":"Reference","title":"P4est.LibP4est.p8est_refine","text":"𝐣𝐥.@cextern p8est_refine(p8est::𝐣𝐥.Ptr{p8est_t}, refine_recursive::𝐣𝐥.Cint, refine_fn::p8est_refine_t, init_fn::p8est_init_t)::𝐣𝐥.Cvoid\n\nRefine a forest. \n\nParameters\n\np8est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nrefine_fn: Callback function that must return true if a quadrant                       shall be refined.  If refinerecursive is true,                       refinefn is called for every existing and newly                       created quadrant.  Otherwise, it is called for every                       existing quadrant.  It is possible that a refinement                       request made by the callback is ignored.  To catch                       this case, you can examine whether initfn gets                       called, or use p8estrefineext in p8estextended.h                       and examine whether replace_fn gets called.\ninit_fn:   Callback function to initialize the user_data of newly                       created quadrants, which is already allocated.  This                       function pointer may be NULL.\n\nReference\n\np8est.h:331\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_refine_ext","page":"Reference","title":"P4est.LibP4est.p8est_refine_ext","text":"𝐣𝐥.@cextern p8est_refine_ext(p8est::𝐣𝐥.Ptr{p8est_t}, refine_recursive::𝐣𝐥.Cint, maxlevel::𝐣𝐥.Cint, refine_fn::p8est_refine_t, init_fn::p8est_init_t, replace_fn::p8est_replace_t)::𝐣𝐥.Cvoid\n\nRefine a forest with a bounded refinement level and a replace option. \n\nParameters\n\np8est: The forest is changed in place.\nrefine_recursive: Boolean to decide on recursive refinement.\nmaxlevel:   Maximum allowed refinement level (inclusive).                        If this is negative the level is restricted only                        by the compile-time constant QMAXLEVEL in p8est.h.\nrefine_fn:  Callback function that must return true if a quadrant                        shall be refined.  If refinerecursive is true,                        refinefn is called for every existing and newly                        created quadrant.  Otherwise, it is called for every                        existing quadrant.  It is possible that a refinement                        request made by the callback is ignored.  To catch                        this case, you can examine whether initfn or                        replacefn gets called.\ninit_fn:    Callback function to initialize the user_data for                        newly created quadrants, which is guaranteed to be                        allocated.  This function pointer may be NULL.\nreplace_fn: Callback function that allows the user to change                        incoming quadrants based on the quadrants they                        replace; may be NULL.\n\nReference\n\np8est_extended.h:444\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_reset_data","page":"Reference","title":"P4est.LibP4est.p8est_reset_data","text":"𝐣𝐥.@cextern p8est_reset_data(p8est::𝐣𝐥.Ptr{p8est_t}, data_size::size_t, init_fn::p8est_init_t, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nReset user pointer and element data. When the data size is changed the quadrant data is freed and allocated. The initialization callback is invoked on each quadrant. Old user_data content is disregarded.\n\nParameters\n\ndata_size:     This is the size of data for each quadrant which                           can be zero.  Then userdatapool is set to NULL.\ninit_fn:       Callback function to initialize the user_data                           which is already allocated automatically.                           May be NULL.\nuser_pointer:  Assign to the userpointer member of the p8est                           before initfn is called the first time.\n\nReference\n\np8est.h:311\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_revision","page":"Reference","title":"P4est.LibP4est.p8est_revision","text":"𝐣𝐥.@cextern p8est_revision(p8est::𝐣𝐥.Ptr{p8est_t})::𝐣𝐥.Clong\n\nReturn the revision counter of the forest. Not collective, even though the revision value is the same on all ranks. A newly created forest starts with a revision counter of zero. Every refine, coarsen, partition, and balance that actually changes the mesh increases the counter by one.  Operations with no effect keep the old value. \n\nParameters\n\np8est:    The forest must be valid.\n\nReturns\n\n          Non-negative number.\n\nReference\n\np8est.h:188\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_save","page":"Reference","title":"P4est.LibP4est.p8est_save","text":"𝐣𝐥.@cextern p8est_save(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p8est::𝐣𝐥.Ptr{p8est_t}, save_data::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSave the complete connectivity/p8est data to disk.\n\nDetails\n\nThis is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations.\n\nBy default, we write the current processor count and partition into the file header.  This makes the file depend on mpisize.  For changing this see p8estsaveext() in p8est_extended.h.\n\nThe revision counter is not saved to the file, since that would make files different that come from different revisions but store the same mesh.\n\nParameters\n\nfilename:    Name of the file to write.\np8est:       Valid forest structure.\nsave_data:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.\n\nNOTE:            Aborts on file errors. \n\nNOTE:            If p4est is not configured to use MPI-IO, some processes                  return from this function before the file is complete, in                  which case immediate read-access to the file may require a                  call to scMPIBarrier.\n\nReference\n\np8est.h:423\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_save_ext","page":"Reference","title":"P4est.LibP4est.p8est_save_ext","text":"𝐣𝐥.@cextern p8est_save_ext(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, p8est::𝐣𝐥.Ptr{p8est_t}, save_data::𝐣𝐥.Cint, save_partition::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSave the complete connectivity/p8est data to disk.  This is a collective operation that all MPI processes need to call.  All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See p8estloadext for information on the autopartition parameter. \n\nParameters\n\nfilename:    Name of the file to write.\np8est:       Valid forest structure.\nsave_data:   If true, the element data is saved.                         Otherwise, a data size of 0 is saved.\nsave_partition:   If false, save file as if 1 core was used.                              If true, save core count and partition.                         Advantage: Partition can be recovered on loading                              with same mpisize and autopartition false.                         Disadvantage: Makes the file depend on mpisize.                  Either way the file can be loaded with autopartition true.\n\nNOTE:            Aborts on file errors.\n\nReference\n\np8est_extended.h:560\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.p8est_source_ext","page":"Reference","title":"P4est.LibP4est.p8est_source_ext","text":"𝐣𝐥.@cextern p8est_source_ext(src::𝐣𝐥.Ptr{sc_io_source_t}, mpicomm::sc_MPI_Comm, data_size::size_t, load_data::𝐣𝐥.Cint, autopartition::𝐣𝐥.Cint, broadcasthead::𝐣𝐥.Cint, user_pointer::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, connectivity::𝐣𝐥.Ptr{𝐣𝐥.Ptr{p8est_connectivity_t}})::𝐣𝐥.Ptr{p8est_t}\n\nThe same as p8estloadext, but reading the connectivity/p8est from an open sciosource_t stream.\n\nReference\n\np8est_extended.h:593\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Abort","page":"Reference","title":"P4est.LibP4est.sc_MPI_Abort","text":"𝐣𝐥.@cextern sc_MPI_Abort(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:283\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Allgather","page":"Reference","title":"P4est.LibP4est.sc_MPI_Allgather","text":"𝐣𝐥.@cextern sc_MPI_Allgather(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:325\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Allgatherv","page":"Reference","title":"P4est.LibP4est.sc_MPI_Allgatherv","text":"𝐣𝐥.@cextern sc_MPI_Allgatherv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?6?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?7?\"::sc_MPI_Datatype, var\"?8?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:327\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Allreduce","page":"Reference","title":"P4est.LibP4est.sc_MPI_Allreduce","text":"𝐣𝐥.@cextern sc_MPI_Allreduce(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:337\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Alltoall","page":"Reference","title":"P4est.LibP4est.sc_MPI_Alltoall","text":"𝐣𝐥.@cextern sc_MPI_Alltoall(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:330\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Barrier","page":"Reference","title":"P4est.LibP4est.sc_MPI_Barrier","text":"𝐣𝐥.@cextern sc_MPI_Barrier(var\"?1?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:317\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Bcast","page":"Reference","title":"P4est.LibP4est.sc_MPI_Bcast","text":"𝐣𝐥.@cextern sc_MPI_Bcast(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:318\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_compare","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_compare","text":"𝐣𝐥.@cextern sc_MPI_Comm_compare(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::sc_MPI_Comm, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:293\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_create","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_create","text":"𝐣𝐥.@cextern sc_MPI_Comm_create(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:287\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_dup","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_dup","text":"𝐣𝐥.@cextern sc_MPI_Comm_dup(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:286\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_free","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_free","text":"𝐣𝐥.@cextern sc_MPI_Comm_free(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:290\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_group","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_group","text":"𝐣𝐥.@cextern sc_MPI_Comm_group(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:294\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_rank","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_rank","text":"𝐣𝐥.@cextern sc_MPI_Comm_rank(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:292\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_size","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_size","text":"𝐣𝐥.@cextern sc_MPI_Comm_size(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:291\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Comm_split","page":"Reference","title":"P4est.LibP4est.sc_MPI_Comm_split","text":"𝐣𝐥.@cextern sc_MPI_Comm_split(var\"?1?\"::sc_MPI_Comm, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:289\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Exscan","page":"Reference","title":"P4est.LibP4est.sc_MPI_Exscan","text":"𝐣𝐥.@cextern sc_MPI_Exscan(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:341\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Finalize","page":"Reference","title":"P4est.LibP4est.sc_MPI_Finalize","text":"𝐣𝐥.@cextern sc_MPI_Finalize()::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:282\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Gather","page":"Reference","title":"P4est.LibP4est.sc_MPI_Gather","text":"𝐣𝐥.@cextern sc_MPI_Gather(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Datatype, var\"?7?\"::𝐣𝐥.Cint, var\"?8?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:320\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Gatherv","page":"Reference","title":"P4est.LibP4est.sc_MPI_Gatherv","text":"𝐣𝐥.@cextern sc_MPI_Gatherv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?6?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?7?\"::sc_MPI_Datatype, var\"?8?\"::𝐣𝐥.Cint, var\"?9?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:322\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Get_count","page":"Reference","title":"P4est.LibP4est.sc_MPI_Get_count","text":"𝐣𝐥.@cextern sc_MPI_Get_count(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Status}, var\"?2?\"::sc_MPI_Datatype, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:359\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_compare","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_compare","text":"𝐣𝐥.@cextern sc_MPI_Group_compare(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:301\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_difference","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_difference","text":"𝐣𝐥.@cextern sc_MPI_Group_difference(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:306\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_excl","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_excl","text":"𝐣𝐥.@cextern sc_MPI_Group_excl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:310\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_free","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_free","text":"𝐣𝐥.@cextern sc_MPI_Group_free(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:296\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_incl","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_incl","text":"𝐣𝐥.@cextern sc_MPI_Group_incl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:308\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_intersection","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_intersection","text":"𝐣𝐥.@cextern sc_MPI_Group_intersection(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:304\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_range_excl","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_range_excl","text":"𝐣𝐥.@cextern sc_MPI_Group_range_excl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:314\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_range_incl","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_range_incl","text":"𝐣𝐥.@cextern sc_MPI_Group_range_incl(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, ranges::(𝐣𝐥.Cint[3])[], var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:312\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_rank","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_rank","text":"𝐣𝐥.@cextern sc_MPI_Group_rank(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:298\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_size","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_size","text":"𝐣𝐥.@cextern sc_MPI_Group_size(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:297\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_translate_ranks","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_translate_ranks","text":"𝐣𝐥.@cextern sc_MPI_Group_translate_ranks(var\"?1?\"::sc_MPI_Group, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::sc_MPI_Group, var\"?5?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:299\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Group_union","page":"Reference","title":"P4est.LibP4est.sc_MPI_Group_union","text":"𝐣𝐥.@cextern sc_MPI_Group_union(var\"?1?\"::sc_MPI_Group, var\"?2?\"::sc_MPI_Group, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Group})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:302\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Init","page":"Reference","title":"P4est.LibP4est.sc_MPI_Init","text":"𝐣𝐥.@cextern sc_MPI_Init(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:279\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Init_thread","page":"Reference","title":"P4est.LibP4est.sc_MPI_Init_thread","text":"𝐣𝐥.@cextern sc_MPI_Init_thread(argc::𝐣𝐥.Ptr{𝐣𝐥.Cint}, argv::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cchar}}}, required::𝐣𝐥.Cint, provided::𝐣𝐥.Ptr{𝐣𝐥.Cint})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:387\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Iprobe","page":"Reference","title":"P4est.LibP4est.sc_MPI_Iprobe","text":"𝐣𝐥.@cextern sc_MPI_Iprobe(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Comm, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?5?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:357\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Irecv","page":"Reference","title":"P4est.LibP4est.sc_MPI_Irecv","text":"𝐣𝐥.@cextern sc_MPI_Irecv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:350\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Isend","page":"Reference","title":"P4est.LibP4est.sc_MPI_Isend","text":"𝐣𝐥.@cextern sc_MPI_Isend(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Request})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:354\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Probe","page":"Reference","title":"P4est.LibP4est.sc_MPI_Probe","text":"𝐣𝐥.@cextern sc_MPI_Probe(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Comm, var\"?4?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:356\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Recv","page":"Reference","title":"P4est.LibP4est.sc_MPI_Recv","text":"𝐣𝐥.@cextern sc_MPI_Recv(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm, var\"?7?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:348\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Reduce","page":"Reference","title":"P4est.LibP4est.sc_MPI_Reduce","text":"𝐣𝐥.@cextern sc_MPI_Reduce(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::𝐣𝐥.Cint, var\"?7?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:332\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Reduce_scatter_block","page":"Reference","title":"P4est.LibP4est.sc_MPI_Reduce_scatter_block","text":"𝐣𝐥.@cextern sc_MPI_Reduce_scatter_block(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:334\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Scan","page":"Reference","title":"P4est.LibP4est.sc_MPI_Scan","text":"𝐣𝐥.@cextern sc_MPI_Scan(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?3?\"::𝐣𝐥.Cint, var\"?4?\"::sc_MPI_Datatype, var\"?5?\"::sc_MPI_Op, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:339\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Send","page":"Reference","title":"P4est.LibP4est.sc_MPI_Send","text":"𝐣𝐥.@cextern sc_MPI_Send(var\"?1?\"::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, var\"?2?\"::𝐣𝐥.Cint, var\"?3?\"::sc_MPI_Datatype, var\"?4?\"::𝐣𝐥.Cint, var\"?5?\"::𝐣𝐥.Cint, var\"?6?\"::sc_MPI_Comm)::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:352\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Wait","page":"Reference","title":"P4est.LibP4est.sc_MPI_Wait","text":"𝐣𝐥.@cextern sc_MPI_Wait(var\"?1?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:364\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Waitall","page":"Reference","title":"P4est.LibP4est.sc_MPI_Waitall","text":"𝐣𝐥.@cextern sc_MPI_Waitall(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?3?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:367\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Waitsome","page":"Reference","title":"P4est.LibP4est.sc_MPI_Waitsome","text":"𝐣𝐥.@cextern sc_MPI_Waitsome(var\"?1?\"::𝐣𝐥.Cint, var\"?2?\"::𝐣𝐥.Ptr{sc_MPI_Request}, var\"?3?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?4?\"::𝐣𝐥.Ptr{𝐣𝐥.Cint}, var\"?5?\"::𝐣𝐥.Ptr{sc_MPI_Status})::𝐣𝐥.Cint\n\nReference\n\nsc_mpi.h:365\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_MPI_Wtime","page":"Reference","title":"P4est.LibP4est.sc_MPI_Wtime","text":"𝐣𝐥.@cextern sc_MPI_Wtime()::𝐣𝐥.Cdouble\n\nReference\n\nsc_mpi.h:344\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_abort","page":"Reference","title":"P4est.LibP4est.sc_abort","text":"𝐣𝐥.@cextern sc_abort()::𝐣𝐥.Cvoid\n\nPrint a stack trace, call the abort handler and then call abort (). \n\nReference\n\nsc.h:553\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_abort_collective","page":"Reference","title":"P4est.LibP4est.sc_abort_collective","text":"𝐣𝐥.@cextern sc_abort_collective(msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid\n\nCollective abort where only root prints a message \n\nReference\n\nsc.h:573\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_abort_verbose","page":"Reference","title":"P4est.LibP4est.sc_abort_verbose","text":"𝐣𝐥.@cextern sc_abort_verbose(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid\n\nPrint a message to stderr and then call sc_abort (). \n\nReference\n\nsc.h:557\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_abort_verbosef","page":"Reference","title":"P4est.LibP4est.sc_abort_verbosef","text":"𝐣𝐥.@cextern sc_abort_verbosef(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nPrint a message to stderr and then call sc_abort (). \n\nReference\n\nsc.h:562\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_abort_verbosev","page":"Reference","title":"P4est.LibP4est.sc_abort_verbosev","text":"𝐣𝐥.@cextern sc_abort_verbosev(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid\n\nPrint a message to stderr and then call sc_abort (). \n\nReference\n\nsc.h:568\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_bsearch","page":"Reference","title":"P4est.LibP4est.sc_array_bsearch","text":"𝐣𝐥.@cextern sc_array_bsearch(array::𝐣𝐥.Ptr{sc_array_t}, key::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::ssize_t\n\nPerforms a binary search on an array. The array must be sorted. \n\nParameters\n\narray:   A sorted array to search in.\nkey:     An element to be searched for.\ncompar:  The comparison function to be used.\n\nReturns\n\nReturns the index into array for the item found, or -1.\n\nReference\n\nsc_containers.h:359\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_checksum","page":"Reference","title":"P4est.LibP4est.sc_array_checksum","text":"𝐣𝐥.@cextern sc_array_checksum(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cuint\n\nComputes the adler32 checksum of array data (see zlib documentation). This is a faster checksum than crc32, and it works with zeros as data.\n\nReference\n\nsc_containers.h:418\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_copy","page":"Reference","title":"P4est.LibP4est.sc_array_copy","text":"𝐣𝐥.@cextern sc_array_copy(dest::𝐣𝐥.Ptr{sc_array_t}, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid\n\nCopy the contents of one array into another. Both arrays must have equal element sizes. The source array may be a view. We use memcpy (3):  If the two arrays overlap, results are undefined. \n\nParameters\n\ndest:     Array (not a view) will be resized and get new data.\nsrc:      Array used as source of new data, will not be changed.\n\nReference\n\nsc_containers.h:285\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_copy_into","page":"Reference","title":"P4est.LibP4est.sc_array_copy_into","text":"𝐣𝐥.@cextern sc_array_copy_into(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid\n\nCopy the contents of one array into some portion of another. Both arrays must have equal element sizes. Either array may be a view.  The destination array must be large enough. We use memcpy (3):  If the two arrays overlap, results are undefined. \n\nParameters\n\ndest:     Array will be written into.  Its element count must                      be at least dest_offset + src->elem_count.\ndest_offset:  First index in dest array to be overwritten.                      As every index, it refers to elements, not bytes.\nsrc:      Array used as source of new data, will not be changed.\n\nReference\n\nsc_containers.h:297\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_destroy","page":"Reference","title":"P4est.LibP4est.sc_array_destroy","text":"𝐣𝐥.@cextern sc_array_destroy(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid\n\nDestroys an array structure. \n\nParameters\n\narray:    The array to be destroyed.\n\nReference\n\nsc_containers.h:168\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_destroy_null","page":"Reference","title":"P4est.LibP4est.sc_array_destroy_null","text":"𝐣𝐥.@cextern sc_array_destroy_null(parray::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_array_t}})::𝐣𝐥.Cvoid\n\nDestroys an array structure and sets the pointer to NULL. \n\nParameters\n\nparray:       Pointer to address of array to be destroyed.                              On output, *parray is NULL.\n\nReference\n\nsc_containers.h:174\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_init","page":"Reference","title":"P4est.LibP4est.sc_array_init","text":"𝐣𝐥.@cextern sc_array_init(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid\n\nInitializes an already allocated (or static) array structure. \n\nParameters\n\narray:       Array structure to be initialized.\nelem_size:        Size of one array element in bytes.\n\nReference\n\nsc_containers.h:180\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_init_count","page":"Reference","title":"P4est.LibP4est.sc_array_init_count","text":"𝐣𝐥.@cextern sc_array_init_count(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid\n\nInitializes an already allocated (or static) array structure and allocates a given number of elements. This function supersedes scarrayinit_size. \n\nParameters\n\narray:       Array structure to be initialized.\nelem_size:        Size of one array element in bytes.\nelem_count:       Number of initial array elements.\n\nReference\n\nsc_containers.h:199\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_init_data","page":"Reference","title":"P4est.LibP4est.sc_array_init_data","text":"𝐣𝐥.@cextern sc_array_init_data(view::𝐣𝐥.Ptr{sc_array_t}, base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid\n\nInitializes an already allocated (or static) view from given plain C data. The array view returned does not require scarrayreset (doesn't hurt though). \n\nParameters\n\nview:     Array structure to be initialized.\nbase:         The data must not be moved while view is alive.\nelem_size:    Size of one array element in bytes.\nelem_count:   The length of the view in element units.                          The view cannot be resized to exceed this length.                          It is not necessary to call scarrayreset later.\n\nReference\n\nsc_containers.h:224\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_init_size","page":"Reference","title":"P4est.LibP4est.sc_array_init_size","text":"𝐣𝐥.@cextern sc_array_init_size(array::𝐣𝐥.Ptr{sc_array_t}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Cvoid\n\nInitializes an already allocated (or static) array structure and allocates a given number of elements. Deprecated: use scarrayinit_count. \n\nParameters\n\narray:       Array structure to be initialized.\nelem_size:        Size of one array element in bytes.\nelem_count:       Number of initial array elements.\n\nReference\n\nsc_containers.h:189\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_init_view","page":"Reference","title":"P4est.LibP4est.sc_array_init_view","text":"𝐣𝐥.@cextern sc_array_init_view(view::𝐣𝐥.Ptr{sc_array_t}, array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Cvoid\n\nInitializes an already allocated (or static) view from existing scarrayt. The array view returned does not require scarrayreset (doesn't hurt though). \n\nParameters\n\nview:  Array structure to be initialized.\narray:     The array must not be resized while view is alive.\noffset:    The offset of the viewed section in element units.                       This offset cannot be changed until the view is reset.\nlength:    The length of the view in element units.                       The view cannot be resized to exceed this length.                       It is not necessary to call scarrayreset later.\n\nReference\n\nsc_containers.h:212\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_is_equal","page":"Reference","title":"P4est.LibP4est.sc_array_is_equal","text":"𝐣𝐥.@cextern sc_array_is_equal(array::𝐣𝐥.Ptr{sc_array_t}, other::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint\n\nCheck whether two arrays have equal size, count, and content. Either array may be a view.  Both arrays will not be changed. \n\nParameters\n\narray:   One array to be compared.\nother:   A second array to be compared.\n\nReturns\n\n          True if array and other are equal, false otherwise.\n\nReference\n\nsc_containers.h:341\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_is_permutation","page":"Reference","title":"P4est.LibP4est.sc_array_is_permutation","text":"𝐣𝐥.@cextern sc_array_is_permutation(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cint\n\nDetermine whether array is an array of sizet's whose entries include every integer 0 <= i < array->elemcount. \n\nParameters\n\narray:         An array.\n\nReturns\n\n               Returns 1 if array contains size_t elements whose                           entries include every integer                           0 <= i < *array->elem_count,* 0 otherwise.\n\nReference\n\nsc_containers.h:399\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_is_sorted","page":"Reference","title":"P4est.LibP4est.sc_array_is_sorted","text":"𝐣𝐥.@cextern sc_array_is_sorted(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cint\n\nCheck whether the array is sorted wrt. the comparison function. \n\nParameters\n\narray:    The array to check.\ncompar:   The comparison function to be used.\n\nReturns\n\n          True if array is sorted, false otherwise.\n\nReference\n\nsc_containers.h:331\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_memory_used","page":"Reference","title":"P4est.LibP4est.sc_array_memory_used","text":"𝐣𝐥.@cextern sc_array_memory_used(array::𝐣𝐥.Ptr{sc_array_t}, is_dynamic::𝐣𝐥.Cint)::size_t\n\nCalculate the memory used by an array. \n\nParameters\n\narray:       The array.\nis_dynamic:  True if created with scarraynew,                         false if initialized with scarrayinit\n\nReturns\n\n             Memory used in bytes.\n\nReference\n\nsc_containers.h:127\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_memset","page":"Reference","title":"P4est.LibP4est.sc_array_memset","text":"𝐣𝐥.@cextern sc_array_memset(array::𝐣𝐥.Ptr{sc_array_t}, c::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nRun memset on the array storage. We pass the character to memset unchanged.  Thus, care must be taken when setting values below -1 or above 127, just as with standard memset (3). \n\nParameters\n\narray:    This array's storage will be overwritten.\nc:            Character to overwrite every byte with.\n\nReference\n\nsc_containers.h:233\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_move_part","page":"Reference","title":"P4est.LibP4est.sc_array_move_part","text":"𝐣𝐥.@cextern sc_array_move_part(dest::𝐣𝐥.Ptr{sc_array_t}, dest_offset::size_t, src::𝐣𝐥.Ptr{sc_array_t}, src_offset::size_t, count::size_t)::𝐣𝐥.Cvoid\n\nCopy part of one array into another using memmove (3). Both arrays must have equal element sizes. Either array may be a view.  The destination array must be large enough. We use memmove (3):  The two arrays may overlap. \n\nParameters\n\ndest:     Array will be written into.  Its element count must                      be at least dest_offset + count.\ndest_offset:  First index in dest array to be overwritten.                      As every index, it refers to elements, not bytes.\nsrc:      Array will be read from.  Its element count must                      be at least src_offset + count.\nsrc_offset:   First index in src array to be used.                      As every index, it refers to elements, not bytes.\ncount:    Number of entries copied.\n\nReference\n\nsc_containers.h:314\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_new","page":"Reference","title":"P4est.LibP4est.sc_array_new","text":"𝐣𝐥.@cextern sc_array_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_array_t}\n\nCreates a new array structure with 0 elements. \n\nParameters\n\nelem_size:    Size of one array element in bytes.\n\nReturns\n\n              Return an allocated array of zero length.\n\nReference\n\nsc_containers.h:133\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_new_count","page":"Reference","title":"P4est.LibP4est.sc_array_new_count","text":"𝐣𝐥.@cextern sc_array_new_count(elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}\n\nCreates a new array structure with a given length (number of elements). \n\nParameters\n\nelem_size:    Size of one array element in bytes.\nelem_count:   Initial number of array elements.\n\nReturns\n\n              Return an allocated array                          with allocated but uninitialized elements.\n\nReference\n\nsc_containers.h:141\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_new_data","page":"Reference","title":"P4est.LibP4est.sc_array_new_data","text":"𝐣𝐥.@cextern sc_array_new_data(base::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, elem_size::size_t, elem_count::size_t)::𝐣𝐥.Ptr{sc_array_t}\n\nCreates a new view of an existing plain C array. \n\nParameters\n\nbase:         The data must not be moved while view is alive.\nelem_size:    Size of one array element in bytes.\nelem_count:   The length of the view in element units.                          The view cannot be resized to exceed this length.\n\nReference\n\nsc_containers.h:162\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_new_view","page":"Reference","title":"P4est.LibP4est.sc_array_new_view","text":"𝐣𝐥.@cextern sc_array_new_view(array::𝐣𝐥.Ptr{sc_array_t}, offset::size_t, length::size_t)::𝐣𝐥.Ptr{sc_array_t}\n\nCreates a new view of an existing scarrayt. \n\nParameters\n\narray:    The array must not be resized while view is alive.\noffset:   The offset of the viewed section in element units.                      This offset cannot be changed until the view is reset.\nlength:   The length of the viewed section in element units.                      The view cannot be resized to exceed this length.\n\nReference\n\nsc_containers.h:153\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_permute","page":"Reference","title":"P4est.LibP4est.sc_array_permute","text":"𝐣𝐥.@cextern sc_array_permute(array::𝐣𝐥.Ptr{sc_array_t}, newindices::𝐣𝐥.Ptr{sc_array_t}, keepperm::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nGiven permutation newindices, permute array in place.  The data that on input is contained in array[i] will be contained in array[newindices[i]] on output.  The entries of newindices will be altered unless keepperm is true. \n\nParameters\n\narray:      An array.\nnewindices: Permutation array (see scarrayis_permutation).\nkeepperm:   If true, newindices will be unchanged by the                            algorithm; if false, newindices will be the                            identity permutation on output, but the                            algorithm will only use O(1) space.\n\nReference\n\nsc_containers.h:412\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_pqueue_add","page":"Reference","title":"P4est.LibP4est.sc_array_pqueue_add","text":"𝐣𝐥.@cextern sc_array_pqueue_add(array::𝐣𝐥.Ptr{sc_array_t}, temp::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t\n\nAdds an element to a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. The priority queue is implemented as a heap in ascending order. A heap is a binary tree where the children are not less than their parent. Assumes that elements [0]..[elemcount-2] form a valid heap. Then propagates [elemcount-1] upward by swapping if necessary. \n\nParameters\n\ntemp:    Pointer to unused allocated memory of elem_size.\ncompar:  The comparison function to be used.\n\nReturns\n\nReturns the number of swap operations. \n\nNOTE:  If the return value is zero for all elements in an array,        the array is sorted linearly and unchanged.\n\nReference\n\nsc_containers.h:433\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_pqueue_pop","page":"Reference","title":"P4est.LibP4est.sc_array_pqueue_pop","text":"𝐣𝐥.@cextern sc_array_pqueue_pop(array::𝐣𝐥.Ptr{sc_array_t}, result::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::size_t\n\nPops the smallest element from a priority queue. PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. This function assumes that the array forms a valid heap in ascending order. \n\nParameters\n\nresult:  Pointer to unused allocated memory of elem_size.\ncompar:  The comparison function to be used.\n\nReturns\n\nReturns the number of swap operations. \n\nNOTE: This function resizes the array to elem_count-1.\n\nReference\n\nsc_containers.h:447\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_reset","page":"Reference","title":"P4est.LibP4est.sc_array_reset","text":"𝐣𝐥.@cextern sc_array_reset(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid\n\nSets the array count to zero and frees all elements. This function turns a view into a newly initialized array. \n\nParameters\n\narray:       Array structure to be reset.\n\nNOTE: Calling scarrayinit, then any array operations,       then scarrayreset is memory neutral.       As an exception, the two functions scarrayinitview and       scarrayinitdata do not require a subsequent call to scarrayreset.       Regardless, it is legal to call scarrayreset anyway.\n\nReference\n\nsc_containers.h:244\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_resize","page":"Reference","title":"P4est.LibP4est.sc_array_resize","text":"𝐣𝐥.@cextern sc_array_resize(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid\n\nSets the element count to newcount. If the array is not a view, reallocation takes place occasionally. If the array is a view, newcount must not be greater than the element count of the view when it was created.  The original offset of the view cannot be changed. \n\nParameters\n\narray:    The element count and address is modified.\nnew_count:    New element count of the array.                          If it is zero and the array is not a view,                          the effect equals scarrayreset.\n\nReference\n\nsc_containers.h:276\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_rewind","page":"Reference","title":"P4est.LibP4est.sc_array_rewind","text":"𝐣𝐥.@cextern sc_array_rewind(array::𝐣𝐥.Ptr{sc_array_t}, new_count::size_t)::𝐣𝐥.Cvoid\n\nShorten an array without reallocating it. \n\nParameters\n\narray:    The element count of this array is modified.\nnew_count:    Must be less or equal than the array's count.                          If it is less, the number of elements in the                          array is reduced without reallocating memory.                          The exception is a new_count of zero                          specified for an array that is not a view:                          In this case scarrayreset is equivalent.\n\nReference\n\nsc_containers.h:264\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_sort","page":"Reference","title":"P4est.LibP4est.sc_array_sort","text":"𝐣𝐥.@cextern sc_array_sort(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid\n\nSorts the array in ascending order wrt. the comparison function. \n\nParameters\n\narray:    The array to sort.\ncompar:   The comparison function to be used.\n\nReference\n\nsc_containers.h:322\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_split","page":"Reference","title":"P4est.LibP4est.sc_array_split","text":"𝐣𝐥.@cextern sc_array_split(array::𝐣𝐥.Ptr{sc_array_t}, offsets::𝐣𝐥.Ptr{sc_array_t}, num_types::size_t, type_fn::sc_array_type_t, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nCompute the offsets of groups of enumerable types in an array. \n\nParameters\n\narray:         Array that is sorted in ascending order by type.                           If k indexes array, then                           0 <= type_fn (array, k, data) <                           num_types.\noffsets:   An initialized array of type sizet that is                           resized to *numtypes* + 1 entries.  The indices                           j of array that contain objects of type k are                           offsets[k] <= j < offsets[k + 1].                           If there are no objects of type k, then                           offsets[k] = offset[k + 1].\nnum_types:     The number of possible types of objects in                           array.\ntype_fn:       Returns the type of an object in the array.\ndata:          Arbitrary user data passed to type_fn.\n\nReference\n\nsc_containers.h:388\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_truncate","page":"Reference","title":"P4est.LibP4est.sc_array_truncate","text":"𝐣𝐥.@cextern sc_array_truncate(array::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid\n\nSets the array count to zero, but does not free elements. Not allowed for views. \n\nParameters\n\narray:       Array structure to be truncated.\n\nNOTE: This is intended to allow an sc_array to be used as a reusable buffer, where the \"high water mark\" of the buffer is preserved, so that O(log (max n)) reallocs occur over the life of the buffer.\n\nReference\n\nsc_containers.h:253\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_array_uniq","page":"Reference","title":"P4est.LibP4est.sc_array_uniq","text":"𝐣𝐥.@cextern sc_array_uniq(array::𝐣𝐥.Ptr{sc_array_t}, compar::𝐣𝐥.Ptr{𝐣𝐥.Cfunction{𝐣𝐥.Cint, 𝐣𝐥.Tuple{𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, 𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}}, 𝐣𝐥.CDECL}})::𝐣𝐥.Cvoid\n\nRemoved duplicate entries from a sorted array. This function is not allowed for views. \n\nParameters\n\narray:  The array size will be reduced as necessary.\ncompar:     The comparison function to be used.\n\nReference\n\nsc_containers.h:349\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_atoi","page":"Reference","title":"P4est.LibP4est.sc_atoi","text":"𝐣𝐥.@cextern sc_atoi(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint\n\nSafe version of the standard library atoi (3) function. \n\nParameters\n\nnptr:     NUL-terminated string.\n\nReturns\n\n          Converted integer value.  0 if no valid number.                      INT_MAX on overflow, INT_MIN on underflow.\n\nReference\n\nsc.h:498\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_atol","page":"Reference","title":"P4est.LibP4est.sc_atol","text":"𝐣𝐥.@cextern sc_atol(nptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Clong\n\nSafe version of the standard library atol (3) function. \n\nParameters\n\nnptr:     NUL-terminated string.\n\nReturns\n\n          Converted long value.  0 if no valid number.                      LONG_MAX on overflow, LONG_MIN on underflow.\n\nReference\n\nsc.h:505\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_calloc","page":"Reference","title":"P4est.LibP4est.sc_calloc","text":"𝐣𝐥.@cextern sc_calloc(package::𝐣𝐥.Cint, nmemb::size_t, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReference\n\nsc.h:477\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_double_compare","page":"Reference","title":"P4est.LibP4est.sc_double_compare","text":"𝐣𝐥.@cextern sc_double_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nReference\n\nsc.h:491\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_fflush_fsync_fclose","page":"Reference","title":"P4est.LibP4est.sc_fflush_fsync_fclose","text":"𝐣𝐥.@cextern sc_fflush_fsync_fclose(file::𝐣𝐥.Ptr{FILE})::𝐣𝐥.Cvoid\n\nBest effort to flush a file's data to disc and close it. \n\nParameters\n\nfile:         File open for writing.\n\nReference\n\nsc_io.h:286\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_finalize","page":"Reference","title":"P4est.LibP4est.sc_finalize","text":"𝐣𝐥.@cextern sc_finalize()::𝐣𝐥.Cvoid\n\nUnregisters all packages, runs the memory check, removes the signal handlers and resets scidentifier and scroot*. This function is optional. This function does not require scinit to be called first.\n\nReference\n\nsc.h:668\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_fread","page":"Reference","title":"P4est.LibP4est.sc_fread","text":"𝐣𝐥.@cextern sc_fread(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid\n\nRead file content into memory. \n\nParameters\n\nptr:     Data array to read from disk.\nsize:     Size of one array member.\nnmemb:    Number of array members.\nfile: File pointer, must be opened for reading.\nerrmsg:   Error message passed to SCCHECKABORT.\n\nNOTE:                This function aborts on file errors.\n\nReference\n\nsc_io.h:280\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_free","page":"Reference","title":"P4est.LibP4est.sc_free","text":"𝐣𝐥.@cextern sc_free(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:480\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_fwrite","page":"Reference","title":"P4est.LibP4est.sc_fwrite","text":"𝐣𝐥.@cextern sc_fwrite(ptr::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, size::size_t, nmemb::size_t, file::𝐣𝐥.Ptr{FILE}, errmsg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid\n\nWrite memory content to a file. \n\nParameters\n\nptr:      Data array to write to disk.\nsize:     Size of one array member.\nnmemb:    Number of array members.\nfile: File pointer, must be opened for writing.\nerrmsg:   Error message passed to SCCHECKABORT.\n\nNOTE:                This function aborts on file errors.\n\nReference\n\nsc_io.h:269\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_destroy","page":"Reference","title":"P4est.LibP4est.sc_hash_array_destroy","text":"𝐣𝐥.@cextern sc_hash_array_destroy(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid\n\nDestroy a hash array.\n\nReference\n\nsc_containers.h:1057\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_insert_unique","page":"Reference","title":"P4est.LibP4est.sc_hash_array_insert_unique","text":"𝐣𝐥.@cextern sc_hash_array_insert_unique(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nInsert an object into a hash array if it is not contained already. The object is not copied into the array.  Use the return value for that. New objects are guaranteed to be added at the end of the array.\n\nParameters\n\nv:          A pointer to the object.  Used for search only.\nposition:   If position != NULL, *position is set to the                         array position of the already contained, or if                         not present, the new object.\n\nReturns\n\n             Returns NULL if the object is already contained.                         Otherwise returns its new address in the array.\n\nReference\n\nsc_containers.h:1090\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_is_valid","page":"Reference","title":"P4est.LibP4est.sc_hash_array_is_valid","text":"𝐣𝐥.@cextern sc_hash_array_is_valid(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cint\n\nCheck the internal consistency of a hash array.\n\nReference\n\nsc_containers.h:1061\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_lookup","page":"Reference","title":"P4est.LibP4est.sc_hash_array_lookup","text":"𝐣𝐥.@cextern sc_hash_array_lookup(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint\n\nCheck if an object is contained in a hash array.\n\nParameters\n\nv:          A pointer to the object.\nposition:   If position != NULL, *position is set to the                         array position of the already contained object                         if found.\n\nReturns\n\n             Returns true if object is found, false otherwise.\n\nReference\n\nsc_containers.h:1076\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_memory_used","page":"Reference","title":"P4est.LibP4est.sc_hash_array_memory_used","text":"𝐣𝐥.@cextern sc_hash_array_memory_used(ha::𝐣𝐥.Ptr{sc_hash_array_t})::size_t\n\nCalculate the memory used by a hash array. \n\nParameters\n\nha:          The hash array.\n\nReturns\n\n             Memory used in bytes.\n\nReference\n\nsc_containers.h:1043\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_new","page":"Reference","title":"P4est.LibP4est.sc_hash_array_new","text":"𝐣𝐥.@cextern sc_hash_array_new(elem_size::size_t, hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_hash_array_t}\n\nCreate a new hash array. \n\nParameters\n\nelem_size:   Size of one array element in bytes.\nhash_fn:     Function to compute the hash value.\nequal_fn:    Function to test two objects for equality.\n\nReference\n\nsc_containers.h:1050\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_rip","page":"Reference","title":"P4est.LibP4est.sc_hash_array_rip","text":"𝐣𝐥.@cextern sc_hash_array_rip(hash_array::𝐣𝐥.Ptr{sc_hash_array_t}, rip::𝐣𝐥.Ptr{sc_array_t})::𝐣𝐥.Cvoid\n\nExtract the array data from a hash array and destroy everything else. \n\nParameters\n\nhash_array:   The hash array is destroyed after extraction.\nrip:          Array structure that will be overwritten.                          All previous array data (if any) will be leaked.                          The filled array can be freed with scarrayreset.\n\nReference\n\nsc_containers.h:1099\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_array_truncate","page":"Reference","title":"P4est.LibP4est.sc_hash_array_truncate","text":"𝐣𝐥.@cextern sc_hash_array_truncate(hash_array::𝐣𝐥.Ptr{sc_hash_array_t})::𝐣𝐥.Cvoid\n\nRemove all elements from the hash array. \n\nParameters\n\nhash_array:   Hash array to truncate.\n\nReference\n\nsc_containers.h:1066\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_destroy","page":"Reference","title":"P4est.LibP4est.sc_hash_destroy","text":"𝐣𝐥.@cextern sc_hash_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid\n\nDestroy a hash table.\n\nDetails\n\nIf the allocator is owned, this runs in O(1), otherwise in O(N). \n\nNOTE: If allocator was provided in schashnew, it will not be destroyed.\n\nReference\n\nsc_containers.h:949\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_destroy_null","page":"Reference","title":"P4est.LibP4est.sc_hash_destroy_null","text":"𝐣𝐥.@cextern sc_hash_destroy_null(phash::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_hash_t}})::𝐣𝐥.Cvoid\n\nDestroy a hash table and set its pointer to NULL. Destruction is done using schashdestroy. \n\nParameters\n\nphash:        Address of pointer to hash table.                              On output, pointer is NULLed.\n\nReference\n\nsc_containers.h:956\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_foreach","page":"Reference","title":"P4est.LibP4est.sc_hash_foreach","text":"𝐣𝐥.@cextern sc_hash_foreach(hash::𝐣𝐥.Ptr{sc_hash_t}, fn::sc_hash_foreach_t)::𝐣𝐥.Cvoid\n\nInvoke a callback for every member of the hash table. The functions hashfn and equalfn are not called by this function.\n\nReference\n\nsc_containers.h:1009\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_function_string","page":"Reference","title":"P4est.LibP4est.sc_hash_function_string","text":"𝐣𝐥.@cextern sc_hash_function_string(s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, u::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cuint\n\nCompute a hash value from a null-terminated string. This hash function is NOT cryptographically safe! Use libcrypt then. \n\nParameters\n\ns:        Null-terminated string to be hashed.\nu:        Not used.\n\nReturns\n\n          The computed hash value as an unsigned integer.\n\nReference\n\nsc_containers.h:925\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_insert_unique","page":"Reference","title":"P4est.LibP4est.sc_hash_insert_unique","text":"𝐣𝐥.@cextern sc_hash_insert_unique(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint\n\nInsert an object into a hash table if it is not contained already. \n\nParameters\n\nv:      The object to be inserted.\nfound:  If found != NULL, *found is set to the address of the                     pointer to the already contained, or if not present,                     the new object.  You can assign to **found to override.\n\nReturns\n\nReturns true if object is added, false if it is already contained.\n\nReference\n\nsc_containers.h:995\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_lookup","page":"Reference","title":"P4est.LibP4est.sc_hash_lookup","text":"𝐣𝐥.@cextern sc_hash_lookup(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}}})::𝐣𝐥.Cint\n\nCheck if an object is contained in the hash table. \n\nParameters\n\nv:      The object to be looked up.\nfound:  If found != NULL, *found is set to the address of the                     pointer to the already contained object if the object                     is found.  You can assign to **found to override.\n\nReturns\n\nReturns true if object is found, false otherwise.\n\nReference\n\nsc_containers.h:986\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_memory_used","page":"Reference","title":"P4est.LibP4est.sc_hash_memory_used","text":"𝐣𝐥.@cextern sc_hash_memory_used(hash::𝐣𝐥.Ptr{sc_hash_t})::size_t\n\nCalculate the memory used by a hash table. \n\nParameters\n\nhash:        The hash table.\n\nReturns\n\n             Memory used in bytes.\n\nReference\n\nsc_containers.h:931\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_new","page":"Reference","title":"P4est.LibP4est.sc_hash_new","text":"𝐣𝐥.@cextern sc_hash_new(hash_fn::sc_hash_function_t, equal_fn::sc_equal_function_t, user_data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_hash_t}\n\nCreate a new hash table. The number of hash slots is chosen dynamically. \n\nParameters\n\nhash_fn:     Function to compute the hash value.\nequal_fn:    Function to test two objects for equality.\nuser_data:   User data passed through to the hash function.\nallocator:   Memory allocator for sclinkt, can be NULL.\n\nReference\n\nsc_containers.h:940\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_print_statistics","page":"Reference","title":"P4est.LibP4est.sc_hash_print_statistics","text":"𝐣𝐥.@cextern sc_hash_print_statistics(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint, hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid\n\nCompute and print statistical information about the occupancy.\n\nReference\n\nsc_containers.h:1013\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_remove","page":"Reference","title":"P4est.LibP4est.sc_hash_remove","text":"𝐣𝐥.@cextern sc_hash_remove(hash::𝐣𝐥.Ptr{sc_hash_t}, v::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, found::𝐣𝐥.Ptr{𝐣𝐥.Ptr{𝐣𝐥.Cvoid}})::𝐣𝐥.Cint\n\nRemove an object from a hash table. \n\nParameters\n\nv:      The object to be removed.\nfound:  If found != NULL, *found is set to the object                       that is removed if that exists.\n\nReturns\n\nReturns true if object is found, false if is not contained.\n\nReference\n\nsc_containers.h:1004\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_truncate","page":"Reference","title":"P4est.LibP4est.sc_hash_truncate","text":"𝐣𝐥.@cextern sc_hash_truncate(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid\n\nRemove all entries from a hash table in O(N).\n\nDetails\n\nIf the allocator is owned, it calls schashunlink and scmempooltruncate. Otherwise, it calls sclistreset on every hash slot which is slower.\n\nReference\n\nsc_containers.h:963\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_unlink","page":"Reference","title":"P4est.LibP4est.sc_hash_unlink","text":"𝐣𝐥.@cextern sc_hash_unlink(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid\n\nUnlink all hash elements without returning them to the mempool.\n\nDetails\n\nIf the allocator is not owned, this runs faster than schashtruncate,    but is dangerous because of potential memory leaks. \n\nParameters\n\nhash:       Hash structure to be unlinked.\n\nReference\n\nsc_containers.h:971\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_hash_unlink_destroy","page":"Reference","title":"P4est.LibP4est.sc_hash_unlink_destroy","text":"𝐣𝐥.@cextern sc_hash_unlink_destroy(hash::𝐣𝐥.Ptr{sc_hash_t})::𝐣𝐥.Cvoid\n\nSame effect as unlink and destroy, but in O(1). This is dangerous because of potential memory leaks. \n\nParameters\n\nhash:       Hash structure to be unlinked and destroyed.\n\nReference\n\nsc_containers.h:977\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_init","page":"Reference","title":"P4est.LibP4est.sc_init","text":"𝐣𝐥.@cextern sc_init(mpicomm::sc_MPI_Comm, catch_signals::𝐣𝐥.Cint, print_backtrace::𝐣𝐥.Cint, log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSets the global program identifier (e.g. the MPI rank) and some flags. This function is optional. This function must only be called before additional threads are created. If this function is not called or called with loghandler == NULL, the default SC log handler will be used. If this function is not called or called with logthreshold == SCLPDEFAULT, the default SC log threshold will be used. The default SC log settings can be changed with scsetlog_defaults (). \n\nParameters\n\nmpicomm:          MPI communicator, can be scMPICOMMNULL.                              If scMPICOMMNULL, the identifier is set to -1.                              Otherwise, scMPIInit must have been called.                              Effectively, we just query size and rank.\ncatch_signals:    If true, signals INT and SEGV are caught.\nprint_backtrace:  If true, sc_abort prints a backtrace.\n\nReference\n\nsc.h:659\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_int16_compare","page":"Reference","title":"P4est.LibP4est.sc_int16_compare","text":"𝐣𝐥.@cextern sc_int16_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nReference\n\nsc.h:488\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_int32_compare","page":"Reference","title":"P4est.LibP4est.sc_int32_compare","text":"𝐣𝐥.@cextern sc_int32_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nReference\n\nsc.h:489\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_int64_compare","page":"Reference","title":"P4est.LibP4est.sc_int64_compare","text":"𝐣𝐥.@cextern sc_int64_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nReference\n\nsc.h:490\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_int8_compare","page":"Reference","title":"P4est.LibP4est.sc_int8_compare","text":"𝐣𝐥.@cextern sc_int8_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nReference\n\nsc.h:487\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_int_compare","page":"Reference","title":"P4est.LibP4est.sc_int_compare","text":"𝐣𝐥.@cextern sc_int_compare(v1::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, v2::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nReference\n\nsc.h:486\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_sink_align","page":"Reference","title":"P4est.LibP4est.sc_io_sink_align","text":"𝐣𝐥.@cextern sc_io_sink_align(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_align::size_t)::𝐣𝐥.Cint\n\nAlign sink to a byte boundary by writing zeros. \n\nParameters\n\nsink:         The sink object to align.\nbytes_align:      Byte boundary.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:156\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_sink_complete","page":"Reference","title":"P4est.LibP4est.sc_io_sink_complete","text":"𝐣𝐥.@cextern sc_io_sink_complete(sink::𝐣𝐥.Ptr{sc_io_sink_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint\n\nFlush all buffered output data to sink. This function may return SCIOERRORAGAIN if another write is required. Currently this may happen if BUFFER requires an integer multiple of bytes. If successful, the updated value of bytes read and written is returned in bytesin/out, and the sink status is reset as if the sink had just been created.  In particular, the bytes counters are reset to zero. The internal state of the sink is not changed otherwise. It is legal to continue writing to the sink hereafter. The sink actions taken depend on its type. BUFFER, FILEFILE: none. FILENAME: call fclose on sink->file. \n\nParameters\n\nsink:         The sink object to write to.\nbytes_in:     Bytes received since the last new or complete                              call.  May be NULL.\nbytes_out:    Bytes written since the last new or complete                              call.  May be NULL.\n\nReturns\n\n                  0 if completed, nonzero on error.\n\nReference\n\nsc_io.h:147\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_sink_destroy","page":"Reference","title":"P4est.LibP4est.sc_io_sink_destroy","text":"𝐣𝐥.@cextern sc_io_sink_destroy(sink::𝐣𝐥.Ptr{sc_io_sink_t})::𝐣𝐥.Cint\n\nFree data sink. Calls sciosinkcomplete and discards the final counts. Errors from complete lead to SCIOERRORFATAL returned from this function. Call sciosinkcomplete yourself if bytesout is of interest. \n\nParameters\n\nsink:         The sink object to complete and free.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:117\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_sink_new","page":"Reference","title":"P4est.LibP4est.sc_io_sink_new","text":"𝐣𝐥.@cextern sc_io_sink_new(iotype::sc_io_type_t, mode::sc_io_mode_t, encode::sc_io_encode_t, var\"?vararg?\"...)::𝐣𝐥.Ptr{sc_io_sink_t}\n\nCreate a generic data sink. \n\nParameters\n\niotype:           Type of the sink.                              Depending on iotype, varargs must follow:                              BUFFER: scarrayt * (existing array).                              FILENAME: const char * (name of file to open).                              FILEFILE: FILE * (file open for writing).                              These buffers are only borrowed by the sink.\nmode:             Mode to add data to sink.                              For type FILEFILE, data is always appended.\nencode:           Type of data encoding.\n\nReturns\n\n                  Newly allocated sink, or NULL on error.\n\nReference\n\nsc_io.h:106\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_sink_write","page":"Reference","title":"P4est.LibP4est.sc_io_sink_write","text":"𝐣𝐥.@cextern sc_io_sink_write(sink::𝐣𝐥.Ptr{sc_io_sink_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, bytes_avail::size_t)::𝐣𝐥.Cint\n\nWrite data to a sink.  Data may be buffered and sunk in a later call. The internal counters sink->bytesin and sink->bytesout are updated. \n\nParameters\n\nsink:         The sink object to write to.\ndata:             Data passed into sink.\nbytes_avail:      Number of data bytes passed in.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:126\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_activate_mirror","page":"Reference","title":"P4est.LibP4est.sc_io_source_activate_mirror","text":"𝐣𝐥.@cextern sc_io_source_activate_mirror(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint\n\nActivate a buffer that mirrors (i.e., stores) the data that was read. \n\nParameters\n\nsource:       The source object to activate mirror in.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:230\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_align","page":"Reference","title":"P4est.LibP4est.sc_io_source_align","text":"𝐣𝐥.@cextern sc_io_source_align(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_align::size_t)::𝐣𝐥.Cint\n\nAlign source to a byte boundary by skipping. \n\nParameters\n\nsource:       The source object to align.\nbytes_align:      Byte boundary.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:223\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_complete","page":"Reference","title":"P4est.LibP4est.sc_io_source_complete","text":"𝐣𝐥.@cextern sc_io_source_complete(source::𝐣𝐥.Ptr{sc_io_source_t}, bytes_in::𝐣𝐥.Ptr{size_t}, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint\n\nDetermine whether all data buffered from source has been returned by read. If it returns SCIOERRORAGAIN, another sciosourceread is required. If the call returns no error, the internal counters source->bytesin and source->bytesout are returned to the caller if requested, and reset to 0. The internal state of the source is not changed otherwise. It is legal to continue reading from the source hereafter.\n\nParameters\n\nsource:       The source object to read from.\nbytes_in:     If not NULL and true is returned,                              the total size of the data sourced.\nbytes_out:    If not NULL and true is returned,                              total bytes passed out by source_read.\n\nReturns\n\n                  SC_IO_ERROR_AGAIN if buffered data remaining.                              Otherwise return ERROR_NONE and reset counters.\n\nReference\n\nsc_io.h:214\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_destroy","page":"Reference","title":"P4est.LibP4est.sc_io_source_destroy","text":"𝐣𝐥.@cextern sc_io_source_destroy(source::𝐣𝐥.Ptr{sc_io_source_t})::𝐣𝐥.Cint\n\nFree data source. Calls sciosource_complete and requires it to return no error. This is to avoid discarding buffered data that has not been passed to read. \n\nParameters\n\nsource:       The source object to free.\n\nReturns\n\n                  0 on success.  Nonzero if an error is                              encountered or is_complete returns one.\n\nReference\n\nsc_io.h:178\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_new","page":"Reference","title":"P4est.LibP4est.sc_io_source_new","text":"𝐣𝐥.@cextern sc_io_source_new(iotype::sc_io_type_t, encode::sc_io_encode_t, var\"?vararg?\"...)::𝐣𝐥.Ptr{sc_io_source_t}\n\nCreate a generic data source. \n\nParameters\n\niotype:           Type of the source.                              Depending on iotype, varargs must follow:                              BUFFER: scarrayt * (existing array).                              FILENAME: const char * (name of file to open).                              FILEFILE: FILE * (file open for reading).\nencode:           Type of data encoding.\n\nReturns\n\n                  Newly allocated source, or NULL on error.\n\nReference\n\nsc_io.h:168\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_read","page":"Reference","title":"P4est.LibP4est.sc_io_source_read","text":"𝐣𝐥.@cextern sc_io_source_read(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint\n\nRead data from a source. The internal counters source->bytesin and source->bytesout are updated. Data is read until the data buffer has not enough room anymore, or source becomes empty.  It is possible that data already read internally remains in the source object for the next call.  Call sciosourcecomplete and check its return value to find out. Returns an error if bytesout is NULL and less than bytes_avail are read. \n\nParameters\n\nsource:       The source object to read from.\ndata:             Data buffer for reading from sink.                              If NULL the output data will be thrown away.\nbytes_avail:      Number of bytes available in data buffer.\nbytes_out:    If not NULL, byte count read into data buffer.                              Otherwise, requires to read exactly bytes_avail.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:195\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_io_source_read_mirror","page":"Reference","title":"P4est.LibP4est.sc_io_source_read_mirror","text":"𝐣𝐥.@cextern sc_io_source_read_mirror(source::𝐣𝐥.Ptr{sc_io_source_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, bytes_avail::size_t, bytes_out::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Cint\n\nRead data from the source's mirror. Same behaviour as sciosource_read. \n\nParameters\n\nsource:       The source object to read mirror data from.\n\nReturns\n\n                  0 on success, nonzero on error.\n\nReference\n\nsc_io.h:237\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_is_root","page":"Reference","title":"P4est.LibP4est.sc_is_root","text":"𝐣𝐥.@cextern sc_is_root()::𝐣𝐥.Cint\n\nIdentify the root process. Only meaningful between scinit and scfinalize and with a communicator that is not scMPICOMM_NULL (otherwise always true).\n\nReturns\n\n      Return true for the root process and false otherwise.\n\nReference\n\nsc.h:676\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_append","page":"Reference","title":"P4est.LibP4est.sc_list_append","text":"𝐣𝐥.@cextern sc_list_append(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}\n\nInsert a list element at the end of the list. \n\nParameters\n\nlist:     Valid list object.\ndata:         A new link is created holding this data.\n\nReturns\n\n              The link that has been created for data.\n\nReference\n\nsc_containers.h:874\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_destroy","page":"Reference","title":"P4est.LibP4est.sc_list_destroy","text":"𝐣𝐥.@cextern sc_list_destroy(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid\n\nDestroy a linked list structure in O(N). \n\nParameters\n\nlist:     All memory allocated for this list is freed.\n\nNOTE: If allocator was provided in sclistnew, it will not be destroyed.\n\nReference\n\nsc_containers.h:840\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_init","page":"Reference","title":"P4est.LibP4est.sc_list_init","text":"𝐣𝐥.@cextern sc_list_init(list::𝐣𝐥.Ptr{sc_list_t}, allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid\n\nInitialize a list object with an external link allocator. \n\nParameters\n\nlist:       List structure to be initialized.\nallocator:  External memory allocator for sclinkt,                             which must exist already.\n\nReference\n\nsc_containers.h:847\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_insert","page":"Reference","title":"P4est.LibP4est.sc_list_insert","text":"𝐣𝐥.@cextern sc_list_insert(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}\n\nInsert an element after a given list position. \n\nParameters\n\nlist:     Valid list object.\npred:     The predecessor of the element to be inserted.\ndata:         A new link is created holding this data.\n\nReturns\n\n              The link that has been created for data.\n\nReference\n\nsc_containers.h:882\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_memory_used","page":"Reference","title":"P4est.LibP4est.sc_list_memory_used","text":"𝐣𝐥.@cextern sc_list_memory_used(list::𝐣𝐥.Ptr{sc_list_t}, is_dynamic::𝐣𝐥.Cint)::size_t\n\nCalculate the total memory used by a list. \n\nParameters\n\nlist:        The list.\nis_dynamic:  True if created with sclistnew,                         false if initialized with sclistinit\n\nReturns\n\n             Memory used in bytes.\n\nReference\n\nsc_containers.h:827\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_new","page":"Reference","title":"P4est.LibP4est.sc_list_new","text":"𝐣𝐥.@cextern sc_list_new(allocator::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Ptr{sc_list_t}\n\nAllocate a new, empty linked list. \n\nParameters\n\nallocator:    Memory allocator for sclinkt, can be NULL                          in which case an internal allocator is created.\n\nReturns\n\n              Pointer to a newly allocated, empty list object.\n\nReference\n\nsc_containers.h:834\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_pop","page":"Reference","title":"P4est.LibP4est.sc_list_pop","text":"𝐣𝐥.@cextern sc_list_pop(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nRemove an element from the front of the list. \n\nParameters\n\nlist:     Valid, non-empty list object.\n\nReturns\n\nReturns the data of the removed first list element.\n\nReference\n\nsc_containers.h:898\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_prepend","page":"Reference","title":"P4est.LibP4est.sc_list_prepend","text":"𝐣𝐥.@cextern sc_list_prepend(list::𝐣𝐥.Ptr{sc_list_t}, data::𝐣𝐥.Ptr{𝐣𝐥.Cvoid})::𝐣𝐥.Ptr{sc_link_t}\n\nInsert a list element at the beginning of the list. \n\nParameters\n\nlist:     Valid list object.\ndata:         A new link is created holding this data.\n\nReturns\n\n              The link that has been created for data.\n\nReference\n\nsc_containers.h:867\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_remove","page":"Reference","title":"P4est.LibP4est.sc_list_remove","text":"𝐣𝐥.@cextern sc_list_remove(list::𝐣𝐥.Ptr{sc_list_t}, pred::𝐣𝐥.Ptr{sc_link_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nRemove an element after a given list position. \n\nParameters\n\nlist:     Valid, non-empty list object.\npred:  The predecessor of the element to be removed.                   If pred == NULL, the first element is removed,                   which is equivalent to calling sclistpop (list).\n\nReturns\n\n       The data of the removed and freed link.\n\nReference\n\nsc_containers.h:892\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_reset","page":"Reference","title":"P4est.LibP4est.sc_list_reset","text":"𝐣𝐥.@cextern sc_list_reset(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid\n\nRemove all elements from a list in O(N). \n\nParameters\n\nlist:       List structure to be emptied.\n\nNOTE: Calling sclistinit, then any list operations,       then sclistreset is memory neutral.\n\nReference\n\nsc_containers.h:854\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_list_unlink","page":"Reference","title":"P4est.LibP4est.sc_list_unlink","text":"𝐣𝐥.@cextern sc_list_unlink(list::𝐣𝐥.Ptr{sc_list_t})::𝐣𝐥.Cvoid\n\nUnlink all list elements without returning them to the mempool. This runs in O(1) but is dangerous because the link memory stays alive. \n\nParameters\n\nlist:       List structure to be unlinked.\n\nReference\n\nsc_containers.h:860\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_log","page":"Reference","title":"P4est.LibP4est.sc_log","text":"𝐣𝐥.@cextern sc_log(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, msg::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid\n\nThe central log function to be called by all packages. Dispatches the log calls by package and filters by category and priority. \n\nParameters\n\npackage:   Must be a registered package id or -1.\ncategory:  Must be SCLCNORMAL or SCLCGLOBAL.\npriority:  Must be > SCLPALWAYS and < SCLPSILENT.\n\nReference\n\nsc.h:529\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_log2_lookup_table","page":"Reference","title":"P4est.LibP4est.sc_log2_lookup_table","text":"𝐣𝐥.@cextern sc_log2_lookup_table::𝐣𝐥.Cconst(𝐣𝐥.Cint)[256]\n\nLookup table to provide fast base-2 logarithm of integers. \n\nReference\n\nsc.h:137\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_log_indent_pop","page":"Reference","title":"P4est.LibP4est.sc_log_indent_pop","text":"𝐣𝐥.@cextern sc_log_indent_pop()::𝐣𝐥.Cvoid\n\nRemove one space from the start of a sc's default log format. \n\nReference\n\nsc.h:550\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_log_indent_pop_count","page":"Reference","title":"P4est.LibP4est.sc_log_indent_pop_count","text":"𝐣𝐥.@cextern sc_log_indent_pop_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nRemove spaces from the start of a package's default log format. \n\nReference\n\nsc.h:544\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_log_indent_push","page":"Reference","title":"P4est.LibP4est.sc_log_indent_push","text":"𝐣𝐥.@cextern sc_log_indent_push()::𝐣𝐥.Cvoid\n\nAdd one space to the start of sc's default log format. \n\nReference\n\nsc.h:547\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_log_indent_push_count","page":"Reference","title":"P4est.LibP4est.sc_log_indent_push_count","text":"𝐣𝐥.@cextern sc_log_indent_push_count(package::𝐣𝐥.Cint, count::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nAdd spaces to the start of a package's default log format. \n\nReference\n\nsc.h:541\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_logf","page":"Reference","title":"P4est.LibP4est.sc_logf","text":"𝐣𝐥.@cextern sc_logf(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:532\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_logv","page":"Reference","title":"P4est.LibP4est.sc_logv","text":"𝐣𝐥.@cextern sc_logv(filename::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, lineno::𝐣𝐥.Cint, package::𝐣𝐥.Cint, category::𝐣𝐥.Cint, priority::𝐣𝐥.Cint, fmt::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, ap::va_list)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:536\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_malloc","page":"Reference","title":"P4est.LibP4est.sc_malloc","text":"𝐣𝐥.@cextern sc_malloc(package::𝐣𝐥.Cint, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReference\n\nsc.h:476\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_memory_check","page":"Reference","title":"P4est.LibP4est.sc_memory_check","text":"𝐣𝐥.@cextern sc_memory_check(package::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nReference\n\nsc.h:482\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_memory_status","page":"Reference","title":"P4est.LibP4est.sc_memory_status","text":"𝐣𝐥.@cextern sc_memory_status(package::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nReference\n\nsc.h:481\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_destroy","page":"Reference","title":"P4est.LibP4est.sc_mempool_destroy","text":"𝐣𝐥.@cextern sc_mempool_destroy(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid\n\nDestroy a mempool structure. All elements that are still in use are invalidated. \n\nParameters\n\nmempool:      Its memory is freed.\n\nReference\n\nsc_containers.h:723\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_destroy_null","page":"Reference","title":"P4est.LibP4est.sc_mempool_destroy_null","text":"𝐣𝐥.@cextern sc_mempool_destroy_null(pmempool::𝐣𝐥.Ptr{𝐣𝐥.Ptr{sc_mempool_t}})::𝐣𝐥.Cvoid\n\nDestroy a mempool structure. All elements that are still in use are invalidated. \n\nParameters\n\npmempool:     Address of pointer to memory pool.                              Its memory is freed, pointer is NULLed.\n\nReference\n\nsc_containers.h:730\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_init","page":"Reference","title":"P4est.LibP4est.sc_mempool_init","text":"𝐣𝐥.@cextern sc_mempool_init(mempool::𝐣𝐥.Ptr{sc_mempool_t}, elem_size::size_t)::𝐣𝐥.Cvoid\n\nSame as scmempoolnew, but for an already allocated scmempoolt pointer. \n\nReference\n\nsc_containers.h:716\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_memory_used","page":"Reference","title":"P4est.LibP4est.sc_mempool_memory_used","text":"𝐣𝐥.@cextern sc_mempool_memory_used(mempool::𝐣𝐥.Ptr{sc_mempool_t})::size_t\n\nCalculate the memory used by a memory pool. \n\nParameters\n\narray:       The memory pool.\n\nReturns\n\n             Memory used in bytes.\n\nReference\n\nsc_containers.h:698\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_new","page":"Reference","title":"P4est.LibP4est.sc_mempool_new","text":"𝐣𝐥.@cextern sc_mempool_new(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}\n\nCreates a new mempool structure with the zeroandpersist option off. The contents of any elements returned by scmempoolalloc are undefined. \n\nParameters\n\nelem_size:  Size of one element in bytes.\n\nReturns\n\nReturns an allocated and initialized memory pool.\n\nReference\n\nsc_containers.h:705\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_new_zero_and_persist","page":"Reference","title":"P4est.LibP4est.sc_mempool_new_zero_and_persist","text":"𝐣𝐥.@cextern sc_mempool_new_zero_and_persist(elem_size::size_t)::𝐣𝐥.Ptr{sc_mempool_t}\n\nCreates a new mempool structure with the zeroandpersist option on. The memory of newly created elements is zero'd out, and the contents of an element are not touched between freeing and re-returning it. \n\nParameters\n\nelem_size:  Size of one element in bytes.\n\nReturns\n\nReturns an allocated and initialized memory pool.\n\nReference\n\nsc_containers.h:713\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_reset","page":"Reference","title":"P4est.LibP4est.sc_mempool_reset","text":"𝐣𝐥.@cextern sc_mempool_reset(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid\n\nSame as scmempooldestroy, but does not free the pointer \n\nReference\n\nsc_containers.h:733\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mempool_truncate","page":"Reference","title":"P4est.LibP4est.sc_mempool_truncate","text":"𝐣𝐥.@cextern sc_mempool_truncate(mempool::𝐣𝐥.Ptr{sc_mempool_t})::𝐣𝐥.Cvoid\n\nInvalidates all previously returned pointers, resets count to 0.\n\nReference\n\nsc_containers.h:737\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_attach_node_comms","page":"Reference","title":"P4est.LibP4est.sc_mpi_comm_attach_node_comms","text":"𝐣𝐥.@cextern sc_mpi_comm_attach_node_comms(comm::sc_MPI_Comm, processes_per_node::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nCompute sc_intranode_comm andscinternodecomm'' communicators and attach them to the current communicator.  This split takes processespernode passed by the user at face value: there is no hardware checking to see if this is the true affinity.\n\nParameters\n\ncomm:                 MPI communicator\nprocesses_per_node:   the size of the intranode                                      communicators. if < 1,                                      sc will try to determine the correct                                      shared memory communicators.\n\nReference\n\nsc_mpi.h:409\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_detach_node_comms","page":"Reference","title":"P4est.LibP4est.sc_mpi_comm_detach_node_comms","text":"𝐣𝐥.@cextern sc_mpi_comm_detach_node_comms(comm::sc_MPI_Comm)::𝐣𝐥.Cvoid\n\nDestroy sc_intranode_comm andscinternodecomm'' communicators that are stored as attributes to communicator ``comm''. This routine enforces a call to the destroy callback for these attributes.\n\nParameters\n\ncomm:                 MPI communicator\n\nReference\n\nsc_mpi.h:418\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mpi_comm_get_node_comms","page":"Reference","title":"P4est.LibP4est.sc_mpi_comm_get_node_comms","text":"𝐣𝐥.@cextern sc_mpi_comm_get_node_comms(comm::sc_MPI_Comm, intranode::𝐣𝐥.Ptr{sc_MPI_Comm}, internode::𝐣𝐥.Ptr{sc_MPI_Comm})::𝐣𝐥.Cvoid\n\nGet the communicators computed in scmpicommattachnodecomms() if they exist; return scMPICOMMNULL otherwise.\n\nParameters\n\ncomm:            Super communicator\nintranode:      intranode communicator\ninternode:      internode communicator\n\nReference\n\nsc_mpi.h:427\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mpi_sizeof","page":"Reference","title":"P4est.LibP4est.sc_mpi_sizeof","text":"𝐣𝐥.@cextern sc_mpi_sizeof(t::sc_MPI_Datatype)::size_t\n\nReturn the size of MPI data types. \n\nParameters\n\nt:    MPI data type.\n\nReturns\n\n      Returns the size in bytes.\n\nReference\n\nsc_mpi.h:396\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mstamp_alloc","page":"Reference","title":"P4est.LibP4est.sc_mstamp_alloc","text":"𝐣𝐥.@cextern sc_mstamp_alloc(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReturn a new item. The memory returned will stay legal until container is destroyed or truncated. \n\nParameters\n\nProperly: initialized stamp container.\n\nReturns\n\n                  Pointer to an item ready to use.                              Legal until sc_stamp_destroy or                              sc_stamp_truncate is called on mst.\n\nReference\n\nsc_containers.h:660\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mstamp_init","page":"Reference","title":"P4est.LibP4est.sc_mstamp_init","text":"𝐣𝐥.@cextern sc_mstamp_init(mst::𝐣𝐥.Ptr{sc_mstamp_t}, stamp_unit::size_t, elem_size::size_t)::𝐣𝐥.Cvoid\n\nInitialize a memory stamp container. We provide allocation of fixed-size memory items without allocating new memory in every request. Instead we block the allocations in what we call a stamp of multiple items. Even if no allocations are done, the container's internal memory must be freed eventually by scmstampreset.\n\nParameters\n\nmst:          Legal pointer to a stamp structure.\nstamp_unit:       Size of each memory block that we allocate.                              If it is larger than the element size,                              we may place more than one element in it.                              Passing 0 is legal and forces                              stamps that hold one item each.\nelem_size:        Size of each item.                              Passing 0 is legal.  In that case,                              scmstampalloc returns NULL.\n\nReference\n\nsc_containers.h:632\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mstamp_memory_used","page":"Reference","title":"P4est.LibP4est.sc_mstamp_memory_used","text":"𝐣𝐥.@cextern sc_mstamp_memory_used(mst::𝐣𝐥.Ptr{sc_mstamp_t})::size_t\n\nReturn memory size in bytes of all data allocated in the container. \n\nParameters\n\nProperly: initialized stamp container.\n\nReturns\n\n                  Total container memory size in bytes.\n\nReference\n\nsc_containers.h:666\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mstamp_reset","page":"Reference","title":"P4est.LibP4est.sc_mstamp_reset","text":"𝐣𝐥.@cextern sc_mstamp_reset(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid\n\nFree all memory in a stamp structure and all items previously returned. \n\nParameters\n\nProperly: initialized stamp container.                              On output, the structure is undefined.\n\nReference\n\nsc_containers.h:639\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_mstamp_truncate","page":"Reference","title":"P4est.LibP4est.sc_mstamp_truncate","text":"𝐣𝐥.@cextern sc_mstamp_truncate(mst::𝐣𝐥.Ptr{sc_mstamp_t})::𝐣𝐥.Cvoid\n\nFree all memory in a stamp structure and initialize it anew. Equivalent to calling scmstampreset followed by                       scmstampinit with the same                            stampunit and elemsize.\n\nParameters\n\nProperly: initialized stamp container.                              On output, its elements have been freed                              and it is ready for further use.\n\nReference\n\nsc_containers.h:650\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_id","page":"Reference","title":"P4est.LibP4est.sc_package_id","text":"𝐣𝐥.@cextern sc_package_id::𝐣𝐥.Cint\n\nlibsc allows for multiple packages to use their own log priorities etc. This is the package id for core sc functions, which is meant to be read only. It starts out with a value of -1, which is fine by itself. It is set to a non-negative value by the (optional) sc_init. \n\nReference\n\nsc.h:144\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_is_registered","page":"Reference","title":"P4est.LibP4est.sc_package_is_registered","text":"𝐣𝐥.@cextern sc_package_is_registered(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nQuery whether an identifier matches a registered package. \n\nParameters\n\npackage_id:       Only a non-negative id can be registered.\n\nReturns\n\n                  True if and only if the package id is                              non-negative and package is registered.\n\nReference\n\nsc.h:590\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_lock","page":"Reference","title":"P4est.LibP4est.sc_package_lock","text":"𝐣𝐥.@cextern sc_package_lock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nAcquire a pthread mutex lock. If configured without –enable-pthread, this function does nothing. This function must be followed with a matching scpackageunlock. \n\nParameters\n\npackage_id:       Either -1 for an undefined package or                              an id returned from scpackageregister.                              Depending on the value, the appropriate mutex                              is chosen.  Thus, we may overlap locking calls                              with distinct package_id.\n\nReference\n\nsc.h:601\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_print_summary","page":"Reference","title":"P4est.LibP4est.sc_package_print_summary","text":"𝐣𝐥.@cextern sc_package_print_summary(log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nPrint a summary of all packages registered with SC. Uses the SCLCGLOBAL log category which by default only prints on rank 0. \n\nParameters\n\nlog_priority:     Priority passed to sc log functions.\n\nReference\n\nsc.h:642\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_register","page":"Reference","title":"P4est.LibP4est.sc_package_register","text":"𝐣𝐥.@cextern sc_package_register(log_handler::sc_log_handler_t, log_threshold::𝐣𝐥.Cint, name::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, full::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cint\n\nRegister a software package with SC. This function must only be called before additional threads are created. The logging parameters are as in scsetlog_defaults. \n\nReturns\n\n               Returns a unique package id.\n\nReference\n\nsc.h:581\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_set_abort_alloc_mismatch","page":"Reference","title":"P4est.LibP4est.sc_package_set_abort_alloc_mismatch","text":"𝐣𝐥.@cextern sc_package_set_abort_alloc_mismatch(package_id::𝐣𝐥.Cint, set_abort::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSet the unregister behavior of scpackageunregister().\n\nParameters\n\npackage_id:    Must be -1 for the default package or                          the identifier of a registered package.\nset_abort:     True if scpackageunregister() should abort if the                          number of allocs does not match the number of                          frees; false otherwise.\n\nReference\n\nsc.h:630\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_set_verbosity","page":"Reference","title":"P4est.LibP4est.sc_package_set_verbosity","text":"𝐣𝐥.@cextern sc_package_set_verbosity(package_id::𝐣𝐥.Cint, log_priority::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSet the logging verbosity of a registered package. This can be called at any point in the program, any number of times. It can only lower the verbosity at and below the value of SCLPTHRESHOLD. \n\nParameters\n\npackage_id:       Must be a registered package identifier.\n\nReference\n\nsc.h:619\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_unlock","page":"Reference","title":"P4est.LibP4est.sc_package_unlock","text":"𝐣𝐥.@cextern sc_package_unlock(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nRelease a pthread mutex lock. If configured without –enable-pthread, this function does nothing. This function must be follow a matching scpackagelock. \n\nParameters\n\npackage_id:       Either -1 for an undefined package or                              an id returned from scpackageregister.                              Depending on the value, the appropriate mutex                              is chosen.  Thus, we may overlap locking calls                              with distinct package_id.\n\nReference\n\nsc.h:612\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_package_unregister","page":"Reference","title":"P4est.LibP4est.sc_package_unregister","text":"𝐣𝐥.@cextern sc_package_unregister(package_id::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nUnregister a software package with SC. This function must only be called after additional threads are finished.\n\nReference\n\nsc.h:636\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_realloc","page":"Reference","title":"P4est.LibP4est.sc_realloc","text":"𝐣𝐥.@cextern sc_realloc(package::𝐣𝐥.Cint, ptr::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}, size::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nReference\n\nsc.h:478\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_init","page":"Reference","title":"P4est.LibP4est.sc_recycle_array_init","text":"𝐣𝐥.@cextern sc_recycle_array_init(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, elem_size::size_t)::𝐣𝐥.Cvoid\n\nInitialize a recycle array.\n\nParameters\n\nelem_size:   Size of the objects to be stored in the array.\n\nReference\n\nsc_containers.h:1122\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_insert","page":"Reference","title":"P4est.LibP4est.sc_recycle_array_insert","text":"𝐣𝐥.@cextern sc_recycle_array_insert(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::𝐣𝐥.Ptr{size_t})::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nInsert an object into the recycle array. The object is not copied into the array.  Use the return value for that.\n\nParameters\n\nposition:   If position != NULL, *position is set to the                         array position of the inserted object.\n\nReturns\n\n             Returns the new address of the object in the array.\n\nReference\n\nsc_containers.h:1139\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_remove","page":"Reference","title":"P4est.LibP4est.sc_recycle_array_remove","text":"𝐣𝐥.@cextern sc_recycle_array_remove(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t}, position::size_t)::𝐣𝐥.Ptr{𝐣𝐥.Cvoid}\n\nRemove an object from the recycle array.  It must be valid.\n\nParameters\n\nposition:   Index into the array for the object to remove.\n\nReturns\n\n            The pointer to the removed object.  Will be valid                        as long as no other function is called                        on this recycle array.\n\nReference\n\nsc_containers.h:1149\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_recycle_array_reset","page":"Reference","title":"P4est.LibP4est.sc_recycle_array_reset","text":"𝐣𝐥.@cextern sc_recycle_array_reset(rec_array::𝐣𝐥.Ptr{sc_recycle_array_t})::𝐣𝐥.Cvoid\n\nReset a recycle array.\n\nDetails\n\nAs with all _reset functions, calling _init, then any array operations, then _reset is memory neutral.\n\nReference\n\nsc_containers.h:1130\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_set_abort_handler","page":"Reference","title":"P4est.LibP4est.sc_set_abort_handler","text":"𝐣𝐥.@cextern sc_set_abort_handler(abort_handler::sc_abort_handler_t)::𝐣𝐥.Cvoid\n\nControls the default SC abort behavior. \n\nParameters\n\nabort_handler: Set default SC above handler (NULL selects                           builtin).  ***This function should not return!***\n\nReference\n\nsc.h:521\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_set_log_defaults","page":"Reference","title":"P4est.LibP4est.sc_set_log_defaults","text":"𝐣𝐥.@cextern sc_set_log_defaults(log_stream::𝐣𝐥.Ptr{FILE}, log_handler::sc_log_handler_t, log_thresold::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nControls the default SC log behavior. \n\nParameters\n\nlog_stream:    Set stream to use by sc_logf (or NULL for stdout).\nlog_handler:   Set default SC log handler (NULL selects builtin).\nlog_threshold: Set default SC log threshold (or SCLPDEFAULT).                           May be SCLPALWAYS or SCLPSILENT.\n\nReference\n\nsc.h:513\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_snprintf","page":"Reference","title":"P4est.LibP4est.sc_snprintf","text":"𝐣𝐥.@cextern sc_snprintf(str::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, format::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}, var\"?vararg?\"...)::𝐣𝐥.Cvoid\n\nWrap the system snprintf function, allowing for truncation. The snprintf function may truncate the string written to the specified length. In some cases, compilers warn when this may occur. Here this is permitted behavior and we avoid the warning. \n\nParameters\n\nstr:     Buffer of length at least size.                      On output, not touched if NULL or size == 0.                      Otherwise, \"\" on snprintf error or the proper result.\nsize:     Allocation length of str.\nformat:   Format string as in man (3) snprintf.\n\nReference\n\nsc.h:698\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_strcopy","page":"Reference","title":"P4est.LibP4est.sc_strcopy","text":"𝐣𝐥.@cextern sc_strcopy(dest::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, size::size_t, src::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Cvoid\n\nProvide a string copy function. \n\nParameters\n\ndest:    Buffer of length at least size.                      On output, not touched if NULL or size == 0.\nsize:     Allocation length of dest.\nsrc:      Null-terminated string.\n\nReturns\n\n          Equivalent to sc_snprintf (dest, size, \"%s\", src).\n\nReference\n\nsc.h:686\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_strdup","page":"Reference","title":"P4est.LibP4est.sc_strdup","text":"𝐣𝐥.@cextern sc_strdup(package::𝐣𝐥.Cint, s::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)})::𝐣𝐥.Ptr{𝐣𝐥.Cchar}\n\nReference\n\nsc.h:479\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_trace_file","page":"Reference","title":"P4est.LibP4est.sc_trace_file","text":"𝐣𝐥.@cextern sc_trace_file::𝐣𝐥.Ptr{FILE}\n\nOptional trace file for logging (see sc_init). Initialized to NULL. \n\nReference\n\nsc.h:148\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_trace_prio","page":"Reference","title":"P4est.LibP4est.sc_trace_prio","text":"𝐣𝐥.@cextern sc_trace_prio::𝐣𝐥.Cint\n\nOptional minimum log priority for messages that go into the trace file. \n\nReference\n\nsc.h:151\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_add","page":"Reference","title":"P4est.LibP4est.sc_uint128_add","text":"𝐣𝐥.@cextern sc_uint128_add(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nAdds the uint128t b to the uint128t a. result == a or result == b is not allowed. a == b is allowed. \n\nParameters\n\na:       A pointer to a scuint128t.\nb:       A pointer to a scuint128t.\nresult:  A pointer to a scuint128t.                      The sum a + b will be saved in result.\n\nReference\n\nsc_uint128.h:116\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_add_inplace","page":"Reference","title":"P4est.LibP4est.sc_uint128_add_inplace","text":"𝐣𝐥.@cextern sc_uint128_add_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid\n\nAdds the uint128 b to the uint128_t a. The result is saved in a. a == b is allowed. \n\nParameters\n\na:   A pointer to a scuint128t. a                      will be overwritten by a + b.\nb:   A pointer to a scuint128t.\n\nReference\n\nsc_uint128.h:203\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_and","page":"Reference","title":"P4est.LibP4est.sc_uint128_bitwise_and","text":"𝐣𝐥.@cextern sc_uint128_bitwise_and(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise and of the uint128t a and the uint128t b. a == result is allowed. Furthermore, a == result and/or b == result is allowed. \n\nParameters\n\na:       A pointer to a scuint128t.\nb:       A pointer to a scuint128t.\nresult:  A pointer to a scuint128t.                      The bitwise and of a and b will be saved.                      in result.\n\nReference\n\nsc_uint128.h:165\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_and_inplace","page":"Reference","title":"P4est.LibP4est.sc_uint128_bitwise_and_inplace","text":"𝐣𝐥.@cextern sc_uint128_bitwise_and_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid\n\nCalculates the bitwise and of the uint128t a and the uint128t b. a == b is allowed. \n\nParameters\n\na:   A pointer to a scuint128t.                      The bitwise and will be saved in a.\nb:   A pointer to a scuint128t.\n\nReference\n\nsc_uint128.h:231\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_neg","page":"Reference","title":"P4est.LibP4est.sc_uint128_bitwise_neg","text":"𝐣𝐥.@cextern sc_uint128_bitwise_neg(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise negation of the uint128_t a. a == result is allowed. \n\nParameters\n\na:        A pointer to a scuint128t.\nresult:   A pointer to a scuint128t.                      The bitwise negation of a will be saved in                      result.\n\nReference\n\nsc_uint128.h:140\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_or","page":"Reference","title":"P4est.LibP4est.sc_uint128_bitwise_or","text":"𝐣𝐥.@cextern sc_uint128_bitwise_or(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nCalculates the bitwise or of the uint128_t a and b. a == result is allowed. Furthermore, a == result and/or b == result is allowed. \n\nParameters\n\na:        A pointer to a scuint128t.\nb:        A pointer to a scuint128t.\nresult:   A pointer to a scuint128t.                      The bitwise or of a and b will be                      saved in result.\n\nReference\n\nsc_uint128.h:152\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_bitwise_or_inplace","page":"Reference","title":"P4est.LibP4est.sc_uint128_bitwise_or_inplace","text":"𝐣𝐥.@cextern sc_uint128_bitwise_or_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid\n\nCalculates the bitwise or of the uint128t a and the uint128t b. a == b is allowed. \n\nParameters\n\na:   A pointer to a scuint128t.                      The bitwise or will be saved in a.\nb:   A pointer to a scuint128t.\n\nReference\n\nsc_uint128.h:222\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_chk_bit","page":"Reference","title":"P4est.LibP4est.sc_uint128_chk_bit","text":"𝐣𝐥.@cextern sc_uint128_chk_bit(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cint\n\nReturns the bit_number-th bit of input. This function checks a bit of an existing, initialized value. \n\nParameters\n\ninput:      A pointer to a scuint128t.\nbit_number: The bit (counted from the right hand side)                            that is checked by logical and.                            Require 0 <= bit_number < 128.\n\nReturns\n\n                True if the checked bit is set, false if not.\n\nReference\n\nsc_uint128.h:86\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_compare","page":"Reference","title":"P4est.LibP4est.sc_uint128_compare","text":"𝐣𝐥.@cextern sc_uint128_compare(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cvoid)})::𝐣𝐥.Cint\n\nCompare the scuint128t a and the scuint128t b. \n\nParameters\n\na: A pointer to a scuint128t.\nb: A pointer to a scuint128t.\n\nReturns\n\n    Returns -1 if a < b,                         1 if a > b and                         0 if a == b.\n\nReference\n\nsc_uint128.h:58\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_copy","page":"Reference","title":"P4est.LibP4est.sc_uint128_copy","text":"𝐣𝐥.@cextern sc_uint128_copy(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, output::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nCopies an initialized scuint128t to a scuint128t. \n\nParameters\n\ninput:    A pointer to the sc_uint128 that is copied.\noutput:   A pointer to a scuint128t.                          The high and low bits of output will                          be set to the high and low bits of                          input, respectively.\n\nReference\n\nsc_uint128.h:105\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_init","page":"Reference","title":"P4est.LibP4est.sc_uint128_init","text":"𝐣𝐥.@cextern sc_uint128_init(a::𝐣𝐥.Ptr{sc_uint128_t}, high::uint64_t, low::uint64_t)::𝐣𝐥.Cvoid\n\nInitializes an unsigned 128 bit integer to a given value. \n\nParameters\n\na:        A pointer to the scuint128t that will be                          initialized.\nhigh:     The given high bits to initialize a.\nlow:      The given low bits to initialize a.\n\nReference\n\nsc_uint128.h:75\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_is_equal","page":"Reference","title":"P4est.LibP4est.sc_uint128_is_equal","text":"𝐣𝐥.@cextern sc_uint128_is_equal(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cint\n\nChecks if the scuint128t a and the scuint128t b are equal. \n\nParameters\n\na: A pointer to a scuint128t.\nb: A pointer to a scuint128t.\n\nReturns\n\n    Returns a true value if *a* and *b* are equal,                false otherwise.\n\nReference\n\nsc_uint128.h:66\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_set_bit","page":"Reference","title":"P4est.LibP4est.sc_uint128_set_bit","text":"𝐣𝐥.@cextern sc_uint128_set_bit(a::𝐣𝐥.Ptr{sc_uint128_t}, exponent::𝐣𝐥.Cint)::𝐣𝐥.Cvoid\n\nSets the exponent-th bit of a to one and keep all other bits. This function modifies an existing, initialized value. \n\nParameters\n\na:        A pointer to a scuint128t.\nexponent:      The bit (0-based from the rightmost bit)                          that is set to one by logical or.                          0 <= exponent < 128.\n\nReference\n\nsc_uint128.h:96\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_shift_left","page":"Reference","title":"P4est.LibP4est.sc_uint128_shift_left","text":"𝐣𝐥.@cextern sc_uint128_shift_left(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nCalculates the bit left shift of uint128t input by shiftcount bits. We shift in zeros from the right. If shift_count >= 128, result is 0. All bits left from the 127th bit (counted zero based from the right hand side) drop out. input == result is allowed. \n\nParameters\n\ninput:       A pointer to a scuint128t.\nshift_count: Bits to shift. shift_count >= 0.\nresult:      A pointer to a scuint128t.                              The left shifted number will be saved                              in result.\n\nReference\n\nsc_uint128.h:193\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_shift_right","page":"Reference","title":"P4est.LibP4est.sc_uint128_shift_right","text":"𝐣𝐥.@cextern sc_uint128_shift_right(input::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, shift_count::𝐣𝐥.Cint, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nCalculates the bit right shift of uint128t input by shiftcount bits. We shift in zeros from the left. If shift_count >= 128, result is 0. All bits right from the zeroth bit (counted from the right hand side) drop out. input == result is allowed. \n\nParameters\n\ninput:       A pointer to a scuint128t.\nshift_count: Bits to shift. shift_count >= 0.\nresult:      A pointer to a scuint128t.                              The right shifted number will be saved                              in result.\n\nReference\n\nsc_uint128.h:179\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_sub","page":"Reference","title":"P4est.LibP4est.sc_uint128_sub","text":"𝐣𝐥.@cextern sc_uint128_sub(a::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)}, result::𝐣𝐥.Ptr{sc_uint128_t})::𝐣𝐥.Cvoid\n\nSubtracts the uint128t b from the uint128t a. This function assumes that the result is >= 0. result == a or result == b is not allowed. a == b is allowed. \n\nParameters\n\na:       A pointer to a scuint128t.\nb:       A pointer to a scuint128t.\nresult:  A pointer to a scuint128t.                      The difference a - b will be saved in result.\n\nReference\n\nsc_uint128.h:129\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_uint128_sub_inplace","page":"Reference","title":"P4est.LibP4est.sc_uint128_sub_inplace","text":"𝐣𝐥.@cextern sc_uint128_sub_inplace(a::𝐣𝐥.Ptr{sc_uint128_t}, b::𝐣𝐥.Ptr{𝐣𝐥.Cconst(sc_uint128_t)})::𝐣𝐥.Cvoid\n\nSubtracts the uint128t b from the uint128t a. The result is saved in a. a == b is allowed. This function assumes that the result is >= 0. \n\nParameters\n\na:   A pointer to a scuint128t.                      a will be overwritten by a - b.\nb:   A pointer to a scuint128t.\n\nReference\n\nsc_uint128.h:213\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_version","page":"Reference","title":"P4est.LibP4est.sc_version","text":"𝐣𝐥.@cextern sc_version()::𝐣𝐥.Ptr{𝐣𝐥.Cconst(𝐣𝐥.Cchar)}\n\nReturn the full version of libsc.\n\nReturns\n\n      Return the version of libsc using the format                  `VERSION_MAJOR.VERSION_MINOR.VERSION_POINT`,                  where `VERSION_POINT` can contain dots and                  characters, e.g. to indicate the additional                  number of commits and a git commit hash.\n\nReference\n\nsc.h:710\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_version_major","page":"Reference","title":"P4est.LibP4est.sc_version_major","text":"𝐣𝐥.@cextern sc_version_major()::𝐣𝐥.Cint\n\nReturn the major version of libsc.\n\nReturns\n\n      Return the major version of libsc.\n\nReference\n\nsc.h:716\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_version_minor","page":"Reference","title":"P4est.LibP4est.sc_version_minor","text":"𝐣𝐥.@cextern sc_version_minor()::𝐣𝐥.Cint\n\nReturn the minor version of libsc.\n\nReturns\n\n      Return the minor version of libsc.\n\nReference\n\nsc.h:722\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_vtk_write_binary","page":"Reference","title":"P4est.LibP4est.sc_vtk_write_binary","text":"𝐣𝐥.@cextern sc_vtk_write_binary(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint\n\nThis function writes numeric binary data in VTK base64 encoding. \n\nParameters\n\nvtkfile:        Stream opened for writing.\nnumeric_data:   A pointer to a numeric data array.\nbyte_length:    The length of the data array in bytes.\n\nReturns\n\n           Returns 0 on success, -1 on file error.\n\nReference\n\nsc_io.h:248\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.sc_vtk_write_compressed","page":"Reference","title":"P4est.LibP4est.sc_vtk_write_compressed","text":"𝐣𝐥.@cextern sc_vtk_write_compressed(vtkfile::𝐣𝐥.Ptr{FILE}, numeric_data::𝐣𝐥.Ptr{𝐣𝐥.Cchar}, byte_length::size_t)::𝐣𝐥.Cint\n\nThis function writes numeric binary data in VTK compressed format. \n\nParameters\n\nvtkfile:        Stream opened for writing.\nnumeric_data:   A pointer to a numeric data array.\nbyte_length:    The length of the data array in bytes.\n\nReturns\n\n           Returns 0 on success, -1 on file error.\n\nReference\n\nsc_io.h:257\n\n\n\n\n\n","category":"function"},{"location":"reference/#P4est.LibP4est.@P4EST_BUILD_2D","page":"Reference","title":"P4est.LibP4est.@P4EST_BUILD_2D","text":"Reference\n\np4est_config.h:10\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_BUILD_3D","page":"Reference","title":"P4est.LibP4est.@P4EST_BUILD_3D","text":"Reference\n\np4est_config.h:15\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_BUILD_P6EST","page":"Reference","title":"P4est.LibP4est.@P4EST_BUILD_P6EST","text":"Reference\n\np4est_config.h:20\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_CC","page":"Reference","title":"P4est.LibP4est.@P4EST_CC","text":"Reference\n\np4est_config.h:25\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_CFLAGS","page":"Reference","title":"P4est.LibP4est.@P4EST_CFLAGS","text":"Reference\n\np4est_config.h:30\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_CHILDREN","page":"Reference","title":"P4est.LibP4est.@P4EST_CHILDREN","text":"Reference\n\np4est_connectivity.h:51\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_CPP","page":"Reference","title":"P4est.LibP4est.@P4EST_CPP","text":"Reference\n\np4est_config.h:35\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_CPPFLAGS","page":"Reference","title":"P4est.LibP4est.@P4EST_CPPFLAGS","text":"Reference\n\np4est_config.h:40\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_DIM","page":"Reference","title":"P4est.LibP4est.@P4EST_DIM","text":"Reference\n\np4est_connectivity.h:45\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ENABLE_BUILD_2D","page":"Reference","title":"P4est.LibP4est.@P4EST_ENABLE_BUILD_2D","text":"Reference\n\np4est_config.h:51\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ENABLE_BUILD_3D","page":"Reference","title":"P4est.LibP4est.@P4EST_ENABLE_BUILD_3D","text":"Reference\n\np4est_config.h:56\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ENABLE_BUILD_P6EST","page":"Reference","title":"P4est.LibP4est.@P4EST_ENABLE_BUILD_P6EST","text":"Reference\n\np4est_config.h:61\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ENABLE_MEMALIGN","page":"Reference","title":"P4est.LibP4est.@P4EST_ENABLE_MEMALIGN","text":"Reference\n\np4est_config.h:70\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ENABLE_VTK_BINARY","page":"Reference","title":"P4est.LibP4est.@P4EST_ENABLE_VTK_BINARY","text":"Reference\n\np4est_config.h:105\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ENABLE_VTK_COMPRESSION","page":"Reference","title":"P4est.LibP4est.@P4EST_ENABLE_VTK_COMPRESSION","text":"Reference\n\np4est_config.h:110\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_FTRANSFORM","page":"Reference","title":"P4est.LibP4est.@P4EST_FTRANSFORM","text":"Reference\n\np4est_connectivity.h:67\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_GLOBAL_NOTICE","page":"Reference","title":"P4est.LibP4est.@P4EST_GLOBAL_NOTICE","text":"Reference\n\np4est_base.h:268\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_GLOBAL_NOTICEF","page":"Reference","title":"P4est.LibP4est.@P4EST_GLOBAL_NOTICEF","text":"Reference\n\np4est_base.h:269\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_GLOIDX_BITS","page":"Reference","title":"P4est.LibP4est.@P4EST_GLOIDX_BITS","text":"Reference\n\np4est_base.h:117\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_GLOIDX_MAX","page":"Reference","title":"P4est.LibP4est.@P4EST_GLOIDX_MAX","text":"Reference\n\np4est_base.h:122\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_GLOIDX_MIN","page":"Reference","title":"P4est.LibP4est.@P4EST_GLOIDX_MIN","text":"Reference\n\np4est_base.h:121\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_ARPA_INET_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_ARPA_INET_H","text":"Reference\n\np4est_config.h:160\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_DLFCN_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_DLFCN_H","text":"Reference\n\np4est_config.h:165\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_INTTYPES_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_INTTYPES_H","text":"Reference\n\np4est_config.h:170\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_MEMORY_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_MEMORY_H","text":"Reference\n\np4est_config.h:181\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_NETINET_IN_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_NETINET_IN_H","text":"Reference\n\np4est_config.h:186\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_POSIX_MEMALIGN","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_POSIX_MEMALIGN","text":"Reference\n\np4est_config.h:194\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_STDINT_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_STDINT_H","text":"Reference\n\np4est_config.h:199\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_STDLIB_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_STDLIB_H","text":"Reference\n\np4est_config.h:204\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_STRINGS_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_STRINGS_H","text":"Reference\n\np4est_config.h:209\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_STRING_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_STRING_H","text":"Reference\n\np4est_config.h:214\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_SYS_STAT_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_SYS_STAT_H","text":"Reference\n\np4est_config.h:219\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_SYS_TYPES_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_SYS_TYPES_H","text":"Reference\n\np4est_config.h:224\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_UNISTD_H","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_UNISTD_H","text":"Reference\n\np4est_config.h:229\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_HAVE_ZLIB","page":"Reference","title":"P4est.LibP4est.@P4EST_HAVE_ZLIB","text":"Reference\n\np4est_config.h:234\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_INSUL","page":"Reference","title":"P4est.LibP4est.@P4EST_INSUL","text":"Reference\n\np4est_connectivity.h:55\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_LDFLAGS","page":"Reference","title":"P4est.LibP4est.@P4EST_LDFLAGS","text":"Reference\n\np4est_config.h:239\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_LIBS","page":"Reference","title":"P4est.LibP4est.@P4EST_LIBS","text":"Reference\n\np4est_config.h:244\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_LOCIDX_BITS","page":"Reference","title":"P4est.LibP4est.@P4EST_LOCIDX_BITS","text":"Reference\n\np4est_base.h:105\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_LOCIDX_MAX","page":"Reference","title":"P4est.LibP4est.@P4EST_LOCIDX_MAX","text":"Reference\n\np4est_base.h:110\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_LOCIDX_MIN","page":"Reference","title":"P4est.LibP4est.@P4EST_LOCIDX_MIN","text":"Reference\n\np4est_base.h:109\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_LT_OBJDIR","page":"Reference","title":"P4est.LibP4est.@P4EST_LT_OBJDIR","text":"Reference\n\np4est_config.h:249\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P4EST_MAXLEVEL","text":"Reference\n\np4est.h:51\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MEMALIGN","page":"Reference","title":"P4est.LibP4est.@P4EST_MEMALIGN","text":"Reference\n\np4est_config.h:254\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MEMALIGN_BYTES","page":"Reference","title":"P4est.LibP4est.@P4EST_MEMALIGN_BYTES","text":"Reference\n\np4est_config.h:259\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MPI_GLOIDX","page":"Reference","title":"P4est.LibP4est.@P4EST_MPI_GLOIDX","text":"Reference\n\np4est_base.h:118\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MPI_LOCIDX","page":"Reference","title":"P4est.LibP4est.@P4EST_MPI_LOCIDX","text":"Reference\n\np4est_base.h:106\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MPI_QCOORD","page":"Reference","title":"P4est.LibP4est.@P4EST_MPI_QCOORD","text":"Reference\n\np4est_base.h:81\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_MPI_TOPIDX","page":"Reference","title":"P4est.LibP4est.@P4EST_MPI_TOPIDX","text":"Reference\n\np4est_base.h:93\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_NOTICE","page":"Reference","title":"P4est.LibP4est.@P4EST_NOTICE","text":"Reference\n\np4est_base.h:314\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_NOTICEF","page":"Reference","title":"P4est.LibP4est.@P4EST_NOTICEF","text":"Reference\n\np4est_base.h:315\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_OLD_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P4EST_OLD_MAXLEVEL","text":"Reference\n\np4est.h:50\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_OLD_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P4EST_OLD_QMAXLEVEL","text":"Reference\n\np4est.h:54\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_ONDISK_FORMAT","page":"Reference","title":"P4est.LibP4est.@P4EST_ONDISK_FORMAT","text":"Reference\n\np4est_connectivity.h:76\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE","text":"Reference\n\np4est_config.h:279\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE_BUGREPORT","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE_BUGREPORT","text":"Reference\n\np4est_config.h:284\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE_NAME","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE_NAME","text":"Reference\n\np4est_config.h:289\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE_STRING","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE_STRING","text":"Reference\n\np4est_config.h:294\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE_TARNAME","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE_TARNAME","text":"Reference\n\np4est_config.h:299\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE_URL","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE_URL","text":"Reference\n\np4est_config.h:304\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_PACKAGE_VERSION","page":"Reference","title":"P4est.LibP4est.@P4EST_PACKAGE_VERSION","text":"Reference\n\np4est_config.h:309\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_QCOORD_BITS","page":"Reference","title":"P4est.LibP4est.@P4EST_QCOORD_BITS","text":"Reference\n\np4est_base.h:80\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_QCOORD_MAX","page":"Reference","title":"P4est.LibP4est.@P4EST_QCOORD_MAX","text":"Reference\n\np4est_base.h:85\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_QCOORD_MIN","page":"Reference","title":"P4est.LibP4est.@P4EST_QCOORD_MIN","text":"Reference\n\np4est_base.h:84\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P4EST_QMAXLEVEL","text":"Reference\n\np4est.h:55\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_SIZEOF_VOID_P","page":"Reference","title":"P4est.LibP4est.@P4EST_SIZEOF_VOID_P","text":"Reference\n\np4est_config.h:329\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_STDC_HEADERS","page":"Reference","title":"P4est.LibP4est.@P4EST_STDC_HEADERS","text":"Reference\n\np4est_config.h:334\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_STRING","page":"Reference","title":"P4est.LibP4est.@P4EST_STRING","text":"Reference\n\np4est_connectivity.h:70\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_TOPIDX_BITS","page":"Reference","title":"P4est.LibP4est.@P4EST_TOPIDX_BITS","text":"Reference\n\np4est_base.h:92\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_TOPIDX_FITS_32","page":"Reference","title":"P4est.LibP4est.@P4EST_TOPIDX_FITS_32","text":"Reference\n\np4est_base.h:98\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_TOPIDX_MAX","page":"Reference","title":"P4est.LibP4est.@P4EST_TOPIDX_MAX","text":"Reference\n\np4est_base.h:97\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_TOPIDX_MIN","page":"Reference","title":"P4est.LibP4est.@P4EST_TOPIDX_MIN","text":"Reference\n\np4est_base.h:96\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VERSION","page":"Reference","title":"P4est.LibP4est.@P4EST_VERSION","text":"Reference\n\np4est_config.h:339\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VERSION_MAJOR","page":"Reference","title":"P4est.LibP4est.@P4EST_VERSION_MAJOR","text":"Reference\n\np4est_config.h:344\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VERSION_MINOR","page":"Reference","title":"P4est.LibP4est.@P4EST_VERSION_MINOR","text":"Reference\n\np4est_config.h:349\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VERSION_POINT","page":"Reference","title":"P4est.LibP4est.@P4EST_VERSION_POINT","text":"Reference\n\np4est_config.h:354\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VTK_BINARY","page":"Reference","title":"P4est.LibP4est.@P4EST_VTK_BINARY","text":"Reference\n\np4est_config.h:359\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VTK_COMPRESSION","page":"Reference","title":"P4est.LibP4est.@P4EST_VTK_COMPRESSION","text":"Reference\n\np4est_config.h:364\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VTK_GLOIDX","page":"Reference","title":"P4est.LibP4est.@P4EST_VTK_GLOIDX","text":"Reference\n\np4est_base.h:119\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VTK_LOCIDX","page":"Reference","title":"P4est.LibP4est.@P4EST_VTK_LOCIDX","text":"Reference\n\np4est_base.h:107\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VTK_QCOORD","page":"Reference","title":"P4est.LibP4est.@P4EST_VTK_QCOORD","text":"Reference\n\np4est_base.h:82\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P4EST_VTK_TOPIDX","page":"Reference","title":"P4est.LibP4est.@P4EST_VTK_TOPIDX","text":"Reference\n\np4est_base.h:94\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_CHILDREN","page":"Reference","title":"P4est.LibP4est.@P8EST_CHILDREN","text":"Reference\n\np8est_connectivity.h:50\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_DIM","page":"Reference","title":"P4est.LibP4est.@P8EST_DIM","text":"Reference\n\np8est_connectivity.h:41\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_EDGES","page":"Reference","title":"P4est.LibP4est.@P8EST_EDGES","text":"Reference\n\np8est_connectivity.h:54\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_FTRANSFORM","page":"Reference","title":"P4est.LibP4est.@P8EST_FTRANSFORM","text":"Reference\n\np8est_connectivity.h:68\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_INSUL","page":"Reference","title":"P4est.LibP4est.@P8EST_INSUL","text":"Reference\n\np8est_connectivity.h:56\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P8EST_MAXLEVEL","text":"Reference\n\np8est.h:47\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_OLD_MAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P8EST_OLD_MAXLEVEL","text":"Reference\n\np8est.h:46\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_OLD_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P8EST_OLD_QMAXLEVEL","text":"Reference\n\np8est.h:50\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_ONDISK_FORMAT","page":"Reference","title":"P4est.LibP4est.@P8EST_ONDISK_FORMAT","text":"Reference\n\np8est_connectivity.h:77\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_QMAXLEVEL","page":"Reference","title":"P4est.LibP4est.@P8EST_QMAXLEVEL","text":"Reference\n\np8est.h:51\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@P8EST_STRING","page":"Reference","title":"P4est.LibP4est.@P8EST_STRING","text":"Reference\n\np8est_connectivity.h:71\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_CC","page":"Reference","title":"P4est.LibP4est.@SC_CC","text":"Reference\n\nsc_config.h:13\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_CFLAGS","page":"Reference","title":"P4est.LibP4est.@SC_CFLAGS","text":"Reference\n\nsc_config.h:18\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_CPP","page":"Reference","title":"P4est.LibP4est.@SC_CPP","text":"Reference\n\nsc_config.h:23\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_CPPFLAGS","page":"Reference","title":"P4est.LibP4est.@SC_CPPFLAGS","text":"Reference\n\nsc_config.h:28\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_CXX","page":"Reference","title":"P4est.LibP4est.@SC_CXX","text":"Reference\n\nsc_config.h:33\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_CXXFLAGS","page":"Reference","title":"P4est.LibP4est.@SC_CXXFLAGS","text":"Reference\n\nsc_config.h:38\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_ENABLE_MEMALIGN","page":"Reference","title":"P4est.LibP4est.@SC_ENABLE_MEMALIGN","text":"Reference\n\nsc_config.h:53\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_ENABLE_USE_REALLOC","page":"Reference","title":"P4est.LibP4est.@SC_ENABLE_USE_REALLOC","text":"Reference\n\nsc_config.h:85\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_ENABLE_V4L2","page":"Reference","title":"P4est.LibP4est.@SC_ENABLE_V4L2","text":"Reference\n\nsc_config.h:90\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_EPS","page":"Reference","title":"P4est.LibP4est.@SC_EPS","text":"Reference\n\nsc.h:154\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_F77","page":"Reference","title":"P4est.LibP4est.@SC_F77","text":"Reference\n\nsc_config.h:95\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_FC","page":"Reference","title":"P4est.LibP4est.@SC_FC","text":"Reference\n\nsc_config.h:118\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_FCFLAGS","page":"Reference","title":"P4est.LibP4est.@SC_FCFLAGS","text":"Reference\n\nsc_config.h:123\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_FFLAGS","page":"Reference","title":"P4est.LibP4est.@SC_FFLAGS","text":"Reference\n\nsc_config.h:149\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_BACKTRACE","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_BACKTRACE","text":"Reference\n\nsc_config.h:157\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_BACKTRACE_SYMBOLS","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_BACKTRACE_SYMBOLS","text":"Reference\n\nsc_config.h:162\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_DLFCN_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_DLFCN_H","text":"Reference\n\nsc_config.h:167\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_EXECINFO_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_EXECINFO_H","text":"Reference\n\nsc_config.h:172\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_FCNTL_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_FCNTL_H","text":"Reference\n\nsc_config.h:177\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_FSYNC","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_FSYNC","text":"Reference\n\nsc_config.h:182\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_INTTYPES_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_INTTYPES_H","text":"Reference\n\nsc_config.h:187\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_LINUX_VIDEODEV2_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_LINUX_VIDEODEV2_H","text":"Reference\n\nsc_config.h:192\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_MEMORY_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_MEMORY_H","text":"Reference\n\nsc_config.h:215\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_POSIX_MEMALIGN","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_POSIX_MEMALIGN","text":"Reference\n\nsc_config.h:223\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_QSORT_R","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_QSORT_R","text":"Reference\n\nsc_config.h:228\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_SIGNAL_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_SIGNAL_H","text":"Reference\n\nsc_config.h:233\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_STDINT_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_STDINT_H","text":"Reference\n\nsc_config.h:238\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_STDLIB_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_STDLIB_H","text":"Reference\n\nsc_config.h:243\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_STRINGS_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_STRINGS_H","text":"Reference\n\nsc_config.h:248\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_STRING_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_STRING_H","text":"Reference\n\nsc_config.h:253\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_STRTOL","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_STRTOL","text":"Reference\n\nsc_config.h:258\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_STRTOLL","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_STRTOLL","text":"Reference\n\nsc_config.h:263\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_SYS_IOCTL_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_SYS_IOCTL_H","text":"Reference\n\nsc_config.h:268\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_SYS_SELECT_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_SYS_SELECT_H","text":"Reference\n\nsc_config.h:273\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_SYS_STAT_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_SYS_STAT_H","text":"Reference\n\nsc_config.h:278\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_SYS_TIME_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_SYS_TIME_H","text":"Reference\n\nsc_config.h:283\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_SYS_TYPES_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_SYS_TYPES_H","text":"Reference\n\nsc_config.h:288\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_TIME_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_TIME_H","text":"Reference\n\nsc_config.h:293\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_UNISTD_H","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_UNISTD_H","text":"Reference\n\nsc_config.h:298\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_HAVE_ZLIB","page":"Reference","title":"P4est.LibP4est.@SC_HAVE_ZLIB","text":"Reference\n\nsc_config.h:303\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LC_GLOBAL","page":"Reference","title":"P4est.LibP4est.@SC_LC_GLOBAL","text":"Reference\n\nsc.h:302\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LC_NORMAL","page":"Reference","title":"P4est.LibP4est.@SC_LC_NORMAL","text":"Reference\n\nsc.h:303\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LDFLAGS","page":"Reference","title":"P4est.LibP4est.@SC_LDFLAGS","text":"Reference\n\nsc_config.h:311\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LIBS","page":"Reference","title":"P4est.LibP4est.@SC_LIBS","text":"Reference\n\nsc_config.h:316\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_ALWAYS","page":"Reference","title":"P4est.LibP4est.@SC_LP_ALWAYS","text":"Reference\n\nsc.h:320\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_DEBUG","page":"Reference","title":"P4est.LibP4est.@SC_LP_DEBUG","text":"Reference\n\nsc.h:322\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_DEFAULT","page":"Reference","title":"P4est.LibP4est.@SC_LP_DEFAULT","text":"Reference\n\nsc.h:319\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_ERROR","page":"Reference","title":"P4est.LibP4est.@SC_LP_ERROR","text":"Reference\n\nsc.h:328\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_ESSENTIAL","page":"Reference","title":"P4est.LibP4est.@SC_LP_ESSENTIAL","text":"Reference\n\nsc.h:327\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_INFO","page":"Reference","title":"P4est.LibP4est.@SC_LP_INFO","text":"Reference\n\nsc.h:324\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_PRODUCTION","page":"Reference","title":"P4est.LibP4est.@SC_LP_PRODUCTION","text":"Reference\n\nsc.h:326\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_SILENT","page":"Reference","title":"P4est.LibP4est.@SC_LP_SILENT","text":"Reference\n\nsc.h:329\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_STATISTICS","page":"Reference","title":"P4est.LibP4est.@SC_LP_STATISTICS","text":"Reference\n\nsc.h:325\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_THRESHOLD","page":"Reference","title":"P4est.LibP4est.@SC_LP_THRESHOLD","text":"Reference\n\nsc.h:341\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_TRACE","page":"Reference","title":"P4est.LibP4est.@SC_LP_TRACE","text":"Reference\n\nsc.h:321\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LP_VERBOSE","page":"Reference","title":"P4est.LibP4est.@SC_LP_VERBOSE","text":"Reference\n\nsc.h:323\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_LT_OBJDIR","page":"Reference","title":"P4est.LibP4est.@SC_LT_OBJDIR","text":"Reference\n\nsc_config.h:324\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_MEMALIGN","page":"Reference","title":"P4est.LibP4est.@SC_MEMALIGN","text":"Reference\n\nsc_config.h:329\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_MEMALIGN_BYTES","page":"Reference","title":"P4est.LibP4est.@SC_MEMALIGN_BYTES","text":"Reference\n\nsc_config.h:334\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE","text":"Reference\n\nsc_config.h:351\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE_BUGREPORT","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE_BUGREPORT","text":"Reference\n\nsc_config.h:356\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE_NAME","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE_NAME","text":"Reference\n\nsc_config.h:361\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE_STRING","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE_STRING","text":"Reference\n\nsc_config.h:366\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE_TARNAME","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE_TARNAME","text":"Reference\n\nsc_config.h:371\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE_URL","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE_URL","text":"Reference\n\nsc_config.h:376\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_PACKAGE_VERSION","page":"Reference","title":"P4est.LibP4est.@SC_PACKAGE_VERSION","text":"Reference\n\nsc_config.h:381\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_SIZEOF_INT","page":"Reference","title":"P4est.LibP4est.@SC_SIZEOF_INT","text":"Reference\n\nsc_config.h:398\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_SIZEOF_LONG","page":"Reference","title":"P4est.LibP4est.@SC_SIZEOF_LONG","text":"Reference\n\nsc_config.h:403\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_SIZEOF_LONG_LONG","page":"Reference","title":"P4est.LibP4est.@SC_SIZEOF_LONG_LONG","text":"Reference\n\nsc_config.h:408\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_SIZEOF_UNSIGNED_LONG","page":"Reference","title":"P4est.LibP4est.@SC_SIZEOF_UNSIGNED_LONG","text":"Reference\n\nsc_config.h:413\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_SIZEOF_UNSIGNED_LONG_LONG","page":"Reference","title":"P4est.LibP4est.@SC_SIZEOF_UNSIGNED_LONG_LONG","text":"Reference\n\nsc_config.h:418\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_SIZEOF_VOID_P","page":"Reference","title":"P4est.LibP4est.@SC_SIZEOF_VOID_P","text":"Reference\n\nsc_config.h:423\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_STDC_HEADERS","page":"Reference","title":"P4est.LibP4est.@SC_STDC_HEADERS","text":"Reference\n\nsc_config.h:428\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_USE_REALLOC","page":"Reference","title":"P4est.LibP4est.@SC_USE_REALLOC","text":"Reference\n\nsc_config.h:433\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_VERSION","page":"Reference","title":"P4est.LibP4est.@SC_VERSION","text":"Reference\n\nsc_config.h:438\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_VERSION_MAJOR","page":"Reference","title":"P4est.LibP4est.@SC_VERSION_MAJOR","text":"Reference\n\nsc_config.h:443\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_VERSION_MINOR","page":"Reference","title":"P4est.LibP4est.@SC_VERSION_MINOR","text":"Reference\n\nsc_config.h:448\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@SC_VERSION_POINT","page":"Reference","title":"P4est.LibP4est.@SC_VERSION_POINT","text":"Reference\n\nsc_config.h:453\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@_CONFIG_P_EST_CONFIG_H","page":"Reference","title":"P4est.LibP4est.@_CONFIG_P_EST_CONFIG_H","text":"Reference\n\np4est_config.h:2\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@_CONFIG_SC_CONFIG_H","page":"Reference","title":"P4est.LibP4est.@_CONFIG_SC_CONFIG_H","text":"Reference\n\nsc_config.h:2\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@_p4est_const","page":"Reference","title":"P4est.LibP4est.@_p4est_const","text":"Reference\n\np4est_base.h:49\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@p4est_gloidx_compare","page":"Reference","title":"P4est.LibP4est.@p4est_gloidx_compare","text":"Reference\n\np4est_base.h:116\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@p4est_locidx_compare","page":"Reference","title":"P4est.LibP4est.@p4est_locidx_compare","text":"Reference\n\np4est_base.h:104\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@p4est_qcoord_compare","page":"Reference","title":"P4est.LibP4est.@p4est_qcoord_compare","text":"Reference\n\np4est_base.h:79\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@p4est_topidx_compare","page":"Reference","title":"P4est.LibP4est.@p4est_topidx_compare","text":"Reference\n\np4est_base.h:91\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_ANY_SOURCE","page":"Reference","title":"P4est.LibP4est.@sc_MPI_ANY_SOURCE","text":"Reference\n\nsc_mpi.h:216\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_ANY_TAG","page":"Reference","title":"P4est.LibP4est.@sc_MPI_ANY_TAG","text":"Reference\n\nsc_mpi.h:217\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_CONGRUENT","page":"Reference","title":"P4est.LibP4est.@sc_MPI_CONGRUENT","text":"Reference\n\nsc_mpi.h:212\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_ERR_GROUP","page":"Reference","title":"P4est.LibP4est.@sc_MPI_ERR_GROUP","text":"Reference\n\nsc_mpi.h:258\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_IDENT","page":"Reference","title":"P4est.LibP4est.@sc_MPI_IDENT","text":"Reference\n\nsc_mpi.h:211\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_SIMILAR","page":"Reference","title":"P4est.LibP4est.@sc_MPI_SIMILAR","text":"Reference\n\nsc_mpi.h:213\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_SUCCESS","page":"Reference","title":"P4est.LibP4est.@sc_MPI_SUCCESS","text":"Reference\n\nsc_mpi.h:203\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_THREAD_FUNNELED","page":"Reference","title":"P4est.LibP4est.@sc_MPI_THREAD_FUNNELED","text":"Reference\n\nsc_mpi.h:383\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_THREAD_MULTIPLE","page":"Reference","title":"P4est.LibP4est.@sc_MPI_THREAD_MULTIPLE","text":"Reference\n\nsc_mpi.h:385\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_THREAD_SERIALIZED","page":"Reference","title":"P4est.LibP4est.@sc_MPI_THREAD_SERIALIZED","text":"Reference\n\nsc_mpi.h:384\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_THREAD_SINGLE","page":"Reference","title":"P4est.LibP4est.@sc_MPI_THREAD_SINGLE","text":"Reference\n\nsc_mpi.h:382\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_UNDEFINED","page":"Reference","title":"P4est.LibP4est.@sc_MPI_UNDEFINED","text":"Reference\n\nsc_mpi.h:256\n\n\n\n\n\n","category":"macro"},{"location":"reference/#P4est.LibP4est.@sc_MPI_UNEQUAL","page":"Reference","title":"P4est.LibP4est.@sc_MPI_UNEQUAL","text":"Reference\n\nsc_mpi.h:214\n\n\n\n\n\n","category":"macro"},{"location":"#P4est.jl","page":"Home","title":"P4est.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is a Julia package that wraps p4est, a C library to manage multiple connected adaptive quadtrees or octrees in parallel.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, please follow the instructions for your operating system. P4est.jl works with Julia v1.6.","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is a registered Julia package. Hence, you can install it by executing the following commands in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"P4est\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl depends on the binary distribution of the p4est library, which is available in the Julia package P4est_jll.jl and which is automatically installed as a dependency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: Currently, P4est_jll.jl only provides serial binaries without MPI support. This limitation is planned to be lifted in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, P4est.jl provides pre-generated Julia bindings to all exported C functions of the underlying p4est library. You can force the build script to re-generate the bindings by setting the environment variable JULIA_P4EST_GENERATE_BINDINGS to a non-empty string.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, when JULIA_P4EST_GENERATE_BINDINGS is non-empty you can also configure P4est.jl to use a custom build of p4est. For this, set the following environment variables and build P4est.jl again afterwards:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Set JULIA_P4EST_PATH.\nYou can set the environment variable JULIA_P4EST_PATH to the install prefix of your p4est library. P4est.jl will then assume to find the corresponding library as joinpath(ENV[\"JULIA_P4EST_PATH\"], \"lib\", \"libp4est.{so,dylib,dll}\") and the include files in joinpath(ENV[\"JULIA_P4EST_PATH\"], \"include\").\nSet JULIA_P4EST_LIBRARY and JULIA_P4EST_INCLUDE.\nAlternatively, you can specify the p4est library and the include directory directly. Note that JULIA_P4EST_LIBRARY expects the full path to the p4est library, while JULIA_P4EST_INCLUDE must be the full path to the directory with the p4est header files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if your custom p4est build is installed to /opt/p4est, you can use it from P4est.jl by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project -e 'ENV[\"JULIA_P4EST_GENERATE_BINDINGS\"] = \"yes\";\n                    ENV[\"JULIA_P4EST_PATH\"] = \"/opt/p4est\";\n                    using Pkg; Pkg.build(\"P4est\"; verbose=true)'","category":"page"},{"location":"","page":"Home","title":"Home","text":"P4est.jl supports p4est both with and without MPI enabled. By default, it uses the p4est library from the binary Julia package P4est_jll, which currently is not compiled with MPI support. However, you may specify a custom p4est build with MPI enabled using the environment variables desribed above. In this case, you need to set a few additional variables to make sure that P4est.jl can create the correct C bindings:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Set JULIA_P4EST_USES_MPI to yes.\nThis is always required, since it tells P4est.jl to use the MPI include directory while generating the C bindings.\nSet JULIA_P4EST_MPI_PATH.\nYou can set the environment variable JULIA_P4EST_MPI_PATH to the install prefix of your MPI library. P4est.jl will then assume to find the corresponding include files in joinpath(ENV[\"JULIA_P4EST_MPI_PATH\"], \"include\").\nSet JULIA_P4EST_MPI_INCLUDE.\nAlternatively, you can specify the MPI include directory directly. Note that JULIA_P4EST_MPI_INCLUDE must be the full path to the directory with the mpi.h header file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please note that you should specify the path to the MPI version with which you also built the parallel version of p4est, in order to avoid errors from mismatching definitions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if your custom p4est build is installed to /opt/p4est and was built using the MPI library installed to /opt/mpich, you can use it from P4est.jl by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project -e 'ENV[\"JULIA_P4EST_GENERATE_BINDINGS\"] = \"yes\";\n                    ENV[\"JULIA_P4EST_PATH\"] = \"/opt/p4est\";\n                    ENV[\"JULIA_P4EST_USES_MPI\"] = \"yes\";\n                    ENV[\"JULIA_P4EST_MPI_PATH\"] = \"/opt/mpich\";\n                    using Pkg; Pkg.build(\"P4est\"; verbose=true)'","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the package P4est.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using P4est","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then access the full p4est API that is defined by the headers. For example, to create a periodic connectivity and check its validity, execute the following lines:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using P4est\nconn_ptr = p4est_connectivity_new_periodic()\np4est_connectivity_is_valid(conn_ptr)\np4est_ptr = p4est_new_ext(sc_MPI_Comm(0), conn_ptr, 0, 2, 0, 0, C_NULL, C_NULL)\np4est_ = unsafe_wrap(p4est_ptr)\np4est_.connectivity == conn_ptr\np4est_.connectivity.num_trees","category":"page"},{"location":"","page":"Home","title":"Home","text":"As can be seen, unsafe_wrap allows to convert pointers to p4est C structs to the corresponding Julia wrapper type provided by CBinding.jl. Once converted, CBinding.jl will automatically wrap pointers nested structures (such as Ptr{p4est_connectivity} in p4est_ in the example above) with the corresponding Julia type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Many functions and types in p4est have been documented with comments by the p4est authors; you can access this documentation as you would for any Julia-native entity through ?:","category":"page"},{"location":"","page":"Home","title":"Home","text":"help?> p4est_memory_used\nsearch: p4est_memory_used p4est_mesh_memory_used p4est_ghost_memory_used p4est_connectivity_memory_used P4EST_HAVE_MEMORY_H @P4EST_HAVE_MEMORY_H\n\n  𝐣𝐥.@cextern p4est_memory_used(p4est::𝐣𝐥.Ptr{p4est_t})::size_t\n\n\n  Calculate local memory usage of a forest structure. Not collective. The memory used on the current rank is returned. The connectivity structure is not counted since it is not owned; use\n  p4estconnectivitymemory_usage (p4est->connectivity).\n\n  Parameters\n  ============\n\n    •    p4est: Valid forest structure.\n\n  Returns\n  =========\n\n            Memory used in bytes.\n\n\n  Reference\n  ===========\n\n  p4est.h:177 (~/.julia/artifacts/bb31421737f71afecd6a7760afa471cd27c9d211/include/p4est.h:177:21)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on how to use p4est via P4est.jl, please refer to the documentation for p4est itself or to the header files (*.h) in the p4est repository.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P4est.jl was initiated by Michael Schlottke-Lakemper (University of Cologne, Germany), Hendrik Ranocha  (University of Münster, Germany), and Alexander Astanin (University of Cologne, Germany). Together, they are the principal developers of P4est.jl. The p4est library itself is written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P4est.jl is licensed under the MIT license (see License). p4est itself is licensed under the GNU General Public License, version 2.","category":"page"}]
}
